
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Follow
 * 
 */
export type Follow = $Result.DefaultSelection<Prisma.$FollowPayload>
/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model RecipeBook
 * 
 */
export type RecipeBook = $Result.DefaultSelection<Prisma.$RecipeBookPayload>
/**
 * Model RecipeBookUser
 * 
 */
export type RecipeBookUser = $Result.DefaultSelection<Prisma.$RecipeBookUserPayload>
/**
 * Model Build
 * 
 */
export type Build = $Result.DefaultSelection<Prisma.$BuildPayload>
/**
 * Model BuildUser
 * 
 */
export type BuildUser = $Result.DefaultSelection<Prisma.$BuildUserPayload>
/**
 * Model Recipe
 * 
 */
export type Recipe = $Result.DefaultSelection<Prisma.$RecipePayload>
/**
 * Model RecipeBookBuild
 * 
 */
export type RecipeBookBuild = $Result.DefaultSelection<Prisma.$RecipeBookBuildPayload>
/**
 * Model Touch
 * 
 */
export type Touch = $Result.DefaultSelection<Prisma.$TouchPayload>
/**
 * Model ArchivedTouch
 * 
 */
export type ArchivedTouch = $Result.DefaultSelection<Prisma.$ArchivedTouchPayload>
/**
 * Model GenericIngredient
 * 
 */
export type GenericIngredient = $Result.DefaultSelection<Prisma.$GenericIngredientPayload>
/**
 * Model SpecificIngredient
 * 
 */
export type SpecificIngredient = $Result.DefaultSelection<Prisma.$SpecificIngredientPayload>
/**
 * Model IngredientUser
 * 
 */
export type IngredientUser = $Result.DefaultSelection<Prisma.$IngredientUserPayload>
/**
 * Model IngredientPreference
 * 
 */
export type IngredientPreference = $Result.DefaultSelection<Prisma.$IngredientPreferencePayload>
/**
 * Model Inventory
 * 
 */
export type Inventory = $Result.DefaultSelection<Prisma.$InventoryPayload>
/**
 * Model InventoryUser
 * 
 */
export type InventoryUser = $Result.DefaultSelection<Prisma.$InventoryUserPayload>
/**
 * Model Storage
 * 
 */
export type Storage = $Result.DefaultSelection<Prisma.$StoragePayload>
/**
 * Model InventoryStorage
 * 
 */
export type InventoryStorage = $Result.DefaultSelection<Prisma.$InventoryStoragePayload>
/**
 * Model IngredientStorage
 * 
 */
export type IngredientStorage = $Result.DefaultSelection<Prisma.$IngredientStoragePayload>
/**
 * Model StorageUser
 * 
 */
export type StorageUser = $Result.DefaultSelection<Prisma.$StorageUserPayload>
/**
 * Model Crew
 * 
 */
export type Crew = $Result.DefaultSelection<Prisma.$CrewPayload>
/**
 * Model CrewUser
 * 
 */
export type CrewUser = $Result.DefaultSelection<Prisma.$CrewUserPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.follow`: Exposes CRUD operations for the **Follow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Follows
    * const follows = await prisma.follow.findMany()
    * ```
    */
  get follow(): Prisma.FollowDelegate<ExtArgs>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs>;

  /**
   * `prisma.recipeBook`: Exposes CRUD operations for the **RecipeBook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecipeBooks
    * const recipeBooks = await prisma.recipeBook.findMany()
    * ```
    */
  get recipeBook(): Prisma.RecipeBookDelegate<ExtArgs>;

  /**
   * `prisma.recipeBookUser`: Exposes CRUD operations for the **RecipeBookUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecipeBookUsers
    * const recipeBookUsers = await prisma.recipeBookUser.findMany()
    * ```
    */
  get recipeBookUser(): Prisma.RecipeBookUserDelegate<ExtArgs>;

  /**
   * `prisma.build`: Exposes CRUD operations for the **Build** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Builds
    * const builds = await prisma.build.findMany()
    * ```
    */
  get build(): Prisma.BuildDelegate<ExtArgs>;

  /**
   * `prisma.buildUser`: Exposes CRUD operations for the **BuildUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BuildUsers
    * const buildUsers = await prisma.buildUser.findMany()
    * ```
    */
  get buildUser(): Prisma.BuildUserDelegate<ExtArgs>;

  /**
   * `prisma.recipe`: Exposes CRUD operations for the **Recipe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recipes
    * const recipes = await prisma.recipe.findMany()
    * ```
    */
  get recipe(): Prisma.RecipeDelegate<ExtArgs>;

  /**
   * `prisma.recipeBookBuild`: Exposes CRUD operations for the **RecipeBookBuild** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecipeBookBuilds
    * const recipeBookBuilds = await prisma.recipeBookBuild.findMany()
    * ```
    */
  get recipeBookBuild(): Prisma.RecipeBookBuildDelegate<ExtArgs>;

  /**
   * `prisma.touch`: Exposes CRUD operations for the **Touch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Touches
    * const touches = await prisma.touch.findMany()
    * ```
    */
  get touch(): Prisma.TouchDelegate<ExtArgs>;

  /**
   * `prisma.archivedTouch`: Exposes CRUD operations for the **ArchivedTouch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ArchivedTouches
    * const archivedTouches = await prisma.archivedTouch.findMany()
    * ```
    */
  get archivedTouch(): Prisma.ArchivedTouchDelegate<ExtArgs>;

  /**
   * `prisma.genericIngredient`: Exposes CRUD operations for the **GenericIngredient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GenericIngredients
    * const genericIngredients = await prisma.genericIngredient.findMany()
    * ```
    */
  get genericIngredient(): Prisma.GenericIngredientDelegate<ExtArgs>;

  /**
   * `prisma.specificIngredient`: Exposes CRUD operations for the **SpecificIngredient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpecificIngredients
    * const specificIngredients = await prisma.specificIngredient.findMany()
    * ```
    */
  get specificIngredient(): Prisma.SpecificIngredientDelegate<ExtArgs>;

  /**
   * `prisma.ingredientUser`: Exposes CRUD operations for the **IngredientUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IngredientUsers
    * const ingredientUsers = await prisma.ingredientUser.findMany()
    * ```
    */
  get ingredientUser(): Prisma.IngredientUserDelegate<ExtArgs>;

  /**
   * `prisma.ingredientPreference`: Exposes CRUD operations for the **IngredientPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IngredientPreferences
    * const ingredientPreferences = await prisma.ingredientPreference.findMany()
    * ```
    */
  get ingredientPreference(): Prisma.IngredientPreferenceDelegate<ExtArgs>;

  /**
   * `prisma.inventory`: Exposes CRUD operations for the **Inventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventories
    * const inventories = await prisma.inventory.findMany()
    * ```
    */
  get inventory(): Prisma.InventoryDelegate<ExtArgs>;

  /**
   * `prisma.inventoryUser`: Exposes CRUD operations for the **InventoryUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryUsers
    * const inventoryUsers = await prisma.inventoryUser.findMany()
    * ```
    */
  get inventoryUser(): Prisma.InventoryUserDelegate<ExtArgs>;

  /**
   * `prisma.storage`: Exposes CRUD operations for the **Storage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Storages
    * const storages = await prisma.storage.findMany()
    * ```
    */
  get storage(): Prisma.StorageDelegate<ExtArgs>;

  /**
   * `prisma.inventoryStorage`: Exposes CRUD operations for the **InventoryStorage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryStorages
    * const inventoryStorages = await prisma.inventoryStorage.findMany()
    * ```
    */
  get inventoryStorage(): Prisma.InventoryStorageDelegate<ExtArgs>;

  /**
   * `prisma.ingredientStorage`: Exposes CRUD operations for the **IngredientStorage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IngredientStorages
    * const ingredientStorages = await prisma.ingredientStorage.findMany()
    * ```
    */
  get ingredientStorage(): Prisma.IngredientStorageDelegate<ExtArgs>;

  /**
   * `prisma.storageUser`: Exposes CRUD operations for the **StorageUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StorageUsers
    * const storageUsers = await prisma.storageUser.findMany()
    * ```
    */
  get storageUser(): Prisma.StorageUserDelegate<ExtArgs>;

  /**
   * `prisma.crew`: Exposes CRUD operations for the **Crew** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Crews
    * const crews = await prisma.crew.findMany()
    * ```
    */
  get crew(): Prisma.CrewDelegate<ExtArgs>;

  /**
   * `prisma.crewUser`: Exposes CRUD operations for the **CrewUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrewUsers
    * const crewUsers = await prisma.crewUser.findMany()
    * ```
    */
  get crewUser(): Prisma.CrewUserDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.6.0
   * Query Engine version: e95e739751f42d8ca026f6b910f5a2dc5adeaeee
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Follow: 'Follow',
    Profile: 'Profile',
    RecipeBook: 'RecipeBook',
    RecipeBookUser: 'RecipeBookUser',
    Build: 'Build',
    BuildUser: 'BuildUser',
    Recipe: 'Recipe',
    RecipeBookBuild: 'RecipeBookBuild',
    Touch: 'Touch',
    ArchivedTouch: 'ArchivedTouch',
    GenericIngredient: 'GenericIngredient',
    SpecificIngredient: 'SpecificIngredient',
    IngredientUser: 'IngredientUser',
    IngredientPreference: 'IngredientPreference',
    Inventory: 'Inventory',
    InventoryUser: 'InventoryUser',
    Storage: 'Storage',
    InventoryStorage: 'InventoryStorage',
    IngredientStorage: 'IngredientStorage',
    StorageUser: 'StorageUser',
    Crew: 'Crew',
    CrewUser: 'CrewUser'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'follow' | 'profile' | 'recipeBook' | 'recipeBookUser' | 'build' | 'buildUser' | 'recipe' | 'recipeBookBuild' | 'touch' | 'archivedTouch' | 'genericIngredient' | 'specificIngredient' | 'ingredientUser' | 'ingredientPreference' | 'inventory' | 'inventoryUser' | 'storage' | 'inventoryStorage' | 'ingredientStorage' | 'storageUser' | 'crew' | 'crewUser'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Follow: {
        payload: Prisma.$FollowPayload<ExtArgs>
        fields: Prisma.FollowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FollowFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FollowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FollowFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          findFirst: {
            args: Prisma.FollowFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FollowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FollowFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          findMany: {
            args: Prisma.FollowFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>[]
          }
          create: {
            args: Prisma.FollowCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          createMany: {
            args: Prisma.FollowCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FollowDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          update: {
            args: Prisma.FollowUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          deleteMany: {
            args: Prisma.FollowDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FollowUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FollowUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          aggregate: {
            args: Prisma.FollowAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFollow>
          }
          groupBy: {
            args: Prisma.FollowGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FollowGroupByOutputType>[]
          }
          count: {
            args: Prisma.FollowCountArgs<ExtArgs>,
            result: $Utils.Optional<FollowCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>,
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      RecipeBook: {
        payload: Prisma.$RecipeBookPayload<ExtArgs>
        fields: Prisma.RecipeBookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeBookFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeBookFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookPayload>
          }
          findFirst: {
            args: Prisma.RecipeBookFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeBookFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookPayload>
          }
          findMany: {
            args: Prisma.RecipeBookFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookPayload>[]
          }
          create: {
            args: Prisma.RecipeBookCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookPayload>
          }
          createMany: {
            args: Prisma.RecipeBookCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RecipeBookDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookPayload>
          }
          update: {
            args: Prisma.RecipeBookUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookPayload>
          }
          deleteMany: {
            args: Prisma.RecipeBookDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeBookUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RecipeBookUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookPayload>
          }
          aggregate: {
            args: Prisma.RecipeBookAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRecipeBook>
          }
          groupBy: {
            args: Prisma.RecipeBookGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RecipeBookGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeBookCountArgs<ExtArgs>,
            result: $Utils.Optional<RecipeBookCountAggregateOutputType> | number
          }
        }
      }
      RecipeBookUser: {
        payload: Prisma.$RecipeBookUserPayload<ExtArgs>
        fields: Prisma.RecipeBookUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeBookUserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeBookUserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookUserPayload>
          }
          findFirst: {
            args: Prisma.RecipeBookUserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeBookUserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookUserPayload>
          }
          findMany: {
            args: Prisma.RecipeBookUserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookUserPayload>[]
          }
          create: {
            args: Prisma.RecipeBookUserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookUserPayload>
          }
          createMany: {
            args: Prisma.RecipeBookUserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RecipeBookUserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookUserPayload>
          }
          update: {
            args: Prisma.RecipeBookUserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookUserPayload>
          }
          deleteMany: {
            args: Prisma.RecipeBookUserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeBookUserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RecipeBookUserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookUserPayload>
          }
          aggregate: {
            args: Prisma.RecipeBookUserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRecipeBookUser>
          }
          groupBy: {
            args: Prisma.RecipeBookUserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RecipeBookUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeBookUserCountArgs<ExtArgs>,
            result: $Utils.Optional<RecipeBookUserCountAggregateOutputType> | number
          }
        }
      }
      Build: {
        payload: Prisma.$BuildPayload<ExtArgs>
        fields: Prisma.BuildFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuildFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuildFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPayload>
          }
          findFirst: {
            args: Prisma.BuildFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuildFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPayload>
          }
          findMany: {
            args: Prisma.BuildFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPayload>[]
          }
          create: {
            args: Prisma.BuildCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPayload>
          }
          createMany: {
            args: Prisma.BuildCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BuildDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPayload>
          }
          update: {
            args: Prisma.BuildUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPayload>
          }
          deleteMany: {
            args: Prisma.BuildDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BuildUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BuildUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPayload>
          }
          aggregate: {
            args: Prisma.BuildAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBuild>
          }
          groupBy: {
            args: Prisma.BuildGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BuildGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuildCountArgs<ExtArgs>,
            result: $Utils.Optional<BuildCountAggregateOutputType> | number
          }
        }
      }
      BuildUser: {
        payload: Prisma.$BuildUserPayload<ExtArgs>
        fields: Prisma.BuildUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuildUserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuildUserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildUserPayload>
          }
          findFirst: {
            args: Prisma.BuildUserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuildUserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildUserPayload>
          }
          findMany: {
            args: Prisma.BuildUserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildUserPayload>[]
          }
          create: {
            args: Prisma.BuildUserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildUserPayload>
          }
          createMany: {
            args: Prisma.BuildUserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BuildUserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildUserPayload>
          }
          update: {
            args: Prisma.BuildUserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildUserPayload>
          }
          deleteMany: {
            args: Prisma.BuildUserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BuildUserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BuildUserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildUserPayload>
          }
          aggregate: {
            args: Prisma.BuildUserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBuildUser>
          }
          groupBy: {
            args: Prisma.BuildUserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BuildUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuildUserCountArgs<ExtArgs>,
            result: $Utils.Optional<BuildUserCountAggregateOutputType> | number
          }
        }
      }
      Recipe: {
        payload: Prisma.$RecipePayload<ExtArgs>
        fields: Prisma.RecipeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          findFirst: {
            args: Prisma.RecipeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          findMany: {
            args: Prisma.RecipeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>[]
          }
          create: {
            args: Prisma.RecipeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          createMany: {
            args: Prisma.RecipeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RecipeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          update: {
            args: Prisma.RecipeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          deleteMany: {
            args: Prisma.RecipeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RecipeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          aggregate: {
            args: Prisma.RecipeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRecipe>
          }
          groupBy: {
            args: Prisma.RecipeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RecipeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeCountArgs<ExtArgs>,
            result: $Utils.Optional<RecipeCountAggregateOutputType> | number
          }
        }
      }
      RecipeBookBuild: {
        payload: Prisma.$RecipeBookBuildPayload<ExtArgs>
        fields: Prisma.RecipeBookBuildFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeBookBuildFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookBuildPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeBookBuildFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookBuildPayload>
          }
          findFirst: {
            args: Prisma.RecipeBookBuildFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookBuildPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeBookBuildFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookBuildPayload>
          }
          findMany: {
            args: Prisma.RecipeBookBuildFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookBuildPayload>[]
          }
          create: {
            args: Prisma.RecipeBookBuildCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookBuildPayload>
          }
          createMany: {
            args: Prisma.RecipeBookBuildCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RecipeBookBuildDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookBuildPayload>
          }
          update: {
            args: Prisma.RecipeBookBuildUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookBuildPayload>
          }
          deleteMany: {
            args: Prisma.RecipeBookBuildDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeBookBuildUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RecipeBookBuildUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookBuildPayload>
          }
          aggregate: {
            args: Prisma.RecipeBookBuildAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRecipeBookBuild>
          }
          groupBy: {
            args: Prisma.RecipeBookBuildGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RecipeBookBuildGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeBookBuildCountArgs<ExtArgs>,
            result: $Utils.Optional<RecipeBookBuildCountAggregateOutputType> | number
          }
        }
      }
      Touch: {
        payload: Prisma.$TouchPayload<ExtArgs>
        fields: Prisma.TouchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TouchFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TouchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TouchFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TouchPayload>
          }
          findFirst: {
            args: Prisma.TouchFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TouchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TouchFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TouchPayload>
          }
          findMany: {
            args: Prisma.TouchFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TouchPayload>[]
          }
          create: {
            args: Prisma.TouchCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TouchPayload>
          }
          createMany: {
            args: Prisma.TouchCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TouchDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TouchPayload>
          }
          update: {
            args: Prisma.TouchUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TouchPayload>
          }
          deleteMany: {
            args: Prisma.TouchDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TouchUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TouchUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TouchPayload>
          }
          aggregate: {
            args: Prisma.TouchAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTouch>
          }
          groupBy: {
            args: Prisma.TouchGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TouchGroupByOutputType>[]
          }
          count: {
            args: Prisma.TouchCountArgs<ExtArgs>,
            result: $Utils.Optional<TouchCountAggregateOutputType> | number
          }
        }
      }
      ArchivedTouch: {
        payload: Prisma.$ArchivedTouchPayload<ExtArgs>
        fields: Prisma.ArchivedTouchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArchivedTouchFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArchivedTouchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArchivedTouchFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArchivedTouchPayload>
          }
          findFirst: {
            args: Prisma.ArchivedTouchFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArchivedTouchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArchivedTouchFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArchivedTouchPayload>
          }
          findMany: {
            args: Prisma.ArchivedTouchFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArchivedTouchPayload>[]
          }
          create: {
            args: Prisma.ArchivedTouchCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArchivedTouchPayload>
          }
          createMany: {
            args: Prisma.ArchivedTouchCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ArchivedTouchDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArchivedTouchPayload>
          }
          update: {
            args: Prisma.ArchivedTouchUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArchivedTouchPayload>
          }
          deleteMany: {
            args: Prisma.ArchivedTouchDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ArchivedTouchUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ArchivedTouchUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArchivedTouchPayload>
          }
          aggregate: {
            args: Prisma.ArchivedTouchAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateArchivedTouch>
          }
          groupBy: {
            args: Prisma.ArchivedTouchGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ArchivedTouchGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArchivedTouchCountArgs<ExtArgs>,
            result: $Utils.Optional<ArchivedTouchCountAggregateOutputType> | number
          }
        }
      }
      GenericIngredient: {
        payload: Prisma.$GenericIngredientPayload<ExtArgs>
        fields: Prisma.GenericIngredientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GenericIngredientFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GenericIngredientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GenericIngredientFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GenericIngredientPayload>
          }
          findFirst: {
            args: Prisma.GenericIngredientFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GenericIngredientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GenericIngredientFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GenericIngredientPayload>
          }
          findMany: {
            args: Prisma.GenericIngredientFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GenericIngredientPayload>[]
          }
          create: {
            args: Prisma.GenericIngredientCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GenericIngredientPayload>
          }
          createMany: {
            args: Prisma.GenericIngredientCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.GenericIngredientDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GenericIngredientPayload>
          }
          update: {
            args: Prisma.GenericIngredientUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GenericIngredientPayload>
          }
          deleteMany: {
            args: Prisma.GenericIngredientDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.GenericIngredientUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.GenericIngredientUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GenericIngredientPayload>
          }
          aggregate: {
            args: Prisma.GenericIngredientAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGenericIngredient>
          }
          groupBy: {
            args: Prisma.GenericIngredientGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GenericIngredientGroupByOutputType>[]
          }
          count: {
            args: Prisma.GenericIngredientCountArgs<ExtArgs>,
            result: $Utils.Optional<GenericIngredientCountAggregateOutputType> | number
          }
        }
      }
      SpecificIngredient: {
        payload: Prisma.$SpecificIngredientPayload<ExtArgs>
        fields: Prisma.SpecificIngredientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpecificIngredientFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpecificIngredientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpecificIngredientFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpecificIngredientPayload>
          }
          findFirst: {
            args: Prisma.SpecificIngredientFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpecificIngredientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpecificIngredientFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpecificIngredientPayload>
          }
          findMany: {
            args: Prisma.SpecificIngredientFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpecificIngredientPayload>[]
          }
          create: {
            args: Prisma.SpecificIngredientCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpecificIngredientPayload>
          }
          createMany: {
            args: Prisma.SpecificIngredientCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SpecificIngredientDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpecificIngredientPayload>
          }
          update: {
            args: Prisma.SpecificIngredientUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpecificIngredientPayload>
          }
          deleteMany: {
            args: Prisma.SpecificIngredientDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SpecificIngredientUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SpecificIngredientUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SpecificIngredientPayload>
          }
          aggregate: {
            args: Prisma.SpecificIngredientAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSpecificIngredient>
          }
          groupBy: {
            args: Prisma.SpecificIngredientGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SpecificIngredientGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpecificIngredientCountArgs<ExtArgs>,
            result: $Utils.Optional<SpecificIngredientCountAggregateOutputType> | number
          }
        }
      }
      IngredientUser: {
        payload: Prisma.$IngredientUserPayload<ExtArgs>
        fields: Prisma.IngredientUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IngredientUserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IngredientUserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientUserPayload>
          }
          findFirst: {
            args: Prisma.IngredientUserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IngredientUserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientUserPayload>
          }
          findMany: {
            args: Prisma.IngredientUserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientUserPayload>[]
          }
          create: {
            args: Prisma.IngredientUserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientUserPayload>
          }
          createMany: {
            args: Prisma.IngredientUserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.IngredientUserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientUserPayload>
          }
          update: {
            args: Prisma.IngredientUserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientUserPayload>
          }
          deleteMany: {
            args: Prisma.IngredientUserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.IngredientUserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.IngredientUserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientUserPayload>
          }
          aggregate: {
            args: Prisma.IngredientUserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIngredientUser>
          }
          groupBy: {
            args: Prisma.IngredientUserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<IngredientUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.IngredientUserCountArgs<ExtArgs>,
            result: $Utils.Optional<IngredientUserCountAggregateOutputType> | number
          }
        }
      }
      IngredientPreference: {
        payload: Prisma.$IngredientPreferencePayload<ExtArgs>
        fields: Prisma.IngredientPreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IngredientPreferenceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IngredientPreferenceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPreferencePayload>
          }
          findFirst: {
            args: Prisma.IngredientPreferenceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IngredientPreferenceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPreferencePayload>
          }
          findMany: {
            args: Prisma.IngredientPreferenceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPreferencePayload>[]
          }
          create: {
            args: Prisma.IngredientPreferenceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPreferencePayload>
          }
          createMany: {
            args: Prisma.IngredientPreferenceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.IngredientPreferenceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPreferencePayload>
          }
          update: {
            args: Prisma.IngredientPreferenceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPreferencePayload>
          }
          deleteMany: {
            args: Prisma.IngredientPreferenceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.IngredientPreferenceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.IngredientPreferenceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPreferencePayload>
          }
          aggregate: {
            args: Prisma.IngredientPreferenceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIngredientPreference>
          }
          groupBy: {
            args: Prisma.IngredientPreferenceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<IngredientPreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.IngredientPreferenceCountArgs<ExtArgs>,
            result: $Utils.Optional<IngredientPreferenceCountAggregateOutputType> | number
          }
        }
      }
      Inventory: {
        payload: Prisma.$InventoryPayload<ExtArgs>
        fields: Prisma.InventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findFirst: {
            args: Prisma.InventoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findMany: {
            args: Prisma.InventoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          create: {
            args: Prisma.InventoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          createMany: {
            args: Prisma.InventoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InventoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          update: {
            args: Prisma.InventoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          deleteMany: {
            args: Prisma.InventoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InventoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          aggregate: {
            args: Prisma.InventoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInventory>
          }
          groupBy: {
            args: Prisma.InventoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryCountArgs<ExtArgs>,
            result: $Utils.Optional<InventoryCountAggregateOutputType> | number
          }
        }
      }
      InventoryUser: {
        payload: Prisma.$InventoryUserPayload<ExtArgs>
        fields: Prisma.InventoryUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryUserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryUserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryUserPayload>
          }
          findFirst: {
            args: Prisma.InventoryUserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryUserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryUserPayload>
          }
          findMany: {
            args: Prisma.InventoryUserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryUserPayload>[]
          }
          create: {
            args: Prisma.InventoryUserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryUserPayload>
          }
          createMany: {
            args: Prisma.InventoryUserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InventoryUserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryUserPayload>
          }
          update: {
            args: Prisma.InventoryUserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryUserPayload>
          }
          deleteMany: {
            args: Prisma.InventoryUserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryUserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InventoryUserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryUserPayload>
          }
          aggregate: {
            args: Prisma.InventoryUserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInventoryUser>
          }
          groupBy: {
            args: Prisma.InventoryUserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InventoryUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryUserCountArgs<ExtArgs>,
            result: $Utils.Optional<InventoryUserCountAggregateOutputType> | number
          }
        }
      }
      Storage: {
        payload: Prisma.$StoragePayload<ExtArgs>
        fields: Prisma.StorageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StorageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StoragePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StorageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StoragePayload>
          }
          findFirst: {
            args: Prisma.StorageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StoragePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StorageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StoragePayload>
          }
          findMany: {
            args: Prisma.StorageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StoragePayload>[]
          }
          create: {
            args: Prisma.StorageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StoragePayload>
          }
          createMany: {
            args: Prisma.StorageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StorageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StoragePayload>
          }
          update: {
            args: Prisma.StorageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StoragePayload>
          }
          deleteMany: {
            args: Prisma.StorageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StorageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StorageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StoragePayload>
          }
          aggregate: {
            args: Prisma.StorageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStorage>
          }
          groupBy: {
            args: Prisma.StorageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StorageGroupByOutputType>[]
          }
          count: {
            args: Prisma.StorageCountArgs<ExtArgs>,
            result: $Utils.Optional<StorageCountAggregateOutputType> | number
          }
        }
      }
      InventoryStorage: {
        payload: Prisma.$InventoryStoragePayload<ExtArgs>
        fields: Prisma.InventoryStorageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryStorageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryStoragePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryStorageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryStoragePayload>
          }
          findFirst: {
            args: Prisma.InventoryStorageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryStoragePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryStorageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryStoragePayload>
          }
          findMany: {
            args: Prisma.InventoryStorageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryStoragePayload>[]
          }
          create: {
            args: Prisma.InventoryStorageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryStoragePayload>
          }
          createMany: {
            args: Prisma.InventoryStorageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InventoryStorageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryStoragePayload>
          }
          update: {
            args: Prisma.InventoryStorageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryStoragePayload>
          }
          deleteMany: {
            args: Prisma.InventoryStorageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryStorageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InventoryStorageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryStoragePayload>
          }
          aggregate: {
            args: Prisma.InventoryStorageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInventoryStorage>
          }
          groupBy: {
            args: Prisma.InventoryStorageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InventoryStorageGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryStorageCountArgs<ExtArgs>,
            result: $Utils.Optional<InventoryStorageCountAggregateOutputType> | number
          }
        }
      }
      IngredientStorage: {
        payload: Prisma.$IngredientStoragePayload<ExtArgs>
        fields: Prisma.IngredientStorageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IngredientStorageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientStoragePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IngredientStorageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientStoragePayload>
          }
          findFirst: {
            args: Prisma.IngredientStorageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientStoragePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IngredientStorageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientStoragePayload>
          }
          findMany: {
            args: Prisma.IngredientStorageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientStoragePayload>[]
          }
          create: {
            args: Prisma.IngredientStorageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientStoragePayload>
          }
          createMany: {
            args: Prisma.IngredientStorageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.IngredientStorageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientStoragePayload>
          }
          update: {
            args: Prisma.IngredientStorageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientStoragePayload>
          }
          deleteMany: {
            args: Prisma.IngredientStorageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.IngredientStorageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.IngredientStorageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientStoragePayload>
          }
          aggregate: {
            args: Prisma.IngredientStorageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIngredientStorage>
          }
          groupBy: {
            args: Prisma.IngredientStorageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<IngredientStorageGroupByOutputType>[]
          }
          count: {
            args: Prisma.IngredientStorageCountArgs<ExtArgs>,
            result: $Utils.Optional<IngredientStorageCountAggregateOutputType> | number
          }
        }
      }
      StorageUser: {
        payload: Prisma.$StorageUserPayload<ExtArgs>
        fields: Prisma.StorageUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StorageUserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StorageUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StorageUserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StorageUserPayload>
          }
          findFirst: {
            args: Prisma.StorageUserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StorageUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StorageUserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StorageUserPayload>
          }
          findMany: {
            args: Prisma.StorageUserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StorageUserPayload>[]
          }
          create: {
            args: Prisma.StorageUserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StorageUserPayload>
          }
          createMany: {
            args: Prisma.StorageUserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StorageUserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StorageUserPayload>
          }
          update: {
            args: Prisma.StorageUserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StorageUserPayload>
          }
          deleteMany: {
            args: Prisma.StorageUserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StorageUserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StorageUserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StorageUserPayload>
          }
          aggregate: {
            args: Prisma.StorageUserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStorageUser>
          }
          groupBy: {
            args: Prisma.StorageUserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StorageUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.StorageUserCountArgs<ExtArgs>,
            result: $Utils.Optional<StorageUserCountAggregateOutputType> | number
          }
        }
      }
      Crew: {
        payload: Prisma.$CrewPayload<ExtArgs>
        fields: Prisma.CrewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CrewFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CrewFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>
          }
          findFirst: {
            args: Prisma.CrewFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CrewFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>
          }
          findMany: {
            args: Prisma.CrewFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>[]
          }
          create: {
            args: Prisma.CrewCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>
          }
          createMany: {
            args: Prisma.CrewCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CrewDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>
          }
          update: {
            args: Prisma.CrewUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>
          }
          deleteMany: {
            args: Prisma.CrewDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CrewUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CrewUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>
          }
          aggregate: {
            args: Prisma.CrewAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCrew>
          }
          groupBy: {
            args: Prisma.CrewGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CrewGroupByOutputType>[]
          }
          count: {
            args: Prisma.CrewCountArgs<ExtArgs>,
            result: $Utils.Optional<CrewCountAggregateOutputType> | number
          }
        }
      }
      CrewUser: {
        payload: Prisma.$CrewUserPayload<ExtArgs>
        fields: Prisma.CrewUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CrewUserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CrewUserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewUserPayload>
          }
          findFirst: {
            args: Prisma.CrewUserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CrewUserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewUserPayload>
          }
          findMany: {
            args: Prisma.CrewUserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewUserPayload>[]
          }
          create: {
            args: Prisma.CrewUserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewUserPayload>
          }
          createMany: {
            args: Prisma.CrewUserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CrewUserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewUserPayload>
          }
          update: {
            args: Prisma.CrewUserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewUserPayload>
          }
          deleteMany: {
            args: Prisma.CrewUserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CrewUserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CrewUserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewUserPayload>
          }
          aggregate: {
            args: Prisma.CrewUserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCrewUser>
          }
          groupBy: {
            args: Prisma.CrewUserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CrewUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.CrewUserCountArgs<ExtArgs>,
            result: $Utils.Optional<CrewUserCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    recipeBookUser: number
    recipeBook: number
    recipeBookEditedBy: number
    recipe: number
    recipeEditedBy: number
    buildUser: number
    build: number
    buildEditedBy: number
    CrewUser: number
    crew: number
    crewEditedBy: number
    ingredient: number
    ingredientPreference: number
    ingredientUser: number
    storageUser: number
    storage: number
    storageEditedBy: number
    inventory: number
    inventoryEditedBy: number
    inventoryUser: number
    followedBy: number
    following: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipeBookUser?: boolean | UserCountOutputTypeCountRecipeBookUserArgs
    recipeBook?: boolean | UserCountOutputTypeCountRecipeBookArgs
    recipeBookEditedBy?: boolean | UserCountOutputTypeCountRecipeBookEditedByArgs
    recipe?: boolean | UserCountOutputTypeCountRecipeArgs
    recipeEditedBy?: boolean | UserCountOutputTypeCountRecipeEditedByArgs
    buildUser?: boolean | UserCountOutputTypeCountBuildUserArgs
    build?: boolean | UserCountOutputTypeCountBuildArgs
    buildEditedBy?: boolean | UserCountOutputTypeCountBuildEditedByArgs
    CrewUser?: boolean | UserCountOutputTypeCountCrewUserArgs
    crew?: boolean | UserCountOutputTypeCountCrewArgs
    crewEditedBy?: boolean | UserCountOutputTypeCountCrewEditedByArgs
    ingredient?: boolean | UserCountOutputTypeCountIngredientArgs
    ingredientPreference?: boolean | UserCountOutputTypeCountIngredientPreferenceArgs
    ingredientUser?: boolean | UserCountOutputTypeCountIngredientUserArgs
    storageUser?: boolean | UserCountOutputTypeCountStorageUserArgs
    storage?: boolean | UserCountOutputTypeCountStorageArgs
    storageEditedBy?: boolean | UserCountOutputTypeCountStorageEditedByArgs
    inventory?: boolean | UserCountOutputTypeCountInventoryArgs
    inventoryEditedBy?: boolean | UserCountOutputTypeCountInventoryEditedByArgs
    inventoryUser?: boolean | UserCountOutputTypeCountInventoryUserArgs
    followedBy?: boolean | UserCountOutputTypeCountFollowedByArgs
    following?: boolean | UserCountOutputTypeCountFollowingArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRecipeBookUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeBookUserWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRecipeBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeBookWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRecipeBookEditedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeBookWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRecipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRecipeEditedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBuildUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildUserWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBuildEditedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCrewUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewUserWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCrewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCrewEditedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIngredientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecificIngredientWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIngredientPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngredientPreferenceWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIngredientUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngredientUserWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStorageUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorageUserWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStorageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorageWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStorageEditedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorageWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInventoryEditedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInventoryUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryUserWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
  }



  /**
   * Count Type RecipeBookCountOutputType
   */

  export type RecipeBookCountOutputType = {
    recipeBookBuild: number
    recipeBookUser: number
  }

  export type RecipeBookCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipeBookBuild?: boolean | RecipeBookCountOutputTypeCountRecipeBookBuildArgs
    recipeBookUser?: boolean | RecipeBookCountOutputTypeCountRecipeBookUserArgs
  }

  // Custom InputTypes

  /**
   * RecipeBookCountOutputType without action
   */
  export type RecipeBookCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookCountOutputType
     */
    select?: RecipeBookCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RecipeBookCountOutputType without action
   */
  export type RecipeBookCountOutputTypeCountRecipeBookBuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeBookBuildWhereInput
  }


  /**
   * RecipeBookCountOutputType without action
   */
  export type RecipeBookCountOutputTypeCountRecipeBookUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeBookUserWhereInput
  }



  /**
   * Count Type BuildCountOutputType
   */

  export type BuildCountOutputType = {
    touch: number
    archivedTouch: number
    RecipeBookBuild: number
    buildUser: number
  }

  export type BuildCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    touch?: boolean | BuildCountOutputTypeCountTouchArgs
    archivedTouch?: boolean | BuildCountOutputTypeCountArchivedTouchArgs
    RecipeBookBuild?: boolean | BuildCountOutputTypeCountRecipeBookBuildArgs
    buildUser?: boolean | BuildCountOutputTypeCountBuildUserArgs
  }

  // Custom InputTypes

  /**
   * BuildCountOutputType without action
   */
  export type BuildCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildCountOutputType
     */
    select?: BuildCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * BuildCountOutputType without action
   */
  export type BuildCountOutputTypeCountTouchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TouchWhereInput
  }


  /**
   * BuildCountOutputType without action
   */
  export type BuildCountOutputTypeCountArchivedTouchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArchivedTouchWhereInput
  }


  /**
   * BuildCountOutputType without action
   */
  export type BuildCountOutputTypeCountRecipeBookBuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeBookBuildWhereInput
  }


  /**
   * BuildCountOutputType without action
   */
  export type BuildCountOutputTypeCountBuildUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildUserWhereInput
  }



  /**
   * Count Type RecipeCountOutputType
   */

  export type RecipeCountOutputType = {
    build: number
  }

  export type RecipeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    build?: boolean | RecipeCountOutputTypeCountBuildArgs
  }

  // Custom InputTypes

  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeCountOutputType
     */
    select?: RecipeCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountBuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildWhereInput
  }



  /**
   * Count Type GenericIngredientCountOutputType
   */

  export type GenericIngredientCountOutputType = {
    touch: number
    archivedTouch: number
    specificIngredient: number
    ingredientPreference: number
  }

  export type GenericIngredientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    touch?: boolean | GenericIngredientCountOutputTypeCountTouchArgs
    archivedTouch?: boolean | GenericIngredientCountOutputTypeCountArchivedTouchArgs
    specificIngredient?: boolean | GenericIngredientCountOutputTypeCountSpecificIngredientArgs
    ingredientPreference?: boolean | GenericIngredientCountOutputTypeCountIngredientPreferenceArgs
  }

  // Custom InputTypes

  /**
   * GenericIngredientCountOutputType without action
   */
  export type GenericIngredientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenericIngredientCountOutputType
     */
    select?: GenericIngredientCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * GenericIngredientCountOutputType without action
   */
  export type GenericIngredientCountOutputTypeCountTouchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TouchWhereInput
  }


  /**
   * GenericIngredientCountOutputType without action
   */
  export type GenericIngredientCountOutputTypeCountArchivedTouchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArchivedTouchWhereInput
  }


  /**
   * GenericIngredientCountOutputType without action
   */
  export type GenericIngredientCountOutputTypeCountSpecificIngredientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecificIngredientWhereInput
  }


  /**
   * GenericIngredientCountOutputType without action
   */
  export type GenericIngredientCountOutputTypeCountIngredientPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngredientPreferenceWhereInput
  }



  /**
   * Count Type SpecificIngredientCountOutputType
   */

  export type SpecificIngredientCountOutputType = {
    touch: number
    archivedTouch: number
    ingredientStorage: number
    ingredientUser: number
    ingredientPreference: number
  }

  export type SpecificIngredientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    touch?: boolean | SpecificIngredientCountOutputTypeCountTouchArgs
    archivedTouch?: boolean | SpecificIngredientCountOutputTypeCountArchivedTouchArgs
    ingredientStorage?: boolean | SpecificIngredientCountOutputTypeCountIngredientStorageArgs
    ingredientUser?: boolean | SpecificIngredientCountOutputTypeCountIngredientUserArgs
    ingredientPreference?: boolean | SpecificIngredientCountOutputTypeCountIngredientPreferenceArgs
  }

  // Custom InputTypes

  /**
   * SpecificIngredientCountOutputType without action
   */
  export type SpecificIngredientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificIngredientCountOutputType
     */
    select?: SpecificIngredientCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SpecificIngredientCountOutputType without action
   */
  export type SpecificIngredientCountOutputTypeCountTouchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TouchWhereInput
  }


  /**
   * SpecificIngredientCountOutputType without action
   */
  export type SpecificIngredientCountOutputTypeCountArchivedTouchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArchivedTouchWhereInput
  }


  /**
   * SpecificIngredientCountOutputType without action
   */
  export type SpecificIngredientCountOutputTypeCountIngredientStorageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngredientStorageWhereInput
  }


  /**
   * SpecificIngredientCountOutputType without action
   */
  export type SpecificIngredientCountOutputTypeCountIngredientUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngredientUserWhereInput
  }


  /**
   * SpecificIngredientCountOutputType without action
   */
  export type SpecificIngredientCountOutputTypeCountIngredientPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngredientPreferenceWhereInput
  }



  /**
   * Count Type InventoryCountOutputType
   */

  export type InventoryCountOutputType = {
    inventoryStorage: number
    inventoryUser: number
  }

  export type InventoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryStorage?: boolean | InventoryCountOutputTypeCountInventoryStorageArgs
    inventoryUser?: boolean | InventoryCountOutputTypeCountInventoryUserArgs
  }

  // Custom InputTypes

  /**
   * InventoryCountOutputType without action
   */
  export type InventoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryCountOutputType
     */
    select?: InventoryCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * InventoryCountOutputType without action
   */
  export type InventoryCountOutputTypeCountInventoryStorageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryStorageWhereInput
  }


  /**
   * InventoryCountOutputType without action
   */
  export type InventoryCountOutputTypeCountInventoryUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryUserWhereInput
  }



  /**
   * Count Type StorageCountOutputType
   */

  export type StorageCountOutputType = {
    inventoryStorage: number
    ingredientStorage: number
    storageUser: number
  }

  export type StorageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryStorage?: boolean | StorageCountOutputTypeCountInventoryStorageArgs
    ingredientStorage?: boolean | StorageCountOutputTypeCountIngredientStorageArgs
    storageUser?: boolean | StorageCountOutputTypeCountStorageUserArgs
  }

  // Custom InputTypes

  /**
   * StorageCountOutputType without action
   */
  export type StorageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageCountOutputType
     */
    select?: StorageCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * StorageCountOutputType without action
   */
  export type StorageCountOutputTypeCountInventoryStorageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryStorageWhereInput
  }


  /**
   * StorageCountOutputType without action
   */
  export type StorageCountOutputTypeCountIngredientStorageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngredientStorageWhereInput
  }


  /**
   * StorageCountOutputType without action
   */
  export type StorageCountOutputTypeCountStorageUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorageUserWhereInput
  }



  /**
   * Count Type CrewCountOutputType
   */

  export type CrewCountOutputType = {
    userCrew: number
  }

  export type CrewCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userCrew?: boolean | CrewCountOutputTypeCountUserCrewArgs
  }

  // Custom InputTypes

  /**
   * CrewCountOutputType without action
   */
  export type CrewCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewCountOutputType
     */
    select?: CrewCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CrewCountOutputType without action
   */
  export type CrewCountOutputTypeCountUserCrewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewUserWhereInput
  }



  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    userName: string | null
    firstName: string | null
    lastName: string | null
    dateJoined: Date | null
    lastEdited: Date | null
    email: string | null
    password: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    userName: string | null
    firstName: string | null
    lastName: string | null
    dateJoined: Date | null
    lastEdited: Date | null
    email: string | null
    password: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    userName: number
    firstName: number
    lastName: number
    dateJoined: number
    lastEdited: number
    email: number
    password: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    userName?: true
    firstName?: true
    lastName?: true
    dateJoined?: true
    lastEdited?: true
    email?: true
    password?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    userName?: true
    firstName?: true
    lastName?: true
    dateJoined?: true
    lastEdited?: true
    email?: true
    password?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    userName?: true
    firstName?: true
    lastName?: true
    dateJoined?: true
    lastEdited?: true
    email?: true
    password?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    userName: string
    firstName: string | null
    lastName: string | null
    dateJoined: Date
    lastEdited: Date
    email: string
    password: string
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userName?: boolean
    firstName?: boolean
    lastName?: boolean
    dateJoined?: boolean
    lastEdited?: boolean
    email?: boolean
    password?: boolean
    profile?: boolean | User$profileArgs<ExtArgs>
    recipeBookUser?: boolean | User$recipeBookUserArgs<ExtArgs>
    recipeBook?: boolean | User$recipeBookArgs<ExtArgs>
    recipeBookEditedBy?: boolean | User$recipeBookEditedByArgs<ExtArgs>
    recipe?: boolean | User$recipeArgs<ExtArgs>
    recipeEditedBy?: boolean | User$recipeEditedByArgs<ExtArgs>
    buildUser?: boolean | User$buildUserArgs<ExtArgs>
    build?: boolean | User$buildArgs<ExtArgs>
    buildEditedBy?: boolean | User$buildEditedByArgs<ExtArgs>
    CrewUser?: boolean | User$CrewUserArgs<ExtArgs>
    crew?: boolean | User$crewArgs<ExtArgs>
    crewEditedBy?: boolean | User$crewEditedByArgs<ExtArgs>
    ingredient?: boolean | User$ingredientArgs<ExtArgs>
    ingredientPreference?: boolean | User$ingredientPreferenceArgs<ExtArgs>
    ingredientUser?: boolean | User$ingredientUserArgs<ExtArgs>
    storageUser?: boolean | User$storageUserArgs<ExtArgs>
    storage?: boolean | User$storageArgs<ExtArgs>
    storageEditedBy?: boolean | User$storageEditedByArgs<ExtArgs>
    inventory?: boolean | User$inventoryArgs<ExtArgs>
    inventoryEditedBy?: boolean | User$inventoryEditedByArgs<ExtArgs>
    inventoryUser?: boolean | User$inventoryUserArgs<ExtArgs>
    followedBy?: boolean | User$followedByArgs<ExtArgs>
    following?: boolean | User$followingArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    userName?: boolean
    firstName?: boolean
    lastName?: boolean
    dateJoined?: boolean
    lastEdited?: boolean
    email?: boolean
    password?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | User$profileArgs<ExtArgs>
    recipeBookUser?: boolean | User$recipeBookUserArgs<ExtArgs>
    recipeBook?: boolean | User$recipeBookArgs<ExtArgs>
    recipeBookEditedBy?: boolean | User$recipeBookEditedByArgs<ExtArgs>
    recipe?: boolean | User$recipeArgs<ExtArgs>
    recipeEditedBy?: boolean | User$recipeEditedByArgs<ExtArgs>
    buildUser?: boolean | User$buildUserArgs<ExtArgs>
    build?: boolean | User$buildArgs<ExtArgs>
    buildEditedBy?: boolean | User$buildEditedByArgs<ExtArgs>
    CrewUser?: boolean | User$CrewUserArgs<ExtArgs>
    crew?: boolean | User$crewArgs<ExtArgs>
    crewEditedBy?: boolean | User$crewEditedByArgs<ExtArgs>
    ingredient?: boolean | User$ingredientArgs<ExtArgs>
    ingredientPreference?: boolean | User$ingredientPreferenceArgs<ExtArgs>
    ingredientUser?: boolean | User$ingredientUserArgs<ExtArgs>
    storageUser?: boolean | User$storageUserArgs<ExtArgs>
    storage?: boolean | User$storageArgs<ExtArgs>
    storageEditedBy?: boolean | User$storageEditedByArgs<ExtArgs>
    inventory?: boolean | User$inventoryArgs<ExtArgs>
    inventoryEditedBy?: boolean | User$inventoryEditedByArgs<ExtArgs>
    inventoryUser?: boolean | User$inventoryUserArgs<ExtArgs>
    followedBy?: boolean | User$followedByArgs<ExtArgs>
    following?: boolean | User$followingArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs> | null
      recipeBookUser: Prisma.$RecipeBookUserPayload<ExtArgs>[]
      recipeBook: Prisma.$RecipeBookPayload<ExtArgs>[]
      recipeBookEditedBy: Prisma.$RecipeBookPayload<ExtArgs>[]
      recipe: Prisma.$RecipePayload<ExtArgs>[]
      recipeEditedBy: Prisma.$RecipePayload<ExtArgs>[]
      buildUser: Prisma.$BuildUserPayload<ExtArgs>[]
      build: Prisma.$BuildPayload<ExtArgs>[]
      buildEditedBy: Prisma.$BuildPayload<ExtArgs>[]
      CrewUser: Prisma.$CrewUserPayload<ExtArgs>[]
      crew: Prisma.$CrewPayload<ExtArgs>[]
      crewEditedBy: Prisma.$CrewPayload<ExtArgs>[]
      ingredient: Prisma.$SpecificIngredientPayload<ExtArgs>[]
      ingredientPreference: Prisma.$IngredientPreferencePayload<ExtArgs>[]
      ingredientUser: Prisma.$IngredientUserPayload<ExtArgs>[]
      storageUser: Prisma.$StorageUserPayload<ExtArgs>[]
      storage: Prisma.$StoragePayload<ExtArgs>[]
      storageEditedBy: Prisma.$StoragePayload<ExtArgs>[]
      inventory: Prisma.$InventoryPayload<ExtArgs>[]
      inventoryEditedBy: Prisma.$InventoryPayload<ExtArgs>[]
      inventoryUser: Prisma.$InventoryUserPayload<ExtArgs>[]
      followedBy: Prisma.$FollowPayload<ExtArgs>[]
      following: Prisma.$FollowPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userName: string
      firstName: string | null
      lastName: string | null
      dateJoined: Date
      lastEdited: Date
      email: string
      password: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    profile<T extends User$profileArgs<ExtArgs> = {}>(args?: Subset<T, User$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    recipeBookUser<T extends User$recipeBookUserArgs<ExtArgs> = {}>(args?: Subset<T, User$recipeBookUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeBookUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    recipeBook<T extends User$recipeBookArgs<ExtArgs> = {}>(args?: Subset<T, User$recipeBookArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeBookPayload<ExtArgs>, T, 'findMany'> | Null>;

    recipeBookEditedBy<T extends User$recipeBookEditedByArgs<ExtArgs> = {}>(args?: Subset<T, User$recipeBookEditedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeBookPayload<ExtArgs>, T, 'findMany'> | Null>;

    recipe<T extends User$recipeArgs<ExtArgs> = {}>(args?: Subset<T, User$recipeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findMany'> | Null>;

    recipeEditedBy<T extends User$recipeEditedByArgs<ExtArgs> = {}>(args?: Subset<T, User$recipeEditedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findMany'> | Null>;

    buildUser<T extends User$buildUserArgs<ExtArgs> = {}>(args?: Subset<T, User$buildUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    build<T extends User$buildArgs<ExtArgs> = {}>(args?: Subset<T, User$buildArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'findMany'> | Null>;

    buildEditedBy<T extends User$buildEditedByArgs<ExtArgs> = {}>(args?: Subset<T, User$buildEditedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'findMany'> | Null>;

    CrewUser<T extends User$CrewUserArgs<ExtArgs> = {}>(args?: Subset<T, User$CrewUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    crew<T extends User$crewArgs<ExtArgs> = {}>(args?: Subset<T, User$crewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, 'findMany'> | Null>;

    crewEditedBy<T extends User$crewEditedByArgs<ExtArgs> = {}>(args?: Subset<T, User$crewEditedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, 'findMany'> | Null>;

    ingredient<T extends User$ingredientArgs<ExtArgs> = {}>(args?: Subset<T, User$ingredientArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecificIngredientPayload<ExtArgs>, T, 'findMany'> | Null>;

    ingredientPreference<T extends User$ingredientPreferenceArgs<ExtArgs> = {}>(args?: Subset<T, User$ingredientPreferenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientPreferencePayload<ExtArgs>, T, 'findMany'> | Null>;

    ingredientUser<T extends User$ingredientUserArgs<ExtArgs> = {}>(args?: Subset<T, User$ingredientUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    storageUser<T extends User$storageUserArgs<ExtArgs> = {}>(args?: Subset<T, User$storageUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorageUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    storage<T extends User$storageArgs<ExtArgs> = {}>(args?: Subset<T, User$storageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, 'findMany'> | Null>;

    storageEditedBy<T extends User$storageEditedByArgs<ExtArgs> = {}>(args?: Subset<T, User$storageEditedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, 'findMany'> | Null>;

    inventory<T extends User$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, User$inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    inventoryEditedBy<T extends User$inventoryEditedByArgs<ExtArgs> = {}>(args?: Subset<T, User$inventoryEditedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    inventoryUser<T extends User$inventoryUserArgs<ExtArgs> = {}>(args?: Subset<T, User$inventoryUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    followedBy<T extends User$followedByArgs<ExtArgs> = {}>(args?: Subset<T, User$followedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, 'findMany'> | Null>;

    following<T extends User$followingArgs<ExtArgs> = {}>(args?: Subset<T, User$followingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly userName: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly dateJoined: FieldRef<"User", 'DateTime'>
    readonly lastEdited: FieldRef<"User", 'DateTime'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.profile
   */
  export type User$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }


  /**
   * User.recipeBookUser
   */
  export type User$recipeBookUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     */
    select?: RecipeBookUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookUserInclude<ExtArgs> | null
    where?: RecipeBookUserWhereInput
    orderBy?: RecipeBookUserOrderByWithRelationInput | RecipeBookUserOrderByWithRelationInput[]
    cursor?: RecipeBookUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeBookUserScalarFieldEnum | RecipeBookUserScalarFieldEnum[]
  }


  /**
   * User.recipeBook
   */
  export type User$recipeBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBook
     */
    select?: RecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookInclude<ExtArgs> | null
    where?: RecipeBookWhereInput
    orderBy?: RecipeBookOrderByWithRelationInput | RecipeBookOrderByWithRelationInput[]
    cursor?: RecipeBookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeBookScalarFieldEnum | RecipeBookScalarFieldEnum[]
  }


  /**
   * User.recipeBookEditedBy
   */
  export type User$recipeBookEditedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBook
     */
    select?: RecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookInclude<ExtArgs> | null
    where?: RecipeBookWhereInput
    orderBy?: RecipeBookOrderByWithRelationInput | RecipeBookOrderByWithRelationInput[]
    cursor?: RecipeBookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeBookScalarFieldEnum | RecipeBookScalarFieldEnum[]
  }


  /**
   * User.recipe
   */
  export type User$recipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    where?: RecipeWhereInput
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    cursor?: RecipeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }


  /**
   * User.recipeEditedBy
   */
  export type User$recipeEditedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    where?: RecipeWhereInput
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    cursor?: RecipeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }


  /**
   * User.buildUser
   */
  export type User$buildUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildUser
     */
    select?: BuildUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildUserInclude<ExtArgs> | null
    where?: BuildUserWhereInput
    orderBy?: BuildUserOrderByWithRelationInput | BuildUserOrderByWithRelationInput[]
    cursor?: BuildUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuildUserScalarFieldEnum | BuildUserScalarFieldEnum[]
  }


  /**
   * User.build
   */
  export type User$buildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    where?: BuildWhereInput
    orderBy?: BuildOrderByWithRelationInput | BuildOrderByWithRelationInput[]
    cursor?: BuildWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuildScalarFieldEnum | BuildScalarFieldEnum[]
  }


  /**
   * User.buildEditedBy
   */
  export type User$buildEditedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    where?: BuildWhereInput
    orderBy?: BuildOrderByWithRelationInput | BuildOrderByWithRelationInput[]
    cursor?: BuildWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuildScalarFieldEnum | BuildScalarFieldEnum[]
  }


  /**
   * User.CrewUser
   */
  export type User$CrewUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewUser
     */
    select?: CrewUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewUserInclude<ExtArgs> | null
    where?: CrewUserWhereInput
    orderBy?: CrewUserOrderByWithRelationInput | CrewUserOrderByWithRelationInput[]
    cursor?: CrewUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrewUserScalarFieldEnum | CrewUserScalarFieldEnum[]
  }


  /**
   * User.crew
   */
  export type User$crewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInclude<ExtArgs> | null
    where?: CrewWhereInput
    orderBy?: CrewOrderByWithRelationInput | CrewOrderByWithRelationInput[]
    cursor?: CrewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrewScalarFieldEnum | CrewScalarFieldEnum[]
  }


  /**
   * User.crewEditedBy
   */
  export type User$crewEditedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInclude<ExtArgs> | null
    where?: CrewWhereInput
    orderBy?: CrewOrderByWithRelationInput | CrewOrderByWithRelationInput[]
    cursor?: CrewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrewScalarFieldEnum | CrewScalarFieldEnum[]
  }


  /**
   * User.ingredient
   */
  export type User$ingredientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificIngredient
     */
    select?: SpecificIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecificIngredientInclude<ExtArgs> | null
    where?: SpecificIngredientWhereInput
    orderBy?: SpecificIngredientOrderByWithRelationInput | SpecificIngredientOrderByWithRelationInput[]
    cursor?: SpecificIngredientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpecificIngredientScalarFieldEnum | SpecificIngredientScalarFieldEnum[]
  }


  /**
   * User.ingredientPreference
   */
  export type User$ingredientPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientPreference
     */
    select?: IngredientPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientPreferenceInclude<ExtArgs> | null
    where?: IngredientPreferenceWhereInput
    orderBy?: IngredientPreferenceOrderByWithRelationInput | IngredientPreferenceOrderByWithRelationInput[]
    cursor?: IngredientPreferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IngredientPreferenceScalarFieldEnum | IngredientPreferenceScalarFieldEnum[]
  }


  /**
   * User.ingredientUser
   */
  export type User$ingredientUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientUser
     */
    select?: IngredientUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientUserInclude<ExtArgs> | null
    where?: IngredientUserWhereInput
    orderBy?: IngredientUserOrderByWithRelationInput | IngredientUserOrderByWithRelationInput[]
    cursor?: IngredientUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IngredientUserScalarFieldEnum | IngredientUserScalarFieldEnum[]
  }


  /**
   * User.storageUser
   */
  export type User$storageUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageUser
     */
    select?: StorageUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageUserInclude<ExtArgs> | null
    where?: StorageUserWhereInput
    orderBy?: StorageUserOrderByWithRelationInput | StorageUserOrderByWithRelationInput[]
    cursor?: StorageUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StorageUserScalarFieldEnum | StorageUserScalarFieldEnum[]
  }


  /**
   * User.storage
   */
  export type User$storageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageInclude<ExtArgs> | null
    where?: StorageWhereInput
    orderBy?: StorageOrderByWithRelationInput | StorageOrderByWithRelationInput[]
    cursor?: StorageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StorageScalarFieldEnum | StorageScalarFieldEnum[]
  }


  /**
   * User.storageEditedBy
   */
  export type User$storageEditedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageInclude<ExtArgs> | null
    where?: StorageWhereInput
    orderBy?: StorageOrderByWithRelationInput | StorageOrderByWithRelationInput[]
    cursor?: StorageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StorageScalarFieldEnum | StorageScalarFieldEnum[]
  }


  /**
   * User.inventory
   */
  export type User$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    cursor?: InventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }


  /**
   * User.inventoryEditedBy
   */
  export type User$inventoryEditedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    cursor?: InventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }


  /**
   * User.inventoryUser
   */
  export type User$inventoryUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUser
     */
    select?: InventoryUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryUserInclude<ExtArgs> | null
    where?: InventoryUserWhereInput
    orderBy?: InventoryUserOrderByWithRelationInput | InventoryUserOrderByWithRelationInput[]
    cursor?: InventoryUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryUserScalarFieldEnum | InventoryUserScalarFieldEnum[]
  }


  /**
   * User.followedBy
   */
  export type User$followedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowInclude<ExtArgs> | null
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    cursor?: FollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }


  /**
   * User.following
   */
  export type User$followingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowInclude<ExtArgs> | null
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    cursor?: FollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model Follow
   */

  export type AggregateFollow = {
    _count: FollowCountAggregateOutputType | null
    _min: FollowMinAggregateOutputType | null
    _max: FollowMaxAggregateOutputType | null
  }

  export type FollowMinAggregateOutputType = {
    followedById: string | null
    followingId: string | null
    relationship: string | null
  }

  export type FollowMaxAggregateOutputType = {
    followedById: string | null
    followingId: string | null
    relationship: string | null
  }

  export type FollowCountAggregateOutputType = {
    followedById: number
    followingId: number
    relationship: number
    _all: number
  }


  export type FollowMinAggregateInputType = {
    followedById?: true
    followingId?: true
    relationship?: true
  }

  export type FollowMaxAggregateInputType = {
    followedById?: true
    followingId?: true
    relationship?: true
  }

  export type FollowCountAggregateInputType = {
    followedById?: true
    followingId?: true
    relationship?: true
    _all?: true
  }

  export type FollowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Follow to aggregate.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Follows
    **/
    _count?: true | FollowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FollowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FollowMaxAggregateInputType
  }

  export type GetFollowAggregateType<T extends FollowAggregateArgs> = {
        [P in keyof T & keyof AggregateFollow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollow[P]>
      : GetScalarType<T[P], AggregateFollow[P]>
  }




  export type FollowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithAggregationInput | FollowOrderByWithAggregationInput[]
    by: FollowScalarFieldEnum[] | FollowScalarFieldEnum
    having?: FollowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FollowCountAggregateInputType | true
    _min?: FollowMinAggregateInputType
    _max?: FollowMaxAggregateInputType
  }

  export type FollowGroupByOutputType = {
    followedById: string
    followingId: string
    relationship: string
    _count: FollowCountAggregateOutputType | null
    _min: FollowMinAggregateOutputType | null
    _max: FollowMaxAggregateOutputType | null
  }

  type GetFollowGroupByPayload<T extends FollowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FollowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FollowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowGroupByOutputType[P]>
            : GetScalarType<T[P], FollowGroupByOutputType[P]>
        }
      >
    >


  export type FollowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    followedById?: boolean
    followingId?: boolean
    relationship?: boolean
    followedBy?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follow"]>

  export type FollowSelectScalar = {
    followedById?: boolean
    followingId?: boolean
    relationship?: boolean
  }

  export type FollowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    followedBy?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $FollowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Follow"
    objects: {
      followedBy: Prisma.$UserPayload<ExtArgs>
      following: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      followedById: string
      followingId: string
      relationship: string
    }, ExtArgs["result"]["follow"]>
    composites: {}
  }


  type FollowGetPayload<S extends boolean | null | undefined | FollowDefaultArgs> = $Result.GetResult<Prisma.$FollowPayload, S>

  type FollowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FollowFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: FollowCountAggregateInputType | true
    }

  export interface FollowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Follow'], meta: { name: 'Follow' } }
    /**
     * Find zero or one Follow that matches the filter.
     * @param {FollowFindUniqueArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FollowFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FollowFindUniqueArgs<ExtArgs>>
    ): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Follow that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FollowFindUniqueOrThrowArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FollowFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FollowFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Follow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindFirstArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FollowFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FollowFindFirstArgs<ExtArgs>>
    ): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Follow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindFirstOrThrowArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FollowFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FollowFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Follows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Follows
     * const follows = await prisma.follow.findMany()
     * 
     * // Get first 10 Follows
     * const follows = await prisma.follow.findMany({ take: 10 })
     * 
     * // Only select the `followedById`
     * const followWithFollowedByIdOnly = await prisma.follow.findMany({ select: { followedById: true } })
     * 
    **/
    findMany<T extends FollowFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FollowFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Follow.
     * @param {FollowCreateArgs} args - Arguments to create a Follow.
     * @example
     * // Create one Follow
     * const Follow = await prisma.follow.create({
     *   data: {
     *     // ... data to create a Follow
     *   }
     * })
     * 
    **/
    create<T extends FollowCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FollowCreateArgs<ExtArgs>>
    ): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Follows.
     *     @param {FollowCreateManyArgs} args - Arguments to create many Follows.
     *     @example
     *     // Create many Follows
     *     const follow = await prisma.follow.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FollowCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FollowCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Follow.
     * @param {FollowDeleteArgs} args - Arguments to delete one Follow.
     * @example
     * // Delete one Follow
     * const Follow = await prisma.follow.delete({
     *   where: {
     *     // ... filter to delete one Follow
     *   }
     * })
     * 
    **/
    delete<T extends FollowDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FollowDeleteArgs<ExtArgs>>
    ): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Follow.
     * @param {FollowUpdateArgs} args - Arguments to update one Follow.
     * @example
     * // Update one Follow
     * const follow = await prisma.follow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FollowUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FollowUpdateArgs<ExtArgs>>
    ): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Follows.
     * @param {FollowDeleteManyArgs} args - Arguments to filter Follows to delete.
     * @example
     * // Delete a few Follows
     * const { count } = await prisma.follow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FollowDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FollowDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Follows
     * const follow = await prisma.follow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FollowUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FollowUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Follow.
     * @param {FollowUpsertArgs} args - Arguments to update or create a Follow.
     * @example
     * // Update or create a Follow
     * const follow = await prisma.follow.upsert({
     *   create: {
     *     // ... data to create a Follow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Follow we want to update
     *   }
     * })
    **/
    upsert<T extends FollowUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FollowUpsertArgs<ExtArgs>>
    ): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowCountArgs} args - Arguments to filter Follows to count.
     * @example
     * // Count the number of Follows
     * const count = await prisma.follow.count({
     *   where: {
     *     // ... the filter for the Follows we want to count
     *   }
     * })
    **/
    count<T extends FollowCountArgs>(
      args?: Subset<T, FollowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Follow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FollowAggregateArgs>(args: Subset<T, FollowAggregateArgs>): Prisma.PrismaPromise<GetFollowAggregateType<T>>

    /**
     * Group by Follow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FollowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FollowGroupByArgs['orderBy'] }
        : { orderBy?: FollowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FollowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFollowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Follow model
   */
  readonly fields: FollowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Follow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FollowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    followedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    following<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Follow model
   */ 
  interface FollowFieldRefs {
    readonly followedById: FieldRef<"Follow", 'String'>
    readonly followingId: FieldRef<"Follow", 'String'>
    readonly relationship: FieldRef<"Follow", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Follow findUnique
   */
  export type FollowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where: FollowWhereUniqueInput
  }


  /**
   * Follow findUniqueOrThrow
   */
  export type FollowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where: FollowWhereUniqueInput
  }


  /**
   * Follow findFirst
   */
  export type FollowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Follows.
     */
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }


  /**
   * Follow findFirstOrThrow
   */
  export type FollowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Follows.
     */
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }


  /**
   * Follow findMany
   */
  export type FollowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follows to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }


  /**
   * Follow create
   */
  export type FollowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The data needed to create a Follow.
     */
    data: XOR<FollowCreateInput, FollowUncheckedCreateInput>
  }


  /**
   * Follow createMany
   */
  export type FollowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Follows.
     */
    data: FollowCreateManyInput | FollowCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Follow update
   */
  export type FollowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The data needed to update a Follow.
     */
    data: XOR<FollowUpdateInput, FollowUncheckedUpdateInput>
    /**
     * Choose, which Follow to update.
     */
    where: FollowWhereUniqueInput
  }


  /**
   * Follow updateMany
   */
  export type FollowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Follows.
     */
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyInput>
    /**
     * Filter which Follows to update
     */
    where?: FollowWhereInput
  }


  /**
   * Follow upsert
   */
  export type FollowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The filter to search for the Follow to update in case it exists.
     */
    where: FollowWhereUniqueInput
    /**
     * In case the Follow found by the `where` argument doesn't exist, create a new Follow with this data.
     */
    create: XOR<FollowCreateInput, FollowUncheckedCreateInput>
    /**
     * In case the Follow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FollowUpdateInput, FollowUncheckedUpdateInput>
  }


  /**
   * Follow delete
   */
  export type FollowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter which Follow to delete.
     */
    where: FollowWhereUniqueInput
  }


  /**
   * Follow deleteMany
   */
  export type FollowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Follows to delete
     */
    where?: FollowWhereInput
  }


  /**
   * Follow without action
   */
  export type FollowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowInclude<ExtArgs> | null
  }



  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    photo: string | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    photo: string | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    userId: number
    photo: number
    _all: number
  }


  export type ProfileMinAggregateInputType = {
    id?: true
    userId?: true
    photo?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    photo?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    userId?: true
    photo?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    userId: string
    photo: string
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    photo?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    photo?: boolean
  }

  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      photo: string
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }


  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProfileFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>
    ): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Profile that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProfileFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>
    ): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProfileFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
    **/
    create<T extends ProfileCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>
    ): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Profiles.
     *     @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     *     @example
     *     // Create many Profiles
     *     const profile = await prisma.profile.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProfileCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
    **/
    delete<T extends ProfileDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>
    ): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProfileUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>
    ): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProfileDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProfileUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
    **/
    upsert<T extends ProfileUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>
    ): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Profile model
   */ 
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'String'>
    readonly userId: FieldRef<"Profile", 'String'>
    readonly photo: FieldRef<"Profile", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }


  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }


  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }


  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }


  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }


  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }


  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }


  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
  }


  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }


  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }


  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
  }


  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
  }



  /**
   * Model RecipeBook
   */

  export type AggregateRecipeBook = {
    _count: RecipeBookCountAggregateOutputType | null
    _min: RecipeBookMinAggregateOutputType | null
    _max: RecipeBookMaxAggregateOutputType | null
  }

  export type RecipeBookMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
  }

  export type RecipeBookMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
  }

  export type RecipeBookCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    editedAt: number
    createdById: number
    editedById: number
    _all: number
  }


  export type RecipeBookMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
  }

  export type RecipeBookMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
  }

  export type RecipeBookCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
    _all?: true
  }

  export type RecipeBookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeBook to aggregate.
     */
    where?: RecipeBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBooks to fetch.
     */
    orderBy?: RecipeBookOrderByWithRelationInput | RecipeBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecipeBooks
    **/
    _count?: true | RecipeBookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeBookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeBookMaxAggregateInputType
  }

  export type GetRecipeBookAggregateType<T extends RecipeBookAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipeBook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipeBook[P]>
      : GetScalarType<T[P], AggregateRecipeBook[P]>
  }




  export type RecipeBookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeBookWhereInput
    orderBy?: RecipeBookOrderByWithAggregationInput | RecipeBookOrderByWithAggregationInput[]
    by: RecipeBookScalarFieldEnum[] | RecipeBookScalarFieldEnum
    having?: RecipeBookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeBookCountAggregateInputType | true
    _min?: RecipeBookMinAggregateInputType
    _max?: RecipeBookMaxAggregateInputType
  }

  export type RecipeBookGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    editedAt: Date
    createdById: string | null
    editedById: string | null
    _count: RecipeBookCountAggregateOutputType | null
    _min: RecipeBookMinAggregateOutputType | null
    _max: RecipeBookMaxAggregateOutputType | null
  }

  type GetRecipeBookGroupByPayload<T extends RecipeBookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeBookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeBookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeBookGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeBookGroupByOutputType[P]>
        }
      >
    >


  export type RecipeBookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    editedAt?: boolean
    createdById?: boolean
    editedById?: boolean
    createdBy?: boolean | RecipeBook$createdByArgs<ExtArgs>
    editedBy?: boolean | RecipeBook$editedByArgs<ExtArgs>
    recipeBookBuild?: boolean | RecipeBook$recipeBookBuildArgs<ExtArgs>
    recipeBookUser?: boolean | RecipeBook$recipeBookUserArgs<ExtArgs>
    _count?: boolean | RecipeBookCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeBook"]>

  export type RecipeBookSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    editedAt?: boolean
    createdById?: boolean
    editedById?: boolean
  }

  export type RecipeBookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | RecipeBook$createdByArgs<ExtArgs>
    editedBy?: boolean | RecipeBook$editedByArgs<ExtArgs>
    recipeBookBuild?: boolean | RecipeBook$recipeBookBuildArgs<ExtArgs>
    recipeBookUser?: boolean | RecipeBook$recipeBookUserArgs<ExtArgs>
    _count?: boolean | RecipeBookCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $RecipeBookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecipeBook"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      editedBy: Prisma.$UserPayload<ExtArgs> | null
      recipeBookBuild: Prisma.$RecipeBookBuildPayload<ExtArgs>[]
      recipeBookUser: Prisma.$RecipeBookUserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      editedAt: Date
      createdById: string | null
      editedById: string | null
    }, ExtArgs["result"]["recipeBook"]>
    composites: {}
  }


  type RecipeBookGetPayload<S extends boolean | null | undefined | RecipeBookDefaultArgs> = $Result.GetResult<Prisma.$RecipeBookPayload, S>

  type RecipeBookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RecipeBookFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: RecipeBookCountAggregateInputType | true
    }

  export interface RecipeBookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecipeBook'], meta: { name: 'RecipeBook' } }
    /**
     * Find zero or one RecipeBook that matches the filter.
     * @param {RecipeBookFindUniqueArgs} args - Arguments to find a RecipeBook
     * @example
     * // Get one RecipeBook
     * const recipeBook = await prisma.recipeBook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RecipeBookFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookFindUniqueArgs<ExtArgs>>
    ): Prisma__RecipeBookClient<$Result.GetResult<Prisma.$RecipeBookPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RecipeBook that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RecipeBookFindUniqueOrThrowArgs} args - Arguments to find a RecipeBook
     * @example
     * // Get one RecipeBook
     * const recipeBook = await prisma.recipeBook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RecipeBookFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RecipeBookClient<$Result.GetResult<Prisma.$RecipeBookPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RecipeBook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookFindFirstArgs} args - Arguments to find a RecipeBook
     * @example
     * // Get one RecipeBook
     * const recipeBook = await prisma.recipeBook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RecipeBookFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookFindFirstArgs<ExtArgs>>
    ): Prisma__RecipeBookClient<$Result.GetResult<Prisma.$RecipeBookPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RecipeBook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookFindFirstOrThrowArgs} args - Arguments to find a RecipeBook
     * @example
     * // Get one RecipeBook
     * const recipeBook = await prisma.recipeBook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RecipeBookFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RecipeBookClient<$Result.GetResult<Prisma.$RecipeBookPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RecipeBooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecipeBooks
     * const recipeBooks = await prisma.recipeBook.findMany()
     * 
     * // Get first 10 RecipeBooks
     * const recipeBooks = await prisma.recipeBook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeBookWithIdOnly = await prisma.recipeBook.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RecipeBookFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeBookPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RecipeBook.
     * @param {RecipeBookCreateArgs} args - Arguments to create a RecipeBook.
     * @example
     * // Create one RecipeBook
     * const RecipeBook = await prisma.recipeBook.create({
     *   data: {
     *     // ... data to create a RecipeBook
     *   }
     * })
     * 
    **/
    create<T extends RecipeBookCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookCreateArgs<ExtArgs>>
    ): Prisma__RecipeBookClient<$Result.GetResult<Prisma.$RecipeBookPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RecipeBooks.
     *     @param {RecipeBookCreateManyArgs} args - Arguments to create many RecipeBooks.
     *     @example
     *     // Create many RecipeBooks
     *     const recipeBook = await prisma.recipeBook.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RecipeBookCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RecipeBook.
     * @param {RecipeBookDeleteArgs} args - Arguments to delete one RecipeBook.
     * @example
     * // Delete one RecipeBook
     * const RecipeBook = await prisma.recipeBook.delete({
     *   where: {
     *     // ... filter to delete one RecipeBook
     *   }
     * })
     * 
    **/
    delete<T extends RecipeBookDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookDeleteArgs<ExtArgs>>
    ): Prisma__RecipeBookClient<$Result.GetResult<Prisma.$RecipeBookPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RecipeBook.
     * @param {RecipeBookUpdateArgs} args - Arguments to update one RecipeBook.
     * @example
     * // Update one RecipeBook
     * const recipeBook = await prisma.recipeBook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RecipeBookUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookUpdateArgs<ExtArgs>>
    ): Prisma__RecipeBookClient<$Result.GetResult<Prisma.$RecipeBookPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RecipeBooks.
     * @param {RecipeBookDeleteManyArgs} args - Arguments to filter RecipeBooks to delete.
     * @example
     * // Delete a few RecipeBooks
     * const { count } = await prisma.recipeBook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RecipeBookDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecipeBooks
     * const recipeBook = await prisma.recipeBook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RecipeBookUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RecipeBook.
     * @param {RecipeBookUpsertArgs} args - Arguments to update or create a RecipeBook.
     * @example
     * // Update or create a RecipeBook
     * const recipeBook = await prisma.recipeBook.upsert({
     *   create: {
     *     // ... data to create a RecipeBook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecipeBook we want to update
     *   }
     * })
    **/
    upsert<T extends RecipeBookUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookUpsertArgs<ExtArgs>>
    ): Prisma__RecipeBookClient<$Result.GetResult<Prisma.$RecipeBookPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RecipeBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookCountArgs} args - Arguments to filter RecipeBooks to count.
     * @example
     * // Count the number of RecipeBooks
     * const count = await prisma.recipeBook.count({
     *   where: {
     *     // ... the filter for the RecipeBooks we want to count
     *   }
     * })
    **/
    count<T extends RecipeBookCountArgs>(
      args?: Subset<T, RecipeBookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeBookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecipeBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeBookAggregateArgs>(args: Subset<T, RecipeBookAggregateArgs>): Prisma.PrismaPromise<GetRecipeBookAggregateType<T>>

    /**
     * Group by RecipeBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeBookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeBookGroupByArgs['orderBy'] }
        : { orderBy?: RecipeBookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeBookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeBookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecipeBook model
   */
  readonly fields: RecipeBookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecipeBook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeBookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    createdBy<T extends RecipeBook$createdByArgs<ExtArgs> = {}>(args?: Subset<T, RecipeBook$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    editedBy<T extends RecipeBook$editedByArgs<ExtArgs> = {}>(args?: Subset<T, RecipeBook$editedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    recipeBookBuild<T extends RecipeBook$recipeBookBuildArgs<ExtArgs> = {}>(args?: Subset<T, RecipeBook$recipeBookBuildArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeBookBuildPayload<ExtArgs>, T, 'findMany'> | Null>;

    recipeBookUser<T extends RecipeBook$recipeBookUserArgs<ExtArgs> = {}>(args?: Subset<T, RecipeBook$recipeBookUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeBookUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RecipeBook model
   */ 
  interface RecipeBookFieldRefs {
    readonly id: FieldRef<"RecipeBook", 'String'>
    readonly name: FieldRef<"RecipeBook", 'String'>
    readonly description: FieldRef<"RecipeBook", 'String'>
    readonly createdAt: FieldRef<"RecipeBook", 'DateTime'>
    readonly editedAt: FieldRef<"RecipeBook", 'DateTime'>
    readonly createdById: FieldRef<"RecipeBook", 'String'>
    readonly editedById: FieldRef<"RecipeBook", 'String'>
  }
    

  // Custom InputTypes

  /**
   * RecipeBook findUnique
   */
  export type RecipeBookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBook
     */
    select?: RecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookInclude<ExtArgs> | null
    /**
     * Filter, which RecipeBook to fetch.
     */
    where: RecipeBookWhereUniqueInput
  }


  /**
   * RecipeBook findUniqueOrThrow
   */
  export type RecipeBookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBook
     */
    select?: RecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookInclude<ExtArgs> | null
    /**
     * Filter, which RecipeBook to fetch.
     */
    where: RecipeBookWhereUniqueInput
  }


  /**
   * RecipeBook findFirst
   */
  export type RecipeBookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBook
     */
    select?: RecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookInclude<ExtArgs> | null
    /**
     * Filter, which RecipeBook to fetch.
     */
    where?: RecipeBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBooks to fetch.
     */
    orderBy?: RecipeBookOrderByWithRelationInput | RecipeBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeBooks.
     */
    cursor?: RecipeBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeBooks.
     */
    distinct?: RecipeBookScalarFieldEnum | RecipeBookScalarFieldEnum[]
  }


  /**
   * RecipeBook findFirstOrThrow
   */
  export type RecipeBookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBook
     */
    select?: RecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookInclude<ExtArgs> | null
    /**
     * Filter, which RecipeBook to fetch.
     */
    where?: RecipeBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBooks to fetch.
     */
    orderBy?: RecipeBookOrderByWithRelationInput | RecipeBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeBooks.
     */
    cursor?: RecipeBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeBooks.
     */
    distinct?: RecipeBookScalarFieldEnum | RecipeBookScalarFieldEnum[]
  }


  /**
   * RecipeBook findMany
   */
  export type RecipeBookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBook
     */
    select?: RecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookInclude<ExtArgs> | null
    /**
     * Filter, which RecipeBooks to fetch.
     */
    where?: RecipeBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBooks to fetch.
     */
    orderBy?: RecipeBookOrderByWithRelationInput | RecipeBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecipeBooks.
     */
    cursor?: RecipeBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBooks.
     */
    skip?: number
    distinct?: RecipeBookScalarFieldEnum | RecipeBookScalarFieldEnum[]
  }


  /**
   * RecipeBook create
   */
  export type RecipeBookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBook
     */
    select?: RecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookInclude<ExtArgs> | null
    /**
     * The data needed to create a RecipeBook.
     */
    data: XOR<RecipeBookCreateInput, RecipeBookUncheckedCreateInput>
  }


  /**
   * RecipeBook createMany
   */
  export type RecipeBookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecipeBooks.
     */
    data: RecipeBookCreateManyInput | RecipeBookCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RecipeBook update
   */
  export type RecipeBookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBook
     */
    select?: RecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookInclude<ExtArgs> | null
    /**
     * The data needed to update a RecipeBook.
     */
    data: XOR<RecipeBookUpdateInput, RecipeBookUncheckedUpdateInput>
    /**
     * Choose, which RecipeBook to update.
     */
    where: RecipeBookWhereUniqueInput
  }


  /**
   * RecipeBook updateMany
   */
  export type RecipeBookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecipeBooks.
     */
    data: XOR<RecipeBookUpdateManyMutationInput, RecipeBookUncheckedUpdateManyInput>
    /**
     * Filter which RecipeBooks to update
     */
    where?: RecipeBookWhereInput
  }


  /**
   * RecipeBook upsert
   */
  export type RecipeBookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBook
     */
    select?: RecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookInclude<ExtArgs> | null
    /**
     * The filter to search for the RecipeBook to update in case it exists.
     */
    where: RecipeBookWhereUniqueInput
    /**
     * In case the RecipeBook found by the `where` argument doesn't exist, create a new RecipeBook with this data.
     */
    create: XOR<RecipeBookCreateInput, RecipeBookUncheckedCreateInput>
    /**
     * In case the RecipeBook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeBookUpdateInput, RecipeBookUncheckedUpdateInput>
  }


  /**
   * RecipeBook delete
   */
  export type RecipeBookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBook
     */
    select?: RecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookInclude<ExtArgs> | null
    /**
     * Filter which RecipeBook to delete.
     */
    where: RecipeBookWhereUniqueInput
  }


  /**
   * RecipeBook deleteMany
   */
  export type RecipeBookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeBooks to delete
     */
    where?: RecipeBookWhereInput
  }


  /**
   * RecipeBook.createdBy
   */
  export type RecipeBook$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * RecipeBook.editedBy
   */
  export type RecipeBook$editedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * RecipeBook.recipeBookBuild
   */
  export type RecipeBook$recipeBookBuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     */
    select?: RecipeBookBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookBuildInclude<ExtArgs> | null
    where?: RecipeBookBuildWhereInput
    orderBy?: RecipeBookBuildOrderByWithRelationInput | RecipeBookBuildOrderByWithRelationInput[]
    cursor?: RecipeBookBuildWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeBookBuildScalarFieldEnum | RecipeBookBuildScalarFieldEnum[]
  }


  /**
   * RecipeBook.recipeBookUser
   */
  export type RecipeBook$recipeBookUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     */
    select?: RecipeBookUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookUserInclude<ExtArgs> | null
    where?: RecipeBookUserWhereInput
    orderBy?: RecipeBookUserOrderByWithRelationInput | RecipeBookUserOrderByWithRelationInput[]
    cursor?: RecipeBookUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeBookUserScalarFieldEnum | RecipeBookUserScalarFieldEnum[]
  }


  /**
   * RecipeBook without action
   */
  export type RecipeBookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBook
     */
    select?: RecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookInclude<ExtArgs> | null
  }



  /**
   * Model RecipeBookUser
   */

  export type AggregateRecipeBookUser = {
    _count: RecipeBookUserCountAggregateOutputType | null
    _min: RecipeBookUserMinAggregateOutputType | null
    _max: RecipeBookUserMaxAggregateOutputType | null
  }

  export type RecipeBookUserMinAggregateOutputType = {
    userId: string | null
    recipeBookId: string | null
    permission: string | null
  }

  export type RecipeBookUserMaxAggregateOutputType = {
    userId: string | null
    recipeBookId: string | null
    permission: string | null
  }

  export type RecipeBookUserCountAggregateOutputType = {
    userId: number
    recipeBookId: number
    permission: number
    _all: number
  }


  export type RecipeBookUserMinAggregateInputType = {
    userId?: true
    recipeBookId?: true
    permission?: true
  }

  export type RecipeBookUserMaxAggregateInputType = {
    userId?: true
    recipeBookId?: true
    permission?: true
  }

  export type RecipeBookUserCountAggregateInputType = {
    userId?: true
    recipeBookId?: true
    permission?: true
    _all?: true
  }

  export type RecipeBookUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeBookUser to aggregate.
     */
    where?: RecipeBookUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBookUsers to fetch.
     */
    orderBy?: RecipeBookUserOrderByWithRelationInput | RecipeBookUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeBookUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBookUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBookUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecipeBookUsers
    **/
    _count?: true | RecipeBookUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeBookUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeBookUserMaxAggregateInputType
  }

  export type GetRecipeBookUserAggregateType<T extends RecipeBookUserAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipeBookUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipeBookUser[P]>
      : GetScalarType<T[P], AggregateRecipeBookUser[P]>
  }




  export type RecipeBookUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeBookUserWhereInput
    orderBy?: RecipeBookUserOrderByWithAggregationInput | RecipeBookUserOrderByWithAggregationInput[]
    by: RecipeBookUserScalarFieldEnum[] | RecipeBookUserScalarFieldEnum
    having?: RecipeBookUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeBookUserCountAggregateInputType | true
    _min?: RecipeBookUserMinAggregateInputType
    _max?: RecipeBookUserMaxAggregateInputType
  }

  export type RecipeBookUserGroupByOutputType = {
    userId: string
    recipeBookId: string
    permission: string
    _count: RecipeBookUserCountAggregateOutputType | null
    _min: RecipeBookUserMinAggregateOutputType | null
    _max: RecipeBookUserMaxAggregateOutputType | null
  }

  type GetRecipeBookUserGroupByPayload<T extends RecipeBookUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeBookUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeBookUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeBookUserGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeBookUserGroupByOutputType[P]>
        }
      >
    >


  export type RecipeBookUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    recipeBookId?: boolean
    permission?: boolean
    recipeBook?: boolean | RecipeBookDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeBookUser"]>

  export type RecipeBookUserSelectScalar = {
    userId?: boolean
    recipeBookId?: boolean
    permission?: boolean
  }

  export type RecipeBookUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipeBook?: boolean | RecipeBookDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $RecipeBookUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecipeBookUser"
    objects: {
      recipeBook: Prisma.$RecipeBookPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      recipeBookId: string
      permission: string
    }, ExtArgs["result"]["recipeBookUser"]>
    composites: {}
  }


  type RecipeBookUserGetPayload<S extends boolean | null | undefined | RecipeBookUserDefaultArgs> = $Result.GetResult<Prisma.$RecipeBookUserPayload, S>

  type RecipeBookUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RecipeBookUserFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: RecipeBookUserCountAggregateInputType | true
    }

  export interface RecipeBookUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecipeBookUser'], meta: { name: 'RecipeBookUser' } }
    /**
     * Find zero or one RecipeBookUser that matches the filter.
     * @param {RecipeBookUserFindUniqueArgs} args - Arguments to find a RecipeBookUser
     * @example
     * // Get one RecipeBookUser
     * const recipeBookUser = await prisma.recipeBookUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RecipeBookUserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookUserFindUniqueArgs<ExtArgs>>
    ): Prisma__RecipeBookUserClient<$Result.GetResult<Prisma.$RecipeBookUserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RecipeBookUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RecipeBookUserFindUniqueOrThrowArgs} args - Arguments to find a RecipeBookUser
     * @example
     * // Get one RecipeBookUser
     * const recipeBookUser = await prisma.recipeBookUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RecipeBookUserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookUserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RecipeBookUserClient<$Result.GetResult<Prisma.$RecipeBookUserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RecipeBookUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookUserFindFirstArgs} args - Arguments to find a RecipeBookUser
     * @example
     * // Get one RecipeBookUser
     * const recipeBookUser = await prisma.recipeBookUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RecipeBookUserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookUserFindFirstArgs<ExtArgs>>
    ): Prisma__RecipeBookUserClient<$Result.GetResult<Prisma.$RecipeBookUserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RecipeBookUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookUserFindFirstOrThrowArgs} args - Arguments to find a RecipeBookUser
     * @example
     * // Get one RecipeBookUser
     * const recipeBookUser = await prisma.recipeBookUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RecipeBookUserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookUserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RecipeBookUserClient<$Result.GetResult<Prisma.$RecipeBookUserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RecipeBookUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecipeBookUsers
     * const recipeBookUsers = await prisma.recipeBookUser.findMany()
     * 
     * // Get first 10 RecipeBookUsers
     * const recipeBookUsers = await prisma.recipeBookUser.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const recipeBookUserWithUserIdOnly = await prisma.recipeBookUser.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends RecipeBookUserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookUserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeBookUserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RecipeBookUser.
     * @param {RecipeBookUserCreateArgs} args - Arguments to create a RecipeBookUser.
     * @example
     * // Create one RecipeBookUser
     * const RecipeBookUser = await prisma.recipeBookUser.create({
     *   data: {
     *     // ... data to create a RecipeBookUser
     *   }
     * })
     * 
    **/
    create<T extends RecipeBookUserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookUserCreateArgs<ExtArgs>>
    ): Prisma__RecipeBookUserClient<$Result.GetResult<Prisma.$RecipeBookUserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RecipeBookUsers.
     *     @param {RecipeBookUserCreateManyArgs} args - Arguments to create many RecipeBookUsers.
     *     @example
     *     // Create many RecipeBookUsers
     *     const recipeBookUser = await prisma.recipeBookUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RecipeBookUserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookUserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RecipeBookUser.
     * @param {RecipeBookUserDeleteArgs} args - Arguments to delete one RecipeBookUser.
     * @example
     * // Delete one RecipeBookUser
     * const RecipeBookUser = await prisma.recipeBookUser.delete({
     *   where: {
     *     // ... filter to delete one RecipeBookUser
     *   }
     * })
     * 
    **/
    delete<T extends RecipeBookUserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookUserDeleteArgs<ExtArgs>>
    ): Prisma__RecipeBookUserClient<$Result.GetResult<Prisma.$RecipeBookUserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RecipeBookUser.
     * @param {RecipeBookUserUpdateArgs} args - Arguments to update one RecipeBookUser.
     * @example
     * // Update one RecipeBookUser
     * const recipeBookUser = await prisma.recipeBookUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RecipeBookUserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookUserUpdateArgs<ExtArgs>>
    ): Prisma__RecipeBookUserClient<$Result.GetResult<Prisma.$RecipeBookUserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RecipeBookUsers.
     * @param {RecipeBookUserDeleteManyArgs} args - Arguments to filter RecipeBookUsers to delete.
     * @example
     * // Delete a few RecipeBookUsers
     * const { count } = await prisma.recipeBookUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RecipeBookUserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookUserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeBookUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecipeBookUsers
     * const recipeBookUser = await prisma.recipeBookUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RecipeBookUserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookUserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RecipeBookUser.
     * @param {RecipeBookUserUpsertArgs} args - Arguments to update or create a RecipeBookUser.
     * @example
     * // Update or create a RecipeBookUser
     * const recipeBookUser = await prisma.recipeBookUser.upsert({
     *   create: {
     *     // ... data to create a RecipeBookUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecipeBookUser we want to update
     *   }
     * })
    **/
    upsert<T extends RecipeBookUserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookUserUpsertArgs<ExtArgs>>
    ): Prisma__RecipeBookUserClient<$Result.GetResult<Prisma.$RecipeBookUserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RecipeBookUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookUserCountArgs} args - Arguments to filter RecipeBookUsers to count.
     * @example
     * // Count the number of RecipeBookUsers
     * const count = await prisma.recipeBookUser.count({
     *   where: {
     *     // ... the filter for the RecipeBookUsers we want to count
     *   }
     * })
    **/
    count<T extends RecipeBookUserCountArgs>(
      args?: Subset<T, RecipeBookUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeBookUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecipeBookUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeBookUserAggregateArgs>(args: Subset<T, RecipeBookUserAggregateArgs>): Prisma.PrismaPromise<GetRecipeBookUserAggregateType<T>>

    /**
     * Group by RecipeBookUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeBookUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeBookUserGroupByArgs['orderBy'] }
        : { orderBy?: RecipeBookUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeBookUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeBookUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecipeBookUser model
   */
  readonly fields: RecipeBookUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecipeBookUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeBookUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    recipeBook<T extends RecipeBookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeBookDefaultArgs<ExtArgs>>): Prisma__RecipeBookClient<$Result.GetResult<Prisma.$RecipeBookPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RecipeBookUser model
   */ 
  interface RecipeBookUserFieldRefs {
    readonly userId: FieldRef<"RecipeBookUser", 'String'>
    readonly recipeBookId: FieldRef<"RecipeBookUser", 'String'>
    readonly permission: FieldRef<"RecipeBookUser", 'String'>
  }
    

  // Custom InputTypes

  /**
   * RecipeBookUser findUnique
   */
  export type RecipeBookUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     */
    select?: RecipeBookUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookUserInclude<ExtArgs> | null
    /**
     * Filter, which RecipeBookUser to fetch.
     */
    where: RecipeBookUserWhereUniqueInput
  }


  /**
   * RecipeBookUser findUniqueOrThrow
   */
  export type RecipeBookUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     */
    select?: RecipeBookUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookUserInclude<ExtArgs> | null
    /**
     * Filter, which RecipeBookUser to fetch.
     */
    where: RecipeBookUserWhereUniqueInput
  }


  /**
   * RecipeBookUser findFirst
   */
  export type RecipeBookUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     */
    select?: RecipeBookUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookUserInclude<ExtArgs> | null
    /**
     * Filter, which RecipeBookUser to fetch.
     */
    where?: RecipeBookUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBookUsers to fetch.
     */
    orderBy?: RecipeBookUserOrderByWithRelationInput | RecipeBookUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeBookUsers.
     */
    cursor?: RecipeBookUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBookUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBookUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeBookUsers.
     */
    distinct?: RecipeBookUserScalarFieldEnum | RecipeBookUserScalarFieldEnum[]
  }


  /**
   * RecipeBookUser findFirstOrThrow
   */
  export type RecipeBookUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     */
    select?: RecipeBookUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookUserInclude<ExtArgs> | null
    /**
     * Filter, which RecipeBookUser to fetch.
     */
    where?: RecipeBookUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBookUsers to fetch.
     */
    orderBy?: RecipeBookUserOrderByWithRelationInput | RecipeBookUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeBookUsers.
     */
    cursor?: RecipeBookUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBookUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBookUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeBookUsers.
     */
    distinct?: RecipeBookUserScalarFieldEnum | RecipeBookUserScalarFieldEnum[]
  }


  /**
   * RecipeBookUser findMany
   */
  export type RecipeBookUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     */
    select?: RecipeBookUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookUserInclude<ExtArgs> | null
    /**
     * Filter, which RecipeBookUsers to fetch.
     */
    where?: RecipeBookUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBookUsers to fetch.
     */
    orderBy?: RecipeBookUserOrderByWithRelationInput | RecipeBookUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecipeBookUsers.
     */
    cursor?: RecipeBookUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBookUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBookUsers.
     */
    skip?: number
    distinct?: RecipeBookUserScalarFieldEnum | RecipeBookUserScalarFieldEnum[]
  }


  /**
   * RecipeBookUser create
   */
  export type RecipeBookUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     */
    select?: RecipeBookUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookUserInclude<ExtArgs> | null
    /**
     * The data needed to create a RecipeBookUser.
     */
    data: XOR<RecipeBookUserCreateInput, RecipeBookUserUncheckedCreateInput>
  }


  /**
   * RecipeBookUser createMany
   */
  export type RecipeBookUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecipeBookUsers.
     */
    data: RecipeBookUserCreateManyInput | RecipeBookUserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RecipeBookUser update
   */
  export type RecipeBookUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     */
    select?: RecipeBookUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookUserInclude<ExtArgs> | null
    /**
     * The data needed to update a RecipeBookUser.
     */
    data: XOR<RecipeBookUserUpdateInput, RecipeBookUserUncheckedUpdateInput>
    /**
     * Choose, which RecipeBookUser to update.
     */
    where: RecipeBookUserWhereUniqueInput
  }


  /**
   * RecipeBookUser updateMany
   */
  export type RecipeBookUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecipeBookUsers.
     */
    data: XOR<RecipeBookUserUpdateManyMutationInput, RecipeBookUserUncheckedUpdateManyInput>
    /**
     * Filter which RecipeBookUsers to update
     */
    where?: RecipeBookUserWhereInput
  }


  /**
   * RecipeBookUser upsert
   */
  export type RecipeBookUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     */
    select?: RecipeBookUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookUserInclude<ExtArgs> | null
    /**
     * The filter to search for the RecipeBookUser to update in case it exists.
     */
    where: RecipeBookUserWhereUniqueInput
    /**
     * In case the RecipeBookUser found by the `where` argument doesn't exist, create a new RecipeBookUser with this data.
     */
    create: XOR<RecipeBookUserCreateInput, RecipeBookUserUncheckedCreateInput>
    /**
     * In case the RecipeBookUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeBookUserUpdateInput, RecipeBookUserUncheckedUpdateInput>
  }


  /**
   * RecipeBookUser delete
   */
  export type RecipeBookUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     */
    select?: RecipeBookUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookUserInclude<ExtArgs> | null
    /**
     * Filter which RecipeBookUser to delete.
     */
    where: RecipeBookUserWhereUniqueInput
  }


  /**
   * RecipeBookUser deleteMany
   */
  export type RecipeBookUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeBookUsers to delete
     */
    where?: RecipeBookUserWhereInput
  }


  /**
   * RecipeBookUser without action
   */
  export type RecipeBookUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     */
    select?: RecipeBookUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookUserInclude<ExtArgs> | null
  }



  /**
   * Model Build
   */

  export type AggregateBuild = {
    _count: BuildCountAggregateOutputType | null
    _min: BuildMinAggregateOutputType | null
    _max: BuildMaxAggregateOutputType | null
  }

  export type BuildMinAggregateOutputType = {
    id: string | null
    buildName: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
    recipeId: string | null
    instructions: string | null
    notes: string | null
    glassware: string | null
    ice: string | null
  }

  export type BuildMaxAggregateOutputType = {
    id: string | null
    buildName: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
    recipeId: string | null
    instructions: string | null
    notes: string | null
    glassware: string | null
    ice: string | null
  }

  export type BuildCountAggregateOutputType = {
    id: number
    buildName: number
    createdAt: number
    editedAt: number
    createdById: number
    editedById: number
    recipeId: number
    instructions: number
    notes: number
    glassware: number
    ice: number
    _all: number
  }


  export type BuildMinAggregateInputType = {
    id?: true
    buildName?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
    recipeId?: true
    instructions?: true
    notes?: true
    glassware?: true
    ice?: true
  }

  export type BuildMaxAggregateInputType = {
    id?: true
    buildName?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
    recipeId?: true
    instructions?: true
    notes?: true
    glassware?: true
    ice?: true
  }

  export type BuildCountAggregateInputType = {
    id?: true
    buildName?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
    recipeId?: true
    instructions?: true
    notes?: true
    glassware?: true
    ice?: true
    _all?: true
  }

  export type BuildAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Build to aggregate.
     */
    where?: BuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Builds to fetch.
     */
    orderBy?: BuildOrderByWithRelationInput | BuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Builds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Builds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Builds
    **/
    _count?: true | BuildCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuildMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuildMaxAggregateInputType
  }

  export type GetBuildAggregateType<T extends BuildAggregateArgs> = {
        [P in keyof T & keyof AggregateBuild]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuild[P]>
      : GetScalarType<T[P], AggregateBuild[P]>
  }




  export type BuildGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildWhereInput
    orderBy?: BuildOrderByWithAggregationInput | BuildOrderByWithAggregationInput[]
    by: BuildScalarFieldEnum[] | BuildScalarFieldEnum
    having?: BuildScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuildCountAggregateInputType | true
    _min?: BuildMinAggregateInputType
    _max?: BuildMaxAggregateInputType
  }

  export type BuildGroupByOutputType = {
    id: string
    buildName: string
    createdAt: Date
    editedAt: Date
    createdById: string | null
    editedById: string | null
    recipeId: string | null
    instructions: string | null
    notes: string | null
    glassware: string | null
    ice: string | null
    _count: BuildCountAggregateOutputType | null
    _min: BuildMinAggregateOutputType | null
    _max: BuildMaxAggregateOutputType | null
  }

  type GetBuildGroupByPayload<T extends BuildGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuildGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuildGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuildGroupByOutputType[P]>
            : GetScalarType<T[P], BuildGroupByOutputType[P]>
        }
      >
    >


  export type BuildSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    buildName?: boolean
    createdAt?: boolean
    editedAt?: boolean
    createdById?: boolean
    editedById?: boolean
    recipeId?: boolean
    instructions?: boolean
    notes?: boolean
    glassware?: boolean
    ice?: boolean
    createdBy?: boolean | Build$createdByArgs<ExtArgs>
    editedBy?: boolean | Build$editedByArgs<ExtArgs>
    recipe?: boolean | Build$recipeArgs<ExtArgs>
    touch?: boolean | Build$touchArgs<ExtArgs>
    archivedTouch?: boolean | Build$archivedTouchArgs<ExtArgs>
    RecipeBookBuild?: boolean | Build$RecipeBookBuildArgs<ExtArgs>
    buildUser?: boolean | Build$buildUserArgs<ExtArgs>
    _count?: boolean | BuildCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["build"]>

  export type BuildSelectScalar = {
    id?: boolean
    buildName?: boolean
    createdAt?: boolean
    editedAt?: boolean
    createdById?: boolean
    editedById?: boolean
    recipeId?: boolean
    instructions?: boolean
    notes?: boolean
    glassware?: boolean
    ice?: boolean
  }

  export type BuildInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Build$createdByArgs<ExtArgs>
    editedBy?: boolean | Build$editedByArgs<ExtArgs>
    recipe?: boolean | Build$recipeArgs<ExtArgs>
    touch?: boolean | Build$touchArgs<ExtArgs>
    archivedTouch?: boolean | Build$archivedTouchArgs<ExtArgs>
    RecipeBookBuild?: boolean | Build$RecipeBookBuildArgs<ExtArgs>
    buildUser?: boolean | Build$buildUserArgs<ExtArgs>
    _count?: boolean | BuildCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $BuildPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Build"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      editedBy: Prisma.$UserPayload<ExtArgs> | null
      recipe: Prisma.$RecipePayload<ExtArgs> | null
      touch: Prisma.$TouchPayload<ExtArgs>[]
      archivedTouch: Prisma.$ArchivedTouchPayload<ExtArgs>[]
      RecipeBookBuild: Prisma.$RecipeBookBuildPayload<ExtArgs>[]
      buildUser: Prisma.$BuildUserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      buildName: string
      createdAt: Date
      editedAt: Date
      createdById: string | null
      editedById: string | null
      recipeId: string | null
      instructions: string | null
      notes: string | null
      glassware: string | null
      ice: string | null
    }, ExtArgs["result"]["build"]>
    composites: {}
  }


  type BuildGetPayload<S extends boolean | null | undefined | BuildDefaultArgs> = $Result.GetResult<Prisma.$BuildPayload, S>

  type BuildCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BuildFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: BuildCountAggregateInputType | true
    }

  export interface BuildDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Build'], meta: { name: 'Build' } }
    /**
     * Find zero or one Build that matches the filter.
     * @param {BuildFindUniqueArgs} args - Arguments to find a Build
     * @example
     * // Get one Build
     * const build = await prisma.build.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BuildFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BuildFindUniqueArgs<ExtArgs>>
    ): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Build that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BuildFindUniqueOrThrowArgs} args - Arguments to find a Build
     * @example
     * // Get one Build
     * const build = await prisma.build.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BuildFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Build that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildFindFirstArgs} args - Arguments to find a Build
     * @example
     * // Get one Build
     * const build = await prisma.build.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BuildFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildFindFirstArgs<ExtArgs>>
    ): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Build that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildFindFirstOrThrowArgs} args - Arguments to find a Build
     * @example
     * // Get one Build
     * const build = await prisma.build.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BuildFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Builds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Builds
     * const builds = await prisma.build.findMany()
     * 
     * // Get first 10 Builds
     * const builds = await prisma.build.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buildWithIdOnly = await prisma.build.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BuildFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Build.
     * @param {BuildCreateArgs} args - Arguments to create a Build.
     * @example
     * // Create one Build
     * const Build = await prisma.build.create({
     *   data: {
     *     // ... data to create a Build
     *   }
     * })
     * 
    **/
    create<T extends BuildCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BuildCreateArgs<ExtArgs>>
    ): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Builds.
     *     @param {BuildCreateManyArgs} args - Arguments to create many Builds.
     *     @example
     *     // Create many Builds
     *     const build = await prisma.build.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BuildCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Build.
     * @param {BuildDeleteArgs} args - Arguments to delete one Build.
     * @example
     * // Delete one Build
     * const Build = await prisma.build.delete({
     *   where: {
     *     // ... filter to delete one Build
     *   }
     * })
     * 
    **/
    delete<T extends BuildDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BuildDeleteArgs<ExtArgs>>
    ): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Build.
     * @param {BuildUpdateArgs} args - Arguments to update one Build.
     * @example
     * // Update one Build
     * const build = await prisma.build.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BuildUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BuildUpdateArgs<ExtArgs>>
    ): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Builds.
     * @param {BuildDeleteManyArgs} args - Arguments to filter Builds to delete.
     * @example
     * // Delete a few Builds
     * const { count } = await prisma.build.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BuildDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Builds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Builds
     * const build = await prisma.build.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BuildUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BuildUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Build.
     * @param {BuildUpsertArgs} args - Arguments to update or create a Build.
     * @example
     * // Update or create a Build
     * const build = await prisma.build.upsert({
     *   create: {
     *     // ... data to create a Build
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Build we want to update
     *   }
     * })
    **/
    upsert<T extends BuildUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BuildUpsertArgs<ExtArgs>>
    ): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Builds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildCountArgs} args - Arguments to filter Builds to count.
     * @example
     * // Count the number of Builds
     * const count = await prisma.build.count({
     *   where: {
     *     // ... the filter for the Builds we want to count
     *   }
     * })
    **/
    count<T extends BuildCountArgs>(
      args?: Subset<T, BuildCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuildCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Build.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuildAggregateArgs>(args: Subset<T, BuildAggregateArgs>): Prisma.PrismaPromise<GetBuildAggregateType<T>>

    /**
     * Group by Build.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuildGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuildGroupByArgs['orderBy'] }
        : { orderBy?: BuildGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuildGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuildGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Build model
   */
  readonly fields: BuildFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Build.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuildClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    createdBy<T extends Build$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Build$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    editedBy<T extends Build$editedByArgs<ExtArgs> = {}>(args?: Subset<T, Build$editedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    recipe<T extends Build$recipeArgs<ExtArgs> = {}>(args?: Subset<T, Build$recipeArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    touch<T extends Build$touchArgs<ExtArgs> = {}>(args?: Subset<T, Build$touchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TouchPayload<ExtArgs>, T, 'findMany'> | Null>;

    archivedTouch<T extends Build$archivedTouchArgs<ExtArgs> = {}>(args?: Subset<T, Build$archivedTouchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArchivedTouchPayload<ExtArgs>, T, 'findMany'> | Null>;

    RecipeBookBuild<T extends Build$RecipeBookBuildArgs<ExtArgs> = {}>(args?: Subset<T, Build$RecipeBookBuildArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeBookBuildPayload<ExtArgs>, T, 'findMany'> | Null>;

    buildUser<T extends Build$buildUserArgs<ExtArgs> = {}>(args?: Subset<T, Build$buildUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Build model
   */ 
  interface BuildFieldRefs {
    readonly id: FieldRef<"Build", 'String'>
    readonly buildName: FieldRef<"Build", 'String'>
    readonly createdAt: FieldRef<"Build", 'DateTime'>
    readonly editedAt: FieldRef<"Build", 'DateTime'>
    readonly createdById: FieldRef<"Build", 'String'>
    readonly editedById: FieldRef<"Build", 'String'>
    readonly recipeId: FieldRef<"Build", 'String'>
    readonly instructions: FieldRef<"Build", 'String'>
    readonly notes: FieldRef<"Build", 'String'>
    readonly glassware: FieldRef<"Build", 'String'>
    readonly ice: FieldRef<"Build", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Build findUnique
   */
  export type BuildFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * Filter, which Build to fetch.
     */
    where: BuildWhereUniqueInput
  }


  /**
   * Build findUniqueOrThrow
   */
  export type BuildFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * Filter, which Build to fetch.
     */
    where: BuildWhereUniqueInput
  }


  /**
   * Build findFirst
   */
  export type BuildFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * Filter, which Build to fetch.
     */
    where?: BuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Builds to fetch.
     */
    orderBy?: BuildOrderByWithRelationInput | BuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Builds.
     */
    cursor?: BuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Builds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Builds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Builds.
     */
    distinct?: BuildScalarFieldEnum | BuildScalarFieldEnum[]
  }


  /**
   * Build findFirstOrThrow
   */
  export type BuildFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * Filter, which Build to fetch.
     */
    where?: BuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Builds to fetch.
     */
    orderBy?: BuildOrderByWithRelationInput | BuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Builds.
     */
    cursor?: BuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Builds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Builds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Builds.
     */
    distinct?: BuildScalarFieldEnum | BuildScalarFieldEnum[]
  }


  /**
   * Build findMany
   */
  export type BuildFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * Filter, which Builds to fetch.
     */
    where?: BuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Builds to fetch.
     */
    orderBy?: BuildOrderByWithRelationInput | BuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Builds.
     */
    cursor?: BuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Builds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Builds.
     */
    skip?: number
    distinct?: BuildScalarFieldEnum | BuildScalarFieldEnum[]
  }


  /**
   * Build create
   */
  export type BuildCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * The data needed to create a Build.
     */
    data?: XOR<BuildCreateInput, BuildUncheckedCreateInput>
  }


  /**
   * Build createMany
   */
  export type BuildCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Builds.
     */
    data: BuildCreateManyInput | BuildCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Build update
   */
  export type BuildUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * The data needed to update a Build.
     */
    data: XOR<BuildUpdateInput, BuildUncheckedUpdateInput>
    /**
     * Choose, which Build to update.
     */
    where: BuildWhereUniqueInput
  }


  /**
   * Build updateMany
   */
  export type BuildUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Builds.
     */
    data: XOR<BuildUpdateManyMutationInput, BuildUncheckedUpdateManyInput>
    /**
     * Filter which Builds to update
     */
    where?: BuildWhereInput
  }


  /**
   * Build upsert
   */
  export type BuildUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * The filter to search for the Build to update in case it exists.
     */
    where: BuildWhereUniqueInput
    /**
     * In case the Build found by the `where` argument doesn't exist, create a new Build with this data.
     */
    create: XOR<BuildCreateInput, BuildUncheckedCreateInput>
    /**
     * In case the Build was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuildUpdateInput, BuildUncheckedUpdateInput>
  }


  /**
   * Build delete
   */
  export type BuildDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * Filter which Build to delete.
     */
    where: BuildWhereUniqueInput
  }


  /**
   * Build deleteMany
   */
  export type BuildDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Builds to delete
     */
    where?: BuildWhereInput
  }


  /**
   * Build.createdBy
   */
  export type Build$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Build.editedBy
   */
  export type Build$editedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Build.recipe
   */
  export type Build$recipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    where?: RecipeWhereInput
  }


  /**
   * Build.touch
   */
  export type Build$touchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Touch
     */
    select?: TouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TouchInclude<ExtArgs> | null
    where?: TouchWhereInput
    orderBy?: TouchOrderByWithRelationInput | TouchOrderByWithRelationInput[]
    cursor?: TouchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TouchScalarFieldEnum | TouchScalarFieldEnum[]
  }


  /**
   * Build.archivedTouch
   */
  export type Build$archivedTouchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedTouch
     */
    select?: ArchivedTouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedTouchInclude<ExtArgs> | null
    where?: ArchivedTouchWhereInput
    orderBy?: ArchivedTouchOrderByWithRelationInput | ArchivedTouchOrderByWithRelationInput[]
    cursor?: ArchivedTouchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArchivedTouchScalarFieldEnum | ArchivedTouchScalarFieldEnum[]
  }


  /**
   * Build.RecipeBookBuild
   */
  export type Build$RecipeBookBuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     */
    select?: RecipeBookBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookBuildInclude<ExtArgs> | null
    where?: RecipeBookBuildWhereInput
    orderBy?: RecipeBookBuildOrderByWithRelationInput | RecipeBookBuildOrderByWithRelationInput[]
    cursor?: RecipeBookBuildWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeBookBuildScalarFieldEnum | RecipeBookBuildScalarFieldEnum[]
  }


  /**
   * Build.buildUser
   */
  export type Build$buildUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildUser
     */
    select?: BuildUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildUserInclude<ExtArgs> | null
    where?: BuildUserWhereInput
    orderBy?: BuildUserOrderByWithRelationInput | BuildUserOrderByWithRelationInput[]
    cursor?: BuildUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuildUserScalarFieldEnum | BuildUserScalarFieldEnum[]
  }


  /**
   * Build without action
   */
  export type BuildDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
  }



  /**
   * Model BuildUser
   */

  export type AggregateBuildUser = {
    _count: BuildUserCountAggregateOutputType | null
    _min: BuildUserMinAggregateOutputType | null
    _max: BuildUserMaxAggregateOutputType | null
  }

  export type BuildUserMinAggregateOutputType = {
    userId: string | null
    buildId: string | null
    permission: string | null
  }

  export type BuildUserMaxAggregateOutputType = {
    userId: string | null
    buildId: string | null
    permission: string | null
  }

  export type BuildUserCountAggregateOutputType = {
    userId: number
    buildId: number
    permission: number
    _all: number
  }


  export type BuildUserMinAggregateInputType = {
    userId?: true
    buildId?: true
    permission?: true
  }

  export type BuildUserMaxAggregateInputType = {
    userId?: true
    buildId?: true
    permission?: true
  }

  export type BuildUserCountAggregateInputType = {
    userId?: true
    buildId?: true
    permission?: true
    _all?: true
  }

  export type BuildUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuildUser to aggregate.
     */
    where?: BuildUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildUsers to fetch.
     */
    orderBy?: BuildUserOrderByWithRelationInput | BuildUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuildUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BuildUsers
    **/
    _count?: true | BuildUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuildUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuildUserMaxAggregateInputType
  }

  export type GetBuildUserAggregateType<T extends BuildUserAggregateArgs> = {
        [P in keyof T & keyof AggregateBuildUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuildUser[P]>
      : GetScalarType<T[P], AggregateBuildUser[P]>
  }




  export type BuildUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildUserWhereInput
    orderBy?: BuildUserOrderByWithAggregationInput | BuildUserOrderByWithAggregationInput[]
    by: BuildUserScalarFieldEnum[] | BuildUserScalarFieldEnum
    having?: BuildUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuildUserCountAggregateInputType | true
    _min?: BuildUserMinAggregateInputType
    _max?: BuildUserMaxAggregateInputType
  }

  export type BuildUserGroupByOutputType = {
    userId: string
    buildId: string
    permission: string
    _count: BuildUserCountAggregateOutputType | null
    _min: BuildUserMinAggregateOutputType | null
    _max: BuildUserMaxAggregateOutputType | null
  }

  type GetBuildUserGroupByPayload<T extends BuildUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuildUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuildUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuildUserGroupByOutputType[P]>
            : GetScalarType<T[P], BuildUserGroupByOutputType[P]>
        }
      >
    >


  export type BuildUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    buildId?: boolean
    permission?: boolean
    user?: boolean | BuildUser$userArgs<ExtArgs>
    build?: boolean | BuildUser$buildArgs<ExtArgs>
  }, ExtArgs["result"]["buildUser"]>

  export type BuildUserSelectScalar = {
    userId?: boolean
    buildId?: boolean
    permission?: boolean
  }

  export type BuildUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | BuildUser$userArgs<ExtArgs>
    build?: boolean | BuildUser$buildArgs<ExtArgs>
  }


  export type $BuildUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BuildUser"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      build: Prisma.$BuildPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      buildId: string
      permission: string
    }, ExtArgs["result"]["buildUser"]>
    composites: {}
  }


  type BuildUserGetPayload<S extends boolean | null | undefined | BuildUserDefaultArgs> = $Result.GetResult<Prisma.$BuildUserPayload, S>

  type BuildUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BuildUserFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: BuildUserCountAggregateInputType | true
    }

  export interface BuildUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BuildUser'], meta: { name: 'BuildUser' } }
    /**
     * Find zero or one BuildUser that matches the filter.
     * @param {BuildUserFindUniqueArgs} args - Arguments to find a BuildUser
     * @example
     * // Get one BuildUser
     * const buildUser = await prisma.buildUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BuildUserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BuildUserFindUniqueArgs<ExtArgs>>
    ): Prisma__BuildUserClient<$Result.GetResult<Prisma.$BuildUserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BuildUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BuildUserFindUniqueOrThrowArgs} args - Arguments to find a BuildUser
     * @example
     * // Get one BuildUser
     * const buildUser = await prisma.buildUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BuildUserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildUserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BuildUserClient<$Result.GetResult<Prisma.$BuildUserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BuildUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildUserFindFirstArgs} args - Arguments to find a BuildUser
     * @example
     * // Get one BuildUser
     * const buildUser = await prisma.buildUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BuildUserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildUserFindFirstArgs<ExtArgs>>
    ): Prisma__BuildUserClient<$Result.GetResult<Prisma.$BuildUserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BuildUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildUserFindFirstOrThrowArgs} args - Arguments to find a BuildUser
     * @example
     * // Get one BuildUser
     * const buildUser = await prisma.buildUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BuildUserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildUserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BuildUserClient<$Result.GetResult<Prisma.$BuildUserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BuildUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BuildUsers
     * const buildUsers = await prisma.buildUser.findMany()
     * 
     * // Get first 10 BuildUsers
     * const buildUsers = await prisma.buildUser.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const buildUserWithUserIdOnly = await prisma.buildUser.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends BuildUserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildUserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildUserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BuildUser.
     * @param {BuildUserCreateArgs} args - Arguments to create a BuildUser.
     * @example
     * // Create one BuildUser
     * const BuildUser = await prisma.buildUser.create({
     *   data: {
     *     // ... data to create a BuildUser
     *   }
     * })
     * 
    **/
    create<T extends BuildUserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BuildUserCreateArgs<ExtArgs>>
    ): Prisma__BuildUserClient<$Result.GetResult<Prisma.$BuildUserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BuildUsers.
     *     @param {BuildUserCreateManyArgs} args - Arguments to create many BuildUsers.
     *     @example
     *     // Create many BuildUsers
     *     const buildUser = await prisma.buildUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BuildUserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildUserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BuildUser.
     * @param {BuildUserDeleteArgs} args - Arguments to delete one BuildUser.
     * @example
     * // Delete one BuildUser
     * const BuildUser = await prisma.buildUser.delete({
     *   where: {
     *     // ... filter to delete one BuildUser
     *   }
     * })
     * 
    **/
    delete<T extends BuildUserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BuildUserDeleteArgs<ExtArgs>>
    ): Prisma__BuildUserClient<$Result.GetResult<Prisma.$BuildUserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BuildUser.
     * @param {BuildUserUpdateArgs} args - Arguments to update one BuildUser.
     * @example
     * // Update one BuildUser
     * const buildUser = await prisma.buildUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BuildUserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BuildUserUpdateArgs<ExtArgs>>
    ): Prisma__BuildUserClient<$Result.GetResult<Prisma.$BuildUserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BuildUsers.
     * @param {BuildUserDeleteManyArgs} args - Arguments to filter BuildUsers to delete.
     * @example
     * // Delete a few BuildUsers
     * const { count } = await prisma.buildUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BuildUserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildUserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BuildUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BuildUsers
     * const buildUser = await prisma.buildUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BuildUserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BuildUserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BuildUser.
     * @param {BuildUserUpsertArgs} args - Arguments to update or create a BuildUser.
     * @example
     * // Update or create a BuildUser
     * const buildUser = await prisma.buildUser.upsert({
     *   create: {
     *     // ... data to create a BuildUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BuildUser we want to update
     *   }
     * })
    **/
    upsert<T extends BuildUserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BuildUserUpsertArgs<ExtArgs>>
    ): Prisma__BuildUserClient<$Result.GetResult<Prisma.$BuildUserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BuildUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildUserCountArgs} args - Arguments to filter BuildUsers to count.
     * @example
     * // Count the number of BuildUsers
     * const count = await prisma.buildUser.count({
     *   where: {
     *     // ... the filter for the BuildUsers we want to count
     *   }
     * })
    **/
    count<T extends BuildUserCountArgs>(
      args?: Subset<T, BuildUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuildUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BuildUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuildUserAggregateArgs>(args: Subset<T, BuildUserAggregateArgs>): Prisma.PrismaPromise<GetBuildUserAggregateType<T>>

    /**
     * Group by BuildUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuildUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuildUserGroupByArgs['orderBy'] }
        : { orderBy?: BuildUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuildUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuildUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BuildUser model
   */
  readonly fields: BuildUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BuildUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuildUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends BuildUser$userArgs<ExtArgs> = {}>(args?: Subset<T, BuildUser$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    build<T extends BuildUser$buildArgs<ExtArgs> = {}>(args?: Subset<T, BuildUser$buildArgs<ExtArgs>>): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BuildUser model
   */ 
  interface BuildUserFieldRefs {
    readonly userId: FieldRef<"BuildUser", 'String'>
    readonly buildId: FieldRef<"BuildUser", 'String'>
    readonly permission: FieldRef<"BuildUser", 'String'>
  }
    

  // Custom InputTypes

  /**
   * BuildUser findUnique
   */
  export type BuildUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildUser
     */
    select?: BuildUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildUserInclude<ExtArgs> | null
    /**
     * Filter, which BuildUser to fetch.
     */
    where: BuildUserWhereUniqueInput
  }


  /**
   * BuildUser findUniqueOrThrow
   */
  export type BuildUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildUser
     */
    select?: BuildUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildUserInclude<ExtArgs> | null
    /**
     * Filter, which BuildUser to fetch.
     */
    where: BuildUserWhereUniqueInput
  }


  /**
   * BuildUser findFirst
   */
  export type BuildUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildUser
     */
    select?: BuildUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildUserInclude<ExtArgs> | null
    /**
     * Filter, which BuildUser to fetch.
     */
    where?: BuildUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildUsers to fetch.
     */
    orderBy?: BuildUserOrderByWithRelationInput | BuildUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuildUsers.
     */
    cursor?: BuildUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuildUsers.
     */
    distinct?: BuildUserScalarFieldEnum | BuildUserScalarFieldEnum[]
  }


  /**
   * BuildUser findFirstOrThrow
   */
  export type BuildUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildUser
     */
    select?: BuildUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildUserInclude<ExtArgs> | null
    /**
     * Filter, which BuildUser to fetch.
     */
    where?: BuildUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildUsers to fetch.
     */
    orderBy?: BuildUserOrderByWithRelationInput | BuildUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuildUsers.
     */
    cursor?: BuildUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuildUsers.
     */
    distinct?: BuildUserScalarFieldEnum | BuildUserScalarFieldEnum[]
  }


  /**
   * BuildUser findMany
   */
  export type BuildUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildUser
     */
    select?: BuildUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildUserInclude<ExtArgs> | null
    /**
     * Filter, which BuildUsers to fetch.
     */
    where?: BuildUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildUsers to fetch.
     */
    orderBy?: BuildUserOrderByWithRelationInput | BuildUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BuildUsers.
     */
    cursor?: BuildUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildUsers.
     */
    skip?: number
    distinct?: BuildUserScalarFieldEnum | BuildUserScalarFieldEnum[]
  }


  /**
   * BuildUser create
   */
  export type BuildUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildUser
     */
    select?: BuildUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildUserInclude<ExtArgs> | null
    /**
     * The data needed to create a BuildUser.
     */
    data: XOR<BuildUserCreateInput, BuildUserUncheckedCreateInput>
  }


  /**
   * BuildUser createMany
   */
  export type BuildUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BuildUsers.
     */
    data: BuildUserCreateManyInput | BuildUserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * BuildUser update
   */
  export type BuildUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildUser
     */
    select?: BuildUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildUserInclude<ExtArgs> | null
    /**
     * The data needed to update a BuildUser.
     */
    data: XOR<BuildUserUpdateInput, BuildUserUncheckedUpdateInput>
    /**
     * Choose, which BuildUser to update.
     */
    where: BuildUserWhereUniqueInput
  }


  /**
   * BuildUser updateMany
   */
  export type BuildUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BuildUsers.
     */
    data: XOR<BuildUserUpdateManyMutationInput, BuildUserUncheckedUpdateManyInput>
    /**
     * Filter which BuildUsers to update
     */
    where?: BuildUserWhereInput
  }


  /**
   * BuildUser upsert
   */
  export type BuildUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildUser
     */
    select?: BuildUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildUserInclude<ExtArgs> | null
    /**
     * The filter to search for the BuildUser to update in case it exists.
     */
    where: BuildUserWhereUniqueInput
    /**
     * In case the BuildUser found by the `where` argument doesn't exist, create a new BuildUser with this data.
     */
    create: XOR<BuildUserCreateInput, BuildUserUncheckedCreateInput>
    /**
     * In case the BuildUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuildUserUpdateInput, BuildUserUncheckedUpdateInput>
  }


  /**
   * BuildUser delete
   */
  export type BuildUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildUser
     */
    select?: BuildUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildUserInclude<ExtArgs> | null
    /**
     * Filter which BuildUser to delete.
     */
    where: BuildUserWhereUniqueInput
  }


  /**
   * BuildUser deleteMany
   */
  export type BuildUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuildUsers to delete
     */
    where?: BuildUserWhereInput
  }


  /**
   * BuildUser.user
   */
  export type BuildUser$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * BuildUser.build
   */
  export type BuildUser$buildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    where?: BuildWhereInput
  }


  /**
   * BuildUser without action
   */
  export type BuildUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildUser
     */
    select?: BuildUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildUserInclude<ExtArgs> | null
  }



  /**
   * Model Recipe
   */

  export type AggregateRecipe = {
    _count: RecipeCountAggregateOutputType | null
    _min: RecipeMinAggregateOutputType | null
    _max: RecipeMaxAggregateOutputType | null
  }

  export type RecipeMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    editedAt: Date | null
    name: string | null
    origin: string | null
    history: string | null
    createdById: string | null
    editedById: string | null
  }

  export type RecipeMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    editedAt: Date | null
    name: string | null
    origin: string | null
    history: string | null
    createdById: string | null
    editedById: string | null
  }

  export type RecipeCountAggregateOutputType = {
    id: number
    createdAt: number
    editedAt: number
    name: number
    origin: number
    history: number
    createdById: number
    editedById: number
    _all: number
  }


  export type RecipeMinAggregateInputType = {
    id?: true
    createdAt?: true
    editedAt?: true
    name?: true
    origin?: true
    history?: true
    createdById?: true
    editedById?: true
  }

  export type RecipeMaxAggregateInputType = {
    id?: true
    createdAt?: true
    editedAt?: true
    name?: true
    origin?: true
    history?: true
    createdById?: true
    editedById?: true
  }

  export type RecipeCountAggregateInputType = {
    id?: true
    createdAt?: true
    editedAt?: true
    name?: true
    origin?: true
    history?: true
    createdById?: true
    editedById?: true
    _all?: true
  }

  export type RecipeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recipe to aggregate.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Recipes
    **/
    _count?: true | RecipeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeMaxAggregateInputType
  }

  export type GetRecipeAggregateType<T extends RecipeAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipe[P]>
      : GetScalarType<T[P], AggregateRecipe[P]>
  }




  export type RecipeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeWhereInput
    orderBy?: RecipeOrderByWithAggregationInput | RecipeOrderByWithAggregationInput[]
    by: RecipeScalarFieldEnum[] | RecipeScalarFieldEnum
    having?: RecipeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeCountAggregateInputType | true
    _min?: RecipeMinAggregateInputType
    _max?: RecipeMaxAggregateInputType
  }

  export type RecipeGroupByOutputType = {
    id: string
    createdAt: Date
    editedAt: Date
    name: string
    origin: string | null
    history: string | null
    createdById: string | null
    editedById: string | null
    _count: RecipeCountAggregateOutputType | null
    _min: RecipeMinAggregateOutputType | null
    _max: RecipeMaxAggregateOutputType | null
  }

  type GetRecipeGroupByPayload<T extends RecipeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeGroupByOutputType[P]>
        }
      >
    >


  export type RecipeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    editedAt?: boolean
    name?: boolean
    origin?: boolean
    history?: boolean
    createdById?: boolean
    editedById?: boolean
    createdBy?: boolean | Recipe$createdByArgs<ExtArgs>
    editedBy?: boolean | Recipe$editedByArgs<ExtArgs>
    build?: boolean | Recipe$buildArgs<ExtArgs>
    _count?: boolean | RecipeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipe"]>

  export type RecipeSelectScalar = {
    id?: boolean
    createdAt?: boolean
    editedAt?: boolean
    name?: boolean
    origin?: boolean
    history?: boolean
    createdById?: boolean
    editedById?: boolean
  }

  export type RecipeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Recipe$createdByArgs<ExtArgs>
    editedBy?: boolean | Recipe$editedByArgs<ExtArgs>
    build?: boolean | Recipe$buildArgs<ExtArgs>
    _count?: boolean | RecipeCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $RecipePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Recipe"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      editedBy: Prisma.$UserPayload<ExtArgs> | null
      build: Prisma.$BuildPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      editedAt: Date
      name: string
      origin: string | null
      history: string | null
      createdById: string | null
      editedById: string | null
    }, ExtArgs["result"]["recipe"]>
    composites: {}
  }


  type RecipeGetPayload<S extends boolean | null | undefined | RecipeDefaultArgs> = $Result.GetResult<Prisma.$RecipePayload, S>

  type RecipeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RecipeFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: RecipeCountAggregateInputType | true
    }

  export interface RecipeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Recipe'], meta: { name: 'Recipe' } }
    /**
     * Find zero or one Recipe that matches the filter.
     * @param {RecipeFindUniqueArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RecipeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeFindUniqueArgs<ExtArgs>>
    ): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Recipe that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RecipeFindUniqueOrThrowArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RecipeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Recipe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindFirstArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RecipeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeFindFirstArgs<ExtArgs>>
    ): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Recipe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindFirstOrThrowArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RecipeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Recipes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recipes
     * const recipes = await prisma.recipe.findMany()
     * 
     * // Get first 10 Recipes
     * const recipes = await prisma.recipe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeWithIdOnly = await prisma.recipe.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RecipeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Recipe.
     * @param {RecipeCreateArgs} args - Arguments to create a Recipe.
     * @example
     * // Create one Recipe
     * const Recipe = await prisma.recipe.create({
     *   data: {
     *     // ... data to create a Recipe
     *   }
     * })
     * 
    **/
    create<T extends RecipeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeCreateArgs<ExtArgs>>
    ): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Recipes.
     *     @param {RecipeCreateManyArgs} args - Arguments to create many Recipes.
     *     @example
     *     // Create many Recipes
     *     const recipe = await prisma.recipe.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RecipeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Recipe.
     * @param {RecipeDeleteArgs} args - Arguments to delete one Recipe.
     * @example
     * // Delete one Recipe
     * const Recipe = await prisma.recipe.delete({
     *   where: {
     *     // ... filter to delete one Recipe
     *   }
     * })
     * 
    **/
    delete<T extends RecipeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeDeleteArgs<ExtArgs>>
    ): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Recipe.
     * @param {RecipeUpdateArgs} args - Arguments to update one Recipe.
     * @example
     * // Update one Recipe
     * const recipe = await prisma.recipe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RecipeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeUpdateArgs<ExtArgs>>
    ): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Recipes.
     * @param {RecipeDeleteManyArgs} args - Arguments to filter Recipes to delete.
     * @example
     * // Delete a few Recipes
     * const { count } = await prisma.recipe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RecipeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recipes
     * const recipe = await prisma.recipe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RecipeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Recipe.
     * @param {RecipeUpsertArgs} args - Arguments to update or create a Recipe.
     * @example
     * // Update or create a Recipe
     * const recipe = await prisma.recipe.upsert({
     *   create: {
     *     // ... data to create a Recipe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recipe we want to update
     *   }
     * })
    **/
    upsert<T extends RecipeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeUpsertArgs<ExtArgs>>
    ): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeCountArgs} args - Arguments to filter Recipes to count.
     * @example
     * // Count the number of Recipes
     * const count = await prisma.recipe.count({
     *   where: {
     *     // ... the filter for the Recipes we want to count
     *   }
     * })
    **/
    count<T extends RecipeCountArgs>(
      args?: Subset<T, RecipeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeAggregateArgs>(args: Subset<T, RecipeAggregateArgs>): Prisma.PrismaPromise<GetRecipeAggregateType<T>>

    /**
     * Group by Recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeGroupByArgs['orderBy'] }
        : { orderBy?: RecipeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Recipe model
   */
  readonly fields: RecipeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Recipe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    createdBy<T extends Recipe$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    editedBy<T extends Recipe$editedByArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$editedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    build<T extends Recipe$buildArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$buildArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Recipe model
   */ 
  interface RecipeFieldRefs {
    readonly id: FieldRef<"Recipe", 'String'>
    readonly createdAt: FieldRef<"Recipe", 'DateTime'>
    readonly editedAt: FieldRef<"Recipe", 'DateTime'>
    readonly name: FieldRef<"Recipe", 'String'>
    readonly origin: FieldRef<"Recipe", 'String'>
    readonly history: FieldRef<"Recipe", 'String'>
    readonly createdById: FieldRef<"Recipe", 'String'>
    readonly editedById: FieldRef<"Recipe", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Recipe findUnique
   */
  export type RecipeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where: RecipeWhereUniqueInput
  }


  /**
   * Recipe findUniqueOrThrow
   */
  export type RecipeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where: RecipeWhereUniqueInput
  }


  /**
   * Recipe findFirst
   */
  export type RecipeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recipes.
     */
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }


  /**
   * Recipe findFirstOrThrow
   */
  export type RecipeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recipes.
     */
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }


  /**
   * Recipe findMany
   */
  export type RecipeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipes to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }


  /**
   * Recipe create
   */
  export type RecipeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The data needed to create a Recipe.
     */
    data: XOR<RecipeCreateInput, RecipeUncheckedCreateInput>
  }


  /**
   * Recipe createMany
   */
  export type RecipeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Recipes.
     */
    data: RecipeCreateManyInput | RecipeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Recipe update
   */
  export type RecipeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The data needed to update a Recipe.
     */
    data: XOR<RecipeUpdateInput, RecipeUncheckedUpdateInput>
    /**
     * Choose, which Recipe to update.
     */
    where: RecipeWhereUniqueInput
  }


  /**
   * Recipe updateMany
   */
  export type RecipeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Recipes.
     */
    data: XOR<RecipeUpdateManyMutationInput, RecipeUncheckedUpdateManyInput>
    /**
     * Filter which Recipes to update
     */
    where?: RecipeWhereInput
  }


  /**
   * Recipe upsert
   */
  export type RecipeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The filter to search for the Recipe to update in case it exists.
     */
    where: RecipeWhereUniqueInput
    /**
     * In case the Recipe found by the `where` argument doesn't exist, create a new Recipe with this data.
     */
    create: XOR<RecipeCreateInput, RecipeUncheckedCreateInput>
    /**
     * In case the Recipe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeUpdateInput, RecipeUncheckedUpdateInput>
  }


  /**
   * Recipe delete
   */
  export type RecipeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter which Recipe to delete.
     */
    where: RecipeWhereUniqueInput
  }


  /**
   * Recipe deleteMany
   */
  export type RecipeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recipes to delete
     */
    where?: RecipeWhereInput
  }


  /**
   * Recipe.createdBy
   */
  export type Recipe$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Recipe.editedBy
   */
  export type Recipe$editedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Recipe.build
   */
  export type Recipe$buildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    where?: BuildWhereInput
    orderBy?: BuildOrderByWithRelationInput | BuildOrderByWithRelationInput[]
    cursor?: BuildWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuildScalarFieldEnum | BuildScalarFieldEnum[]
  }


  /**
   * Recipe without action
   */
  export type RecipeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
  }



  /**
   * Model RecipeBookBuild
   */

  export type AggregateRecipeBookBuild = {
    _count: RecipeBookBuildCountAggregateOutputType | null
    _min: RecipeBookBuildMinAggregateOutputType | null
    _max: RecipeBookBuildMaxAggregateOutputType | null
  }

  export type RecipeBookBuildMinAggregateOutputType = {
    buildId: string | null
    recipeBookId: string | null
  }

  export type RecipeBookBuildMaxAggregateOutputType = {
    buildId: string | null
    recipeBookId: string | null
  }

  export type RecipeBookBuildCountAggregateOutputType = {
    buildId: number
    recipeBookId: number
    _all: number
  }


  export type RecipeBookBuildMinAggregateInputType = {
    buildId?: true
    recipeBookId?: true
  }

  export type RecipeBookBuildMaxAggregateInputType = {
    buildId?: true
    recipeBookId?: true
  }

  export type RecipeBookBuildCountAggregateInputType = {
    buildId?: true
    recipeBookId?: true
    _all?: true
  }

  export type RecipeBookBuildAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeBookBuild to aggregate.
     */
    where?: RecipeBookBuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBookBuilds to fetch.
     */
    orderBy?: RecipeBookBuildOrderByWithRelationInput | RecipeBookBuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeBookBuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBookBuilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBookBuilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecipeBookBuilds
    **/
    _count?: true | RecipeBookBuildCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeBookBuildMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeBookBuildMaxAggregateInputType
  }

  export type GetRecipeBookBuildAggregateType<T extends RecipeBookBuildAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipeBookBuild]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipeBookBuild[P]>
      : GetScalarType<T[P], AggregateRecipeBookBuild[P]>
  }




  export type RecipeBookBuildGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeBookBuildWhereInput
    orderBy?: RecipeBookBuildOrderByWithAggregationInput | RecipeBookBuildOrderByWithAggregationInput[]
    by: RecipeBookBuildScalarFieldEnum[] | RecipeBookBuildScalarFieldEnum
    having?: RecipeBookBuildScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeBookBuildCountAggregateInputType | true
    _min?: RecipeBookBuildMinAggregateInputType
    _max?: RecipeBookBuildMaxAggregateInputType
  }

  export type RecipeBookBuildGroupByOutputType = {
    buildId: string
    recipeBookId: string
    _count: RecipeBookBuildCountAggregateOutputType | null
    _min: RecipeBookBuildMinAggregateOutputType | null
    _max: RecipeBookBuildMaxAggregateOutputType | null
  }

  type GetRecipeBookBuildGroupByPayload<T extends RecipeBookBuildGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeBookBuildGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeBookBuildGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeBookBuildGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeBookBuildGroupByOutputType[P]>
        }
      >
    >


  export type RecipeBookBuildSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    buildId?: boolean
    recipeBookId?: boolean
    recipeBook?: boolean | RecipeBookDefaultArgs<ExtArgs>
    build?: boolean | BuildDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeBookBuild"]>

  export type RecipeBookBuildSelectScalar = {
    buildId?: boolean
    recipeBookId?: boolean
  }

  export type RecipeBookBuildInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipeBook?: boolean | RecipeBookDefaultArgs<ExtArgs>
    build?: boolean | BuildDefaultArgs<ExtArgs>
  }


  export type $RecipeBookBuildPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecipeBookBuild"
    objects: {
      recipeBook: Prisma.$RecipeBookPayload<ExtArgs>
      build: Prisma.$BuildPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      buildId: string
      recipeBookId: string
    }, ExtArgs["result"]["recipeBookBuild"]>
    composites: {}
  }


  type RecipeBookBuildGetPayload<S extends boolean | null | undefined | RecipeBookBuildDefaultArgs> = $Result.GetResult<Prisma.$RecipeBookBuildPayload, S>

  type RecipeBookBuildCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RecipeBookBuildFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: RecipeBookBuildCountAggregateInputType | true
    }

  export interface RecipeBookBuildDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecipeBookBuild'], meta: { name: 'RecipeBookBuild' } }
    /**
     * Find zero or one RecipeBookBuild that matches the filter.
     * @param {RecipeBookBuildFindUniqueArgs} args - Arguments to find a RecipeBookBuild
     * @example
     * // Get one RecipeBookBuild
     * const recipeBookBuild = await prisma.recipeBookBuild.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RecipeBookBuildFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookBuildFindUniqueArgs<ExtArgs>>
    ): Prisma__RecipeBookBuildClient<$Result.GetResult<Prisma.$RecipeBookBuildPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RecipeBookBuild that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RecipeBookBuildFindUniqueOrThrowArgs} args - Arguments to find a RecipeBookBuild
     * @example
     * // Get one RecipeBookBuild
     * const recipeBookBuild = await prisma.recipeBookBuild.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RecipeBookBuildFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookBuildFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RecipeBookBuildClient<$Result.GetResult<Prisma.$RecipeBookBuildPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RecipeBookBuild that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookBuildFindFirstArgs} args - Arguments to find a RecipeBookBuild
     * @example
     * // Get one RecipeBookBuild
     * const recipeBookBuild = await prisma.recipeBookBuild.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RecipeBookBuildFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookBuildFindFirstArgs<ExtArgs>>
    ): Prisma__RecipeBookBuildClient<$Result.GetResult<Prisma.$RecipeBookBuildPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RecipeBookBuild that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookBuildFindFirstOrThrowArgs} args - Arguments to find a RecipeBookBuild
     * @example
     * // Get one RecipeBookBuild
     * const recipeBookBuild = await prisma.recipeBookBuild.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RecipeBookBuildFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookBuildFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RecipeBookBuildClient<$Result.GetResult<Prisma.$RecipeBookBuildPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RecipeBookBuilds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookBuildFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecipeBookBuilds
     * const recipeBookBuilds = await prisma.recipeBookBuild.findMany()
     * 
     * // Get first 10 RecipeBookBuilds
     * const recipeBookBuilds = await prisma.recipeBookBuild.findMany({ take: 10 })
     * 
     * // Only select the `buildId`
     * const recipeBookBuildWithBuildIdOnly = await prisma.recipeBookBuild.findMany({ select: { buildId: true } })
     * 
    **/
    findMany<T extends RecipeBookBuildFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookBuildFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeBookBuildPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RecipeBookBuild.
     * @param {RecipeBookBuildCreateArgs} args - Arguments to create a RecipeBookBuild.
     * @example
     * // Create one RecipeBookBuild
     * const RecipeBookBuild = await prisma.recipeBookBuild.create({
     *   data: {
     *     // ... data to create a RecipeBookBuild
     *   }
     * })
     * 
    **/
    create<T extends RecipeBookBuildCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookBuildCreateArgs<ExtArgs>>
    ): Prisma__RecipeBookBuildClient<$Result.GetResult<Prisma.$RecipeBookBuildPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RecipeBookBuilds.
     *     @param {RecipeBookBuildCreateManyArgs} args - Arguments to create many RecipeBookBuilds.
     *     @example
     *     // Create many RecipeBookBuilds
     *     const recipeBookBuild = await prisma.recipeBookBuild.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RecipeBookBuildCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookBuildCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RecipeBookBuild.
     * @param {RecipeBookBuildDeleteArgs} args - Arguments to delete one RecipeBookBuild.
     * @example
     * // Delete one RecipeBookBuild
     * const RecipeBookBuild = await prisma.recipeBookBuild.delete({
     *   where: {
     *     // ... filter to delete one RecipeBookBuild
     *   }
     * })
     * 
    **/
    delete<T extends RecipeBookBuildDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookBuildDeleteArgs<ExtArgs>>
    ): Prisma__RecipeBookBuildClient<$Result.GetResult<Prisma.$RecipeBookBuildPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RecipeBookBuild.
     * @param {RecipeBookBuildUpdateArgs} args - Arguments to update one RecipeBookBuild.
     * @example
     * // Update one RecipeBookBuild
     * const recipeBookBuild = await prisma.recipeBookBuild.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RecipeBookBuildUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookBuildUpdateArgs<ExtArgs>>
    ): Prisma__RecipeBookBuildClient<$Result.GetResult<Prisma.$RecipeBookBuildPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RecipeBookBuilds.
     * @param {RecipeBookBuildDeleteManyArgs} args - Arguments to filter RecipeBookBuilds to delete.
     * @example
     * // Delete a few RecipeBookBuilds
     * const { count } = await prisma.recipeBookBuild.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RecipeBookBuildDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookBuildDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeBookBuilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookBuildUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecipeBookBuilds
     * const recipeBookBuild = await prisma.recipeBookBuild.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RecipeBookBuildUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookBuildUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RecipeBookBuild.
     * @param {RecipeBookBuildUpsertArgs} args - Arguments to update or create a RecipeBookBuild.
     * @example
     * // Update or create a RecipeBookBuild
     * const recipeBookBuild = await prisma.recipeBookBuild.upsert({
     *   create: {
     *     // ... data to create a RecipeBookBuild
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecipeBookBuild we want to update
     *   }
     * })
    **/
    upsert<T extends RecipeBookBuildUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookBuildUpsertArgs<ExtArgs>>
    ): Prisma__RecipeBookBuildClient<$Result.GetResult<Prisma.$RecipeBookBuildPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RecipeBookBuilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookBuildCountArgs} args - Arguments to filter RecipeBookBuilds to count.
     * @example
     * // Count the number of RecipeBookBuilds
     * const count = await prisma.recipeBookBuild.count({
     *   where: {
     *     // ... the filter for the RecipeBookBuilds we want to count
     *   }
     * })
    **/
    count<T extends RecipeBookBuildCountArgs>(
      args?: Subset<T, RecipeBookBuildCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeBookBuildCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecipeBookBuild.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookBuildAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeBookBuildAggregateArgs>(args: Subset<T, RecipeBookBuildAggregateArgs>): Prisma.PrismaPromise<GetRecipeBookBuildAggregateType<T>>

    /**
     * Group by RecipeBookBuild.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookBuildGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeBookBuildGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeBookBuildGroupByArgs['orderBy'] }
        : { orderBy?: RecipeBookBuildGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeBookBuildGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeBookBuildGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecipeBookBuild model
   */
  readonly fields: RecipeBookBuildFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecipeBookBuild.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeBookBuildClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    recipeBook<T extends RecipeBookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeBookDefaultArgs<ExtArgs>>): Prisma__RecipeBookClient<$Result.GetResult<Prisma.$RecipeBookPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    build<T extends BuildDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BuildDefaultArgs<ExtArgs>>): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RecipeBookBuild model
   */ 
  interface RecipeBookBuildFieldRefs {
    readonly buildId: FieldRef<"RecipeBookBuild", 'String'>
    readonly recipeBookId: FieldRef<"RecipeBookBuild", 'String'>
  }
    

  // Custom InputTypes

  /**
   * RecipeBookBuild findUnique
   */
  export type RecipeBookBuildFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     */
    select?: RecipeBookBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookBuildInclude<ExtArgs> | null
    /**
     * Filter, which RecipeBookBuild to fetch.
     */
    where: RecipeBookBuildWhereUniqueInput
  }


  /**
   * RecipeBookBuild findUniqueOrThrow
   */
  export type RecipeBookBuildFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     */
    select?: RecipeBookBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookBuildInclude<ExtArgs> | null
    /**
     * Filter, which RecipeBookBuild to fetch.
     */
    where: RecipeBookBuildWhereUniqueInput
  }


  /**
   * RecipeBookBuild findFirst
   */
  export type RecipeBookBuildFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     */
    select?: RecipeBookBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookBuildInclude<ExtArgs> | null
    /**
     * Filter, which RecipeBookBuild to fetch.
     */
    where?: RecipeBookBuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBookBuilds to fetch.
     */
    orderBy?: RecipeBookBuildOrderByWithRelationInput | RecipeBookBuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeBookBuilds.
     */
    cursor?: RecipeBookBuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBookBuilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBookBuilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeBookBuilds.
     */
    distinct?: RecipeBookBuildScalarFieldEnum | RecipeBookBuildScalarFieldEnum[]
  }


  /**
   * RecipeBookBuild findFirstOrThrow
   */
  export type RecipeBookBuildFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     */
    select?: RecipeBookBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookBuildInclude<ExtArgs> | null
    /**
     * Filter, which RecipeBookBuild to fetch.
     */
    where?: RecipeBookBuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBookBuilds to fetch.
     */
    orderBy?: RecipeBookBuildOrderByWithRelationInput | RecipeBookBuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeBookBuilds.
     */
    cursor?: RecipeBookBuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBookBuilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBookBuilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeBookBuilds.
     */
    distinct?: RecipeBookBuildScalarFieldEnum | RecipeBookBuildScalarFieldEnum[]
  }


  /**
   * RecipeBookBuild findMany
   */
  export type RecipeBookBuildFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     */
    select?: RecipeBookBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookBuildInclude<ExtArgs> | null
    /**
     * Filter, which RecipeBookBuilds to fetch.
     */
    where?: RecipeBookBuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBookBuilds to fetch.
     */
    orderBy?: RecipeBookBuildOrderByWithRelationInput | RecipeBookBuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecipeBookBuilds.
     */
    cursor?: RecipeBookBuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBookBuilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBookBuilds.
     */
    skip?: number
    distinct?: RecipeBookBuildScalarFieldEnum | RecipeBookBuildScalarFieldEnum[]
  }


  /**
   * RecipeBookBuild create
   */
  export type RecipeBookBuildCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     */
    select?: RecipeBookBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookBuildInclude<ExtArgs> | null
    /**
     * The data needed to create a RecipeBookBuild.
     */
    data: XOR<RecipeBookBuildCreateInput, RecipeBookBuildUncheckedCreateInput>
  }


  /**
   * RecipeBookBuild createMany
   */
  export type RecipeBookBuildCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecipeBookBuilds.
     */
    data: RecipeBookBuildCreateManyInput | RecipeBookBuildCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RecipeBookBuild update
   */
  export type RecipeBookBuildUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     */
    select?: RecipeBookBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookBuildInclude<ExtArgs> | null
    /**
     * The data needed to update a RecipeBookBuild.
     */
    data: XOR<RecipeBookBuildUpdateInput, RecipeBookBuildUncheckedUpdateInput>
    /**
     * Choose, which RecipeBookBuild to update.
     */
    where: RecipeBookBuildWhereUniqueInput
  }


  /**
   * RecipeBookBuild updateMany
   */
  export type RecipeBookBuildUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecipeBookBuilds.
     */
    data: XOR<RecipeBookBuildUpdateManyMutationInput, RecipeBookBuildUncheckedUpdateManyInput>
    /**
     * Filter which RecipeBookBuilds to update
     */
    where?: RecipeBookBuildWhereInput
  }


  /**
   * RecipeBookBuild upsert
   */
  export type RecipeBookBuildUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     */
    select?: RecipeBookBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookBuildInclude<ExtArgs> | null
    /**
     * The filter to search for the RecipeBookBuild to update in case it exists.
     */
    where: RecipeBookBuildWhereUniqueInput
    /**
     * In case the RecipeBookBuild found by the `where` argument doesn't exist, create a new RecipeBookBuild with this data.
     */
    create: XOR<RecipeBookBuildCreateInput, RecipeBookBuildUncheckedCreateInput>
    /**
     * In case the RecipeBookBuild was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeBookBuildUpdateInput, RecipeBookBuildUncheckedUpdateInput>
  }


  /**
   * RecipeBookBuild delete
   */
  export type RecipeBookBuildDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     */
    select?: RecipeBookBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookBuildInclude<ExtArgs> | null
    /**
     * Filter which RecipeBookBuild to delete.
     */
    where: RecipeBookBuildWhereUniqueInput
  }


  /**
   * RecipeBookBuild deleteMany
   */
  export type RecipeBookBuildDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeBookBuilds to delete
     */
    where?: RecipeBookBuildWhereInput
  }


  /**
   * RecipeBookBuild without action
   */
  export type RecipeBookBuildDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     */
    select?: RecipeBookBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookBuildInclude<ExtArgs> | null
  }



  /**
   * Model Touch
   */

  export type AggregateTouch = {
    _count: TouchCountAggregateOutputType | null
    _avg: TouchAvgAggregateOutputType | null
    _sum: TouchSumAggregateOutputType | null
    _min: TouchMinAggregateOutputType | null
    _max: TouchMaxAggregateOutputType | null
  }

  export type TouchAvgAggregateOutputType = {
    order: number | null
    amount: number | null
    version: number | null
  }

  export type TouchSumAggregateOutputType = {
    order: number | null
    amount: number | null
    version: number | null
  }

  export type TouchMinAggregateOutputType = {
    id: string | null
    buildId: string | null
    order: number | null
    amount: number | null
    unit: string | null
    genericIngredientId: string | null
    specificIngredientId: string | null
    version: number | null
  }

  export type TouchMaxAggregateOutputType = {
    id: string | null
    buildId: string | null
    order: number | null
    amount: number | null
    unit: string | null
    genericIngredientId: string | null
    specificIngredientId: string | null
    version: number | null
  }

  export type TouchCountAggregateOutputType = {
    id: number
    buildId: number
    order: number
    amount: number
    unit: number
    genericIngredientId: number
    specificIngredientId: number
    version: number
    _all: number
  }


  export type TouchAvgAggregateInputType = {
    order?: true
    amount?: true
    version?: true
  }

  export type TouchSumAggregateInputType = {
    order?: true
    amount?: true
    version?: true
  }

  export type TouchMinAggregateInputType = {
    id?: true
    buildId?: true
    order?: true
    amount?: true
    unit?: true
    genericIngredientId?: true
    specificIngredientId?: true
    version?: true
  }

  export type TouchMaxAggregateInputType = {
    id?: true
    buildId?: true
    order?: true
    amount?: true
    unit?: true
    genericIngredientId?: true
    specificIngredientId?: true
    version?: true
  }

  export type TouchCountAggregateInputType = {
    id?: true
    buildId?: true
    order?: true
    amount?: true
    unit?: true
    genericIngredientId?: true
    specificIngredientId?: true
    version?: true
    _all?: true
  }

  export type TouchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Touch to aggregate.
     */
    where?: TouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Touches to fetch.
     */
    orderBy?: TouchOrderByWithRelationInput | TouchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Touches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Touches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Touches
    **/
    _count?: true | TouchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TouchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TouchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TouchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TouchMaxAggregateInputType
  }

  export type GetTouchAggregateType<T extends TouchAggregateArgs> = {
        [P in keyof T & keyof AggregateTouch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTouch[P]>
      : GetScalarType<T[P], AggregateTouch[P]>
  }




  export type TouchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TouchWhereInput
    orderBy?: TouchOrderByWithAggregationInput | TouchOrderByWithAggregationInput[]
    by: TouchScalarFieldEnum[] | TouchScalarFieldEnum
    having?: TouchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TouchCountAggregateInputType | true
    _avg?: TouchAvgAggregateInputType
    _sum?: TouchSumAggregateInputType
    _min?: TouchMinAggregateInputType
    _max?: TouchMaxAggregateInputType
  }

  export type TouchGroupByOutputType = {
    id: string
    buildId: string
    order: number | null
    amount: number | null
    unit: string | null
    genericIngredientId: string
    specificIngredientId: string | null
    version: number | null
    _count: TouchCountAggregateOutputType | null
    _avg: TouchAvgAggregateOutputType | null
    _sum: TouchSumAggregateOutputType | null
    _min: TouchMinAggregateOutputType | null
    _max: TouchMaxAggregateOutputType | null
  }

  type GetTouchGroupByPayload<T extends TouchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TouchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TouchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TouchGroupByOutputType[P]>
            : GetScalarType<T[P], TouchGroupByOutputType[P]>
        }
      >
    >


  export type TouchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    buildId?: boolean
    order?: boolean
    amount?: boolean
    unit?: boolean
    genericIngredientId?: boolean
    specificIngredientId?: boolean
    version?: boolean
    build?: boolean | BuildDefaultArgs<ExtArgs>
    genericIngredient?: boolean | GenericIngredientDefaultArgs<ExtArgs>
    specificIngredient?: boolean | Touch$specificIngredientArgs<ExtArgs>
  }, ExtArgs["result"]["touch"]>

  export type TouchSelectScalar = {
    id?: boolean
    buildId?: boolean
    order?: boolean
    amount?: boolean
    unit?: boolean
    genericIngredientId?: boolean
    specificIngredientId?: boolean
    version?: boolean
  }

  export type TouchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    build?: boolean | BuildDefaultArgs<ExtArgs>
    genericIngredient?: boolean | GenericIngredientDefaultArgs<ExtArgs>
    specificIngredient?: boolean | Touch$specificIngredientArgs<ExtArgs>
  }


  export type $TouchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Touch"
    objects: {
      build: Prisma.$BuildPayload<ExtArgs>
      genericIngredient: Prisma.$GenericIngredientPayload<ExtArgs>
      specificIngredient: Prisma.$SpecificIngredientPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      buildId: string
      order: number | null
      amount: number | null
      unit: string | null
      genericIngredientId: string
      specificIngredientId: string | null
      version: number | null
    }, ExtArgs["result"]["touch"]>
    composites: {}
  }


  type TouchGetPayload<S extends boolean | null | undefined | TouchDefaultArgs> = $Result.GetResult<Prisma.$TouchPayload, S>

  type TouchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TouchFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: TouchCountAggregateInputType | true
    }

  export interface TouchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Touch'], meta: { name: 'Touch' } }
    /**
     * Find zero or one Touch that matches the filter.
     * @param {TouchFindUniqueArgs} args - Arguments to find a Touch
     * @example
     * // Get one Touch
     * const touch = await prisma.touch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TouchFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TouchFindUniqueArgs<ExtArgs>>
    ): Prisma__TouchClient<$Result.GetResult<Prisma.$TouchPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Touch that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TouchFindUniqueOrThrowArgs} args - Arguments to find a Touch
     * @example
     * // Get one Touch
     * const touch = await prisma.touch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TouchFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TouchFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TouchClient<$Result.GetResult<Prisma.$TouchPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Touch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchFindFirstArgs} args - Arguments to find a Touch
     * @example
     * // Get one Touch
     * const touch = await prisma.touch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TouchFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TouchFindFirstArgs<ExtArgs>>
    ): Prisma__TouchClient<$Result.GetResult<Prisma.$TouchPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Touch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchFindFirstOrThrowArgs} args - Arguments to find a Touch
     * @example
     * // Get one Touch
     * const touch = await prisma.touch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TouchFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TouchFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TouchClient<$Result.GetResult<Prisma.$TouchPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Touches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Touches
     * const touches = await prisma.touch.findMany()
     * 
     * // Get first 10 Touches
     * const touches = await prisma.touch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const touchWithIdOnly = await prisma.touch.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TouchFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TouchFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TouchPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Touch.
     * @param {TouchCreateArgs} args - Arguments to create a Touch.
     * @example
     * // Create one Touch
     * const Touch = await prisma.touch.create({
     *   data: {
     *     // ... data to create a Touch
     *   }
     * })
     * 
    **/
    create<T extends TouchCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TouchCreateArgs<ExtArgs>>
    ): Prisma__TouchClient<$Result.GetResult<Prisma.$TouchPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Touches.
     *     @param {TouchCreateManyArgs} args - Arguments to create many Touches.
     *     @example
     *     // Create many Touches
     *     const touch = await prisma.touch.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TouchCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TouchCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Touch.
     * @param {TouchDeleteArgs} args - Arguments to delete one Touch.
     * @example
     * // Delete one Touch
     * const Touch = await prisma.touch.delete({
     *   where: {
     *     // ... filter to delete one Touch
     *   }
     * })
     * 
    **/
    delete<T extends TouchDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TouchDeleteArgs<ExtArgs>>
    ): Prisma__TouchClient<$Result.GetResult<Prisma.$TouchPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Touch.
     * @param {TouchUpdateArgs} args - Arguments to update one Touch.
     * @example
     * // Update one Touch
     * const touch = await prisma.touch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TouchUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TouchUpdateArgs<ExtArgs>>
    ): Prisma__TouchClient<$Result.GetResult<Prisma.$TouchPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Touches.
     * @param {TouchDeleteManyArgs} args - Arguments to filter Touches to delete.
     * @example
     * // Delete a few Touches
     * const { count } = await prisma.touch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TouchDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TouchDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Touches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Touches
     * const touch = await prisma.touch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TouchUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TouchUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Touch.
     * @param {TouchUpsertArgs} args - Arguments to update or create a Touch.
     * @example
     * // Update or create a Touch
     * const touch = await prisma.touch.upsert({
     *   create: {
     *     // ... data to create a Touch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Touch we want to update
     *   }
     * })
    **/
    upsert<T extends TouchUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TouchUpsertArgs<ExtArgs>>
    ): Prisma__TouchClient<$Result.GetResult<Prisma.$TouchPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Touches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchCountArgs} args - Arguments to filter Touches to count.
     * @example
     * // Count the number of Touches
     * const count = await prisma.touch.count({
     *   where: {
     *     // ... the filter for the Touches we want to count
     *   }
     * })
    **/
    count<T extends TouchCountArgs>(
      args?: Subset<T, TouchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TouchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Touch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TouchAggregateArgs>(args: Subset<T, TouchAggregateArgs>): Prisma.PrismaPromise<GetTouchAggregateType<T>>

    /**
     * Group by Touch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TouchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TouchGroupByArgs['orderBy'] }
        : { orderBy?: TouchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TouchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTouchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Touch model
   */
  readonly fields: TouchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Touch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TouchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    build<T extends BuildDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BuildDefaultArgs<ExtArgs>>): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    genericIngredient<T extends GenericIngredientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GenericIngredientDefaultArgs<ExtArgs>>): Prisma__GenericIngredientClient<$Result.GetResult<Prisma.$GenericIngredientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    specificIngredient<T extends Touch$specificIngredientArgs<ExtArgs> = {}>(args?: Subset<T, Touch$specificIngredientArgs<ExtArgs>>): Prisma__SpecificIngredientClient<$Result.GetResult<Prisma.$SpecificIngredientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Touch model
   */ 
  interface TouchFieldRefs {
    readonly id: FieldRef<"Touch", 'String'>
    readonly buildId: FieldRef<"Touch", 'String'>
    readonly order: FieldRef<"Touch", 'Int'>
    readonly amount: FieldRef<"Touch", 'Float'>
    readonly unit: FieldRef<"Touch", 'String'>
    readonly genericIngredientId: FieldRef<"Touch", 'String'>
    readonly specificIngredientId: FieldRef<"Touch", 'String'>
    readonly version: FieldRef<"Touch", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Touch findUnique
   */
  export type TouchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Touch
     */
    select?: TouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TouchInclude<ExtArgs> | null
    /**
     * Filter, which Touch to fetch.
     */
    where: TouchWhereUniqueInput
  }


  /**
   * Touch findUniqueOrThrow
   */
  export type TouchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Touch
     */
    select?: TouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TouchInclude<ExtArgs> | null
    /**
     * Filter, which Touch to fetch.
     */
    where: TouchWhereUniqueInput
  }


  /**
   * Touch findFirst
   */
  export type TouchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Touch
     */
    select?: TouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TouchInclude<ExtArgs> | null
    /**
     * Filter, which Touch to fetch.
     */
    where?: TouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Touches to fetch.
     */
    orderBy?: TouchOrderByWithRelationInput | TouchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Touches.
     */
    cursor?: TouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Touches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Touches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Touches.
     */
    distinct?: TouchScalarFieldEnum | TouchScalarFieldEnum[]
  }


  /**
   * Touch findFirstOrThrow
   */
  export type TouchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Touch
     */
    select?: TouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TouchInclude<ExtArgs> | null
    /**
     * Filter, which Touch to fetch.
     */
    where?: TouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Touches to fetch.
     */
    orderBy?: TouchOrderByWithRelationInput | TouchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Touches.
     */
    cursor?: TouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Touches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Touches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Touches.
     */
    distinct?: TouchScalarFieldEnum | TouchScalarFieldEnum[]
  }


  /**
   * Touch findMany
   */
  export type TouchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Touch
     */
    select?: TouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TouchInclude<ExtArgs> | null
    /**
     * Filter, which Touches to fetch.
     */
    where?: TouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Touches to fetch.
     */
    orderBy?: TouchOrderByWithRelationInput | TouchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Touches.
     */
    cursor?: TouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Touches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Touches.
     */
    skip?: number
    distinct?: TouchScalarFieldEnum | TouchScalarFieldEnum[]
  }


  /**
   * Touch create
   */
  export type TouchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Touch
     */
    select?: TouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TouchInclude<ExtArgs> | null
    /**
     * The data needed to create a Touch.
     */
    data: XOR<TouchCreateInput, TouchUncheckedCreateInput>
  }


  /**
   * Touch createMany
   */
  export type TouchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Touches.
     */
    data: TouchCreateManyInput | TouchCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Touch update
   */
  export type TouchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Touch
     */
    select?: TouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TouchInclude<ExtArgs> | null
    /**
     * The data needed to update a Touch.
     */
    data: XOR<TouchUpdateInput, TouchUncheckedUpdateInput>
    /**
     * Choose, which Touch to update.
     */
    where: TouchWhereUniqueInput
  }


  /**
   * Touch updateMany
   */
  export type TouchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Touches.
     */
    data: XOR<TouchUpdateManyMutationInput, TouchUncheckedUpdateManyInput>
    /**
     * Filter which Touches to update
     */
    where?: TouchWhereInput
  }


  /**
   * Touch upsert
   */
  export type TouchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Touch
     */
    select?: TouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TouchInclude<ExtArgs> | null
    /**
     * The filter to search for the Touch to update in case it exists.
     */
    where: TouchWhereUniqueInput
    /**
     * In case the Touch found by the `where` argument doesn't exist, create a new Touch with this data.
     */
    create: XOR<TouchCreateInput, TouchUncheckedCreateInput>
    /**
     * In case the Touch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TouchUpdateInput, TouchUncheckedUpdateInput>
  }


  /**
   * Touch delete
   */
  export type TouchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Touch
     */
    select?: TouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TouchInclude<ExtArgs> | null
    /**
     * Filter which Touch to delete.
     */
    where: TouchWhereUniqueInput
  }


  /**
   * Touch deleteMany
   */
  export type TouchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Touches to delete
     */
    where?: TouchWhereInput
  }


  /**
   * Touch.specificIngredient
   */
  export type Touch$specificIngredientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificIngredient
     */
    select?: SpecificIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecificIngredientInclude<ExtArgs> | null
    where?: SpecificIngredientWhereInput
  }


  /**
   * Touch without action
   */
  export type TouchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Touch
     */
    select?: TouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TouchInclude<ExtArgs> | null
  }



  /**
   * Model ArchivedTouch
   */

  export type AggregateArchivedTouch = {
    _count: ArchivedTouchCountAggregateOutputType | null
    _avg: ArchivedTouchAvgAggregateOutputType | null
    _sum: ArchivedTouchSumAggregateOutputType | null
    _min: ArchivedTouchMinAggregateOutputType | null
    _max: ArchivedTouchMaxAggregateOutputType | null
  }

  export type ArchivedTouchAvgAggregateOutputType = {
    order: number | null
    amount: number | null
    version: number | null
  }

  export type ArchivedTouchSumAggregateOutputType = {
    order: number | null
    amount: number | null
    version: number | null
  }

  export type ArchivedTouchMinAggregateOutputType = {
    id: string | null
    buildId: string | null
    order: number | null
    amount: number | null
    unit: string | null
    genericIngredientId: string | null
    specificIngredientId: string | null
    version: number | null
  }

  export type ArchivedTouchMaxAggregateOutputType = {
    id: string | null
    buildId: string | null
    order: number | null
    amount: number | null
    unit: string | null
    genericIngredientId: string | null
    specificIngredientId: string | null
    version: number | null
  }

  export type ArchivedTouchCountAggregateOutputType = {
    id: number
    buildId: number
    order: number
    amount: number
    unit: number
    genericIngredientId: number
    specificIngredientId: number
    version: number
    _all: number
  }


  export type ArchivedTouchAvgAggregateInputType = {
    order?: true
    amount?: true
    version?: true
  }

  export type ArchivedTouchSumAggregateInputType = {
    order?: true
    amount?: true
    version?: true
  }

  export type ArchivedTouchMinAggregateInputType = {
    id?: true
    buildId?: true
    order?: true
    amount?: true
    unit?: true
    genericIngredientId?: true
    specificIngredientId?: true
    version?: true
  }

  export type ArchivedTouchMaxAggregateInputType = {
    id?: true
    buildId?: true
    order?: true
    amount?: true
    unit?: true
    genericIngredientId?: true
    specificIngredientId?: true
    version?: true
  }

  export type ArchivedTouchCountAggregateInputType = {
    id?: true
    buildId?: true
    order?: true
    amount?: true
    unit?: true
    genericIngredientId?: true
    specificIngredientId?: true
    version?: true
    _all?: true
  }

  export type ArchivedTouchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArchivedTouch to aggregate.
     */
    where?: ArchivedTouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArchivedTouches to fetch.
     */
    orderBy?: ArchivedTouchOrderByWithRelationInput | ArchivedTouchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArchivedTouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArchivedTouches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArchivedTouches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ArchivedTouches
    **/
    _count?: true | ArchivedTouchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArchivedTouchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArchivedTouchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArchivedTouchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArchivedTouchMaxAggregateInputType
  }

  export type GetArchivedTouchAggregateType<T extends ArchivedTouchAggregateArgs> = {
        [P in keyof T & keyof AggregateArchivedTouch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArchivedTouch[P]>
      : GetScalarType<T[P], AggregateArchivedTouch[P]>
  }




  export type ArchivedTouchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArchivedTouchWhereInput
    orderBy?: ArchivedTouchOrderByWithAggregationInput | ArchivedTouchOrderByWithAggregationInput[]
    by: ArchivedTouchScalarFieldEnum[] | ArchivedTouchScalarFieldEnum
    having?: ArchivedTouchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArchivedTouchCountAggregateInputType | true
    _avg?: ArchivedTouchAvgAggregateInputType
    _sum?: ArchivedTouchSumAggregateInputType
    _min?: ArchivedTouchMinAggregateInputType
    _max?: ArchivedTouchMaxAggregateInputType
  }

  export type ArchivedTouchGroupByOutputType = {
    id: string
    buildId: string
    order: number | null
    amount: number | null
    unit: string | null
    genericIngredientId: string
    specificIngredientId: string | null
    version: number | null
    _count: ArchivedTouchCountAggregateOutputType | null
    _avg: ArchivedTouchAvgAggregateOutputType | null
    _sum: ArchivedTouchSumAggregateOutputType | null
    _min: ArchivedTouchMinAggregateOutputType | null
    _max: ArchivedTouchMaxAggregateOutputType | null
  }

  type GetArchivedTouchGroupByPayload<T extends ArchivedTouchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArchivedTouchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArchivedTouchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArchivedTouchGroupByOutputType[P]>
            : GetScalarType<T[P], ArchivedTouchGroupByOutputType[P]>
        }
      >
    >


  export type ArchivedTouchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    buildId?: boolean
    order?: boolean
    amount?: boolean
    unit?: boolean
    genericIngredientId?: boolean
    specificIngredientId?: boolean
    version?: boolean
    build?: boolean | BuildDefaultArgs<ExtArgs>
    genericIngredient?: boolean | GenericIngredientDefaultArgs<ExtArgs>
    specificIngredient?: boolean | ArchivedTouch$specificIngredientArgs<ExtArgs>
  }, ExtArgs["result"]["archivedTouch"]>

  export type ArchivedTouchSelectScalar = {
    id?: boolean
    buildId?: boolean
    order?: boolean
    amount?: boolean
    unit?: boolean
    genericIngredientId?: boolean
    specificIngredientId?: boolean
    version?: boolean
  }

  export type ArchivedTouchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    build?: boolean | BuildDefaultArgs<ExtArgs>
    genericIngredient?: boolean | GenericIngredientDefaultArgs<ExtArgs>
    specificIngredient?: boolean | ArchivedTouch$specificIngredientArgs<ExtArgs>
  }


  export type $ArchivedTouchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ArchivedTouch"
    objects: {
      build: Prisma.$BuildPayload<ExtArgs>
      genericIngredient: Prisma.$GenericIngredientPayload<ExtArgs>
      specificIngredient: Prisma.$SpecificIngredientPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      buildId: string
      order: number | null
      amount: number | null
      unit: string | null
      genericIngredientId: string
      specificIngredientId: string | null
      version: number | null
    }, ExtArgs["result"]["archivedTouch"]>
    composites: {}
  }


  type ArchivedTouchGetPayload<S extends boolean | null | undefined | ArchivedTouchDefaultArgs> = $Result.GetResult<Prisma.$ArchivedTouchPayload, S>

  type ArchivedTouchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ArchivedTouchFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ArchivedTouchCountAggregateInputType | true
    }

  export interface ArchivedTouchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ArchivedTouch'], meta: { name: 'ArchivedTouch' } }
    /**
     * Find zero or one ArchivedTouch that matches the filter.
     * @param {ArchivedTouchFindUniqueArgs} args - Arguments to find a ArchivedTouch
     * @example
     * // Get one ArchivedTouch
     * const archivedTouch = await prisma.archivedTouch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ArchivedTouchFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ArchivedTouchFindUniqueArgs<ExtArgs>>
    ): Prisma__ArchivedTouchClient<$Result.GetResult<Prisma.$ArchivedTouchPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ArchivedTouch that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ArchivedTouchFindUniqueOrThrowArgs} args - Arguments to find a ArchivedTouch
     * @example
     * // Get one ArchivedTouch
     * const archivedTouch = await prisma.archivedTouch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ArchivedTouchFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ArchivedTouchFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ArchivedTouchClient<$Result.GetResult<Prisma.$ArchivedTouchPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ArchivedTouch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArchivedTouchFindFirstArgs} args - Arguments to find a ArchivedTouch
     * @example
     * // Get one ArchivedTouch
     * const archivedTouch = await prisma.archivedTouch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ArchivedTouchFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ArchivedTouchFindFirstArgs<ExtArgs>>
    ): Prisma__ArchivedTouchClient<$Result.GetResult<Prisma.$ArchivedTouchPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ArchivedTouch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArchivedTouchFindFirstOrThrowArgs} args - Arguments to find a ArchivedTouch
     * @example
     * // Get one ArchivedTouch
     * const archivedTouch = await prisma.archivedTouch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ArchivedTouchFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ArchivedTouchFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ArchivedTouchClient<$Result.GetResult<Prisma.$ArchivedTouchPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ArchivedTouches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArchivedTouchFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ArchivedTouches
     * const archivedTouches = await prisma.archivedTouch.findMany()
     * 
     * // Get first 10 ArchivedTouches
     * const archivedTouches = await prisma.archivedTouch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const archivedTouchWithIdOnly = await prisma.archivedTouch.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ArchivedTouchFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ArchivedTouchFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArchivedTouchPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ArchivedTouch.
     * @param {ArchivedTouchCreateArgs} args - Arguments to create a ArchivedTouch.
     * @example
     * // Create one ArchivedTouch
     * const ArchivedTouch = await prisma.archivedTouch.create({
     *   data: {
     *     // ... data to create a ArchivedTouch
     *   }
     * })
     * 
    **/
    create<T extends ArchivedTouchCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ArchivedTouchCreateArgs<ExtArgs>>
    ): Prisma__ArchivedTouchClient<$Result.GetResult<Prisma.$ArchivedTouchPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ArchivedTouches.
     *     @param {ArchivedTouchCreateManyArgs} args - Arguments to create many ArchivedTouches.
     *     @example
     *     // Create many ArchivedTouches
     *     const archivedTouch = await prisma.archivedTouch.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ArchivedTouchCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ArchivedTouchCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ArchivedTouch.
     * @param {ArchivedTouchDeleteArgs} args - Arguments to delete one ArchivedTouch.
     * @example
     * // Delete one ArchivedTouch
     * const ArchivedTouch = await prisma.archivedTouch.delete({
     *   where: {
     *     // ... filter to delete one ArchivedTouch
     *   }
     * })
     * 
    **/
    delete<T extends ArchivedTouchDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ArchivedTouchDeleteArgs<ExtArgs>>
    ): Prisma__ArchivedTouchClient<$Result.GetResult<Prisma.$ArchivedTouchPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ArchivedTouch.
     * @param {ArchivedTouchUpdateArgs} args - Arguments to update one ArchivedTouch.
     * @example
     * // Update one ArchivedTouch
     * const archivedTouch = await prisma.archivedTouch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ArchivedTouchUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ArchivedTouchUpdateArgs<ExtArgs>>
    ): Prisma__ArchivedTouchClient<$Result.GetResult<Prisma.$ArchivedTouchPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ArchivedTouches.
     * @param {ArchivedTouchDeleteManyArgs} args - Arguments to filter ArchivedTouches to delete.
     * @example
     * // Delete a few ArchivedTouches
     * const { count } = await prisma.archivedTouch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ArchivedTouchDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ArchivedTouchDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArchivedTouches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArchivedTouchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ArchivedTouches
     * const archivedTouch = await prisma.archivedTouch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ArchivedTouchUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ArchivedTouchUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ArchivedTouch.
     * @param {ArchivedTouchUpsertArgs} args - Arguments to update or create a ArchivedTouch.
     * @example
     * // Update or create a ArchivedTouch
     * const archivedTouch = await prisma.archivedTouch.upsert({
     *   create: {
     *     // ... data to create a ArchivedTouch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ArchivedTouch we want to update
     *   }
     * })
    **/
    upsert<T extends ArchivedTouchUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ArchivedTouchUpsertArgs<ExtArgs>>
    ): Prisma__ArchivedTouchClient<$Result.GetResult<Prisma.$ArchivedTouchPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ArchivedTouches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArchivedTouchCountArgs} args - Arguments to filter ArchivedTouches to count.
     * @example
     * // Count the number of ArchivedTouches
     * const count = await prisma.archivedTouch.count({
     *   where: {
     *     // ... the filter for the ArchivedTouches we want to count
     *   }
     * })
    **/
    count<T extends ArchivedTouchCountArgs>(
      args?: Subset<T, ArchivedTouchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArchivedTouchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ArchivedTouch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArchivedTouchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArchivedTouchAggregateArgs>(args: Subset<T, ArchivedTouchAggregateArgs>): Prisma.PrismaPromise<GetArchivedTouchAggregateType<T>>

    /**
     * Group by ArchivedTouch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArchivedTouchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArchivedTouchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArchivedTouchGroupByArgs['orderBy'] }
        : { orderBy?: ArchivedTouchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArchivedTouchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArchivedTouchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ArchivedTouch model
   */
  readonly fields: ArchivedTouchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ArchivedTouch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArchivedTouchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    build<T extends BuildDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BuildDefaultArgs<ExtArgs>>): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    genericIngredient<T extends GenericIngredientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GenericIngredientDefaultArgs<ExtArgs>>): Prisma__GenericIngredientClient<$Result.GetResult<Prisma.$GenericIngredientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    specificIngredient<T extends ArchivedTouch$specificIngredientArgs<ExtArgs> = {}>(args?: Subset<T, ArchivedTouch$specificIngredientArgs<ExtArgs>>): Prisma__SpecificIngredientClient<$Result.GetResult<Prisma.$SpecificIngredientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ArchivedTouch model
   */ 
  interface ArchivedTouchFieldRefs {
    readonly id: FieldRef<"ArchivedTouch", 'String'>
    readonly buildId: FieldRef<"ArchivedTouch", 'String'>
    readonly order: FieldRef<"ArchivedTouch", 'Int'>
    readonly amount: FieldRef<"ArchivedTouch", 'Float'>
    readonly unit: FieldRef<"ArchivedTouch", 'String'>
    readonly genericIngredientId: FieldRef<"ArchivedTouch", 'String'>
    readonly specificIngredientId: FieldRef<"ArchivedTouch", 'String'>
    readonly version: FieldRef<"ArchivedTouch", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * ArchivedTouch findUnique
   */
  export type ArchivedTouchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedTouch
     */
    select?: ArchivedTouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedTouchInclude<ExtArgs> | null
    /**
     * Filter, which ArchivedTouch to fetch.
     */
    where: ArchivedTouchWhereUniqueInput
  }


  /**
   * ArchivedTouch findUniqueOrThrow
   */
  export type ArchivedTouchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedTouch
     */
    select?: ArchivedTouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedTouchInclude<ExtArgs> | null
    /**
     * Filter, which ArchivedTouch to fetch.
     */
    where: ArchivedTouchWhereUniqueInput
  }


  /**
   * ArchivedTouch findFirst
   */
  export type ArchivedTouchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedTouch
     */
    select?: ArchivedTouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedTouchInclude<ExtArgs> | null
    /**
     * Filter, which ArchivedTouch to fetch.
     */
    where?: ArchivedTouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArchivedTouches to fetch.
     */
    orderBy?: ArchivedTouchOrderByWithRelationInput | ArchivedTouchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArchivedTouches.
     */
    cursor?: ArchivedTouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArchivedTouches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArchivedTouches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArchivedTouches.
     */
    distinct?: ArchivedTouchScalarFieldEnum | ArchivedTouchScalarFieldEnum[]
  }


  /**
   * ArchivedTouch findFirstOrThrow
   */
  export type ArchivedTouchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedTouch
     */
    select?: ArchivedTouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedTouchInclude<ExtArgs> | null
    /**
     * Filter, which ArchivedTouch to fetch.
     */
    where?: ArchivedTouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArchivedTouches to fetch.
     */
    orderBy?: ArchivedTouchOrderByWithRelationInput | ArchivedTouchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArchivedTouches.
     */
    cursor?: ArchivedTouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArchivedTouches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArchivedTouches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArchivedTouches.
     */
    distinct?: ArchivedTouchScalarFieldEnum | ArchivedTouchScalarFieldEnum[]
  }


  /**
   * ArchivedTouch findMany
   */
  export type ArchivedTouchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedTouch
     */
    select?: ArchivedTouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedTouchInclude<ExtArgs> | null
    /**
     * Filter, which ArchivedTouches to fetch.
     */
    where?: ArchivedTouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArchivedTouches to fetch.
     */
    orderBy?: ArchivedTouchOrderByWithRelationInput | ArchivedTouchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ArchivedTouches.
     */
    cursor?: ArchivedTouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArchivedTouches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArchivedTouches.
     */
    skip?: number
    distinct?: ArchivedTouchScalarFieldEnum | ArchivedTouchScalarFieldEnum[]
  }


  /**
   * ArchivedTouch create
   */
  export type ArchivedTouchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedTouch
     */
    select?: ArchivedTouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedTouchInclude<ExtArgs> | null
    /**
     * The data needed to create a ArchivedTouch.
     */
    data: XOR<ArchivedTouchCreateInput, ArchivedTouchUncheckedCreateInput>
  }


  /**
   * ArchivedTouch createMany
   */
  export type ArchivedTouchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ArchivedTouches.
     */
    data: ArchivedTouchCreateManyInput | ArchivedTouchCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ArchivedTouch update
   */
  export type ArchivedTouchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedTouch
     */
    select?: ArchivedTouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedTouchInclude<ExtArgs> | null
    /**
     * The data needed to update a ArchivedTouch.
     */
    data: XOR<ArchivedTouchUpdateInput, ArchivedTouchUncheckedUpdateInput>
    /**
     * Choose, which ArchivedTouch to update.
     */
    where: ArchivedTouchWhereUniqueInput
  }


  /**
   * ArchivedTouch updateMany
   */
  export type ArchivedTouchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ArchivedTouches.
     */
    data: XOR<ArchivedTouchUpdateManyMutationInput, ArchivedTouchUncheckedUpdateManyInput>
    /**
     * Filter which ArchivedTouches to update
     */
    where?: ArchivedTouchWhereInput
  }


  /**
   * ArchivedTouch upsert
   */
  export type ArchivedTouchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedTouch
     */
    select?: ArchivedTouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedTouchInclude<ExtArgs> | null
    /**
     * The filter to search for the ArchivedTouch to update in case it exists.
     */
    where: ArchivedTouchWhereUniqueInput
    /**
     * In case the ArchivedTouch found by the `where` argument doesn't exist, create a new ArchivedTouch with this data.
     */
    create: XOR<ArchivedTouchCreateInput, ArchivedTouchUncheckedCreateInput>
    /**
     * In case the ArchivedTouch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArchivedTouchUpdateInput, ArchivedTouchUncheckedUpdateInput>
  }


  /**
   * ArchivedTouch delete
   */
  export type ArchivedTouchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedTouch
     */
    select?: ArchivedTouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedTouchInclude<ExtArgs> | null
    /**
     * Filter which ArchivedTouch to delete.
     */
    where: ArchivedTouchWhereUniqueInput
  }


  /**
   * ArchivedTouch deleteMany
   */
  export type ArchivedTouchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArchivedTouches to delete
     */
    where?: ArchivedTouchWhereInput
  }


  /**
   * ArchivedTouch.specificIngredient
   */
  export type ArchivedTouch$specificIngredientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificIngredient
     */
    select?: SpecificIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecificIngredientInclude<ExtArgs> | null
    where?: SpecificIngredientWhereInput
  }


  /**
   * ArchivedTouch without action
   */
  export type ArchivedTouchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedTouch
     */
    select?: ArchivedTouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedTouchInclude<ExtArgs> | null
  }



  /**
   * Model GenericIngredient
   */

  export type AggregateGenericIngredient = {
    _count: GenericIngredientCountAggregateOutputType | null
    _min: GenericIngredientMinAggregateOutputType | null
    _max: GenericIngredientMaxAggregateOutputType | null
  }

  export type GenericIngredientMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
  }

  export type GenericIngredientMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
  }

  export type GenericIngredientCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type GenericIngredientMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type GenericIngredientMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type GenericIngredientCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type GenericIngredientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GenericIngredient to aggregate.
     */
    where?: GenericIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GenericIngredients to fetch.
     */
    orderBy?: GenericIngredientOrderByWithRelationInput | GenericIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GenericIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GenericIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GenericIngredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GenericIngredients
    **/
    _count?: true | GenericIngredientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GenericIngredientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GenericIngredientMaxAggregateInputType
  }

  export type GetGenericIngredientAggregateType<T extends GenericIngredientAggregateArgs> = {
        [P in keyof T & keyof AggregateGenericIngredient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGenericIngredient[P]>
      : GetScalarType<T[P], AggregateGenericIngredient[P]>
  }




  export type GenericIngredientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GenericIngredientWhereInput
    orderBy?: GenericIngredientOrderByWithAggregationInput | GenericIngredientOrderByWithAggregationInput[]
    by: GenericIngredientScalarFieldEnum[] | GenericIngredientScalarFieldEnum
    having?: GenericIngredientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GenericIngredientCountAggregateInputType | true
    _min?: GenericIngredientMinAggregateInputType
    _max?: GenericIngredientMaxAggregateInputType
  }

  export type GenericIngredientGroupByOutputType = {
    id: string
    name: string
    description: string | null
    _count: GenericIngredientCountAggregateOutputType | null
    _min: GenericIngredientMinAggregateOutputType | null
    _max: GenericIngredientMaxAggregateOutputType | null
  }

  type GetGenericIngredientGroupByPayload<T extends GenericIngredientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GenericIngredientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GenericIngredientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GenericIngredientGroupByOutputType[P]>
            : GetScalarType<T[P], GenericIngredientGroupByOutputType[P]>
        }
      >
    >


  export type GenericIngredientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    touch?: boolean | GenericIngredient$touchArgs<ExtArgs>
    archivedTouch?: boolean | GenericIngredient$archivedTouchArgs<ExtArgs>
    specificIngredient?: boolean | GenericIngredient$specificIngredientArgs<ExtArgs>
    ingredientPreference?: boolean | GenericIngredient$ingredientPreferenceArgs<ExtArgs>
    _count?: boolean | GenericIngredientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["genericIngredient"]>

  export type GenericIngredientSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type GenericIngredientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    touch?: boolean | GenericIngredient$touchArgs<ExtArgs>
    archivedTouch?: boolean | GenericIngredient$archivedTouchArgs<ExtArgs>
    specificIngredient?: boolean | GenericIngredient$specificIngredientArgs<ExtArgs>
    ingredientPreference?: boolean | GenericIngredient$ingredientPreferenceArgs<ExtArgs>
    _count?: boolean | GenericIngredientCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $GenericIngredientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GenericIngredient"
    objects: {
      touch: Prisma.$TouchPayload<ExtArgs>[]
      archivedTouch: Prisma.$ArchivedTouchPayload<ExtArgs>[]
      specificIngredient: Prisma.$SpecificIngredientPayload<ExtArgs>[]
      ingredientPreference: Prisma.$IngredientPreferencePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
    }, ExtArgs["result"]["genericIngredient"]>
    composites: {}
  }


  type GenericIngredientGetPayload<S extends boolean | null | undefined | GenericIngredientDefaultArgs> = $Result.GetResult<Prisma.$GenericIngredientPayload, S>

  type GenericIngredientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GenericIngredientFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: GenericIngredientCountAggregateInputType | true
    }

  export interface GenericIngredientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GenericIngredient'], meta: { name: 'GenericIngredient' } }
    /**
     * Find zero or one GenericIngredient that matches the filter.
     * @param {GenericIngredientFindUniqueArgs} args - Arguments to find a GenericIngredient
     * @example
     * // Get one GenericIngredient
     * const genericIngredient = await prisma.genericIngredient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GenericIngredientFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, GenericIngredientFindUniqueArgs<ExtArgs>>
    ): Prisma__GenericIngredientClient<$Result.GetResult<Prisma.$GenericIngredientPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one GenericIngredient that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GenericIngredientFindUniqueOrThrowArgs} args - Arguments to find a GenericIngredient
     * @example
     * // Get one GenericIngredient
     * const genericIngredient = await prisma.genericIngredient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GenericIngredientFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GenericIngredientFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__GenericIngredientClient<$Result.GetResult<Prisma.$GenericIngredientPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first GenericIngredient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenericIngredientFindFirstArgs} args - Arguments to find a GenericIngredient
     * @example
     * // Get one GenericIngredient
     * const genericIngredient = await prisma.genericIngredient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GenericIngredientFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, GenericIngredientFindFirstArgs<ExtArgs>>
    ): Prisma__GenericIngredientClient<$Result.GetResult<Prisma.$GenericIngredientPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first GenericIngredient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenericIngredientFindFirstOrThrowArgs} args - Arguments to find a GenericIngredient
     * @example
     * // Get one GenericIngredient
     * const genericIngredient = await prisma.genericIngredient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GenericIngredientFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GenericIngredientFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__GenericIngredientClient<$Result.GetResult<Prisma.$GenericIngredientPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more GenericIngredients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenericIngredientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GenericIngredients
     * const genericIngredients = await prisma.genericIngredient.findMany()
     * 
     * // Get first 10 GenericIngredients
     * const genericIngredients = await prisma.genericIngredient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const genericIngredientWithIdOnly = await prisma.genericIngredient.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GenericIngredientFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GenericIngredientFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenericIngredientPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a GenericIngredient.
     * @param {GenericIngredientCreateArgs} args - Arguments to create a GenericIngredient.
     * @example
     * // Create one GenericIngredient
     * const GenericIngredient = await prisma.genericIngredient.create({
     *   data: {
     *     // ... data to create a GenericIngredient
     *   }
     * })
     * 
    **/
    create<T extends GenericIngredientCreateArgs<ExtArgs>>(
      args: SelectSubset<T, GenericIngredientCreateArgs<ExtArgs>>
    ): Prisma__GenericIngredientClient<$Result.GetResult<Prisma.$GenericIngredientPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many GenericIngredients.
     *     @param {GenericIngredientCreateManyArgs} args - Arguments to create many GenericIngredients.
     *     @example
     *     // Create many GenericIngredients
     *     const genericIngredient = await prisma.genericIngredient.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GenericIngredientCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GenericIngredientCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GenericIngredient.
     * @param {GenericIngredientDeleteArgs} args - Arguments to delete one GenericIngredient.
     * @example
     * // Delete one GenericIngredient
     * const GenericIngredient = await prisma.genericIngredient.delete({
     *   where: {
     *     // ... filter to delete one GenericIngredient
     *   }
     * })
     * 
    **/
    delete<T extends GenericIngredientDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, GenericIngredientDeleteArgs<ExtArgs>>
    ): Prisma__GenericIngredientClient<$Result.GetResult<Prisma.$GenericIngredientPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one GenericIngredient.
     * @param {GenericIngredientUpdateArgs} args - Arguments to update one GenericIngredient.
     * @example
     * // Update one GenericIngredient
     * const genericIngredient = await prisma.genericIngredient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GenericIngredientUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, GenericIngredientUpdateArgs<ExtArgs>>
    ): Prisma__GenericIngredientClient<$Result.GetResult<Prisma.$GenericIngredientPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more GenericIngredients.
     * @param {GenericIngredientDeleteManyArgs} args - Arguments to filter GenericIngredients to delete.
     * @example
     * // Delete a few GenericIngredients
     * const { count } = await prisma.genericIngredient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GenericIngredientDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GenericIngredientDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GenericIngredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenericIngredientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GenericIngredients
     * const genericIngredient = await prisma.genericIngredient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GenericIngredientUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, GenericIngredientUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GenericIngredient.
     * @param {GenericIngredientUpsertArgs} args - Arguments to update or create a GenericIngredient.
     * @example
     * // Update or create a GenericIngredient
     * const genericIngredient = await prisma.genericIngredient.upsert({
     *   create: {
     *     // ... data to create a GenericIngredient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GenericIngredient we want to update
     *   }
     * })
    **/
    upsert<T extends GenericIngredientUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, GenericIngredientUpsertArgs<ExtArgs>>
    ): Prisma__GenericIngredientClient<$Result.GetResult<Prisma.$GenericIngredientPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of GenericIngredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenericIngredientCountArgs} args - Arguments to filter GenericIngredients to count.
     * @example
     * // Count the number of GenericIngredients
     * const count = await prisma.genericIngredient.count({
     *   where: {
     *     // ... the filter for the GenericIngredients we want to count
     *   }
     * })
    **/
    count<T extends GenericIngredientCountArgs>(
      args?: Subset<T, GenericIngredientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GenericIngredientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GenericIngredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenericIngredientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GenericIngredientAggregateArgs>(args: Subset<T, GenericIngredientAggregateArgs>): Prisma.PrismaPromise<GetGenericIngredientAggregateType<T>>

    /**
     * Group by GenericIngredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenericIngredientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GenericIngredientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GenericIngredientGroupByArgs['orderBy'] }
        : { orderBy?: GenericIngredientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GenericIngredientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGenericIngredientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GenericIngredient model
   */
  readonly fields: GenericIngredientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GenericIngredient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GenericIngredientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    touch<T extends GenericIngredient$touchArgs<ExtArgs> = {}>(args?: Subset<T, GenericIngredient$touchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TouchPayload<ExtArgs>, T, 'findMany'> | Null>;

    archivedTouch<T extends GenericIngredient$archivedTouchArgs<ExtArgs> = {}>(args?: Subset<T, GenericIngredient$archivedTouchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArchivedTouchPayload<ExtArgs>, T, 'findMany'> | Null>;

    specificIngredient<T extends GenericIngredient$specificIngredientArgs<ExtArgs> = {}>(args?: Subset<T, GenericIngredient$specificIngredientArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecificIngredientPayload<ExtArgs>, T, 'findMany'> | Null>;

    ingredientPreference<T extends GenericIngredient$ingredientPreferenceArgs<ExtArgs> = {}>(args?: Subset<T, GenericIngredient$ingredientPreferenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientPreferencePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the GenericIngredient model
   */ 
  interface GenericIngredientFieldRefs {
    readonly id: FieldRef<"GenericIngredient", 'String'>
    readonly name: FieldRef<"GenericIngredient", 'String'>
    readonly description: FieldRef<"GenericIngredient", 'String'>
  }
    

  // Custom InputTypes

  /**
   * GenericIngredient findUnique
   */
  export type GenericIngredientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenericIngredient
     */
    select?: GenericIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenericIngredientInclude<ExtArgs> | null
    /**
     * Filter, which GenericIngredient to fetch.
     */
    where: GenericIngredientWhereUniqueInput
  }


  /**
   * GenericIngredient findUniqueOrThrow
   */
  export type GenericIngredientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenericIngredient
     */
    select?: GenericIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenericIngredientInclude<ExtArgs> | null
    /**
     * Filter, which GenericIngredient to fetch.
     */
    where: GenericIngredientWhereUniqueInput
  }


  /**
   * GenericIngredient findFirst
   */
  export type GenericIngredientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenericIngredient
     */
    select?: GenericIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenericIngredientInclude<ExtArgs> | null
    /**
     * Filter, which GenericIngredient to fetch.
     */
    where?: GenericIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GenericIngredients to fetch.
     */
    orderBy?: GenericIngredientOrderByWithRelationInput | GenericIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GenericIngredients.
     */
    cursor?: GenericIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GenericIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GenericIngredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GenericIngredients.
     */
    distinct?: GenericIngredientScalarFieldEnum | GenericIngredientScalarFieldEnum[]
  }


  /**
   * GenericIngredient findFirstOrThrow
   */
  export type GenericIngredientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenericIngredient
     */
    select?: GenericIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenericIngredientInclude<ExtArgs> | null
    /**
     * Filter, which GenericIngredient to fetch.
     */
    where?: GenericIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GenericIngredients to fetch.
     */
    orderBy?: GenericIngredientOrderByWithRelationInput | GenericIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GenericIngredients.
     */
    cursor?: GenericIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GenericIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GenericIngredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GenericIngredients.
     */
    distinct?: GenericIngredientScalarFieldEnum | GenericIngredientScalarFieldEnum[]
  }


  /**
   * GenericIngredient findMany
   */
  export type GenericIngredientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenericIngredient
     */
    select?: GenericIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenericIngredientInclude<ExtArgs> | null
    /**
     * Filter, which GenericIngredients to fetch.
     */
    where?: GenericIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GenericIngredients to fetch.
     */
    orderBy?: GenericIngredientOrderByWithRelationInput | GenericIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GenericIngredients.
     */
    cursor?: GenericIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GenericIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GenericIngredients.
     */
    skip?: number
    distinct?: GenericIngredientScalarFieldEnum | GenericIngredientScalarFieldEnum[]
  }


  /**
   * GenericIngredient create
   */
  export type GenericIngredientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenericIngredient
     */
    select?: GenericIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenericIngredientInclude<ExtArgs> | null
    /**
     * The data needed to create a GenericIngredient.
     */
    data: XOR<GenericIngredientCreateInput, GenericIngredientUncheckedCreateInput>
  }


  /**
   * GenericIngredient createMany
   */
  export type GenericIngredientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GenericIngredients.
     */
    data: GenericIngredientCreateManyInput | GenericIngredientCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * GenericIngredient update
   */
  export type GenericIngredientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenericIngredient
     */
    select?: GenericIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenericIngredientInclude<ExtArgs> | null
    /**
     * The data needed to update a GenericIngredient.
     */
    data: XOR<GenericIngredientUpdateInput, GenericIngredientUncheckedUpdateInput>
    /**
     * Choose, which GenericIngredient to update.
     */
    where: GenericIngredientWhereUniqueInput
  }


  /**
   * GenericIngredient updateMany
   */
  export type GenericIngredientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GenericIngredients.
     */
    data: XOR<GenericIngredientUpdateManyMutationInput, GenericIngredientUncheckedUpdateManyInput>
    /**
     * Filter which GenericIngredients to update
     */
    where?: GenericIngredientWhereInput
  }


  /**
   * GenericIngredient upsert
   */
  export type GenericIngredientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenericIngredient
     */
    select?: GenericIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenericIngredientInclude<ExtArgs> | null
    /**
     * The filter to search for the GenericIngredient to update in case it exists.
     */
    where: GenericIngredientWhereUniqueInput
    /**
     * In case the GenericIngredient found by the `where` argument doesn't exist, create a new GenericIngredient with this data.
     */
    create: XOR<GenericIngredientCreateInput, GenericIngredientUncheckedCreateInput>
    /**
     * In case the GenericIngredient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GenericIngredientUpdateInput, GenericIngredientUncheckedUpdateInput>
  }


  /**
   * GenericIngredient delete
   */
  export type GenericIngredientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenericIngredient
     */
    select?: GenericIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenericIngredientInclude<ExtArgs> | null
    /**
     * Filter which GenericIngredient to delete.
     */
    where: GenericIngredientWhereUniqueInput
  }


  /**
   * GenericIngredient deleteMany
   */
  export type GenericIngredientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GenericIngredients to delete
     */
    where?: GenericIngredientWhereInput
  }


  /**
   * GenericIngredient.touch
   */
  export type GenericIngredient$touchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Touch
     */
    select?: TouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TouchInclude<ExtArgs> | null
    where?: TouchWhereInput
    orderBy?: TouchOrderByWithRelationInput | TouchOrderByWithRelationInput[]
    cursor?: TouchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TouchScalarFieldEnum | TouchScalarFieldEnum[]
  }


  /**
   * GenericIngredient.archivedTouch
   */
  export type GenericIngredient$archivedTouchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedTouch
     */
    select?: ArchivedTouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedTouchInclude<ExtArgs> | null
    where?: ArchivedTouchWhereInput
    orderBy?: ArchivedTouchOrderByWithRelationInput | ArchivedTouchOrderByWithRelationInput[]
    cursor?: ArchivedTouchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArchivedTouchScalarFieldEnum | ArchivedTouchScalarFieldEnum[]
  }


  /**
   * GenericIngredient.specificIngredient
   */
  export type GenericIngredient$specificIngredientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificIngredient
     */
    select?: SpecificIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecificIngredientInclude<ExtArgs> | null
    where?: SpecificIngredientWhereInput
    orderBy?: SpecificIngredientOrderByWithRelationInput | SpecificIngredientOrderByWithRelationInput[]
    cursor?: SpecificIngredientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpecificIngredientScalarFieldEnum | SpecificIngredientScalarFieldEnum[]
  }


  /**
   * GenericIngredient.ingredientPreference
   */
  export type GenericIngredient$ingredientPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientPreference
     */
    select?: IngredientPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientPreferenceInclude<ExtArgs> | null
    where?: IngredientPreferenceWhereInput
    orderBy?: IngredientPreferenceOrderByWithRelationInput | IngredientPreferenceOrderByWithRelationInput[]
    cursor?: IngredientPreferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IngredientPreferenceScalarFieldEnum | IngredientPreferenceScalarFieldEnum[]
  }


  /**
   * GenericIngredient without action
   */
  export type GenericIngredientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenericIngredient
     */
    select?: GenericIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenericIngredientInclude<ExtArgs> | null
  }



  /**
   * Model SpecificIngredient
   */

  export type AggregateSpecificIngredient = {
    _count: SpecificIngredientCountAggregateOutputType | null
    _avg: SpecificIngredientAvgAggregateOutputType | null
    _sum: SpecificIngredientSumAggregateOutputType | null
    _min: SpecificIngredientMinAggregateOutputType | null
    _max: SpecificIngredientMaxAggregateOutputType | null
  }

  export type SpecificIngredientAvgAggregateOutputType = {
    price: number | null
    amount: number | null
  }

  export type SpecificIngredientSumAggregateOutputType = {
    price: number | null
    amount: number | null
  }

  export type SpecificIngredientMinAggregateOutputType = {
    id: string | null
    dateCreated: Date | null
    createdById: string | null
    genericIngredientId: string | null
    name: string | null
    description: string | null
    price: number | null
    amount: number | null
    unit: string | null
    source: string | null
  }

  export type SpecificIngredientMaxAggregateOutputType = {
    id: string | null
    dateCreated: Date | null
    createdById: string | null
    genericIngredientId: string | null
    name: string | null
    description: string | null
    price: number | null
    amount: number | null
    unit: string | null
    source: string | null
  }

  export type SpecificIngredientCountAggregateOutputType = {
    id: number
    dateCreated: number
    createdById: number
    genericIngredientId: number
    name: number
    description: number
    price: number
    amount: number
    unit: number
    source: number
    _all: number
  }


  export type SpecificIngredientAvgAggregateInputType = {
    price?: true
    amount?: true
  }

  export type SpecificIngredientSumAggregateInputType = {
    price?: true
    amount?: true
  }

  export type SpecificIngredientMinAggregateInputType = {
    id?: true
    dateCreated?: true
    createdById?: true
    genericIngredientId?: true
    name?: true
    description?: true
    price?: true
    amount?: true
    unit?: true
    source?: true
  }

  export type SpecificIngredientMaxAggregateInputType = {
    id?: true
    dateCreated?: true
    createdById?: true
    genericIngredientId?: true
    name?: true
    description?: true
    price?: true
    amount?: true
    unit?: true
    source?: true
  }

  export type SpecificIngredientCountAggregateInputType = {
    id?: true
    dateCreated?: true
    createdById?: true
    genericIngredientId?: true
    name?: true
    description?: true
    price?: true
    amount?: true
    unit?: true
    source?: true
    _all?: true
  }

  export type SpecificIngredientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpecificIngredient to aggregate.
     */
    where?: SpecificIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecificIngredients to fetch.
     */
    orderBy?: SpecificIngredientOrderByWithRelationInput | SpecificIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpecificIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecificIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecificIngredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpecificIngredients
    **/
    _count?: true | SpecificIngredientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpecificIngredientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpecificIngredientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpecificIngredientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpecificIngredientMaxAggregateInputType
  }

  export type GetSpecificIngredientAggregateType<T extends SpecificIngredientAggregateArgs> = {
        [P in keyof T & keyof AggregateSpecificIngredient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpecificIngredient[P]>
      : GetScalarType<T[P], AggregateSpecificIngredient[P]>
  }




  export type SpecificIngredientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecificIngredientWhereInput
    orderBy?: SpecificIngredientOrderByWithAggregationInput | SpecificIngredientOrderByWithAggregationInput[]
    by: SpecificIngredientScalarFieldEnum[] | SpecificIngredientScalarFieldEnum
    having?: SpecificIngredientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpecificIngredientCountAggregateInputType | true
    _avg?: SpecificIngredientAvgAggregateInputType
    _sum?: SpecificIngredientSumAggregateInputType
    _min?: SpecificIngredientMinAggregateInputType
    _max?: SpecificIngredientMaxAggregateInputType
  }

  export type SpecificIngredientGroupByOutputType = {
    id: string
    dateCreated: Date
    createdById: string | null
    genericIngredientId: string
    name: string
    description: string
    price: number | null
    amount: number | null
    unit: string | null
    source: string | null
    _count: SpecificIngredientCountAggregateOutputType | null
    _avg: SpecificIngredientAvgAggregateOutputType | null
    _sum: SpecificIngredientSumAggregateOutputType | null
    _min: SpecificIngredientMinAggregateOutputType | null
    _max: SpecificIngredientMaxAggregateOutputType | null
  }

  type GetSpecificIngredientGroupByPayload<T extends SpecificIngredientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpecificIngredientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpecificIngredientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpecificIngredientGroupByOutputType[P]>
            : GetScalarType<T[P], SpecificIngredientGroupByOutputType[P]>
        }
      >
    >


  export type SpecificIngredientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dateCreated?: boolean
    createdById?: boolean
    genericIngredientId?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    amount?: boolean
    unit?: boolean
    source?: boolean
    createdBy?: boolean | SpecificIngredient$createdByArgs<ExtArgs>
    genericIngredient?: boolean | GenericIngredientDefaultArgs<ExtArgs>
    touch?: boolean | SpecificIngredient$touchArgs<ExtArgs>
    archivedTouch?: boolean | SpecificIngredient$archivedTouchArgs<ExtArgs>
    ingredientStorage?: boolean | SpecificIngredient$ingredientStorageArgs<ExtArgs>
    ingredientUser?: boolean | SpecificIngredient$ingredientUserArgs<ExtArgs>
    ingredientPreference?: boolean | SpecificIngredient$ingredientPreferenceArgs<ExtArgs>
    _count?: boolean | SpecificIngredientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["specificIngredient"]>

  export type SpecificIngredientSelectScalar = {
    id?: boolean
    dateCreated?: boolean
    createdById?: boolean
    genericIngredientId?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    amount?: boolean
    unit?: boolean
    source?: boolean
  }

  export type SpecificIngredientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | SpecificIngredient$createdByArgs<ExtArgs>
    genericIngredient?: boolean | GenericIngredientDefaultArgs<ExtArgs>
    touch?: boolean | SpecificIngredient$touchArgs<ExtArgs>
    archivedTouch?: boolean | SpecificIngredient$archivedTouchArgs<ExtArgs>
    ingredientStorage?: boolean | SpecificIngredient$ingredientStorageArgs<ExtArgs>
    ingredientUser?: boolean | SpecificIngredient$ingredientUserArgs<ExtArgs>
    ingredientPreference?: boolean | SpecificIngredient$ingredientPreferenceArgs<ExtArgs>
    _count?: boolean | SpecificIngredientCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SpecificIngredientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpecificIngredient"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      genericIngredient: Prisma.$GenericIngredientPayload<ExtArgs>
      touch: Prisma.$TouchPayload<ExtArgs>[]
      archivedTouch: Prisma.$ArchivedTouchPayload<ExtArgs>[]
      ingredientStorage: Prisma.$IngredientStoragePayload<ExtArgs>[]
      ingredientUser: Prisma.$IngredientUserPayload<ExtArgs>[]
      ingredientPreference: Prisma.$IngredientPreferencePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dateCreated: Date
      createdById: string | null
      genericIngredientId: string
      name: string
      description: string
      price: number | null
      amount: number | null
      unit: string | null
      source: string | null
    }, ExtArgs["result"]["specificIngredient"]>
    composites: {}
  }


  type SpecificIngredientGetPayload<S extends boolean | null | undefined | SpecificIngredientDefaultArgs> = $Result.GetResult<Prisma.$SpecificIngredientPayload, S>

  type SpecificIngredientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpecificIngredientFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: SpecificIngredientCountAggregateInputType | true
    }

  export interface SpecificIngredientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpecificIngredient'], meta: { name: 'SpecificIngredient' } }
    /**
     * Find zero or one SpecificIngredient that matches the filter.
     * @param {SpecificIngredientFindUniqueArgs} args - Arguments to find a SpecificIngredient
     * @example
     * // Get one SpecificIngredient
     * const specificIngredient = await prisma.specificIngredient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SpecificIngredientFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SpecificIngredientFindUniqueArgs<ExtArgs>>
    ): Prisma__SpecificIngredientClient<$Result.GetResult<Prisma.$SpecificIngredientPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SpecificIngredient that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SpecificIngredientFindUniqueOrThrowArgs} args - Arguments to find a SpecificIngredient
     * @example
     * // Get one SpecificIngredient
     * const specificIngredient = await prisma.specificIngredient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SpecificIngredientFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SpecificIngredientFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SpecificIngredientClient<$Result.GetResult<Prisma.$SpecificIngredientPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SpecificIngredient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecificIngredientFindFirstArgs} args - Arguments to find a SpecificIngredient
     * @example
     * // Get one SpecificIngredient
     * const specificIngredient = await prisma.specificIngredient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SpecificIngredientFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SpecificIngredientFindFirstArgs<ExtArgs>>
    ): Prisma__SpecificIngredientClient<$Result.GetResult<Prisma.$SpecificIngredientPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SpecificIngredient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecificIngredientFindFirstOrThrowArgs} args - Arguments to find a SpecificIngredient
     * @example
     * // Get one SpecificIngredient
     * const specificIngredient = await prisma.specificIngredient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SpecificIngredientFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SpecificIngredientFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SpecificIngredientClient<$Result.GetResult<Prisma.$SpecificIngredientPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SpecificIngredients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecificIngredientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpecificIngredients
     * const specificIngredients = await prisma.specificIngredient.findMany()
     * 
     * // Get first 10 SpecificIngredients
     * const specificIngredients = await prisma.specificIngredient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const specificIngredientWithIdOnly = await prisma.specificIngredient.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SpecificIngredientFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpecificIngredientFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecificIngredientPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SpecificIngredient.
     * @param {SpecificIngredientCreateArgs} args - Arguments to create a SpecificIngredient.
     * @example
     * // Create one SpecificIngredient
     * const SpecificIngredient = await prisma.specificIngredient.create({
     *   data: {
     *     // ... data to create a SpecificIngredient
     *   }
     * })
     * 
    **/
    create<T extends SpecificIngredientCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SpecificIngredientCreateArgs<ExtArgs>>
    ): Prisma__SpecificIngredientClient<$Result.GetResult<Prisma.$SpecificIngredientPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SpecificIngredients.
     *     @param {SpecificIngredientCreateManyArgs} args - Arguments to create many SpecificIngredients.
     *     @example
     *     // Create many SpecificIngredients
     *     const specificIngredient = await prisma.specificIngredient.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SpecificIngredientCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpecificIngredientCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SpecificIngredient.
     * @param {SpecificIngredientDeleteArgs} args - Arguments to delete one SpecificIngredient.
     * @example
     * // Delete one SpecificIngredient
     * const SpecificIngredient = await prisma.specificIngredient.delete({
     *   where: {
     *     // ... filter to delete one SpecificIngredient
     *   }
     * })
     * 
    **/
    delete<T extends SpecificIngredientDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SpecificIngredientDeleteArgs<ExtArgs>>
    ): Prisma__SpecificIngredientClient<$Result.GetResult<Prisma.$SpecificIngredientPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SpecificIngredient.
     * @param {SpecificIngredientUpdateArgs} args - Arguments to update one SpecificIngredient.
     * @example
     * // Update one SpecificIngredient
     * const specificIngredient = await prisma.specificIngredient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SpecificIngredientUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SpecificIngredientUpdateArgs<ExtArgs>>
    ): Prisma__SpecificIngredientClient<$Result.GetResult<Prisma.$SpecificIngredientPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SpecificIngredients.
     * @param {SpecificIngredientDeleteManyArgs} args - Arguments to filter SpecificIngredients to delete.
     * @example
     * // Delete a few SpecificIngredients
     * const { count } = await prisma.specificIngredient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SpecificIngredientDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpecificIngredientDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpecificIngredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecificIngredientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpecificIngredients
     * const specificIngredient = await prisma.specificIngredient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SpecificIngredientUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SpecificIngredientUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpecificIngredient.
     * @param {SpecificIngredientUpsertArgs} args - Arguments to update or create a SpecificIngredient.
     * @example
     * // Update or create a SpecificIngredient
     * const specificIngredient = await prisma.specificIngredient.upsert({
     *   create: {
     *     // ... data to create a SpecificIngredient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpecificIngredient we want to update
     *   }
     * })
    **/
    upsert<T extends SpecificIngredientUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SpecificIngredientUpsertArgs<ExtArgs>>
    ): Prisma__SpecificIngredientClient<$Result.GetResult<Prisma.$SpecificIngredientPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SpecificIngredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecificIngredientCountArgs} args - Arguments to filter SpecificIngredients to count.
     * @example
     * // Count the number of SpecificIngredients
     * const count = await prisma.specificIngredient.count({
     *   where: {
     *     // ... the filter for the SpecificIngredients we want to count
     *   }
     * })
    **/
    count<T extends SpecificIngredientCountArgs>(
      args?: Subset<T, SpecificIngredientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpecificIngredientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpecificIngredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecificIngredientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpecificIngredientAggregateArgs>(args: Subset<T, SpecificIngredientAggregateArgs>): Prisma.PrismaPromise<GetSpecificIngredientAggregateType<T>>

    /**
     * Group by SpecificIngredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecificIngredientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpecificIngredientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpecificIngredientGroupByArgs['orderBy'] }
        : { orderBy?: SpecificIngredientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpecificIngredientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpecificIngredientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpecificIngredient model
   */
  readonly fields: SpecificIngredientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpecificIngredient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpecificIngredientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    createdBy<T extends SpecificIngredient$createdByArgs<ExtArgs> = {}>(args?: Subset<T, SpecificIngredient$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    genericIngredient<T extends GenericIngredientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GenericIngredientDefaultArgs<ExtArgs>>): Prisma__GenericIngredientClient<$Result.GetResult<Prisma.$GenericIngredientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    touch<T extends SpecificIngredient$touchArgs<ExtArgs> = {}>(args?: Subset<T, SpecificIngredient$touchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TouchPayload<ExtArgs>, T, 'findMany'> | Null>;

    archivedTouch<T extends SpecificIngredient$archivedTouchArgs<ExtArgs> = {}>(args?: Subset<T, SpecificIngredient$archivedTouchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArchivedTouchPayload<ExtArgs>, T, 'findMany'> | Null>;

    ingredientStorage<T extends SpecificIngredient$ingredientStorageArgs<ExtArgs> = {}>(args?: Subset<T, SpecificIngredient$ingredientStorageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientStoragePayload<ExtArgs>, T, 'findMany'> | Null>;

    ingredientUser<T extends SpecificIngredient$ingredientUserArgs<ExtArgs> = {}>(args?: Subset<T, SpecificIngredient$ingredientUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    ingredientPreference<T extends SpecificIngredient$ingredientPreferenceArgs<ExtArgs> = {}>(args?: Subset<T, SpecificIngredient$ingredientPreferenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientPreferencePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SpecificIngredient model
   */ 
  interface SpecificIngredientFieldRefs {
    readonly id: FieldRef<"SpecificIngredient", 'String'>
    readonly dateCreated: FieldRef<"SpecificIngredient", 'DateTime'>
    readonly createdById: FieldRef<"SpecificIngredient", 'String'>
    readonly genericIngredientId: FieldRef<"SpecificIngredient", 'String'>
    readonly name: FieldRef<"SpecificIngredient", 'String'>
    readonly description: FieldRef<"SpecificIngredient", 'String'>
    readonly price: FieldRef<"SpecificIngredient", 'Float'>
    readonly amount: FieldRef<"SpecificIngredient", 'Float'>
    readonly unit: FieldRef<"SpecificIngredient", 'String'>
    readonly source: FieldRef<"SpecificIngredient", 'String'>
  }
    

  // Custom InputTypes

  /**
   * SpecificIngredient findUnique
   */
  export type SpecificIngredientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificIngredient
     */
    select?: SpecificIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecificIngredientInclude<ExtArgs> | null
    /**
     * Filter, which SpecificIngredient to fetch.
     */
    where: SpecificIngredientWhereUniqueInput
  }


  /**
   * SpecificIngredient findUniqueOrThrow
   */
  export type SpecificIngredientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificIngredient
     */
    select?: SpecificIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecificIngredientInclude<ExtArgs> | null
    /**
     * Filter, which SpecificIngredient to fetch.
     */
    where: SpecificIngredientWhereUniqueInput
  }


  /**
   * SpecificIngredient findFirst
   */
  export type SpecificIngredientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificIngredient
     */
    select?: SpecificIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecificIngredientInclude<ExtArgs> | null
    /**
     * Filter, which SpecificIngredient to fetch.
     */
    where?: SpecificIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecificIngredients to fetch.
     */
    orderBy?: SpecificIngredientOrderByWithRelationInput | SpecificIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpecificIngredients.
     */
    cursor?: SpecificIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecificIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecificIngredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpecificIngredients.
     */
    distinct?: SpecificIngredientScalarFieldEnum | SpecificIngredientScalarFieldEnum[]
  }


  /**
   * SpecificIngredient findFirstOrThrow
   */
  export type SpecificIngredientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificIngredient
     */
    select?: SpecificIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecificIngredientInclude<ExtArgs> | null
    /**
     * Filter, which SpecificIngredient to fetch.
     */
    where?: SpecificIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecificIngredients to fetch.
     */
    orderBy?: SpecificIngredientOrderByWithRelationInput | SpecificIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpecificIngredients.
     */
    cursor?: SpecificIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecificIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecificIngredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpecificIngredients.
     */
    distinct?: SpecificIngredientScalarFieldEnum | SpecificIngredientScalarFieldEnum[]
  }


  /**
   * SpecificIngredient findMany
   */
  export type SpecificIngredientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificIngredient
     */
    select?: SpecificIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecificIngredientInclude<ExtArgs> | null
    /**
     * Filter, which SpecificIngredients to fetch.
     */
    where?: SpecificIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecificIngredients to fetch.
     */
    orderBy?: SpecificIngredientOrderByWithRelationInput | SpecificIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpecificIngredients.
     */
    cursor?: SpecificIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecificIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecificIngredients.
     */
    skip?: number
    distinct?: SpecificIngredientScalarFieldEnum | SpecificIngredientScalarFieldEnum[]
  }


  /**
   * SpecificIngredient create
   */
  export type SpecificIngredientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificIngredient
     */
    select?: SpecificIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecificIngredientInclude<ExtArgs> | null
    /**
     * The data needed to create a SpecificIngredient.
     */
    data: XOR<SpecificIngredientCreateInput, SpecificIngredientUncheckedCreateInput>
  }


  /**
   * SpecificIngredient createMany
   */
  export type SpecificIngredientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpecificIngredients.
     */
    data: SpecificIngredientCreateManyInput | SpecificIngredientCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SpecificIngredient update
   */
  export type SpecificIngredientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificIngredient
     */
    select?: SpecificIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecificIngredientInclude<ExtArgs> | null
    /**
     * The data needed to update a SpecificIngredient.
     */
    data: XOR<SpecificIngredientUpdateInput, SpecificIngredientUncheckedUpdateInput>
    /**
     * Choose, which SpecificIngredient to update.
     */
    where: SpecificIngredientWhereUniqueInput
  }


  /**
   * SpecificIngredient updateMany
   */
  export type SpecificIngredientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpecificIngredients.
     */
    data: XOR<SpecificIngredientUpdateManyMutationInput, SpecificIngredientUncheckedUpdateManyInput>
    /**
     * Filter which SpecificIngredients to update
     */
    where?: SpecificIngredientWhereInput
  }


  /**
   * SpecificIngredient upsert
   */
  export type SpecificIngredientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificIngredient
     */
    select?: SpecificIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecificIngredientInclude<ExtArgs> | null
    /**
     * The filter to search for the SpecificIngredient to update in case it exists.
     */
    where: SpecificIngredientWhereUniqueInput
    /**
     * In case the SpecificIngredient found by the `where` argument doesn't exist, create a new SpecificIngredient with this data.
     */
    create: XOR<SpecificIngredientCreateInput, SpecificIngredientUncheckedCreateInput>
    /**
     * In case the SpecificIngredient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpecificIngredientUpdateInput, SpecificIngredientUncheckedUpdateInput>
  }


  /**
   * SpecificIngredient delete
   */
  export type SpecificIngredientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificIngredient
     */
    select?: SpecificIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecificIngredientInclude<ExtArgs> | null
    /**
     * Filter which SpecificIngredient to delete.
     */
    where: SpecificIngredientWhereUniqueInput
  }


  /**
   * SpecificIngredient deleteMany
   */
  export type SpecificIngredientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpecificIngredients to delete
     */
    where?: SpecificIngredientWhereInput
  }


  /**
   * SpecificIngredient.createdBy
   */
  export type SpecificIngredient$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * SpecificIngredient.touch
   */
  export type SpecificIngredient$touchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Touch
     */
    select?: TouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TouchInclude<ExtArgs> | null
    where?: TouchWhereInput
    orderBy?: TouchOrderByWithRelationInput | TouchOrderByWithRelationInput[]
    cursor?: TouchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TouchScalarFieldEnum | TouchScalarFieldEnum[]
  }


  /**
   * SpecificIngredient.archivedTouch
   */
  export type SpecificIngredient$archivedTouchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedTouch
     */
    select?: ArchivedTouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedTouchInclude<ExtArgs> | null
    where?: ArchivedTouchWhereInput
    orderBy?: ArchivedTouchOrderByWithRelationInput | ArchivedTouchOrderByWithRelationInput[]
    cursor?: ArchivedTouchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArchivedTouchScalarFieldEnum | ArchivedTouchScalarFieldEnum[]
  }


  /**
   * SpecificIngredient.ingredientStorage
   */
  export type SpecificIngredient$ingredientStorageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientStorage
     */
    select?: IngredientStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientStorageInclude<ExtArgs> | null
    where?: IngredientStorageWhereInput
    orderBy?: IngredientStorageOrderByWithRelationInput | IngredientStorageOrderByWithRelationInput[]
    cursor?: IngredientStorageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IngredientStorageScalarFieldEnum | IngredientStorageScalarFieldEnum[]
  }


  /**
   * SpecificIngredient.ingredientUser
   */
  export type SpecificIngredient$ingredientUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientUser
     */
    select?: IngredientUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientUserInclude<ExtArgs> | null
    where?: IngredientUserWhereInput
    orderBy?: IngredientUserOrderByWithRelationInput | IngredientUserOrderByWithRelationInput[]
    cursor?: IngredientUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IngredientUserScalarFieldEnum | IngredientUserScalarFieldEnum[]
  }


  /**
   * SpecificIngredient.ingredientPreference
   */
  export type SpecificIngredient$ingredientPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientPreference
     */
    select?: IngredientPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientPreferenceInclude<ExtArgs> | null
    where?: IngredientPreferenceWhereInput
    orderBy?: IngredientPreferenceOrderByWithRelationInput | IngredientPreferenceOrderByWithRelationInput[]
    cursor?: IngredientPreferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IngredientPreferenceScalarFieldEnum | IngredientPreferenceScalarFieldEnum[]
  }


  /**
   * SpecificIngredient without action
   */
  export type SpecificIngredientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecificIngredient
     */
    select?: SpecificIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecificIngredientInclude<ExtArgs> | null
  }



  /**
   * Model IngredientUser
   */

  export type AggregateIngredientUser = {
    _count: IngredientUserCountAggregateOutputType | null
    _min: IngredientUserMinAggregateOutputType | null
    _max: IngredientUserMaxAggregateOutputType | null
  }

  export type IngredientUserMinAggregateOutputType = {
    ingredientId: string | null
    userId: string | null
    permission: string | null
  }

  export type IngredientUserMaxAggregateOutputType = {
    ingredientId: string | null
    userId: string | null
    permission: string | null
  }

  export type IngredientUserCountAggregateOutputType = {
    ingredientId: number
    userId: number
    permission: number
    _all: number
  }


  export type IngredientUserMinAggregateInputType = {
    ingredientId?: true
    userId?: true
    permission?: true
  }

  export type IngredientUserMaxAggregateInputType = {
    ingredientId?: true
    userId?: true
    permission?: true
  }

  export type IngredientUserCountAggregateInputType = {
    ingredientId?: true
    userId?: true
    permission?: true
    _all?: true
  }

  export type IngredientUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IngredientUser to aggregate.
     */
    where?: IngredientUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientUsers to fetch.
     */
    orderBy?: IngredientUserOrderByWithRelationInput | IngredientUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IngredientUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IngredientUsers
    **/
    _count?: true | IngredientUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IngredientUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IngredientUserMaxAggregateInputType
  }

  export type GetIngredientUserAggregateType<T extends IngredientUserAggregateArgs> = {
        [P in keyof T & keyof AggregateIngredientUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIngredientUser[P]>
      : GetScalarType<T[P], AggregateIngredientUser[P]>
  }




  export type IngredientUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngredientUserWhereInput
    orderBy?: IngredientUserOrderByWithAggregationInput | IngredientUserOrderByWithAggregationInput[]
    by: IngredientUserScalarFieldEnum[] | IngredientUserScalarFieldEnum
    having?: IngredientUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IngredientUserCountAggregateInputType | true
    _min?: IngredientUserMinAggregateInputType
    _max?: IngredientUserMaxAggregateInputType
  }

  export type IngredientUserGroupByOutputType = {
    ingredientId: string
    userId: string
    permission: string
    _count: IngredientUserCountAggregateOutputType | null
    _min: IngredientUserMinAggregateOutputType | null
    _max: IngredientUserMaxAggregateOutputType | null
  }

  type GetIngredientUserGroupByPayload<T extends IngredientUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IngredientUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IngredientUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IngredientUserGroupByOutputType[P]>
            : GetScalarType<T[P], IngredientUserGroupByOutputType[P]>
        }
      >
    >


  export type IngredientUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ingredientId?: boolean
    userId?: boolean
    permission?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    ingredient?: boolean | SpecificIngredientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ingredientUser"]>

  export type IngredientUserSelectScalar = {
    ingredientId?: boolean
    userId?: boolean
    permission?: boolean
  }

  export type IngredientUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    ingredient?: boolean | SpecificIngredientDefaultArgs<ExtArgs>
  }


  export type $IngredientUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IngredientUser"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      ingredient: Prisma.$SpecificIngredientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ingredientId: string
      userId: string
      permission: string
    }, ExtArgs["result"]["ingredientUser"]>
    composites: {}
  }


  type IngredientUserGetPayload<S extends boolean | null | undefined | IngredientUserDefaultArgs> = $Result.GetResult<Prisma.$IngredientUserPayload, S>

  type IngredientUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IngredientUserFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: IngredientUserCountAggregateInputType | true
    }

  export interface IngredientUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IngredientUser'], meta: { name: 'IngredientUser' } }
    /**
     * Find zero or one IngredientUser that matches the filter.
     * @param {IngredientUserFindUniqueArgs} args - Arguments to find a IngredientUser
     * @example
     * // Get one IngredientUser
     * const ingredientUser = await prisma.ingredientUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IngredientUserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientUserFindUniqueArgs<ExtArgs>>
    ): Prisma__IngredientUserClient<$Result.GetResult<Prisma.$IngredientUserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one IngredientUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {IngredientUserFindUniqueOrThrowArgs} args - Arguments to find a IngredientUser
     * @example
     * // Get one IngredientUser
     * const ingredientUser = await prisma.ingredientUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends IngredientUserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientUserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__IngredientUserClient<$Result.GetResult<Prisma.$IngredientUserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first IngredientUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientUserFindFirstArgs} args - Arguments to find a IngredientUser
     * @example
     * // Get one IngredientUser
     * const ingredientUser = await prisma.ingredientUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IngredientUserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientUserFindFirstArgs<ExtArgs>>
    ): Prisma__IngredientUserClient<$Result.GetResult<Prisma.$IngredientUserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first IngredientUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientUserFindFirstOrThrowArgs} args - Arguments to find a IngredientUser
     * @example
     * // Get one IngredientUser
     * const ingredientUser = await prisma.ingredientUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends IngredientUserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientUserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__IngredientUserClient<$Result.GetResult<Prisma.$IngredientUserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more IngredientUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IngredientUsers
     * const ingredientUsers = await prisma.ingredientUser.findMany()
     * 
     * // Get first 10 IngredientUsers
     * const ingredientUsers = await prisma.ingredientUser.findMany({ take: 10 })
     * 
     * // Only select the `ingredientId`
     * const ingredientUserWithIngredientIdOnly = await prisma.ingredientUser.findMany({ select: { ingredientId: true } })
     * 
    **/
    findMany<T extends IngredientUserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientUserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientUserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a IngredientUser.
     * @param {IngredientUserCreateArgs} args - Arguments to create a IngredientUser.
     * @example
     * // Create one IngredientUser
     * const IngredientUser = await prisma.ingredientUser.create({
     *   data: {
     *     // ... data to create a IngredientUser
     *   }
     * })
     * 
    **/
    create<T extends IngredientUserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientUserCreateArgs<ExtArgs>>
    ): Prisma__IngredientUserClient<$Result.GetResult<Prisma.$IngredientUserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many IngredientUsers.
     *     @param {IngredientUserCreateManyArgs} args - Arguments to create many IngredientUsers.
     *     @example
     *     // Create many IngredientUsers
     *     const ingredientUser = await prisma.ingredientUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IngredientUserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientUserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a IngredientUser.
     * @param {IngredientUserDeleteArgs} args - Arguments to delete one IngredientUser.
     * @example
     * // Delete one IngredientUser
     * const IngredientUser = await prisma.ingredientUser.delete({
     *   where: {
     *     // ... filter to delete one IngredientUser
     *   }
     * })
     * 
    **/
    delete<T extends IngredientUserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientUserDeleteArgs<ExtArgs>>
    ): Prisma__IngredientUserClient<$Result.GetResult<Prisma.$IngredientUserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one IngredientUser.
     * @param {IngredientUserUpdateArgs} args - Arguments to update one IngredientUser.
     * @example
     * // Update one IngredientUser
     * const ingredientUser = await prisma.ingredientUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IngredientUserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientUserUpdateArgs<ExtArgs>>
    ): Prisma__IngredientUserClient<$Result.GetResult<Prisma.$IngredientUserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more IngredientUsers.
     * @param {IngredientUserDeleteManyArgs} args - Arguments to filter IngredientUsers to delete.
     * @example
     * // Delete a few IngredientUsers
     * const { count } = await prisma.ingredientUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IngredientUserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientUserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IngredientUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IngredientUsers
     * const ingredientUser = await prisma.ingredientUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IngredientUserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientUserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IngredientUser.
     * @param {IngredientUserUpsertArgs} args - Arguments to update or create a IngredientUser.
     * @example
     * // Update or create a IngredientUser
     * const ingredientUser = await prisma.ingredientUser.upsert({
     *   create: {
     *     // ... data to create a IngredientUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IngredientUser we want to update
     *   }
     * })
    **/
    upsert<T extends IngredientUserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientUserUpsertArgs<ExtArgs>>
    ): Prisma__IngredientUserClient<$Result.GetResult<Prisma.$IngredientUserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of IngredientUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientUserCountArgs} args - Arguments to filter IngredientUsers to count.
     * @example
     * // Count the number of IngredientUsers
     * const count = await prisma.ingredientUser.count({
     *   where: {
     *     // ... the filter for the IngredientUsers we want to count
     *   }
     * })
    **/
    count<T extends IngredientUserCountArgs>(
      args?: Subset<T, IngredientUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IngredientUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IngredientUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IngredientUserAggregateArgs>(args: Subset<T, IngredientUserAggregateArgs>): Prisma.PrismaPromise<GetIngredientUserAggregateType<T>>

    /**
     * Group by IngredientUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IngredientUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IngredientUserGroupByArgs['orderBy'] }
        : { orderBy?: IngredientUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IngredientUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIngredientUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IngredientUser model
   */
  readonly fields: IngredientUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IngredientUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IngredientUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    ingredient<T extends SpecificIngredientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpecificIngredientDefaultArgs<ExtArgs>>): Prisma__SpecificIngredientClient<$Result.GetResult<Prisma.$SpecificIngredientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the IngredientUser model
   */ 
  interface IngredientUserFieldRefs {
    readonly ingredientId: FieldRef<"IngredientUser", 'String'>
    readonly userId: FieldRef<"IngredientUser", 'String'>
    readonly permission: FieldRef<"IngredientUser", 'String'>
  }
    

  // Custom InputTypes

  /**
   * IngredientUser findUnique
   */
  export type IngredientUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientUser
     */
    select?: IngredientUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientUserInclude<ExtArgs> | null
    /**
     * Filter, which IngredientUser to fetch.
     */
    where: IngredientUserWhereUniqueInput
  }


  /**
   * IngredientUser findUniqueOrThrow
   */
  export type IngredientUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientUser
     */
    select?: IngredientUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientUserInclude<ExtArgs> | null
    /**
     * Filter, which IngredientUser to fetch.
     */
    where: IngredientUserWhereUniqueInput
  }


  /**
   * IngredientUser findFirst
   */
  export type IngredientUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientUser
     */
    select?: IngredientUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientUserInclude<ExtArgs> | null
    /**
     * Filter, which IngredientUser to fetch.
     */
    where?: IngredientUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientUsers to fetch.
     */
    orderBy?: IngredientUserOrderByWithRelationInput | IngredientUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IngredientUsers.
     */
    cursor?: IngredientUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IngredientUsers.
     */
    distinct?: IngredientUserScalarFieldEnum | IngredientUserScalarFieldEnum[]
  }


  /**
   * IngredientUser findFirstOrThrow
   */
  export type IngredientUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientUser
     */
    select?: IngredientUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientUserInclude<ExtArgs> | null
    /**
     * Filter, which IngredientUser to fetch.
     */
    where?: IngredientUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientUsers to fetch.
     */
    orderBy?: IngredientUserOrderByWithRelationInput | IngredientUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IngredientUsers.
     */
    cursor?: IngredientUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IngredientUsers.
     */
    distinct?: IngredientUserScalarFieldEnum | IngredientUserScalarFieldEnum[]
  }


  /**
   * IngredientUser findMany
   */
  export type IngredientUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientUser
     */
    select?: IngredientUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientUserInclude<ExtArgs> | null
    /**
     * Filter, which IngredientUsers to fetch.
     */
    where?: IngredientUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientUsers to fetch.
     */
    orderBy?: IngredientUserOrderByWithRelationInput | IngredientUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IngredientUsers.
     */
    cursor?: IngredientUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientUsers.
     */
    skip?: number
    distinct?: IngredientUserScalarFieldEnum | IngredientUserScalarFieldEnum[]
  }


  /**
   * IngredientUser create
   */
  export type IngredientUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientUser
     */
    select?: IngredientUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientUserInclude<ExtArgs> | null
    /**
     * The data needed to create a IngredientUser.
     */
    data: XOR<IngredientUserCreateInput, IngredientUserUncheckedCreateInput>
  }


  /**
   * IngredientUser createMany
   */
  export type IngredientUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IngredientUsers.
     */
    data: IngredientUserCreateManyInput | IngredientUserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * IngredientUser update
   */
  export type IngredientUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientUser
     */
    select?: IngredientUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientUserInclude<ExtArgs> | null
    /**
     * The data needed to update a IngredientUser.
     */
    data: XOR<IngredientUserUpdateInput, IngredientUserUncheckedUpdateInput>
    /**
     * Choose, which IngredientUser to update.
     */
    where: IngredientUserWhereUniqueInput
  }


  /**
   * IngredientUser updateMany
   */
  export type IngredientUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IngredientUsers.
     */
    data: XOR<IngredientUserUpdateManyMutationInput, IngredientUserUncheckedUpdateManyInput>
    /**
     * Filter which IngredientUsers to update
     */
    where?: IngredientUserWhereInput
  }


  /**
   * IngredientUser upsert
   */
  export type IngredientUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientUser
     */
    select?: IngredientUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientUserInclude<ExtArgs> | null
    /**
     * The filter to search for the IngredientUser to update in case it exists.
     */
    where: IngredientUserWhereUniqueInput
    /**
     * In case the IngredientUser found by the `where` argument doesn't exist, create a new IngredientUser with this data.
     */
    create: XOR<IngredientUserCreateInput, IngredientUserUncheckedCreateInput>
    /**
     * In case the IngredientUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IngredientUserUpdateInput, IngredientUserUncheckedUpdateInput>
  }


  /**
   * IngredientUser delete
   */
  export type IngredientUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientUser
     */
    select?: IngredientUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientUserInclude<ExtArgs> | null
    /**
     * Filter which IngredientUser to delete.
     */
    where: IngredientUserWhereUniqueInput
  }


  /**
   * IngredientUser deleteMany
   */
  export type IngredientUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IngredientUsers to delete
     */
    where?: IngredientUserWhereInput
  }


  /**
   * IngredientUser without action
   */
  export type IngredientUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientUser
     */
    select?: IngredientUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientUserInclude<ExtArgs> | null
  }



  /**
   * Model IngredientPreference
   */

  export type AggregateIngredientPreference = {
    _count: IngredientPreferenceCountAggregateOutputType | null
    _min: IngredientPreferenceMinAggregateOutputType | null
    _max: IngredientPreferenceMaxAggregateOutputType | null
  }

  export type IngredientPreferenceMinAggregateOutputType = {
    genericIngredientId: string | null
    specificIngredientId: string | null
    userId: string | null
  }

  export type IngredientPreferenceMaxAggregateOutputType = {
    genericIngredientId: string | null
    specificIngredientId: string | null
    userId: string | null
  }

  export type IngredientPreferenceCountAggregateOutputType = {
    genericIngredientId: number
    specificIngredientId: number
    userId: number
    _all: number
  }


  export type IngredientPreferenceMinAggregateInputType = {
    genericIngredientId?: true
    specificIngredientId?: true
    userId?: true
  }

  export type IngredientPreferenceMaxAggregateInputType = {
    genericIngredientId?: true
    specificIngredientId?: true
    userId?: true
  }

  export type IngredientPreferenceCountAggregateInputType = {
    genericIngredientId?: true
    specificIngredientId?: true
    userId?: true
    _all?: true
  }

  export type IngredientPreferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IngredientPreference to aggregate.
     */
    where?: IngredientPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientPreferences to fetch.
     */
    orderBy?: IngredientPreferenceOrderByWithRelationInput | IngredientPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IngredientPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IngredientPreferences
    **/
    _count?: true | IngredientPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IngredientPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IngredientPreferenceMaxAggregateInputType
  }

  export type GetIngredientPreferenceAggregateType<T extends IngredientPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateIngredientPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIngredientPreference[P]>
      : GetScalarType<T[P], AggregateIngredientPreference[P]>
  }




  export type IngredientPreferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngredientPreferenceWhereInput
    orderBy?: IngredientPreferenceOrderByWithAggregationInput | IngredientPreferenceOrderByWithAggregationInput[]
    by: IngredientPreferenceScalarFieldEnum[] | IngredientPreferenceScalarFieldEnum
    having?: IngredientPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IngredientPreferenceCountAggregateInputType | true
    _min?: IngredientPreferenceMinAggregateInputType
    _max?: IngredientPreferenceMaxAggregateInputType
  }

  export type IngredientPreferenceGroupByOutputType = {
    genericIngredientId: string
    specificIngredientId: string
    userId: string
    _count: IngredientPreferenceCountAggregateOutputType | null
    _min: IngredientPreferenceMinAggregateOutputType | null
    _max: IngredientPreferenceMaxAggregateOutputType | null
  }

  type GetIngredientPreferenceGroupByPayload<T extends IngredientPreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IngredientPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IngredientPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IngredientPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], IngredientPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type IngredientPreferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    genericIngredientId?: boolean
    specificIngredientId?: boolean
    userId?: boolean
    genericIngredient?: boolean | GenericIngredientDefaultArgs<ExtArgs>
    specificIngredient?: boolean | SpecificIngredientDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ingredientPreference"]>

  export type IngredientPreferenceSelectScalar = {
    genericIngredientId?: boolean
    specificIngredientId?: boolean
    userId?: boolean
  }

  export type IngredientPreferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    genericIngredient?: boolean | GenericIngredientDefaultArgs<ExtArgs>
    specificIngredient?: boolean | SpecificIngredientDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $IngredientPreferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IngredientPreference"
    objects: {
      genericIngredient: Prisma.$GenericIngredientPayload<ExtArgs>
      specificIngredient: Prisma.$SpecificIngredientPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      genericIngredientId: string
      specificIngredientId: string
      userId: string
    }, ExtArgs["result"]["ingredientPreference"]>
    composites: {}
  }


  type IngredientPreferenceGetPayload<S extends boolean | null | undefined | IngredientPreferenceDefaultArgs> = $Result.GetResult<Prisma.$IngredientPreferencePayload, S>

  type IngredientPreferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IngredientPreferenceFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: IngredientPreferenceCountAggregateInputType | true
    }

  export interface IngredientPreferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IngredientPreference'], meta: { name: 'IngredientPreference' } }
    /**
     * Find zero or one IngredientPreference that matches the filter.
     * @param {IngredientPreferenceFindUniqueArgs} args - Arguments to find a IngredientPreference
     * @example
     * // Get one IngredientPreference
     * const ingredientPreference = await prisma.ingredientPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IngredientPreferenceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientPreferenceFindUniqueArgs<ExtArgs>>
    ): Prisma__IngredientPreferenceClient<$Result.GetResult<Prisma.$IngredientPreferencePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one IngredientPreference that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {IngredientPreferenceFindUniqueOrThrowArgs} args - Arguments to find a IngredientPreference
     * @example
     * // Get one IngredientPreference
     * const ingredientPreference = await prisma.ingredientPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends IngredientPreferenceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientPreferenceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__IngredientPreferenceClient<$Result.GetResult<Prisma.$IngredientPreferencePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first IngredientPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientPreferenceFindFirstArgs} args - Arguments to find a IngredientPreference
     * @example
     * // Get one IngredientPreference
     * const ingredientPreference = await prisma.ingredientPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IngredientPreferenceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientPreferenceFindFirstArgs<ExtArgs>>
    ): Prisma__IngredientPreferenceClient<$Result.GetResult<Prisma.$IngredientPreferencePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first IngredientPreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientPreferenceFindFirstOrThrowArgs} args - Arguments to find a IngredientPreference
     * @example
     * // Get one IngredientPreference
     * const ingredientPreference = await prisma.ingredientPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends IngredientPreferenceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientPreferenceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__IngredientPreferenceClient<$Result.GetResult<Prisma.$IngredientPreferencePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more IngredientPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientPreferenceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IngredientPreferences
     * const ingredientPreferences = await prisma.ingredientPreference.findMany()
     * 
     * // Get first 10 IngredientPreferences
     * const ingredientPreferences = await prisma.ingredientPreference.findMany({ take: 10 })
     * 
     * // Only select the `genericIngredientId`
     * const ingredientPreferenceWithGenericIngredientIdOnly = await prisma.ingredientPreference.findMany({ select: { genericIngredientId: true } })
     * 
    **/
    findMany<T extends IngredientPreferenceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientPreferenceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientPreferencePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a IngredientPreference.
     * @param {IngredientPreferenceCreateArgs} args - Arguments to create a IngredientPreference.
     * @example
     * // Create one IngredientPreference
     * const IngredientPreference = await prisma.ingredientPreference.create({
     *   data: {
     *     // ... data to create a IngredientPreference
     *   }
     * })
     * 
    **/
    create<T extends IngredientPreferenceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientPreferenceCreateArgs<ExtArgs>>
    ): Prisma__IngredientPreferenceClient<$Result.GetResult<Prisma.$IngredientPreferencePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many IngredientPreferences.
     *     @param {IngredientPreferenceCreateManyArgs} args - Arguments to create many IngredientPreferences.
     *     @example
     *     // Create many IngredientPreferences
     *     const ingredientPreference = await prisma.ingredientPreference.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IngredientPreferenceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientPreferenceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a IngredientPreference.
     * @param {IngredientPreferenceDeleteArgs} args - Arguments to delete one IngredientPreference.
     * @example
     * // Delete one IngredientPreference
     * const IngredientPreference = await prisma.ingredientPreference.delete({
     *   where: {
     *     // ... filter to delete one IngredientPreference
     *   }
     * })
     * 
    **/
    delete<T extends IngredientPreferenceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientPreferenceDeleteArgs<ExtArgs>>
    ): Prisma__IngredientPreferenceClient<$Result.GetResult<Prisma.$IngredientPreferencePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one IngredientPreference.
     * @param {IngredientPreferenceUpdateArgs} args - Arguments to update one IngredientPreference.
     * @example
     * // Update one IngredientPreference
     * const ingredientPreference = await prisma.ingredientPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IngredientPreferenceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientPreferenceUpdateArgs<ExtArgs>>
    ): Prisma__IngredientPreferenceClient<$Result.GetResult<Prisma.$IngredientPreferencePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more IngredientPreferences.
     * @param {IngredientPreferenceDeleteManyArgs} args - Arguments to filter IngredientPreferences to delete.
     * @example
     * // Delete a few IngredientPreferences
     * const { count } = await prisma.ingredientPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IngredientPreferenceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientPreferenceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IngredientPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IngredientPreferences
     * const ingredientPreference = await prisma.ingredientPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IngredientPreferenceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientPreferenceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IngredientPreference.
     * @param {IngredientPreferenceUpsertArgs} args - Arguments to update or create a IngredientPreference.
     * @example
     * // Update or create a IngredientPreference
     * const ingredientPreference = await prisma.ingredientPreference.upsert({
     *   create: {
     *     // ... data to create a IngredientPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IngredientPreference we want to update
     *   }
     * })
    **/
    upsert<T extends IngredientPreferenceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientPreferenceUpsertArgs<ExtArgs>>
    ): Prisma__IngredientPreferenceClient<$Result.GetResult<Prisma.$IngredientPreferencePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of IngredientPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientPreferenceCountArgs} args - Arguments to filter IngredientPreferences to count.
     * @example
     * // Count the number of IngredientPreferences
     * const count = await prisma.ingredientPreference.count({
     *   where: {
     *     // ... the filter for the IngredientPreferences we want to count
     *   }
     * })
    **/
    count<T extends IngredientPreferenceCountArgs>(
      args?: Subset<T, IngredientPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IngredientPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IngredientPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IngredientPreferenceAggregateArgs>(args: Subset<T, IngredientPreferenceAggregateArgs>): Prisma.PrismaPromise<GetIngredientPreferenceAggregateType<T>>

    /**
     * Group by IngredientPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IngredientPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IngredientPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: IngredientPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IngredientPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIngredientPreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IngredientPreference model
   */
  readonly fields: IngredientPreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IngredientPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IngredientPreferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    genericIngredient<T extends GenericIngredientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GenericIngredientDefaultArgs<ExtArgs>>): Prisma__GenericIngredientClient<$Result.GetResult<Prisma.$GenericIngredientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    specificIngredient<T extends SpecificIngredientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpecificIngredientDefaultArgs<ExtArgs>>): Prisma__SpecificIngredientClient<$Result.GetResult<Prisma.$SpecificIngredientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the IngredientPreference model
   */ 
  interface IngredientPreferenceFieldRefs {
    readonly genericIngredientId: FieldRef<"IngredientPreference", 'String'>
    readonly specificIngredientId: FieldRef<"IngredientPreference", 'String'>
    readonly userId: FieldRef<"IngredientPreference", 'String'>
  }
    

  // Custom InputTypes

  /**
   * IngredientPreference findUnique
   */
  export type IngredientPreferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientPreference
     */
    select?: IngredientPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which IngredientPreference to fetch.
     */
    where: IngredientPreferenceWhereUniqueInput
  }


  /**
   * IngredientPreference findUniqueOrThrow
   */
  export type IngredientPreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientPreference
     */
    select?: IngredientPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which IngredientPreference to fetch.
     */
    where: IngredientPreferenceWhereUniqueInput
  }


  /**
   * IngredientPreference findFirst
   */
  export type IngredientPreferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientPreference
     */
    select?: IngredientPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which IngredientPreference to fetch.
     */
    where?: IngredientPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientPreferences to fetch.
     */
    orderBy?: IngredientPreferenceOrderByWithRelationInput | IngredientPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IngredientPreferences.
     */
    cursor?: IngredientPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IngredientPreferences.
     */
    distinct?: IngredientPreferenceScalarFieldEnum | IngredientPreferenceScalarFieldEnum[]
  }


  /**
   * IngredientPreference findFirstOrThrow
   */
  export type IngredientPreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientPreference
     */
    select?: IngredientPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which IngredientPreference to fetch.
     */
    where?: IngredientPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientPreferences to fetch.
     */
    orderBy?: IngredientPreferenceOrderByWithRelationInput | IngredientPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IngredientPreferences.
     */
    cursor?: IngredientPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IngredientPreferences.
     */
    distinct?: IngredientPreferenceScalarFieldEnum | IngredientPreferenceScalarFieldEnum[]
  }


  /**
   * IngredientPreference findMany
   */
  export type IngredientPreferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientPreference
     */
    select?: IngredientPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which IngredientPreferences to fetch.
     */
    where?: IngredientPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientPreferences to fetch.
     */
    orderBy?: IngredientPreferenceOrderByWithRelationInput | IngredientPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IngredientPreferences.
     */
    cursor?: IngredientPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientPreferences.
     */
    skip?: number
    distinct?: IngredientPreferenceScalarFieldEnum | IngredientPreferenceScalarFieldEnum[]
  }


  /**
   * IngredientPreference create
   */
  export type IngredientPreferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientPreference
     */
    select?: IngredientPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a IngredientPreference.
     */
    data: XOR<IngredientPreferenceCreateInput, IngredientPreferenceUncheckedCreateInput>
  }


  /**
   * IngredientPreference createMany
   */
  export type IngredientPreferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IngredientPreferences.
     */
    data: IngredientPreferenceCreateManyInput | IngredientPreferenceCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * IngredientPreference update
   */
  export type IngredientPreferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientPreference
     */
    select?: IngredientPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a IngredientPreference.
     */
    data: XOR<IngredientPreferenceUpdateInput, IngredientPreferenceUncheckedUpdateInput>
    /**
     * Choose, which IngredientPreference to update.
     */
    where: IngredientPreferenceWhereUniqueInput
  }


  /**
   * IngredientPreference updateMany
   */
  export type IngredientPreferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IngredientPreferences.
     */
    data: XOR<IngredientPreferenceUpdateManyMutationInput, IngredientPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which IngredientPreferences to update
     */
    where?: IngredientPreferenceWhereInput
  }


  /**
   * IngredientPreference upsert
   */
  export type IngredientPreferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientPreference
     */
    select?: IngredientPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientPreferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the IngredientPreference to update in case it exists.
     */
    where: IngredientPreferenceWhereUniqueInput
    /**
     * In case the IngredientPreference found by the `where` argument doesn't exist, create a new IngredientPreference with this data.
     */
    create: XOR<IngredientPreferenceCreateInput, IngredientPreferenceUncheckedCreateInput>
    /**
     * In case the IngredientPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IngredientPreferenceUpdateInput, IngredientPreferenceUncheckedUpdateInput>
  }


  /**
   * IngredientPreference delete
   */
  export type IngredientPreferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientPreference
     */
    select?: IngredientPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientPreferenceInclude<ExtArgs> | null
    /**
     * Filter which IngredientPreference to delete.
     */
    where: IngredientPreferenceWhereUniqueInput
  }


  /**
   * IngredientPreference deleteMany
   */
  export type IngredientPreferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IngredientPreferences to delete
     */
    where?: IngredientPreferenceWhereInput
  }


  /**
   * IngredientPreference without action
   */
  export type IngredientPreferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientPreference
     */
    select?: IngredientPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientPreferenceInclude<ExtArgs> | null
  }



  /**
   * Model Inventory
   */

  export type AggregateInventory = {
    _count: InventoryCountAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  export type InventoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
  }

  export type InventoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
  }

  export type InventoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    editedAt: number
    createdById: number
    editedById: number
    _all: number
  }


  export type InventoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
  }

  export type InventoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
  }

  export type InventoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
    _all?: true
  }

  export type InventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventory to aggregate.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inventories
    **/
    _count?: true | InventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMaxAggregateInputType
  }

  export type GetInventoryAggregateType<T extends InventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventory[P]>
      : GetScalarType<T[P], AggregateInventory[P]>
  }




  export type InventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithAggregationInput | InventoryOrderByWithAggregationInput[]
    by: InventoryScalarFieldEnum[] | InventoryScalarFieldEnum
    having?: InventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryCountAggregateInputType | true
    _min?: InventoryMinAggregateInputType
    _max?: InventoryMaxAggregateInputType
  }

  export type InventoryGroupByOutputType = {
    id: string
    name: string
    description: string
    createdAt: Date
    editedAt: Date
    createdById: string
    editedById: string
    _count: InventoryCountAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  type GetInventoryGroupByPayload<T extends InventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryGroupByOutputType[P]>
        }
      >
    >


  export type InventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    editedAt?: boolean
    createdById?: boolean
    editedById?: boolean
    createdBy?: boolean | Inventory$createdByArgs<ExtArgs>
    editedBy?: boolean | Inventory$editedByArgs<ExtArgs>
    inventoryStorage?: boolean | Inventory$inventoryStorageArgs<ExtArgs>
    inventoryUser?: boolean | Inventory$inventoryUserArgs<ExtArgs>
    _count?: boolean | InventoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    editedAt?: boolean
    createdById?: boolean
    editedById?: boolean
  }

  export type InventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Inventory$createdByArgs<ExtArgs>
    editedBy?: boolean | Inventory$editedByArgs<ExtArgs>
    inventoryStorage?: boolean | Inventory$inventoryStorageArgs<ExtArgs>
    inventoryUser?: boolean | Inventory$inventoryUserArgs<ExtArgs>
    _count?: boolean | InventoryCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $InventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inventory"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      editedBy: Prisma.$UserPayload<ExtArgs> | null
      inventoryStorage: Prisma.$InventoryStoragePayload<ExtArgs>[]
      inventoryUser: Prisma.$InventoryUserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      createdAt: Date
      editedAt: Date
      createdById: string
      editedById: string
    }, ExtArgs["result"]["inventory"]>
    composites: {}
  }


  type InventoryGetPayload<S extends boolean | null | undefined | InventoryDefaultArgs> = $Result.GetResult<Prisma.$InventoryPayload, S>

  type InventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InventoryFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: InventoryCountAggregateInputType | true
    }

  export interface InventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inventory'], meta: { name: 'Inventory' } }
    /**
     * Find zero or one Inventory that matches the filter.
     * @param {InventoryFindUniqueArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InventoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryFindUniqueArgs<ExtArgs>>
    ): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inventory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InventoryFindUniqueOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InventoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InventoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryFindFirstArgs<ExtArgs>>
    ): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InventoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventories
     * const inventories = await prisma.inventory.findMany()
     * 
     * // Get first 10 Inventories
     * const inventories = await prisma.inventory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryWithIdOnly = await prisma.inventory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InventoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inventory.
     * @param {InventoryCreateArgs} args - Arguments to create a Inventory.
     * @example
     * // Create one Inventory
     * const Inventory = await prisma.inventory.create({
     *   data: {
     *     // ... data to create a Inventory
     *   }
     * })
     * 
    **/
    create<T extends InventoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryCreateArgs<ExtArgs>>
    ): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inventories.
     *     @param {InventoryCreateManyArgs} args - Arguments to create many Inventories.
     *     @example
     *     // Create many Inventories
     *     const inventory = await prisma.inventory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InventoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inventory.
     * @param {InventoryDeleteArgs} args - Arguments to delete one Inventory.
     * @example
     * // Delete one Inventory
     * const Inventory = await prisma.inventory.delete({
     *   where: {
     *     // ... filter to delete one Inventory
     *   }
     * })
     * 
    **/
    delete<T extends InventoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryDeleteArgs<ExtArgs>>
    ): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inventory.
     * @param {InventoryUpdateArgs} args - Arguments to update one Inventory.
     * @example
     * // Update one Inventory
     * const inventory = await prisma.inventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InventoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryUpdateArgs<ExtArgs>>
    ): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inventories.
     * @param {InventoryDeleteManyArgs} args - Arguments to filter Inventories to delete.
     * @example
     * // Delete a few Inventories
     * const { count } = await prisma.inventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InventoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InventoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inventory.
     * @param {InventoryUpsertArgs} args - Arguments to update or create a Inventory.
     * @example
     * // Update or create a Inventory
     * const inventory = await prisma.inventory.upsert({
     *   create: {
     *     // ... data to create a Inventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventory we want to update
     *   }
     * })
    **/
    upsert<T extends InventoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryUpsertArgs<ExtArgs>>
    ): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCountArgs} args - Arguments to filter Inventories to count.
     * @example
     * // Count the number of Inventories
     * const count = await prisma.inventory.count({
     *   where: {
     *     // ... the filter for the Inventories we want to count
     *   }
     * })
    **/
    count<T extends InventoryCountArgs>(
      args?: Subset<T, InventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryAggregateArgs>(args: Subset<T, InventoryAggregateArgs>): Prisma.PrismaPromise<GetInventoryAggregateType<T>>

    /**
     * Group by Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryGroupByArgs['orderBy'] }
        : { orderBy?: InventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inventory model
   */
  readonly fields: InventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    createdBy<T extends Inventory$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Inventory$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    editedBy<T extends Inventory$editedByArgs<ExtArgs> = {}>(args?: Subset<T, Inventory$editedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    inventoryStorage<T extends Inventory$inventoryStorageArgs<ExtArgs> = {}>(args?: Subset<T, Inventory$inventoryStorageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryStoragePayload<ExtArgs>, T, 'findMany'> | Null>;

    inventoryUser<T extends Inventory$inventoryUserArgs<ExtArgs> = {}>(args?: Subset<T, Inventory$inventoryUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Inventory model
   */ 
  interface InventoryFieldRefs {
    readonly id: FieldRef<"Inventory", 'String'>
    readonly name: FieldRef<"Inventory", 'String'>
    readonly description: FieldRef<"Inventory", 'String'>
    readonly createdAt: FieldRef<"Inventory", 'DateTime'>
    readonly editedAt: FieldRef<"Inventory", 'DateTime'>
    readonly createdById: FieldRef<"Inventory", 'String'>
    readonly editedById: FieldRef<"Inventory", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Inventory findUnique
   */
  export type InventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }


  /**
   * Inventory findUniqueOrThrow
   */
  export type InventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }


  /**
   * Inventory findFirst
   */
  export type InventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }


  /**
   * Inventory findFirstOrThrow
   */
  export type InventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }


  /**
   * Inventory findMany
   */
  export type InventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventories to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }


  /**
   * Inventory create
   */
  export type InventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Inventory.
     */
    data: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
  }


  /**
   * Inventory createMany
   */
  export type InventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inventories.
     */
    data: InventoryCreateManyInput | InventoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Inventory update
   */
  export type InventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Inventory.
     */
    data: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
    /**
     * Choose, which Inventory to update.
     */
    where: InventoryWhereUniqueInput
  }


  /**
   * Inventory updateMany
   */
  export type InventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inventories.
     */
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyInput>
    /**
     * Filter which Inventories to update
     */
    where?: InventoryWhereInput
  }


  /**
   * Inventory upsert
   */
  export type InventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Inventory to update in case it exists.
     */
    where: InventoryWhereUniqueInput
    /**
     * In case the Inventory found by the `where` argument doesn't exist, create a new Inventory with this data.
     */
    create: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
    /**
     * In case the Inventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
  }


  /**
   * Inventory delete
   */
  export type InventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter which Inventory to delete.
     */
    where: InventoryWhereUniqueInput
  }


  /**
   * Inventory deleteMany
   */
  export type InventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventories to delete
     */
    where?: InventoryWhereInput
  }


  /**
   * Inventory.createdBy
   */
  export type Inventory$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Inventory.editedBy
   */
  export type Inventory$editedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Inventory.inventoryStorage
   */
  export type Inventory$inventoryStorageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     */
    select?: InventoryStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryStorageInclude<ExtArgs> | null
    where?: InventoryStorageWhereInput
    orderBy?: InventoryStorageOrderByWithRelationInput | InventoryStorageOrderByWithRelationInput[]
    cursor?: InventoryStorageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryStorageScalarFieldEnum | InventoryStorageScalarFieldEnum[]
  }


  /**
   * Inventory.inventoryUser
   */
  export type Inventory$inventoryUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUser
     */
    select?: InventoryUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryUserInclude<ExtArgs> | null
    where?: InventoryUserWhereInput
    orderBy?: InventoryUserOrderByWithRelationInput | InventoryUserOrderByWithRelationInput[]
    cursor?: InventoryUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryUserScalarFieldEnum | InventoryUserScalarFieldEnum[]
  }


  /**
   * Inventory without action
   */
  export type InventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
  }



  /**
   * Model InventoryUser
   */

  export type AggregateInventoryUser = {
    _count: InventoryUserCountAggregateOutputType | null
    _min: InventoryUserMinAggregateOutputType | null
    _max: InventoryUserMaxAggregateOutputType | null
  }

  export type InventoryUserMinAggregateOutputType = {
    userId: string | null
    inventoryId: string | null
    permission: string | null
  }

  export type InventoryUserMaxAggregateOutputType = {
    userId: string | null
    inventoryId: string | null
    permission: string | null
  }

  export type InventoryUserCountAggregateOutputType = {
    userId: number
    inventoryId: number
    permission: number
    _all: number
  }


  export type InventoryUserMinAggregateInputType = {
    userId?: true
    inventoryId?: true
    permission?: true
  }

  export type InventoryUserMaxAggregateInputType = {
    userId?: true
    inventoryId?: true
    permission?: true
  }

  export type InventoryUserCountAggregateInputType = {
    userId?: true
    inventoryId?: true
    permission?: true
    _all?: true
  }

  export type InventoryUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryUser to aggregate.
     */
    where?: InventoryUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryUsers to fetch.
     */
    orderBy?: InventoryUserOrderByWithRelationInput | InventoryUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryUsers
    **/
    _count?: true | InventoryUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryUserMaxAggregateInputType
  }

  export type GetInventoryUserAggregateType<T extends InventoryUserAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryUser[P]>
      : GetScalarType<T[P], AggregateInventoryUser[P]>
  }




  export type InventoryUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryUserWhereInput
    orderBy?: InventoryUserOrderByWithAggregationInput | InventoryUserOrderByWithAggregationInput[]
    by: InventoryUserScalarFieldEnum[] | InventoryUserScalarFieldEnum
    having?: InventoryUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryUserCountAggregateInputType | true
    _min?: InventoryUserMinAggregateInputType
    _max?: InventoryUserMaxAggregateInputType
  }

  export type InventoryUserGroupByOutputType = {
    userId: string
    inventoryId: string
    permission: string
    _count: InventoryUserCountAggregateOutputType | null
    _min: InventoryUserMinAggregateOutputType | null
    _max: InventoryUserMaxAggregateOutputType | null
  }

  type GetInventoryUserGroupByPayload<T extends InventoryUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryUserGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryUserGroupByOutputType[P]>
        }
      >
    >


  export type InventoryUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    inventoryId?: boolean
    permission?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryUser"]>

  export type InventoryUserSelectScalar = {
    userId?: boolean
    inventoryId?: boolean
    permission?: boolean
  }

  export type InventoryUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
  }


  export type $InventoryUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryUser"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      inventory: Prisma.$InventoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      inventoryId: string
      permission: string
    }, ExtArgs["result"]["inventoryUser"]>
    composites: {}
  }


  type InventoryUserGetPayload<S extends boolean | null | undefined | InventoryUserDefaultArgs> = $Result.GetResult<Prisma.$InventoryUserPayload, S>

  type InventoryUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InventoryUserFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: InventoryUserCountAggregateInputType | true
    }

  export interface InventoryUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryUser'], meta: { name: 'InventoryUser' } }
    /**
     * Find zero or one InventoryUser that matches the filter.
     * @param {InventoryUserFindUniqueArgs} args - Arguments to find a InventoryUser
     * @example
     * // Get one InventoryUser
     * const inventoryUser = await prisma.inventoryUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InventoryUserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryUserFindUniqueArgs<ExtArgs>>
    ): Prisma__InventoryUserClient<$Result.GetResult<Prisma.$InventoryUserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one InventoryUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InventoryUserFindUniqueOrThrowArgs} args - Arguments to find a InventoryUser
     * @example
     * // Get one InventoryUser
     * const inventoryUser = await prisma.inventoryUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InventoryUserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryUserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InventoryUserClient<$Result.GetResult<Prisma.$InventoryUserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first InventoryUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUserFindFirstArgs} args - Arguments to find a InventoryUser
     * @example
     * // Get one InventoryUser
     * const inventoryUser = await prisma.inventoryUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InventoryUserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryUserFindFirstArgs<ExtArgs>>
    ): Prisma__InventoryUserClient<$Result.GetResult<Prisma.$InventoryUserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first InventoryUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUserFindFirstOrThrowArgs} args - Arguments to find a InventoryUser
     * @example
     * // Get one InventoryUser
     * const inventoryUser = await prisma.inventoryUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InventoryUserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryUserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InventoryUserClient<$Result.GetResult<Prisma.$InventoryUserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more InventoryUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryUsers
     * const inventoryUsers = await prisma.inventoryUser.findMany()
     * 
     * // Get first 10 InventoryUsers
     * const inventoryUsers = await prisma.inventoryUser.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const inventoryUserWithUserIdOnly = await prisma.inventoryUser.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends InventoryUserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryUserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryUserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a InventoryUser.
     * @param {InventoryUserCreateArgs} args - Arguments to create a InventoryUser.
     * @example
     * // Create one InventoryUser
     * const InventoryUser = await prisma.inventoryUser.create({
     *   data: {
     *     // ... data to create a InventoryUser
     *   }
     * })
     * 
    **/
    create<T extends InventoryUserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryUserCreateArgs<ExtArgs>>
    ): Prisma__InventoryUserClient<$Result.GetResult<Prisma.$InventoryUserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many InventoryUsers.
     *     @param {InventoryUserCreateManyArgs} args - Arguments to create many InventoryUsers.
     *     @example
     *     // Create many InventoryUsers
     *     const inventoryUser = await prisma.inventoryUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InventoryUserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryUserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InventoryUser.
     * @param {InventoryUserDeleteArgs} args - Arguments to delete one InventoryUser.
     * @example
     * // Delete one InventoryUser
     * const InventoryUser = await prisma.inventoryUser.delete({
     *   where: {
     *     // ... filter to delete one InventoryUser
     *   }
     * })
     * 
    **/
    delete<T extends InventoryUserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryUserDeleteArgs<ExtArgs>>
    ): Prisma__InventoryUserClient<$Result.GetResult<Prisma.$InventoryUserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one InventoryUser.
     * @param {InventoryUserUpdateArgs} args - Arguments to update one InventoryUser.
     * @example
     * // Update one InventoryUser
     * const inventoryUser = await prisma.inventoryUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InventoryUserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryUserUpdateArgs<ExtArgs>>
    ): Prisma__InventoryUserClient<$Result.GetResult<Prisma.$InventoryUserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more InventoryUsers.
     * @param {InventoryUserDeleteManyArgs} args - Arguments to filter InventoryUsers to delete.
     * @example
     * // Delete a few InventoryUsers
     * const { count } = await prisma.inventoryUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InventoryUserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryUserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryUsers
     * const inventoryUser = await prisma.inventoryUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InventoryUserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryUserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InventoryUser.
     * @param {InventoryUserUpsertArgs} args - Arguments to update or create a InventoryUser.
     * @example
     * // Update or create a InventoryUser
     * const inventoryUser = await prisma.inventoryUser.upsert({
     *   create: {
     *     // ... data to create a InventoryUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryUser we want to update
     *   }
     * })
    **/
    upsert<T extends InventoryUserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryUserUpsertArgs<ExtArgs>>
    ): Prisma__InventoryUserClient<$Result.GetResult<Prisma.$InventoryUserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of InventoryUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUserCountArgs} args - Arguments to filter InventoryUsers to count.
     * @example
     * // Count the number of InventoryUsers
     * const count = await prisma.inventoryUser.count({
     *   where: {
     *     // ... the filter for the InventoryUsers we want to count
     *   }
     * })
    **/
    count<T extends InventoryUserCountArgs>(
      args?: Subset<T, InventoryUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryUserAggregateArgs>(args: Subset<T, InventoryUserAggregateArgs>): Prisma.PrismaPromise<GetInventoryUserAggregateType<T>>

    /**
     * Group by InventoryUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryUserGroupByArgs['orderBy'] }
        : { orderBy?: InventoryUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryUser model
   */
  readonly fields: InventoryUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    inventory<T extends InventoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryDefaultArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the InventoryUser model
   */ 
  interface InventoryUserFieldRefs {
    readonly userId: FieldRef<"InventoryUser", 'String'>
    readonly inventoryId: FieldRef<"InventoryUser", 'String'>
    readonly permission: FieldRef<"InventoryUser", 'String'>
  }
    

  // Custom InputTypes

  /**
   * InventoryUser findUnique
   */
  export type InventoryUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUser
     */
    select?: InventoryUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryUserInclude<ExtArgs> | null
    /**
     * Filter, which InventoryUser to fetch.
     */
    where: InventoryUserWhereUniqueInput
  }


  /**
   * InventoryUser findUniqueOrThrow
   */
  export type InventoryUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUser
     */
    select?: InventoryUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryUserInclude<ExtArgs> | null
    /**
     * Filter, which InventoryUser to fetch.
     */
    where: InventoryUserWhereUniqueInput
  }


  /**
   * InventoryUser findFirst
   */
  export type InventoryUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUser
     */
    select?: InventoryUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryUserInclude<ExtArgs> | null
    /**
     * Filter, which InventoryUser to fetch.
     */
    where?: InventoryUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryUsers to fetch.
     */
    orderBy?: InventoryUserOrderByWithRelationInput | InventoryUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryUsers.
     */
    cursor?: InventoryUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryUsers.
     */
    distinct?: InventoryUserScalarFieldEnum | InventoryUserScalarFieldEnum[]
  }


  /**
   * InventoryUser findFirstOrThrow
   */
  export type InventoryUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUser
     */
    select?: InventoryUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryUserInclude<ExtArgs> | null
    /**
     * Filter, which InventoryUser to fetch.
     */
    where?: InventoryUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryUsers to fetch.
     */
    orderBy?: InventoryUserOrderByWithRelationInput | InventoryUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryUsers.
     */
    cursor?: InventoryUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryUsers.
     */
    distinct?: InventoryUserScalarFieldEnum | InventoryUserScalarFieldEnum[]
  }


  /**
   * InventoryUser findMany
   */
  export type InventoryUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUser
     */
    select?: InventoryUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryUserInclude<ExtArgs> | null
    /**
     * Filter, which InventoryUsers to fetch.
     */
    where?: InventoryUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryUsers to fetch.
     */
    orderBy?: InventoryUserOrderByWithRelationInput | InventoryUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryUsers.
     */
    cursor?: InventoryUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryUsers.
     */
    skip?: number
    distinct?: InventoryUserScalarFieldEnum | InventoryUserScalarFieldEnum[]
  }


  /**
   * InventoryUser create
   */
  export type InventoryUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUser
     */
    select?: InventoryUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryUserInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryUser.
     */
    data: XOR<InventoryUserCreateInput, InventoryUserUncheckedCreateInput>
  }


  /**
   * InventoryUser createMany
   */
  export type InventoryUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryUsers.
     */
    data: InventoryUserCreateManyInput | InventoryUserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * InventoryUser update
   */
  export type InventoryUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUser
     */
    select?: InventoryUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryUserInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryUser.
     */
    data: XOR<InventoryUserUpdateInput, InventoryUserUncheckedUpdateInput>
    /**
     * Choose, which InventoryUser to update.
     */
    where: InventoryUserWhereUniqueInput
  }


  /**
   * InventoryUser updateMany
   */
  export type InventoryUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryUsers.
     */
    data: XOR<InventoryUserUpdateManyMutationInput, InventoryUserUncheckedUpdateManyInput>
    /**
     * Filter which InventoryUsers to update
     */
    where?: InventoryUserWhereInput
  }


  /**
   * InventoryUser upsert
   */
  export type InventoryUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUser
     */
    select?: InventoryUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryUserInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryUser to update in case it exists.
     */
    where: InventoryUserWhereUniqueInput
    /**
     * In case the InventoryUser found by the `where` argument doesn't exist, create a new InventoryUser with this data.
     */
    create: XOR<InventoryUserCreateInput, InventoryUserUncheckedCreateInput>
    /**
     * In case the InventoryUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryUserUpdateInput, InventoryUserUncheckedUpdateInput>
  }


  /**
   * InventoryUser delete
   */
  export type InventoryUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUser
     */
    select?: InventoryUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryUserInclude<ExtArgs> | null
    /**
     * Filter which InventoryUser to delete.
     */
    where: InventoryUserWhereUniqueInput
  }


  /**
   * InventoryUser deleteMany
   */
  export type InventoryUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryUsers to delete
     */
    where?: InventoryUserWhereInput
  }


  /**
   * InventoryUser without action
   */
  export type InventoryUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUser
     */
    select?: InventoryUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryUserInclude<ExtArgs> | null
  }



  /**
   * Model Storage
   */

  export type AggregateStorage = {
    _count: StorageCountAggregateOutputType | null
    _min: StorageMinAggregateOutputType | null
    _max: StorageMaxAggregateOutputType | null
  }

  export type StorageMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
  }

  export type StorageMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
  }

  export type StorageCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    editedAt: number
    createdById: number
    editedById: number
    _all: number
  }


  export type StorageMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
  }

  export type StorageMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
  }

  export type StorageCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
    _all?: true
  }

  export type StorageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Storage to aggregate.
     */
    where?: StorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Storages to fetch.
     */
    orderBy?: StorageOrderByWithRelationInput | StorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Storages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Storages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Storages
    **/
    _count?: true | StorageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StorageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StorageMaxAggregateInputType
  }

  export type GetStorageAggregateType<T extends StorageAggregateArgs> = {
        [P in keyof T & keyof AggregateStorage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStorage[P]>
      : GetScalarType<T[P], AggregateStorage[P]>
  }




  export type StorageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorageWhereInput
    orderBy?: StorageOrderByWithAggregationInput | StorageOrderByWithAggregationInput[]
    by: StorageScalarFieldEnum[] | StorageScalarFieldEnum
    having?: StorageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StorageCountAggregateInputType | true
    _min?: StorageMinAggregateInputType
    _max?: StorageMaxAggregateInputType
  }

  export type StorageGroupByOutputType = {
    id: string
    name: string
    description: string
    createdAt: Date
    editedAt: Date
    createdById: string
    editedById: string
    _count: StorageCountAggregateOutputType | null
    _min: StorageMinAggregateOutputType | null
    _max: StorageMaxAggregateOutputType | null
  }

  type GetStorageGroupByPayload<T extends StorageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StorageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StorageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StorageGroupByOutputType[P]>
            : GetScalarType<T[P], StorageGroupByOutputType[P]>
        }
      >
    >


  export type StorageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    editedAt?: boolean
    createdById?: boolean
    editedById?: boolean
    createdBy?: boolean | Storage$createdByArgs<ExtArgs>
    editedBy?: boolean | Storage$editedByArgs<ExtArgs>
    inventoryStorage?: boolean | Storage$inventoryStorageArgs<ExtArgs>
    ingredientStorage?: boolean | Storage$ingredientStorageArgs<ExtArgs>
    storageUser?: boolean | Storage$storageUserArgs<ExtArgs>
    _count?: boolean | StorageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storage"]>

  export type StorageSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    editedAt?: boolean
    createdById?: boolean
    editedById?: boolean
  }

  export type StorageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Storage$createdByArgs<ExtArgs>
    editedBy?: boolean | Storage$editedByArgs<ExtArgs>
    inventoryStorage?: boolean | Storage$inventoryStorageArgs<ExtArgs>
    ingredientStorage?: boolean | Storage$ingredientStorageArgs<ExtArgs>
    storageUser?: boolean | Storage$storageUserArgs<ExtArgs>
    _count?: boolean | StorageCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $StoragePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Storage"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      editedBy: Prisma.$UserPayload<ExtArgs> | null
      inventoryStorage: Prisma.$InventoryStoragePayload<ExtArgs>[]
      ingredientStorage: Prisma.$IngredientStoragePayload<ExtArgs>[]
      storageUser: Prisma.$StorageUserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      createdAt: Date
      editedAt: Date
      createdById: string
      editedById: string
    }, ExtArgs["result"]["storage"]>
    composites: {}
  }


  type StorageGetPayload<S extends boolean | null | undefined | StorageDefaultArgs> = $Result.GetResult<Prisma.$StoragePayload, S>

  type StorageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StorageFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: StorageCountAggregateInputType | true
    }

  export interface StorageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Storage'], meta: { name: 'Storage' } }
    /**
     * Find zero or one Storage that matches the filter.
     * @param {StorageFindUniqueArgs} args - Arguments to find a Storage
     * @example
     * // Get one Storage
     * const storage = await prisma.storage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StorageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StorageFindUniqueArgs<ExtArgs>>
    ): Prisma__StorageClient<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Storage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StorageFindUniqueOrThrowArgs} args - Arguments to find a Storage
     * @example
     * // Get one Storage
     * const storage = await prisma.storage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StorageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StorageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StorageClient<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Storage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageFindFirstArgs} args - Arguments to find a Storage
     * @example
     * // Get one Storage
     * const storage = await prisma.storage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StorageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StorageFindFirstArgs<ExtArgs>>
    ): Prisma__StorageClient<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Storage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageFindFirstOrThrowArgs} args - Arguments to find a Storage
     * @example
     * // Get one Storage
     * const storage = await prisma.storage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StorageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StorageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StorageClient<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Storages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Storages
     * const storages = await prisma.storage.findMany()
     * 
     * // Get first 10 Storages
     * const storages = await prisma.storage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storageWithIdOnly = await prisma.storage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StorageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StorageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Storage.
     * @param {StorageCreateArgs} args - Arguments to create a Storage.
     * @example
     * // Create one Storage
     * const Storage = await prisma.storage.create({
     *   data: {
     *     // ... data to create a Storage
     *   }
     * })
     * 
    **/
    create<T extends StorageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StorageCreateArgs<ExtArgs>>
    ): Prisma__StorageClient<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Storages.
     *     @param {StorageCreateManyArgs} args - Arguments to create many Storages.
     *     @example
     *     // Create many Storages
     *     const storage = await prisma.storage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StorageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StorageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Storage.
     * @param {StorageDeleteArgs} args - Arguments to delete one Storage.
     * @example
     * // Delete one Storage
     * const Storage = await prisma.storage.delete({
     *   where: {
     *     // ... filter to delete one Storage
     *   }
     * })
     * 
    **/
    delete<T extends StorageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StorageDeleteArgs<ExtArgs>>
    ): Prisma__StorageClient<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Storage.
     * @param {StorageUpdateArgs} args - Arguments to update one Storage.
     * @example
     * // Update one Storage
     * const storage = await prisma.storage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StorageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StorageUpdateArgs<ExtArgs>>
    ): Prisma__StorageClient<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Storages.
     * @param {StorageDeleteManyArgs} args - Arguments to filter Storages to delete.
     * @example
     * // Delete a few Storages
     * const { count } = await prisma.storage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StorageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StorageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Storages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Storages
     * const storage = await prisma.storage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StorageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StorageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Storage.
     * @param {StorageUpsertArgs} args - Arguments to update or create a Storage.
     * @example
     * // Update or create a Storage
     * const storage = await prisma.storage.upsert({
     *   create: {
     *     // ... data to create a Storage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Storage we want to update
     *   }
     * })
    **/
    upsert<T extends StorageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StorageUpsertArgs<ExtArgs>>
    ): Prisma__StorageClient<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Storages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageCountArgs} args - Arguments to filter Storages to count.
     * @example
     * // Count the number of Storages
     * const count = await prisma.storage.count({
     *   where: {
     *     // ... the filter for the Storages we want to count
     *   }
     * })
    **/
    count<T extends StorageCountArgs>(
      args?: Subset<T, StorageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StorageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Storage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StorageAggregateArgs>(args: Subset<T, StorageAggregateArgs>): Prisma.PrismaPromise<GetStorageAggregateType<T>>

    /**
     * Group by Storage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StorageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StorageGroupByArgs['orderBy'] }
        : { orderBy?: StorageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StorageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStorageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Storage model
   */
  readonly fields: StorageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Storage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StorageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    createdBy<T extends Storage$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Storage$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    editedBy<T extends Storage$editedByArgs<ExtArgs> = {}>(args?: Subset<T, Storage$editedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    inventoryStorage<T extends Storage$inventoryStorageArgs<ExtArgs> = {}>(args?: Subset<T, Storage$inventoryStorageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryStoragePayload<ExtArgs>, T, 'findMany'> | Null>;

    ingredientStorage<T extends Storage$ingredientStorageArgs<ExtArgs> = {}>(args?: Subset<T, Storage$ingredientStorageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientStoragePayload<ExtArgs>, T, 'findMany'> | Null>;

    storageUser<T extends Storage$storageUserArgs<ExtArgs> = {}>(args?: Subset<T, Storage$storageUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorageUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Storage model
   */ 
  interface StorageFieldRefs {
    readonly id: FieldRef<"Storage", 'String'>
    readonly name: FieldRef<"Storage", 'String'>
    readonly description: FieldRef<"Storage", 'String'>
    readonly createdAt: FieldRef<"Storage", 'DateTime'>
    readonly editedAt: FieldRef<"Storage", 'DateTime'>
    readonly createdById: FieldRef<"Storage", 'String'>
    readonly editedById: FieldRef<"Storage", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Storage findUnique
   */
  export type StorageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageInclude<ExtArgs> | null
    /**
     * Filter, which Storage to fetch.
     */
    where: StorageWhereUniqueInput
  }


  /**
   * Storage findUniqueOrThrow
   */
  export type StorageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageInclude<ExtArgs> | null
    /**
     * Filter, which Storage to fetch.
     */
    where: StorageWhereUniqueInput
  }


  /**
   * Storage findFirst
   */
  export type StorageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageInclude<ExtArgs> | null
    /**
     * Filter, which Storage to fetch.
     */
    where?: StorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Storages to fetch.
     */
    orderBy?: StorageOrderByWithRelationInput | StorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Storages.
     */
    cursor?: StorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Storages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Storages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Storages.
     */
    distinct?: StorageScalarFieldEnum | StorageScalarFieldEnum[]
  }


  /**
   * Storage findFirstOrThrow
   */
  export type StorageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageInclude<ExtArgs> | null
    /**
     * Filter, which Storage to fetch.
     */
    where?: StorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Storages to fetch.
     */
    orderBy?: StorageOrderByWithRelationInput | StorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Storages.
     */
    cursor?: StorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Storages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Storages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Storages.
     */
    distinct?: StorageScalarFieldEnum | StorageScalarFieldEnum[]
  }


  /**
   * Storage findMany
   */
  export type StorageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageInclude<ExtArgs> | null
    /**
     * Filter, which Storages to fetch.
     */
    where?: StorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Storages to fetch.
     */
    orderBy?: StorageOrderByWithRelationInput | StorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Storages.
     */
    cursor?: StorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Storages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Storages.
     */
    skip?: number
    distinct?: StorageScalarFieldEnum | StorageScalarFieldEnum[]
  }


  /**
   * Storage create
   */
  export type StorageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageInclude<ExtArgs> | null
    /**
     * The data needed to create a Storage.
     */
    data: XOR<StorageCreateInput, StorageUncheckedCreateInput>
  }


  /**
   * Storage createMany
   */
  export type StorageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Storages.
     */
    data: StorageCreateManyInput | StorageCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Storage update
   */
  export type StorageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageInclude<ExtArgs> | null
    /**
     * The data needed to update a Storage.
     */
    data: XOR<StorageUpdateInput, StorageUncheckedUpdateInput>
    /**
     * Choose, which Storage to update.
     */
    where: StorageWhereUniqueInput
  }


  /**
   * Storage updateMany
   */
  export type StorageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Storages.
     */
    data: XOR<StorageUpdateManyMutationInput, StorageUncheckedUpdateManyInput>
    /**
     * Filter which Storages to update
     */
    where?: StorageWhereInput
  }


  /**
   * Storage upsert
   */
  export type StorageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageInclude<ExtArgs> | null
    /**
     * The filter to search for the Storage to update in case it exists.
     */
    where: StorageWhereUniqueInput
    /**
     * In case the Storage found by the `where` argument doesn't exist, create a new Storage with this data.
     */
    create: XOR<StorageCreateInput, StorageUncheckedCreateInput>
    /**
     * In case the Storage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StorageUpdateInput, StorageUncheckedUpdateInput>
  }


  /**
   * Storage delete
   */
  export type StorageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageInclude<ExtArgs> | null
    /**
     * Filter which Storage to delete.
     */
    where: StorageWhereUniqueInput
  }


  /**
   * Storage deleteMany
   */
  export type StorageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Storages to delete
     */
    where?: StorageWhereInput
  }


  /**
   * Storage.createdBy
   */
  export type Storage$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Storage.editedBy
   */
  export type Storage$editedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Storage.inventoryStorage
   */
  export type Storage$inventoryStorageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     */
    select?: InventoryStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryStorageInclude<ExtArgs> | null
    where?: InventoryStorageWhereInput
    orderBy?: InventoryStorageOrderByWithRelationInput | InventoryStorageOrderByWithRelationInput[]
    cursor?: InventoryStorageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryStorageScalarFieldEnum | InventoryStorageScalarFieldEnum[]
  }


  /**
   * Storage.ingredientStorage
   */
  export type Storage$ingredientStorageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientStorage
     */
    select?: IngredientStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientStorageInclude<ExtArgs> | null
    where?: IngredientStorageWhereInput
    orderBy?: IngredientStorageOrderByWithRelationInput | IngredientStorageOrderByWithRelationInput[]
    cursor?: IngredientStorageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IngredientStorageScalarFieldEnum | IngredientStorageScalarFieldEnum[]
  }


  /**
   * Storage.storageUser
   */
  export type Storage$storageUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageUser
     */
    select?: StorageUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageUserInclude<ExtArgs> | null
    where?: StorageUserWhereInput
    orderBy?: StorageUserOrderByWithRelationInput | StorageUserOrderByWithRelationInput[]
    cursor?: StorageUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StorageUserScalarFieldEnum | StorageUserScalarFieldEnum[]
  }


  /**
   * Storage without action
   */
  export type StorageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageInclude<ExtArgs> | null
  }



  /**
   * Model InventoryStorage
   */

  export type AggregateInventoryStorage = {
    _count: InventoryStorageCountAggregateOutputType | null
    _min: InventoryStorageMinAggregateOutputType | null
    _max: InventoryStorageMaxAggregateOutputType | null
  }

  export type InventoryStorageMinAggregateOutputType = {
    inventoryId: string | null
    storageId: string | null
  }

  export type InventoryStorageMaxAggregateOutputType = {
    inventoryId: string | null
    storageId: string | null
  }

  export type InventoryStorageCountAggregateOutputType = {
    inventoryId: number
    storageId: number
    _all: number
  }


  export type InventoryStorageMinAggregateInputType = {
    inventoryId?: true
    storageId?: true
  }

  export type InventoryStorageMaxAggregateInputType = {
    inventoryId?: true
    storageId?: true
  }

  export type InventoryStorageCountAggregateInputType = {
    inventoryId?: true
    storageId?: true
    _all?: true
  }

  export type InventoryStorageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryStorage to aggregate.
     */
    where?: InventoryStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryStorages to fetch.
     */
    orderBy?: InventoryStorageOrderByWithRelationInput | InventoryStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryStorages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryStorages
    **/
    _count?: true | InventoryStorageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryStorageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryStorageMaxAggregateInputType
  }

  export type GetInventoryStorageAggregateType<T extends InventoryStorageAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryStorage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryStorage[P]>
      : GetScalarType<T[P], AggregateInventoryStorage[P]>
  }




  export type InventoryStorageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryStorageWhereInput
    orderBy?: InventoryStorageOrderByWithAggregationInput | InventoryStorageOrderByWithAggregationInput[]
    by: InventoryStorageScalarFieldEnum[] | InventoryStorageScalarFieldEnum
    having?: InventoryStorageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryStorageCountAggregateInputType | true
    _min?: InventoryStorageMinAggregateInputType
    _max?: InventoryStorageMaxAggregateInputType
  }

  export type InventoryStorageGroupByOutputType = {
    inventoryId: string
    storageId: string
    _count: InventoryStorageCountAggregateOutputType | null
    _min: InventoryStorageMinAggregateOutputType | null
    _max: InventoryStorageMaxAggregateOutputType | null
  }

  type GetInventoryStorageGroupByPayload<T extends InventoryStorageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryStorageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryStorageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryStorageGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryStorageGroupByOutputType[P]>
        }
      >
    >


  export type InventoryStorageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    inventoryId?: boolean
    storageId?: boolean
    storage?: boolean | StorageDefaultArgs<ExtArgs>
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryStorage"]>

  export type InventoryStorageSelectScalar = {
    inventoryId?: boolean
    storageId?: boolean
  }

  export type InventoryStorageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    storage?: boolean | StorageDefaultArgs<ExtArgs>
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
  }


  export type $InventoryStoragePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryStorage"
    objects: {
      storage: Prisma.$StoragePayload<ExtArgs>
      inventory: Prisma.$InventoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      inventoryId: string
      storageId: string
    }, ExtArgs["result"]["inventoryStorage"]>
    composites: {}
  }


  type InventoryStorageGetPayload<S extends boolean | null | undefined | InventoryStorageDefaultArgs> = $Result.GetResult<Prisma.$InventoryStoragePayload, S>

  type InventoryStorageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InventoryStorageFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: InventoryStorageCountAggregateInputType | true
    }

  export interface InventoryStorageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryStorage'], meta: { name: 'InventoryStorage' } }
    /**
     * Find zero or one InventoryStorage that matches the filter.
     * @param {InventoryStorageFindUniqueArgs} args - Arguments to find a InventoryStorage
     * @example
     * // Get one InventoryStorage
     * const inventoryStorage = await prisma.inventoryStorage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InventoryStorageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryStorageFindUniqueArgs<ExtArgs>>
    ): Prisma__InventoryStorageClient<$Result.GetResult<Prisma.$InventoryStoragePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one InventoryStorage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InventoryStorageFindUniqueOrThrowArgs} args - Arguments to find a InventoryStorage
     * @example
     * // Get one InventoryStorage
     * const inventoryStorage = await prisma.inventoryStorage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InventoryStorageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryStorageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InventoryStorageClient<$Result.GetResult<Prisma.$InventoryStoragePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first InventoryStorage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryStorageFindFirstArgs} args - Arguments to find a InventoryStorage
     * @example
     * // Get one InventoryStorage
     * const inventoryStorage = await prisma.inventoryStorage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InventoryStorageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryStorageFindFirstArgs<ExtArgs>>
    ): Prisma__InventoryStorageClient<$Result.GetResult<Prisma.$InventoryStoragePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first InventoryStorage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryStorageFindFirstOrThrowArgs} args - Arguments to find a InventoryStorage
     * @example
     * // Get one InventoryStorage
     * const inventoryStorage = await prisma.inventoryStorage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InventoryStorageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryStorageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InventoryStorageClient<$Result.GetResult<Prisma.$InventoryStoragePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more InventoryStorages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryStorageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryStorages
     * const inventoryStorages = await prisma.inventoryStorage.findMany()
     * 
     * // Get first 10 InventoryStorages
     * const inventoryStorages = await prisma.inventoryStorage.findMany({ take: 10 })
     * 
     * // Only select the `inventoryId`
     * const inventoryStorageWithInventoryIdOnly = await prisma.inventoryStorage.findMany({ select: { inventoryId: true } })
     * 
    **/
    findMany<T extends InventoryStorageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryStorageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryStoragePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a InventoryStorage.
     * @param {InventoryStorageCreateArgs} args - Arguments to create a InventoryStorage.
     * @example
     * // Create one InventoryStorage
     * const InventoryStorage = await prisma.inventoryStorage.create({
     *   data: {
     *     // ... data to create a InventoryStorage
     *   }
     * })
     * 
    **/
    create<T extends InventoryStorageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryStorageCreateArgs<ExtArgs>>
    ): Prisma__InventoryStorageClient<$Result.GetResult<Prisma.$InventoryStoragePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many InventoryStorages.
     *     @param {InventoryStorageCreateManyArgs} args - Arguments to create many InventoryStorages.
     *     @example
     *     // Create many InventoryStorages
     *     const inventoryStorage = await prisma.inventoryStorage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InventoryStorageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryStorageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InventoryStorage.
     * @param {InventoryStorageDeleteArgs} args - Arguments to delete one InventoryStorage.
     * @example
     * // Delete one InventoryStorage
     * const InventoryStorage = await prisma.inventoryStorage.delete({
     *   where: {
     *     // ... filter to delete one InventoryStorage
     *   }
     * })
     * 
    **/
    delete<T extends InventoryStorageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryStorageDeleteArgs<ExtArgs>>
    ): Prisma__InventoryStorageClient<$Result.GetResult<Prisma.$InventoryStoragePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one InventoryStorage.
     * @param {InventoryStorageUpdateArgs} args - Arguments to update one InventoryStorage.
     * @example
     * // Update one InventoryStorage
     * const inventoryStorage = await prisma.inventoryStorage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InventoryStorageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryStorageUpdateArgs<ExtArgs>>
    ): Prisma__InventoryStorageClient<$Result.GetResult<Prisma.$InventoryStoragePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more InventoryStorages.
     * @param {InventoryStorageDeleteManyArgs} args - Arguments to filter InventoryStorages to delete.
     * @example
     * // Delete a few InventoryStorages
     * const { count } = await prisma.inventoryStorage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InventoryStorageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryStorageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryStorages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryStorageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryStorages
     * const inventoryStorage = await prisma.inventoryStorage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InventoryStorageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryStorageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InventoryStorage.
     * @param {InventoryStorageUpsertArgs} args - Arguments to update or create a InventoryStorage.
     * @example
     * // Update or create a InventoryStorage
     * const inventoryStorage = await prisma.inventoryStorage.upsert({
     *   create: {
     *     // ... data to create a InventoryStorage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryStorage we want to update
     *   }
     * })
    **/
    upsert<T extends InventoryStorageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryStorageUpsertArgs<ExtArgs>>
    ): Prisma__InventoryStorageClient<$Result.GetResult<Prisma.$InventoryStoragePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of InventoryStorages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryStorageCountArgs} args - Arguments to filter InventoryStorages to count.
     * @example
     * // Count the number of InventoryStorages
     * const count = await prisma.inventoryStorage.count({
     *   where: {
     *     // ... the filter for the InventoryStorages we want to count
     *   }
     * })
    **/
    count<T extends InventoryStorageCountArgs>(
      args?: Subset<T, InventoryStorageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryStorageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryStorage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryStorageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryStorageAggregateArgs>(args: Subset<T, InventoryStorageAggregateArgs>): Prisma.PrismaPromise<GetInventoryStorageAggregateType<T>>

    /**
     * Group by InventoryStorage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryStorageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryStorageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryStorageGroupByArgs['orderBy'] }
        : { orderBy?: InventoryStorageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryStorageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryStorageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryStorage model
   */
  readonly fields: InventoryStorageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryStorage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryStorageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    storage<T extends StorageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StorageDefaultArgs<ExtArgs>>): Prisma__StorageClient<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    inventory<T extends InventoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryDefaultArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the InventoryStorage model
   */ 
  interface InventoryStorageFieldRefs {
    readonly inventoryId: FieldRef<"InventoryStorage", 'String'>
    readonly storageId: FieldRef<"InventoryStorage", 'String'>
  }
    

  // Custom InputTypes

  /**
   * InventoryStorage findUnique
   */
  export type InventoryStorageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     */
    select?: InventoryStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryStorageInclude<ExtArgs> | null
    /**
     * Filter, which InventoryStorage to fetch.
     */
    where: InventoryStorageWhereUniqueInput
  }


  /**
   * InventoryStorage findUniqueOrThrow
   */
  export type InventoryStorageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     */
    select?: InventoryStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryStorageInclude<ExtArgs> | null
    /**
     * Filter, which InventoryStorage to fetch.
     */
    where: InventoryStorageWhereUniqueInput
  }


  /**
   * InventoryStorage findFirst
   */
  export type InventoryStorageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     */
    select?: InventoryStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryStorageInclude<ExtArgs> | null
    /**
     * Filter, which InventoryStorage to fetch.
     */
    where?: InventoryStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryStorages to fetch.
     */
    orderBy?: InventoryStorageOrderByWithRelationInput | InventoryStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryStorages.
     */
    cursor?: InventoryStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryStorages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryStorages.
     */
    distinct?: InventoryStorageScalarFieldEnum | InventoryStorageScalarFieldEnum[]
  }


  /**
   * InventoryStorage findFirstOrThrow
   */
  export type InventoryStorageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     */
    select?: InventoryStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryStorageInclude<ExtArgs> | null
    /**
     * Filter, which InventoryStorage to fetch.
     */
    where?: InventoryStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryStorages to fetch.
     */
    orderBy?: InventoryStorageOrderByWithRelationInput | InventoryStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryStorages.
     */
    cursor?: InventoryStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryStorages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryStorages.
     */
    distinct?: InventoryStorageScalarFieldEnum | InventoryStorageScalarFieldEnum[]
  }


  /**
   * InventoryStorage findMany
   */
  export type InventoryStorageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     */
    select?: InventoryStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryStorageInclude<ExtArgs> | null
    /**
     * Filter, which InventoryStorages to fetch.
     */
    where?: InventoryStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryStorages to fetch.
     */
    orderBy?: InventoryStorageOrderByWithRelationInput | InventoryStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryStorages.
     */
    cursor?: InventoryStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryStorages.
     */
    skip?: number
    distinct?: InventoryStorageScalarFieldEnum | InventoryStorageScalarFieldEnum[]
  }


  /**
   * InventoryStorage create
   */
  export type InventoryStorageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     */
    select?: InventoryStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryStorageInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryStorage.
     */
    data: XOR<InventoryStorageCreateInput, InventoryStorageUncheckedCreateInput>
  }


  /**
   * InventoryStorage createMany
   */
  export type InventoryStorageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryStorages.
     */
    data: InventoryStorageCreateManyInput | InventoryStorageCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * InventoryStorage update
   */
  export type InventoryStorageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     */
    select?: InventoryStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryStorageInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryStorage.
     */
    data: XOR<InventoryStorageUpdateInput, InventoryStorageUncheckedUpdateInput>
    /**
     * Choose, which InventoryStorage to update.
     */
    where: InventoryStorageWhereUniqueInput
  }


  /**
   * InventoryStorage updateMany
   */
  export type InventoryStorageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryStorages.
     */
    data: XOR<InventoryStorageUpdateManyMutationInput, InventoryStorageUncheckedUpdateManyInput>
    /**
     * Filter which InventoryStorages to update
     */
    where?: InventoryStorageWhereInput
  }


  /**
   * InventoryStorage upsert
   */
  export type InventoryStorageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     */
    select?: InventoryStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryStorageInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryStorage to update in case it exists.
     */
    where: InventoryStorageWhereUniqueInput
    /**
     * In case the InventoryStorage found by the `where` argument doesn't exist, create a new InventoryStorage with this data.
     */
    create: XOR<InventoryStorageCreateInput, InventoryStorageUncheckedCreateInput>
    /**
     * In case the InventoryStorage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryStorageUpdateInput, InventoryStorageUncheckedUpdateInput>
  }


  /**
   * InventoryStorage delete
   */
  export type InventoryStorageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     */
    select?: InventoryStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryStorageInclude<ExtArgs> | null
    /**
     * Filter which InventoryStorage to delete.
     */
    where: InventoryStorageWhereUniqueInput
  }


  /**
   * InventoryStorage deleteMany
   */
  export type InventoryStorageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryStorages to delete
     */
    where?: InventoryStorageWhereInput
  }


  /**
   * InventoryStorage without action
   */
  export type InventoryStorageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     */
    select?: InventoryStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryStorageInclude<ExtArgs> | null
  }



  /**
   * Model IngredientStorage
   */

  export type AggregateIngredientStorage = {
    _count: IngredientStorageCountAggregateOutputType | null
    _avg: IngredientStorageAvgAggregateOutputType | null
    _sum: IngredientStorageSumAggregateOutputType | null
    _min: IngredientStorageMinAggregateOutputType | null
    _max: IngredientStorageMaxAggregateOutputType | null
  }

  export type IngredientStorageAvgAggregateOutputType = {
    quantity: number | null
  }

  export type IngredientStorageSumAggregateOutputType = {
    quantity: number | null
  }

  export type IngredientStorageMinAggregateOutputType = {
    ingredientId: string | null
    storageId: string | null
    quantity: number | null
  }

  export type IngredientStorageMaxAggregateOutputType = {
    ingredientId: string | null
    storageId: string | null
    quantity: number | null
  }

  export type IngredientStorageCountAggregateOutputType = {
    ingredientId: number
    storageId: number
    quantity: number
    _all: number
  }


  export type IngredientStorageAvgAggregateInputType = {
    quantity?: true
  }

  export type IngredientStorageSumAggregateInputType = {
    quantity?: true
  }

  export type IngredientStorageMinAggregateInputType = {
    ingredientId?: true
    storageId?: true
    quantity?: true
  }

  export type IngredientStorageMaxAggregateInputType = {
    ingredientId?: true
    storageId?: true
    quantity?: true
  }

  export type IngredientStorageCountAggregateInputType = {
    ingredientId?: true
    storageId?: true
    quantity?: true
    _all?: true
  }

  export type IngredientStorageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IngredientStorage to aggregate.
     */
    where?: IngredientStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientStorages to fetch.
     */
    orderBy?: IngredientStorageOrderByWithRelationInput | IngredientStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IngredientStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientStorages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IngredientStorages
    **/
    _count?: true | IngredientStorageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IngredientStorageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IngredientStorageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IngredientStorageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IngredientStorageMaxAggregateInputType
  }

  export type GetIngredientStorageAggregateType<T extends IngredientStorageAggregateArgs> = {
        [P in keyof T & keyof AggregateIngredientStorage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIngredientStorage[P]>
      : GetScalarType<T[P], AggregateIngredientStorage[P]>
  }




  export type IngredientStorageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngredientStorageWhereInput
    orderBy?: IngredientStorageOrderByWithAggregationInput | IngredientStorageOrderByWithAggregationInput[]
    by: IngredientStorageScalarFieldEnum[] | IngredientStorageScalarFieldEnum
    having?: IngredientStorageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IngredientStorageCountAggregateInputType | true
    _avg?: IngredientStorageAvgAggregateInputType
    _sum?: IngredientStorageSumAggregateInputType
    _min?: IngredientStorageMinAggregateInputType
    _max?: IngredientStorageMaxAggregateInputType
  }

  export type IngredientStorageGroupByOutputType = {
    ingredientId: string
    storageId: string
    quantity: number | null
    _count: IngredientStorageCountAggregateOutputType | null
    _avg: IngredientStorageAvgAggregateOutputType | null
    _sum: IngredientStorageSumAggregateOutputType | null
    _min: IngredientStorageMinAggregateOutputType | null
    _max: IngredientStorageMaxAggregateOutputType | null
  }

  type GetIngredientStorageGroupByPayload<T extends IngredientStorageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IngredientStorageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IngredientStorageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IngredientStorageGroupByOutputType[P]>
            : GetScalarType<T[P], IngredientStorageGroupByOutputType[P]>
        }
      >
    >


  export type IngredientStorageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ingredientId?: boolean
    storageId?: boolean
    quantity?: boolean
    ingredient?: boolean | SpecificIngredientDefaultArgs<ExtArgs>
    Storage?: boolean | StorageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ingredientStorage"]>

  export type IngredientStorageSelectScalar = {
    ingredientId?: boolean
    storageId?: boolean
    quantity?: boolean
  }

  export type IngredientStorageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ingredient?: boolean | SpecificIngredientDefaultArgs<ExtArgs>
    Storage?: boolean | StorageDefaultArgs<ExtArgs>
  }


  export type $IngredientStoragePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IngredientStorage"
    objects: {
      ingredient: Prisma.$SpecificIngredientPayload<ExtArgs>
      Storage: Prisma.$StoragePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ingredientId: string
      storageId: string
      quantity: number | null
    }, ExtArgs["result"]["ingredientStorage"]>
    composites: {}
  }


  type IngredientStorageGetPayload<S extends boolean | null | undefined | IngredientStorageDefaultArgs> = $Result.GetResult<Prisma.$IngredientStoragePayload, S>

  type IngredientStorageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IngredientStorageFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: IngredientStorageCountAggregateInputType | true
    }

  export interface IngredientStorageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IngredientStorage'], meta: { name: 'IngredientStorage' } }
    /**
     * Find zero or one IngredientStorage that matches the filter.
     * @param {IngredientStorageFindUniqueArgs} args - Arguments to find a IngredientStorage
     * @example
     * // Get one IngredientStorage
     * const ingredientStorage = await prisma.ingredientStorage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IngredientStorageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientStorageFindUniqueArgs<ExtArgs>>
    ): Prisma__IngredientStorageClient<$Result.GetResult<Prisma.$IngredientStoragePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one IngredientStorage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {IngredientStorageFindUniqueOrThrowArgs} args - Arguments to find a IngredientStorage
     * @example
     * // Get one IngredientStorage
     * const ingredientStorage = await prisma.ingredientStorage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends IngredientStorageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientStorageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__IngredientStorageClient<$Result.GetResult<Prisma.$IngredientStoragePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first IngredientStorage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientStorageFindFirstArgs} args - Arguments to find a IngredientStorage
     * @example
     * // Get one IngredientStorage
     * const ingredientStorage = await prisma.ingredientStorage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IngredientStorageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientStorageFindFirstArgs<ExtArgs>>
    ): Prisma__IngredientStorageClient<$Result.GetResult<Prisma.$IngredientStoragePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first IngredientStorage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientStorageFindFirstOrThrowArgs} args - Arguments to find a IngredientStorage
     * @example
     * // Get one IngredientStorage
     * const ingredientStorage = await prisma.ingredientStorage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends IngredientStorageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientStorageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__IngredientStorageClient<$Result.GetResult<Prisma.$IngredientStoragePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more IngredientStorages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientStorageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IngredientStorages
     * const ingredientStorages = await prisma.ingredientStorage.findMany()
     * 
     * // Get first 10 IngredientStorages
     * const ingredientStorages = await prisma.ingredientStorage.findMany({ take: 10 })
     * 
     * // Only select the `ingredientId`
     * const ingredientStorageWithIngredientIdOnly = await prisma.ingredientStorage.findMany({ select: { ingredientId: true } })
     * 
    **/
    findMany<T extends IngredientStorageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientStorageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientStoragePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a IngredientStorage.
     * @param {IngredientStorageCreateArgs} args - Arguments to create a IngredientStorage.
     * @example
     * // Create one IngredientStorage
     * const IngredientStorage = await prisma.ingredientStorage.create({
     *   data: {
     *     // ... data to create a IngredientStorage
     *   }
     * })
     * 
    **/
    create<T extends IngredientStorageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientStorageCreateArgs<ExtArgs>>
    ): Prisma__IngredientStorageClient<$Result.GetResult<Prisma.$IngredientStoragePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many IngredientStorages.
     *     @param {IngredientStorageCreateManyArgs} args - Arguments to create many IngredientStorages.
     *     @example
     *     // Create many IngredientStorages
     *     const ingredientStorage = await prisma.ingredientStorage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IngredientStorageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientStorageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a IngredientStorage.
     * @param {IngredientStorageDeleteArgs} args - Arguments to delete one IngredientStorage.
     * @example
     * // Delete one IngredientStorage
     * const IngredientStorage = await prisma.ingredientStorage.delete({
     *   where: {
     *     // ... filter to delete one IngredientStorage
     *   }
     * })
     * 
    **/
    delete<T extends IngredientStorageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientStorageDeleteArgs<ExtArgs>>
    ): Prisma__IngredientStorageClient<$Result.GetResult<Prisma.$IngredientStoragePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one IngredientStorage.
     * @param {IngredientStorageUpdateArgs} args - Arguments to update one IngredientStorage.
     * @example
     * // Update one IngredientStorage
     * const ingredientStorage = await prisma.ingredientStorage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IngredientStorageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientStorageUpdateArgs<ExtArgs>>
    ): Prisma__IngredientStorageClient<$Result.GetResult<Prisma.$IngredientStoragePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more IngredientStorages.
     * @param {IngredientStorageDeleteManyArgs} args - Arguments to filter IngredientStorages to delete.
     * @example
     * // Delete a few IngredientStorages
     * const { count } = await prisma.ingredientStorage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IngredientStorageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientStorageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IngredientStorages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientStorageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IngredientStorages
     * const ingredientStorage = await prisma.ingredientStorage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IngredientStorageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientStorageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IngredientStorage.
     * @param {IngredientStorageUpsertArgs} args - Arguments to update or create a IngredientStorage.
     * @example
     * // Update or create a IngredientStorage
     * const ingredientStorage = await prisma.ingredientStorage.upsert({
     *   create: {
     *     // ... data to create a IngredientStorage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IngredientStorage we want to update
     *   }
     * })
    **/
    upsert<T extends IngredientStorageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientStorageUpsertArgs<ExtArgs>>
    ): Prisma__IngredientStorageClient<$Result.GetResult<Prisma.$IngredientStoragePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of IngredientStorages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientStorageCountArgs} args - Arguments to filter IngredientStorages to count.
     * @example
     * // Count the number of IngredientStorages
     * const count = await prisma.ingredientStorage.count({
     *   where: {
     *     // ... the filter for the IngredientStorages we want to count
     *   }
     * })
    **/
    count<T extends IngredientStorageCountArgs>(
      args?: Subset<T, IngredientStorageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IngredientStorageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IngredientStorage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientStorageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IngredientStorageAggregateArgs>(args: Subset<T, IngredientStorageAggregateArgs>): Prisma.PrismaPromise<GetIngredientStorageAggregateType<T>>

    /**
     * Group by IngredientStorage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientStorageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IngredientStorageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IngredientStorageGroupByArgs['orderBy'] }
        : { orderBy?: IngredientStorageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IngredientStorageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIngredientStorageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IngredientStorage model
   */
  readonly fields: IngredientStorageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IngredientStorage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IngredientStorageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    ingredient<T extends SpecificIngredientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpecificIngredientDefaultArgs<ExtArgs>>): Prisma__SpecificIngredientClient<$Result.GetResult<Prisma.$SpecificIngredientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Storage<T extends StorageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StorageDefaultArgs<ExtArgs>>): Prisma__StorageClient<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the IngredientStorage model
   */ 
  interface IngredientStorageFieldRefs {
    readonly ingredientId: FieldRef<"IngredientStorage", 'String'>
    readonly storageId: FieldRef<"IngredientStorage", 'String'>
    readonly quantity: FieldRef<"IngredientStorage", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * IngredientStorage findUnique
   */
  export type IngredientStorageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientStorage
     */
    select?: IngredientStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientStorageInclude<ExtArgs> | null
    /**
     * Filter, which IngredientStorage to fetch.
     */
    where: IngredientStorageWhereUniqueInput
  }


  /**
   * IngredientStorage findUniqueOrThrow
   */
  export type IngredientStorageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientStorage
     */
    select?: IngredientStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientStorageInclude<ExtArgs> | null
    /**
     * Filter, which IngredientStorage to fetch.
     */
    where: IngredientStorageWhereUniqueInput
  }


  /**
   * IngredientStorage findFirst
   */
  export type IngredientStorageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientStorage
     */
    select?: IngredientStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientStorageInclude<ExtArgs> | null
    /**
     * Filter, which IngredientStorage to fetch.
     */
    where?: IngredientStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientStorages to fetch.
     */
    orderBy?: IngredientStorageOrderByWithRelationInput | IngredientStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IngredientStorages.
     */
    cursor?: IngredientStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientStorages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IngredientStorages.
     */
    distinct?: IngredientStorageScalarFieldEnum | IngredientStorageScalarFieldEnum[]
  }


  /**
   * IngredientStorage findFirstOrThrow
   */
  export type IngredientStorageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientStorage
     */
    select?: IngredientStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientStorageInclude<ExtArgs> | null
    /**
     * Filter, which IngredientStorage to fetch.
     */
    where?: IngredientStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientStorages to fetch.
     */
    orderBy?: IngredientStorageOrderByWithRelationInput | IngredientStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IngredientStorages.
     */
    cursor?: IngredientStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientStorages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IngredientStorages.
     */
    distinct?: IngredientStorageScalarFieldEnum | IngredientStorageScalarFieldEnum[]
  }


  /**
   * IngredientStorage findMany
   */
  export type IngredientStorageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientStorage
     */
    select?: IngredientStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientStorageInclude<ExtArgs> | null
    /**
     * Filter, which IngredientStorages to fetch.
     */
    where?: IngredientStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientStorages to fetch.
     */
    orderBy?: IngredientStorageOrderByWithRelationInput | IngredientStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IngredientStorages.
     */
    cursor?: IngredientStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientStorages.
     */
    skip?: number
    distinct?: IngredientStorageScalarFieldEnum | IngredientStorageScalarFieldEnum[]
  }


  /**
   * IngredientStorage create
   */
  export type IngredientStorageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientStorage
     */
    select?: IngredientStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientStorageInclude<ExtArgs> | null
    /**
     * The data needed to create a IngredientStorage.
     */
    data: XOR<IngredientStorageCreateInput, IngredientStorageUncheckedCreateInput>
  }


  /**
   * IngredientStorage createMany
   */
  export type IngredientStorageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IngredientStorages.
     */
    data: IngredientStorageCreateManyInput | IngredientStorageCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * IngredientStorage update
   */
  export type IngredientStorageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientStorage
     */
    select?: IngredientStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientStorageInclude<ExtArgs> | null
    /**
     * The data needed to update a IngredientStorage.
     */
    data: XOR<IngredientStorageUpdateInput, IngredientStorageUncheckedUpdateInput>
    /**
     * Choose, which IngredientStorage to update.
     */
    where: IngredientStorageWhereUniqueInput
  }


  /**
   * IngredientStorage updateMany
   */
  export type IngredientStorageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IngredientStorages.
     */
    data: XOR<IngredientStorageUpdateManyMutationInput, IngredientStorageUncheckedUpdateManyInput>
    /**
     * Filter which IngredientStorages to update
     */
    where?: IngredientStorageWhereInput
  }


  /**
   * IngredientStorage upsert
   */
  export type IngredientStorageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientStorage
     */
    select?: IngredientStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientStorageInclude<ExtArgs> | null
    /**
     * The filter to search for the IngredientStorage to update in case it exists.
     */
    where: IngredientStorageWhereUniqueInput
    /**
     * In case the IngredientStorage found by the `where` argument doesn't exist, create a new IngredientStorage with this data.
     */
    create: XOR<IngredientStorageCreateInput, IngredientStorageUncheckedCreateInput>
    /**
     * In case the IngredientStorage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IngredientStorageUpdateInput, IngredientStorageUncheckedUpdateInput>
  }


  /**
   * IngredientStorage delete
   */
  export type IngredientStorageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientStorage
     */
    select?: IngredientStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientStorageInclude<ExtArgs> | null
    /**
     * Filter which IngredientStorage to delete.
     */
    where: IngredientStorageWhereUniqueInput
  }


  /**
   * IngredientStorage deleteMany
   */
  export type IngredientStorageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IngredientStorages to delete
     */
    where?: IngredientStorageWhereInput
  }


  /**
   * IngredientStorage without action
   */
  export type IngredientStorageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientStorage
     */
    select?: IngredientStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientStorageInclude<ExtArgs> | null
  }



  /**
   * Model StorageUser
   */

  export type AggregateStorageUser = {
    _count: StorageUserCountAggregateOutputType | null
    _min: StorageUserMinAggregateOutputType | null
    _max: StorageUserMaxAggregateOutputType | null
  }

  export type StorageUserMinAggregateOutputType = {
    userId: string | null
    storageId: string | null
    permission: string | null
  }

  export type StorageUserMaxAggregateOutputType = {
    userId: string | null
    storageId: string | null
    permission: string | null
  }

  export type StorageUserCountAggregateOutputType = {
    userId: number
    storageId: number
    permission: number
    _all: number
  }


  export type StorageUserMinAggregateInputType = {
    userId?: true
    storageId?: true
    permission?: true
  }

  export type StorageUserMaxAggregateInputType = {
    userId?: true
    storageId?: true
    permission?: true
  }

  export type StorageUserCountAggregateInputType = {
    userId?: true
    storageId?: true
    permission?: true
    _all?: true
  }

  export type StorageUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StorageUser to aggregate.
     */
    where?: StorageUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageUsers to fetch.
     */
    orderBy?: StorageUserOrderByWithRelationInput | StorageUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StorageUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StorageUsers
    **/
    _count?: true | StorageUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StorageUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StorageUserMaxAggregateInputType
  }

  export type GetStorageUserAggregateType<T extends StorageUserAggregateArgs> = {
        [P in keyof T & keyof AggregateStorageUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStorageUser[P]>
      : GetScalarType<T[P], AggregateStorageUser[P]>
  }




  export type StorageUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorageUserWhereInput
    orderBy?: StorageUserOrderByWithAggregationInput | StorageUserOrderByWithAggregationInput[]
    by: StorageUserScalarFieldEnum[] | StorageUserScalarFieldEnum
    having?: StorageUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StorageUserCountAggregateInputType | true
    _min?: StorageUserMinAggregateInputType
    _max?: StorageUserMaxAggregateInputType
  }

  export type StorageUserGroupByOutputType = {
    userId: string
    storageId: string
    permission: string
    _count: StorageUserCountAggregateOutputType | null
    _min: StorageUserMinAggregateOutputType | null
    _max: StorageUserMaxAggregateOutputType | null
  }

  type GetStorageUserGroupByPayload<T extends StorageUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StorageUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StorageUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StorageUserGroupByOutputType[P]>
            : GetScalarType<T[P], StorageUserGroupByOutputType[P]>
        }
      >
    >


  export type StorageUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    storageId?: boolean
    permission?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    Storage?: boolean | StorageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storageUser"]>

  export type StorageUserSelectScalar = {
    userId?: boolean
    storageId?: boolean
    permission?: boolean
  }

  export type StorageUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    Storage?: boolean | StorageDefaultArgs<ExtArgs>
  }


  export type $StorageUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StorageUser"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      Storage: Prisma.$StoragePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      storageId: string
      permission: string
    }, ExtArgs["result"]["storageUser"]>
    composites: {}
  }


  type StorageUserGetPayload<S extends boolean | null | undefined | StorageUserDefaultArgs> = $Result.GetResult<Prisma.$StorageUserPayload, S>

  type StorageUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StorageUserFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: StorageUserCountAggregateInputType | true
    }

  export interface StorageUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StorageUser'], meta: { name: 'StorageUser' } }
    /**
     * Find zero or one StorageUser that matches the filter.
     * @param {StorageUserFindUniqueArgs} args - Arguments to find a StorageUser
     * @example
     * // Get one StorageUser
     * const storageUser = await prisma.storageUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StorageUserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StorageUserFindUniqueArgs<ExtArgs>>
    ): Prisma__StorageUserClient<$Result.GetResult<Prisma.$StorageUserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StorageUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StorageUserFindUniqueOrThrowArgs} args - Arguments to find a StorageUser
     * @example
     * // Get one StorageUser
     * const storageUser = await prisma.storageUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StorageUserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StorageUserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StorageUserClient<$Result.GetResult<Prisma.$StorageUserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StorageUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageUserFindFirstArgs} args - Arguments to find a StorageUser
     * @example
     * // Get one StorageUser
     * const storageUser = await prisma.storageUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StorageUserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StorageUserFindFirstArgs<ExtArgs>>
    ): Prisma__StorageUserClient<$Result.GetResult<Prisma.$StorageUserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StorageUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageUserFindFirstOrThrowArgs} args - Arguments to find a StorageUser
     * @example
     * // Get one StorageUser
     * const storageUser = await prisma.storageUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StorageUserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StorageUserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StorageUserClient<$Result.GetResult<Prisma.$StorageUserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StorageUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StorageUsers
     * const storageUsers = await prisma.storageUser.findMany()
     * 
     * // Get first 10 StorageUsers
     * const storageUsers = await prisma.storageUser.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const storageUserWithUserIdOnly = await prisma.storageUser.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends StorageUserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StorageUserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorageUserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StorageUser.
     * @param {StorageUserCreateArgs} args - Arguments to create a StorageUser.
     * @example
     * // Create one StorageUser
     * const StorageUser = await prisma.storageUser.create({
     *   data: {
     *     // ... data to create a StorageUser
     *   }
     * })
     * 
    **/
    create<T extends StorageUserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StorageUserCreateArgs<ExtArgs>>
    ): Prisma__StorageUserClient<$Result.GetResult<Prisma.$StorageUserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StorageUsers.
     *     @param {StorageUserCreateManyArgs} args - Arguments to create many StorageUsers.
     *     @example
     *     // Create many StorageUsers
     *     const storageUser = await prisma.storageUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StorageUserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StorageUserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StorageUser.
     * @param {StorageUserDeleteArgs} args - Arguments to delete one StorageUser.
     * @example
     * // Delete one StorageUser
     * const StorageUser = await prisma.storageUser.delete({
     *   where: {
     *     // ... filter to delete one StorageUser
     *   }
     * })
     * 
    **/
    delete<T extends StorageUserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StorageUserDeleteArgs<ExtArgs>>
    ): Prisma__StorageUserClient<$Result.GetResult<Prisma.$StorageUserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StorageUser.
     * @param {StorageUserUpdateArgs} args - Arguments to update one StorageUser.
     * @example
     * // Update one StorageUser
     * const storageUser = await prisma.storageUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StorageUserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StorageUserUpdateArgs<ExtArgs>>
    ): Prisma__StorageUserClient<$Result.GetResult<Prisma.$StorageUserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StorageUsers.
     * @param {StorageUserDeleteManyArgs} args - Arguments to filter StorageUsers to delete.
     * @example
     * // Delete a few StorageUsers
     * const { count } = await prisma.storageUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StorageUserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StorageUserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StorageUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StorageUsers
     * const storageUser = await prisma.storageUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StorageUserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StorageUserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StorageUser.
     * @param {StorageUserUpsertArgs} args - Arguments to update or create a StorageUser.
     * @example
     * // Update or create a StorageUser
     * const storageUser = await prisma.storageUser.upsert({
     *   create: {
     *     // ... data to create a StorageUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StorageUser we want to update
     *   }
     * })
    **/
    upsert<T extends StorageUserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StorageUserUpsertArgs<ExtArgs>>
    ): Prisma__StorageUserClient<$Result.GetResult<Prisma.$StorageUserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StorageUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageUserCountArgs} args - Arguments to filter StorageUsers to count.
     * @example
     * // Count the number of StorageUsers
     * const count = await prisma.storageUser.count({
     *   where: {
     *     // ... the filter for the StorageUsers we want to count
     *   }
     * })
    **/
    count<T extends StorageUserCountArgs>(
      args?: Subset<T, StorageUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StorageUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StorageUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StorageUserAggregateArgs>(args: Subset<T, StorageUserAggregateArgs>): Prisma.PrismaPromise<GetStorageUserAggregateType<T>>

    /**
     * Group by StorageUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StorageUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StorageUserGroupByArgs['orderBy'] }
        : { orderBy?: StorageUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StorageUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStorageUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StorageUser model
   */
  readonly fields: StorageUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StorageUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StorageUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Storage<T extends StorageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StorageDefaultArgs<ExtArgs>>): Prisma__StorageClient<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StorageUser model
   */ 
  interface StorageUserFieldRefs {
    readonly userId: FieldRef<"StorageUser", 'String'>
    readonly storageId: FieldRef<"StorageUser", 'String'>
    readonly permission: FieldRef<"StorageUser", 'String'>
  }
    

  // Custom InputTypes

  /**
   * StorageUser findUnique
   */
  export type StorageUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageUser
     */
    select?: StorageUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageUserInclude<ExtArgs> | null
    /**
     * Filter, which StorageUser to fetch.
     */
    where: StorageUserWhereUniqueInput
  }


  /**
   * StorageUser findUniqueOrThrow
   */
  export type StorageUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageUser
     */
    select?: StorageUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageUserInclude<ExtArgs> | null
    /**
     * Filter, which StorageUser to fetch.
     */
    where: StorageUserWhereUniqueInput
  }


  /**
   * StorageUser findFirst
   */
  export type StorageUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageUser
     */
    select?: StorageUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageUserInclude<ExtArgs> | null
    /**
     * Filter, which StorageUser to fetch.
     */
    where?: StorageUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageUsers to fetch.
     */
    orderBy?: StorageUserOrderByWithRelationInput | StorageUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StorageUsers.
     */
    cursor?: StorageUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StorageUsers.
     */
    distinct?: StorageUserScalarFieldEnum | StorageUserScalarFieldEnum[]
  }


  /**
   * StorageUser findFirstOrThrow
   */
  export type StorageUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageUser
     */
    select?: StorageUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageUserInclude<ExtArgs> | null
    /**
     * Filter, which StorageUser to fetch.
     */
    where?: StorageUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageUsers to fetch.
     */
    orderBy?: StorageUserOrderByWithRelationInput | StorageUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StorageUsers.
     */
    cursor?: StorageUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StorageUsers.
     */
    distinct?: StorageUserScalarFieldEnum | StorageUserScalarFieldEnum[]
  }


  /**
   * StorageUser findMany
   */
  export type StorageUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageUser
     */
    select?: StorageUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageUserInclude<ExtArgs> | null
    /**
     * Filter, which StorageUsers to fetch.
     */
    where?: StorageUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageUsers to fetch.
     */
    orderBy?: StorageUserOrderByWithRelationInput | StorageUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StorageUsers.
     */
    cursor?: StorageUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageUsers.
     */
    skip?: number
    distinct?: StorageUserScalarFieldEnum | StorageUserScalarFieldEnum[]
  }


  /**
   * StorageUser create
   */
  export type StorageUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageUser
     */
    select?: StorageUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageUserInclude<ExtArgs> | null
    /**
     * The data needed to create a StorageUser.
     */
    data: XOR<StorageUserCreateInput, StorageUserUncheckedCreateInput>
  }


  /**
   * StorageUser createMany
   */
  export type StorageUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StorageUsers.
     */
    data: StorageUserCreateManyInput | StorageUserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * StorageUser update
   */
  export type StorageUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageUser
     */
    select?: StorageUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageUserInclude<ExtArgs> | null
    /**
     * The data needed to update a StorageUser.
     */
    data: XOR<StorageUserUpdateInput, StorageUserUncheckedUpdateInput>
    /**
     * Choose, which StorageUser to update.
     */
    where: StorageUserWhereUniqueInput
  }


  /**
   * StorageUser updateMany
   */
  export type StorageUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StorageUsers.
     */
    data: XOR<StorageUserUpdateManyMutationInput, StorageUserUncheckedUpdateManyInput>
    /**
     * Filter which StorageUsers to update
     */
    where?: StorageUserWhereInput
  }


  /**
   * StorageUser upsert
   */
  export type StorageUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageUser
     */
    select?: StorageUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageUserInclude<ExtArgs> | null
    /**
     * The filter to search for the StorageUser to update in case it exists.
     */
    where: StorageUserWhereUniqueInput
    /**
     * In case the StorageUser found by the `where` argument doesn't exist, create a new StorageUser with this data.
     */
    create: XOR<StorageUserCreateInput, StorageUserUncheckedCreateInput>
    /**
     * In case the StorageUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StorageUserUpdateInput, StorageUserUncheckedUpdateInput>
  }


  /**
   * StorageUser delete
   */
  export type StorageUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageUser
     */
    select?: StorageUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageUserInclude<ExtArgs> | null
    /**
     * Filter which StorageUser to delete.
     */
    where: StorageUserWhereUniqueInput
  }


  /**
   * StorageUser deleteMany
   */
  export type StorageUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StorageUsers to delete
     */
    where?: StorageUserWhereInput
  }


  /**
   * StorageUser without action
   */
  export type StorageUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageUser
     */
    select?: StorageUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageUserInclude<ExtArgs> | null
  }



  /**
   * Model Crew
   */

  export type AggregateCrew = {
    _count: CrewCountAggregateOutputType | null
    _min: CrewMinAggregateOutputType | null
    _max: CrewMaxAggregateOutputType | null
  }

  export type CrewMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
  }

  export type CrewMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
  }

  export type CrewCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    editedAt: number
    createdById: number
    editedById: number
    _all: number
  }


  export type CrewMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
  }

  export type CrewMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
  }

  export type CrewCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
    _all?: true
  }

  export type CrewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Crew to aggregate.
     */
    where?: CrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crews to fetch.
     */
    orderBy?: CrewOrderByWithRelationInput | CrewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Crews
    **/
    _count?: true | CrewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrewMaxAggregateInputType
  }

  export type GetCrewAggregateType<T extends CrewAggregateArgs> = {
        [P in keyof T & keyof AggregateCrew]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrew[P]>
      : GetScalarType<T[P], AggregateCrew[P]>
  }




  export type CrewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewWhereInput
    orderBy?: CrewOrderByWithAggregationInput | CrewOrderByWithAggregationInput[]
    by: CrewScalarFieldEnum[] | CrewScalarFieldEnum
    having?: CrewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrewCountAggregateInputType | true
    _min?: CrewMinAggregateInputType
    _max?: CrewMaxAggregateInputType
  }

  export type CrewGroupByOutputType = {
    id: string
    name: string
    description: string
    createdAt: Date
    editedAt: Date
    createdById: string
    editedById: string
    _count: CrewCountAggregateOutputType | null
    _min: CrewMinAggregateOutputType | null
    _max: CrewMaxAggregateOutputType | null
  }

  type GetCrewGroupByPayload<T extends CrewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrewGroupByOutputType[P]>
            : GetScalarType<T[P], CrewGroupByOutputType[P]>
        }
      >
    >


  export type CrewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    editedAt?: boolean
    createdById?: boolean
    editedById?: boolean
    createdBy?: boolean | Crew$createdByArgs<ExtArgs>
    editedBy?: boolean | Crew$editedByArgs<ExtArgs>
    userCrew?: boolean | Crew$userCrewArgs<ExtArgs>
    _count?: boolean | CrewCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crew"]>

  export type CrewSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    editedAt?: boolean
    createdById?: boolean
    editedById?: boolean
  }

  export type CrewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Crew$createdByArgs<ExtArgs>
    editedBy?: boolean | Crew$editedByArgs<ExtArgs>
    userCrew?: boolean | Crew$userCrewArgs<ExtArgs>
    _count?: boolean | CrewCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CrewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Crew"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      editedBy: Prisma.$UserPayload<ExtArgs> | null
      userCrew: Prisma.$CrewUserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      createdAt: Date
      editedAt: Date
      createdById: string
      editedById: string
    }, ExtArgs["result"]["crew"]>
    composites: {}
  }


  type CrewGetPayload<S extends boolean | null | undefined | CrewDefaultArgs> = $Result.GetResult<Prisma.$CrewPayload, S>

  type CrewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CrewFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CrewCountAggregateInputType | true
    }

  export interface CrewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Crew'], meta: { name: 'Crew' } }
    /**
     * Find zero or one Crew that matches the filter.
     * @param {CrewFindUniqueArgs} args - Arguments to find a Crew
     * @example
     * // Get one Crew
     * const crew = await prisma.crew.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CrewFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CrewFindUniqueArgs<ExtArgs>>
    ): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Crew that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CrewFindUniqueOrThrowArgs} args - Arguments to find a Crew
     * @example
     * // Get one Crew
     * const crew = await prisma.crew.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CrewFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Crew that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewFindFirstArgs} args - Arguments to find a Crew
     * @example
     * // Get one Crew
     * const crew = await prisma.crew.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CrewFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewFindFirstArgs<ExtArgs>>
    ): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Crew that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewFindFirstOrThrowArgs} args - Arguments to find a Crew
     * @example
     * // Get one Crew
     * const crew = await prisma.crew.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CrewFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Crews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Crews
     * const crews = await prisma.crew.findMany()
     * 
     * // Get first 10 Crews
     * const crews = await prisma.crew.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const crewWithIdOnly = await prisma.crew.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CrewFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Crew.
     * @param {CrewCreateArgs} args - Arguments to create a Crew.
     * @example
     * // Create one Crew
     * const Crew = await prisma.crew.create({
     *   data: {
     *     // ... data to create a Crew
     *   }
     * })
     * 
    **/
    create<T extends CrewCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CrewCreateArgs<ExtArgs>>
    ): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Crews.
     *     @param {CrewCreateManyArgs} args - Arguments to create many Crews.
     *     @example
     *     // Create many Crews
     *     const crew = await prisma.crew.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CrewCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Crew.
     * @param {CrewDeleteArgs} args - Arguments to delete one Crew.
     * @example
     * // Delete one Crew
     * const Crew = await prisma.crew.delete({
     *   where: {
     *     // ... filter to delete one Crew
     *   }
     * })
     * 
    **/
    delete<T extends CrewDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CrewDeleteArgs<ExtArgs>>
    ): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Crew.
     * @param {CrewUpdateArgs} args - Arguments to update one Crew.
     * @example
     * // Update one Crew
     * const crew = await prisma.crew.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CrewUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CrewUpdateArgs<ExtArgs>>
    ): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Crews.
     * @param {CrewDeleteManyArgs} args - Arguments to filter Crews to delete.
     * @example
     * // Delete a few Crews
     * const { count } = await prisma.crew.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CrewDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Crews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Crews
     * const crew = await prisma.crew.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CrewUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CrewUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Crew.
     * @param {CrewUpsertArgs} args - Arguments to update or create a Crew.
     * @example
     * // Update or create a Crew
     * const crew = await prisma.crew.upsert({
     *   create: {
     *     // ... data to create a Crew
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Crew we want to update
     *   }
     * })
    **/
    upsert<T extends CrewUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CrewUpsertArgs<ExtArgs>>
    ): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Crews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewCountArgs} args - Arguments to filter Crews to count.
     * @example
     * // Count the number of Crews
     * const count = await prisma.crew.count({
     *   where: {
     *     // ... the filter for the Crews we want to count
     *   }
     * })
    **/
    count<T extends CrewCountArgs>(
      args?: Subset<T, CrewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Crew.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrewAggregateArgs>(args: Subset<T, CrewAggregateArgs>): Prisma.PrismaPromise<GetCrewAggregateType<T>>

    /**
     * Group by Crew.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrewGroupByArgs['orderBy'] }
        : { orderBy?: CrewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Crew model
   */
  readonly fields: CrewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Crew.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CrewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    createdBy<T extends Crew$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Crew$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    editedBy<T extends Crew$editedByArgs<ExtArgs> = {}>(args?: Subset<T, Crew$editedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    userCrew<T extends Crew$userCrewArgs<ExtArgs> = {}>(args?: Subset<T, Crew$userCrewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Crew model
   */ 
  interface CrewFieldRefs {
    readonly id: FieldRef<"Crew", 'String'>
    readonly name: FieldRef<"Crew", 'String'>
    readonly description: FieldRef<"Crew", 'String'>
    readonly createdAt: FieldRef<"Crew", 'DateTime'>
    readonly editedAt: FieldRef<"Crew", 'DateTime'>
    readonly createdById: FieldRef<"Crew", 'String'>
    readonly editedById: FieldRef<"Crew", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Crew findUnique
   */
  export type CrewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * Filter, which Crew to fetch.
     */
    where: CrewWhereUniqueInput
  }


  /**
   * Crew findUniqueOrThrow
   */
  export type CrewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * Filter, which Crew to fetch.
     */
    where: CrewWhereUniqueInput
  }


  /**
   * Crew findFirst
   */
  export type CrewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * Filter, which Crew to fetch.
     */
    where?: CrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crews to fetch.
     */
    orderBy?: CrewOrderByWithRelationInput | CrewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Crews.
     */
    cursor?: CrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Crews.
     */
    distinct?: CrewScalarFieldEnum | CrewScalarFieldEnum[]
  }


  /**
   * Crew findFirstOrThrow
   */
  export type CrewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * Filter, which Crew to fetch.
     */
    where?: CrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crews to fetch.
     */
    orderBy?: CrewOrderByWithRelationInput | CrewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Crews.
     */
    cursor?: CrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Crews.
     */
    distinct?: CrewScalarFieldEnum | CrewScalarFieldEnum[]
  }


  /**
   * Crew findMany
   */
  export type CrewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * Filter, which Crews to fetch.
     */
    where?: CrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crews to fetch.
     */
    orderBy?: CrewOrderByWithRelationInput | CrewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Crews.
     */
    cursor?: CrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crews.
     */
    skip?: number
    distinct?: CrewScalarFieldEnum | CrewScalarFieldEnum[]
  }


  /**
   * Crew create
   */
  export type CrewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * The data needed to create a Crew.
     */
    data: XOR<CrewCreateInput, CrewUncheckedCreateInput>
  }


  /**
   * Crew createMany
   */
  export type CrewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Crews.
     */
    data: CrewCreateManyInput | CrewCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Crew update
   */
  export type CrewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * The data needed to update a Crew.
     */
    data: XOR<CrewUpdateInput, CrewUncheckedUpdateInput>
    /**
     * Choose, which Crew to update.
     */
    where: CrewWhereUniqueInput
  }


  /**
   * Crew updateMany
   */
  export type CrewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Crews.
     */
    data: XOR<CrewUpdateManyMutationInput, CrewUncheckedUpdateManyInput>
    /**
     * Filter which Crews to update
     */
    where?: CrewWhereInput
  }


  /**
   * Crew upsert
   */
  export type CrewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * The filter to search for the Crew to update in case it exists.
     */
    where: CrewWhereUniqueInput
    /**
     * In case the Crew found by the `where` argument doesn't exist, create a new Crew with this data.
     */
    create: XOR<CrewCreateInput, CrewUncheckedCreateInput>
    /**
     * In case the Crew was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CrewUpdateInput, CrewUncheckedUpdateInput>
  }


  /**
   * Crew delete
   */
  export type CrewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * Filter which Crew to delete.
     */
    where: CrewWhereUniqueInput
  }


  /**
   * Crew deleteMany
   */
  export type CrewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Crews to delete
     */
    where?: CrewWhereInput
  }


  /**
   * Crew.createdBy
   */
  export type Crew$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Crew.editedBy
   */
  export type Crew$editedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Crew.userCrew
   */
  export type Crew$userCrewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewUser
     */
    select?: CrewUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewUserInclude<ExtArgs> | null
    where?: CrewUserWhereInput
    orderBy?: CrewUserOrderByWithRelationInput | CrewUserOrderByWithRelationInput[]
    cursor?: CrewUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrewUserScalarFieldEnum | CrewUserScalarFieldEnum[]
  }


  /**
   * Crew without action
   */
  export type CrewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInclude<ExtArgs> | null
  }



  /**
   * Model CrewUser
   */

  export type AggregateCrewUser = {
    _count: CrewUserCountAggregateOutputType | null
    _min: CrewUserMinAggregateOutputType | null
    _max: CrewUserMaxAggregateOutputType | null
  }

  export type CrewUserMinAggregateOutputType = {
    userId: string | null
    crewId: string | null
    permission: string | null
  }

  export type CrewUserMaxAggregateOutputType = {
    userId: string | null
    crewId: string | null
    permission: string | null
  }

  export type CrewUserCountAggregateOutputType = {
    userId: number
    crewId: number
    permission: number
    _all: number
  }


  export type CrewUserMinAggregateInputType = {
    userId?: true
    crewId?: true
    permission?: true
  }

  export type CrewUserMaxAggregateInputType = {
    userId?: true
    crewId?: true
    permission?: true
  }

  export type CrewUserCountAggregateInputType = {
    userId?: true
    crewId?: true
    permission?: true
    _all?: true
  }

  export type CrewUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrewUser to aggregate.
     */
    where?: CrewUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewUsers to fetch.
     */
    orderBy?: CrewUserOrderByWithRelationInput | CrewUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CrewUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CrewUsers
    **/
    _count?: true | CrewUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrewUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrewUserMaxAggregateInputType
  }

  export type GetCrewUserAggregateType<T extends CrewUserAggregateArgs> = {
        [P in keyof T & keyof AggregateCrewUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrewUser[P]>
      : GetScalarType<T[P], AggregateCrewUser[P]>
  }




  export type CrewUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewUserWhereInput
    orderBy?: CrewUserOrderByWithAggregationInput | CrewUserOrderByWithAggregationInput[]
    by: CrewUserScalarFieldEnum[] | CrewUserScalarFieldEnum
    having?: CrewUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrewUserCountAggregateInputType | true
    _min?: CrewUserMinAggregateInputType
    _max?: CrewUserMaxAggregateInputType
  }

  export type CrewUserGroupByOutputType = {
    userId: string
    crewId: string
    permission: string
    _count: CrewUserCountAggregateOutputType | null
    _min: CrewUserMinAggregateOutputType | null
    _max: CrewUserMaxAggregateOutputType | null
  }

  type GetCrewUserGroupByPayload<T extends CrewUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrewUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrewUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrewUserGroupByOutputType[P]>
            : GetScalarType<T[P], CrewUserGroupByOutputType[P]>
        }
      >
    >


  export type CrewUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    crewId?: boolean
    permission?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    crew?: boolean | CrewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crewUser"]>

  export type CrewUserSelectScalar = {
    userId?: boolean
    crewId?: boolean
    permission?: boolean
  }

  export type CrewUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    crew?: boolean | CrewDefaultArgs<ExtArgs>
  }


  export type $CrewUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CrewUser"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      crew: Prisma.$CrewPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      crewId: string
      permission: string
    }, ExtArgs["result"]["crewUser"]>
    composites: {}
  }


  type CrewUserGetPayload<S extends boolean | null | undefined | CrewUserDefaultArgs> = $Result.GetResult<Prisma.$CrewUserPayload, S>

  type CrewUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CrewUserFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CrewUserCountAggregateInputType | true
    }

  export interface CrewUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CrewUser'], meta: { name: 'CrewUser' } }
    /**
     * Find zero or one CrewUser that matches the filter.
     * @param {CrewUserFindUniqueArgs} args - Arguments to find a CrewUser
     * @example
     * // Get one CrewUser
     * const crewUser = await prisma.crewUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CrewUserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CrewUserFindUniqueArgs<ExtArgs>>
    ): Prisma__CrewUserClient<$Result.GetResult<Prisma.$CrewUserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CrewUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CrewUserFindUniqueOrThrowArgs} args - Arguments to find a CrewUser
     * @example
     * // Get one CrewUser
     * const crewUser = await prisma.crewUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CrewUserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewUserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CrewUserClient<$Result.GetResult<Prisma.$CrewUserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CrewUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewUserFindFirstArgs} args - Arguments to find a CrewUser
     * @example
     * // Get one CrewUser
     * const crewUser = await prisma.crewUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CrewUserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewUserFindFirstArgs<ExtArgs>>
    ): Prisma__CrewUserClient<$Result.GetResult<Prisma.$CrewUserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CrewUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewUserFindFirstOrThrowArgs} args - Arguments to find a CrewUser
     * @example
     * // Get one CrewUser
     * const crewUser = await prisma.crewUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CrewUserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewUserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CrewUserClient<$Result.GetResult<Prisma.$CrewUserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CrewUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrewUsers
     * const crewUsers = await prisma.crewUser.findMany()
     * 
     * // Get first 10 CrewUsers
     * const crewUsers = await prisma.crewUser.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const crewUserWithUserIdOnly = await prisma.crewUser.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends CrewUserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewUserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewUserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CrewUser.
     * @param {CrewUserCreateArgs} args - Arguments to create a CrewUser.
     * @example
     * // Create one CrewUser
     * const CrewUser = await prisma.crewUser.create({
     *   data: {
     *     // ... data to create a CrewUser
     *   }
     * })
     * 
    **/
    create<T extends CrewUserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CrewUserCreateArgs<ExtArgs>>
    ): Prisma__CrewUserClient<$Result.GetResult<Prisma.$CrewUserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CrewUsers.
     *     @param {CrewUserCreateManyArgs} args - Arguments to create many CrewUsers.
     *     @example
     *     // Create many CrewUsers
     *     const crewUser = await prisma.crewUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CrewUserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewUserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CrewUser.
     * @param {CrewUserDeleteArgs} args - Arguments to delete one CrewUser.
     * @example
     * // Delete one CrewUser
     * const CrewUser = await prisma.crewUser.delete({
     *   where: {
     *     // ... filter to delete one CrewUser
     *   }
     * })
     * 
    **/
    delete<T extends CrewUserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CrewUserDeleteArgs<ExtArgs>>
    ): Prisma__CrewUserClient<$Result.GetResult<Prisma.$CrewUserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CrewUser.
     * @param {CrewUserUpdateArgs} args - Arguments to update one CrewUser.
     * @example
     * // Update one CrewUser
     * const crewUser = await prisma.crewUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CrewUserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CrewUserUpdateArgs<ExtArgs>>
    ): Prisma__CrewUserClient<$Result.GetResult<Prisma.$CrewUserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CrewUsers.
     * @param {CrewUserDeleteManyArgs} args - Arguments to filter CrewUsers to delete.
     * @example
     * // Delete a few CrewUsers
     * const { count } = await prisma.crewUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CrewUserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewUserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrewUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrewUsers
     * const crewUser = await prisma.crewUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CrewUserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CrewUserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CrewUser.
     * @param {CrewUserUpsertArgs} args - Arguments to update or create a CrewUser.
     * @example
     * // Update or create a CrewUser
     * const crewUser = await prisma.crewUser.upsert({
     *   create: {
     *     // ... data to create a CrewUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrewUser we want to update
     *   }
     * })
    **/
    upsert<T extends CrewUserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CrewUserUpsertArgs<ExtArgs>>
    ): Prisma__CrewUserClient<$Result.GetResult<Prisma.$CrewUserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CrewUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewUserCountArgs} args - Arguments to filter CrewUsers to count.
     * @example
     * // Count the number of CrewUsers
     * const count = await prisma.crewUser.count({
     *   where: {
     *     // ... the filter for the CrewUsers we want to count
     *   }
     * })
    **/
    count<T extends CrewUserCountArgs>(
      args?: Subset<T, CrewUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrewUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrewUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrewUserAggregateArgs>(args: Subset<T, CrewUserAggregateArgs>): Prisma.PrismaPromise<GetCrewUserAggregateType<T>>

    /**
     * Group by CrewUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrewUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrewUserGroupByArgs['orderBy'] }
        : { orderBy?: CrewUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrewUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrewUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CrewUser model
   */
  readonly fields: CrewUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CrewUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CrewUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    crew<T extends CrewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CrewDefaultArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CrewUser model
   */ 
  interface CrewUserFieldRefs {
    readonly userId: FieldRef<"CrewUser", 'String'>
    readonly crewId: FieldRef<"CrewUser", 'String'>
    readonly permission: FieldRef<"CrewUser", 'String'>
  }
    

  // Custom InputTypes

  /**
   * CrewUser findUnique
   */
  export type CrewUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewUser
     */
    select?: CrewUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewUserInclude<ExtArgs> | null
    /**
     * Filter, which CrewUser to fetch.
     */
    where: CrewUserWhereUniqueInput
  }


  /**
   * CrewUser findUniqueOrThrow
   */
  export type CrewUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewUser
     */
    select?: CrewUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewUserInclude<ExtArgs> | null
    /**
     * Filter, which CrewUser to fetch.
     */
    where: CrewUserWhereUniqueInput
  }


  /**
   * CrewUser findFirst
   */
  export type CrewUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewUser
     */
    select?: CrewUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewUserInclude<ExtArgs> | null
    /**
     * Filter, which CrewUser to fetch.
     */
    where?: CrewUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewUsers to fetch.
     */
    orderBy?: CrewUserOrderByWithRelationInput | CrewUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrewUsers.
     */
    cursor?: CrewUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrewUsers.
     */
    distinct?: CrewUserScalarFieldEnum | CrewUserScalarFieldEnum[]
  }


  /**
   * CrewUser findFirstOrThrow
   */
  export type CrewUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewUser
     */
    select?: CrewUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewUserInclude<ExtArgs> | null
    /**
     * Filter, which CrewUser to fetch.
     */
    where?: CrewUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewUsers to fetch.
     */
    orderBy?: CrewUserOrderByWithRelationInput | CrewUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrewUsers.
     */
    cursor?: CrewUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrewUsers.
     */
    distinct?: CrewUserScalarFieldEnum | CrewUserScalarFieldEnum[]
  }


  /**
   * CrewUser findMany
   */
  export type CrewUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewUser
     */
    select?: CrewUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewUserInclude<ExtArgs> | null
    /**
     * Filter, which CrewUsers to fetch.
     */
    where?: CrewUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewUsers to fetch.
     */
    orderBy?: CrewUserOrderByWithRelationInput | CrewUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CrewUsers.
     */
    cursor?: CrewUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewUsers.
     */
    skip?: number
    distinct?: CrewUserScalarFieldEnum | CrewUserScalarFieldEnum[]
  }


  /**
   * CrewUser create
   */
  export type CrewUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewUser
     */
    select?: CrewUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewUserInclude<ExtArgs> | null
    /**
     * The data needed to create a CrewUser.
     */
    data: XOR<CrewUserCreateInput, CrewUserUncheckedCreateInput>
  }


  /**
   * CrewUser createMany
   */
  export type CrewUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CrewUsers.
     */
    data: CrewUserCreateManyInput | CrewUserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CrewUser update
   */
  export type CrewUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewUser
     */
    select?: CrewUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewUserInclude<ExtArgs> | null
    /**
     * The data needed to update a CrewUser.
     */
    data: XOR<CrewUserUpdateInput, CrewUserUncheckedUpdateInput>
    /**
     * Choose, which CrewUser to update.
     */
    where: CrewUserWhereUniqueInput
  }


  /**
   * CrewUser updateMany
   */
  export type CrewUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CrewUsers.
     */
    data: XOR<CrewUserUpdateManyMutationInput, CrewUserUncheckedUpdateManyInput>
    /**
     * Filter which CrewUsers to update
     */
    where?: CrewUserWhereInput
  }


  /**
   * CrewUser upsert
   */
  export type CrewUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewUser
     */
    select?: CrewUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewUserInclude<ExtArgs> | null
    /**
     * The filter to search for the CrewUser to update in case it exists.
     */
    where: CrewUserWhereUniqueInput
    /**
     * In case the CrewUser found by the `where` argument doesn't exist, create a new CrewUser with this data.
     */
    create: XOR<CrewUserCreateInput, CrewUserUncheckedCreateInput>
    /**
     * In case the CrewUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CrewUserUpdateInput, CrewUserUncheckedUpdateInput>
  }


  /**
   * CrewUser delete
   */
  export type CrewUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewUser
     */
    select?: CrewUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewUserInclude<ExtArgs> | null
    /**
     * Filter which CrewUser to delete.
     */
    where: CrewUserWhereUniqueInput
  }


  /**
   * CrewUser deleteMany
   */
  export type CrewUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrewUsers to delete
     */
    where?: CrewUserWhereInput
  }


  /**
   * CrewUser without action
   */
  export type CrewUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewUser
     */
    select?: CrewUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewUserInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    userName: 'userName',
    firstName: 'firstName',
    lastName: 'lastName',
    dateJoined: 'dateJoined',
    lastEdited: 'lastEdited',
    email: 'email',
    password: 'password'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const FollowScalarFieldEnum: {
    followedById: 'followedById',
    followingId: 'followingId',
    relationship: 'relationship'
  };

  export type FollowScalarFieldEnum = (typeof FollowScalarFieldEnum)[keyof typeof FollowScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    photo: 'photo'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const RecipeBookScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    editedAt: 'editedAt',
    createdById: 'createdById',
    editedById: 'editedById'
  };

  export type RecipeBookScalarFieldEnum = (typeof RecipeBookScalarFieldEnum)[keyof typeof RecipeBookScalarFieldEnum]


  export const RecipeBookUserScalarFieldEnum: {
    userId: 'userId',
    recipeBookId: 'recipeBookId',
    permission: 'permission'
  };

  export type RecipeBookUserScalarFieldEnum = (typeof RecipeBookUserScalarFieldEnum)[keyof typeof RecipeBookUserScalarFieldEnum]


  export const BuildScalarFieldEnum: {
    id: 'id',
    buildName: 'buildName',
    createdAt: 'createdAt',
    editedAt: 'editedAt',
    createdById: 'createdById',
    editedById: 'editedById',
    recipeId: 'recipeId',
    instructions: 'instructions',
    notes: 'notes',
    glassware: 'glassware',
    ice: 'ice'
  };

  export type BuildScalarFieldEnum = (typeof BuildScalarFieldEnum)[keyof typeof BuildScalarFieldEnum]


  export const BuildUserScalarFieldEnum: {
    userId: 'userId',
    buildId: 'buildId',
    permission: 'permission'
  };

  export type BuildUserScalarFieldEnum = (typeof BuildUserScalarFieldEnum)[keyof typeof BuildUserScalarFieldEnum]


  export const RecipeScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    editedAt: 'editedAt',
    name: 'name',
    origin: 'origin',
    history: 'history',
    createdById: 'createdById',
    editedById: 'editedById'
  };

  export type RecipeScalarFieldEnum = (typeof RecipeScalarFieldEnum)[keyof typeof RecipeScalarFieldEnum]


  export const RecipeBookBuildScalarFieldEnum: {
    buildId: 'buildId',
    recipeBookId: 'recipeBookId'
  };

  export type RecipeBookBuildScalarFieldEnum = (typeof RecipeBookBuildScalarFieldEnum)[keyof typeof RecipeBookBuildScalarFieldEnum]


  export const TouchScalarFieldEnum: {
    id: 'id',
    buildId: 'buildId',
    order: 'order',
    amount: 'amount',
    unit: 'unit',
    genericIngredientId: 'genericIngredientId',
    specificIngredientId: 'specificIngredientId',
    version: 'version'
  };

  export type TouchScalarFieldEnum = (typeof TouchScalarFieldEnum)[keyof typeof TouchScalarFieldEnum]


  export const ArchivedTouchScalarFieldEnum: {
    id: 'id',
    buildId: 'buildId',
    order: 'order',
    amount: 'amount',
    unit: 'unit',
    genericIngredientId: 'genericIngredientId',
    specificIngredientId: 'specificIngredientId',
    version: 'version'
  };

  export type ArchivedTouchScalarFieldEnum = (typeof ArchivedTouchScalarFieldEnum)[keyof typeof ArchivedTouchScalarFieldEnum]


  export const GenericIngredientScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type GenericIngredientScalarFieldEnum = (typeof GenericIngredientScalarFieldEnum)[keyof typeof GenericIngredientScalarFieldEnum]


  export const SpecificIngredientScalarFieldEnum: {
    id: 'id',
    dateCreated: 'dateCreated',
    createdById: 'createdById',
    genericIngredientId: 'genericIngredientId',
    name: 'name',
    description: 'description',
    price: 'price',
    amount: 'amount',
    unit: 'unit',
    source: 'source'
  };

  export type SpecificIngredientScalarFieldEnum = (typeof SpecificIngredientScalarFieldEnum)[keyof typeof SpecificIngredientScalarFieldEnum]


  export const IngredientUserScalarFieldEnum: {
    ingredientId: 'ingredientId',
    userId: 'userId',
    permission: 'permission'
  };

  export type IngredientUserScalarFieldEnum = (typeof IngredientUserScalarFieldEnum)[keyof typeof IngredientUserScalarFieldEnum]


  export const IngredientPreferenceScalarFieldEnum: {
    genericIngredientId: 'genericIngredientId',
    specificIngredientId: 'specificIngredientId',
    userId: 'userId'
  };

  export type IngredientPreferenceScalarFieldEnum = (typeof IngredientPreferenceScalarFieldEnum)[keyof typeof IngredientPreferenceScalarFieldEnum]


  export const InventoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    editedAt: 'editedAt',
    createdById: 'createdById',
    editedById: 'editedById'
  };

  export type InventoryScalarFieldEnum = (typeof InventoryScalarFieldEnum)[keyof typeof InventoryScalarFieldEnum]


  export const InventoryUserScalarFieldEnum: {
    userId: 'userId',
    inventoryId: 'inventoryId',
    permission: 'permission'
  };

  export type InventoryUserScalarFieldEnum = (typeof InventoryUserScalarFieldEnum)[keyof typeof InventoryUserScalarFieldEnum]


  export const StorageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    editedAt: 'editedAt',
    createdById: 'createdById',
    editedById: 'editedById'
  };

  export type StorageScalarFieldEnum = (typeof StorageScalarFieldEnum)[keyof typeof StorageScalarFieldEnum]


  export const InventoryStorageScalarFieldEnum: {
    inventoryId: 'inventoryId',
    storageId: 'storageId'
  };

  export type InventoryStorageScalarFieldEnum = (typeof InventoryStorageScalarFieldEnum)[keyof typeof InventoryStorageScalarFieldEnum]


  export const IngredientStorageScalarFieldEnum: {
    ingredientId: 'ingredientId',
    storageId: 'storageId',
    quantity: 'quantity'
  };

  export type IngredientStorageScalarFieldEnum = (typeof IngredientStorageScalarFieldEnum)[keyof typeof IngredientStorageScalarFieldEnum]


  export const StorageUserScalarFieldEnum: {
    userId: 'userId',
    storageId: 'storageId',
    permission: 'permission'
  };

  export type StorageUserScalarFieldEnum = (typeof StorageUserScalarFieldEnum)[keyof typeof StorageUserScalarFieldEnum]


  export const CrewScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    editedAt: 'editedAt',
    createdById: 'createdById',
    editedById: 'editedById'
  };

  export type CrewScalarFieldEnum = (typeof CrewScalarFieldEnum)[keyof typeof CrewScalarFieldEnum]


  export const CrewUserScalarFieldEnum: {
    userId: 'userId',
    crewId: 'crewId',
    permission: 'permission'
  };

  export type CrewUserScalarFieldEnum = (typeof CrewUserScalarFieldEnum)[keyof typeof CrewUserScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    userName?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    dateJoined?: DateTimeFilter<"User"> | Date | string
    lastEdited?: DateTimeFilter<"User"> | Date | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    recipeBookUser?: RecipeBookUserListRelationFilter
    recipeBook?: RecipeBookListRelationFilter
    recipeBookEditedBy?: RecipeBookListRelationFilter
    recipe?: RecipeListRelationFilter
    recipeEditedBy?: RecipeListRelationFilter
    buildUser?: BuildUserListRelationFilter
    build?: BuildListRelationFilter
    buildEditedBy?: BuildListRelationFilter
    CrewUser?: CrewUserListRelationFilter
    crew?: CrewListRelationFilter
    crewEditedBy?: CrewListRelationFilter
    ingredient?: SpecificIngredientListRelationFilter
    ingredientPreference?: IngredientPreferenceListRelationFilter
    ingredientUser?: IngredientUserListRelationFilter
    storageUser?: StorageUserListRelationFilter
    storage?: StorageListRelationFilter
    storageEditedBy?: StorageListRelationFilter
    inventory?: InventoryListRelationFilter
    inventoryEditedBy?: InventoryListRelationFilter
    inventoryUser?: InventoryUserListRelationFilter
    followedBy?: FollowListRelationFilter
    following?: FollowListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    userName?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    dateJoined?: SortOrder
    lastEdited?: SortOrder
    email?: SortOrder
    password?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    recipeBookUser?: RecipeBookUserOrderByRelationAggregateInput
    recipeBook?: RecipeBookOrderByRelationAggregateInput
    recipeBookEditedBy?: RecipeBookOrderByRelationAggregateInput
    recipe?: RecipeOrderByRelationAggregateInput
    recipeEditedBy?: RecipeOrderByRelationAggregateInput
    buildUser?: BuildUserOrderByRelationAggregateInput
    build?: BuildOrderByRelationAggregateInput
    buildEditedBy?: BuildOrderByRelationAggregateInput
    CrewUser?: CrewUserOrderByRelationAggregateInput
    crew?: CrewOrderByRelationAggregateInput
    crewEditedBy?: CrewOrderByRelationAggregateInput
    ingredient?: SpecificIngredientOrderByRelationAggregateInput
    ingredientPreference?: IngredientPreferenceOrderByRelationAggregateInput
    ingredientUser?: IngredientUserOrderByRelationAggregateInput
    storageUser?: StorageUserOrderByRelationAggregateInput
    storage?: StorageOrderByRelationAggregateInput
    storageEditedBy?: StorageOrderByRelationAggregateInput
    inventory?: InventoryOrderByRelationAggregateInput
    inventoryEditedBy?: InventoryOrderByRelationAggregateInput
    inventoryUser?: InventoryUserOrderByRelationAggregateInput
    followedBy?: FollowOrderByRelationAggregateInput
    following?: FollowOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    userName?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    dateJoined?: DateTimeFilter<"User"> | Date | string
    lastEdited?: DateTimeFilter<"User"> | Date | string
    password?: StringFilter<"User"> | string
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    recipeBookUser?: RecipeBookUserListRelationFilter
    recipeBook?: RecipeBookListRelationFilter
    recipeBookEditedBy?: RecipeBookListRelationFilter
    recipe?: RecipeListRelationFilter
    recipeEditedBy?: RecipeListRelationFilter
    buildUser?: BuildUserListRelationFilter
    build?: BuildListRelationFilter
    buildEditedBy?: BuildListRelationFilter
    CrewUser?: CrewUserListRelationFilter
    crew?: CrewListRelationFilter
    crewEditedBy?: CrewListRelationFilter
    ingredient?: SpecificIngredientListRelationFilter
    ingredientPreference?: IngredientPreferenceListRelationFilter
    ingredientUser?: IngredientUserListRelationFilter
    storageUser?: StorageUserListRelationFilter
    storage?: StorageListRelationFilter
    storageEditedBy?: StorageListRelationFilter
    inventory?: InventoryListRelationFilter
    inventoryEditedBy?: InventoryListRelationFilter
    inventoryUser?: InventoryUserListRelationFilter
    followedBy?: FollowListRelationFilter
    following?: FollowListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    userName?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    dateJoined?: SortOrder
    lastEdited?: SortOrder
    email?: SortOrder
    password?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    userName?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    dateJoined?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastEdited?: DateTimeWithAggregatesFilter<"User"> | Date | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
  }

  export type FollowWhereInput = {
    AND?: FollowWhereInput | FollowWhereInput[]
    OR?: FollowWhereInput[]
    NOT?: FollowWhereInput | FollowWhereInput[]
    followedById?: StringFilter<"Follow"> | string
    followingId?: StringFilter<"Follow"> | string
    relationship?: StringFilter<"Follow"> | string
    followedBy?: XOR<UserRelationFilter, UserWhereInput>
    following?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type FollowOrderByWithRelationInput = {
    followedById?: SortOrder
    followingId?: SortOrder
    relationship?: SortOrder
    followedBy?: UserOrderByWithRelationInput
    following?: UserOrderByWithRelationInput
  }

  export type FollowWhereUniqueInput = Prisma.AtLeast<{
    followingId_followedById?: FollowFollowingIdFollowedByIdCompoundUniqueInput
    AND?: FollowWhereInput | FollowWhereInput[]
    OR?: FollowWhereInput[]
    NOT?: FollowWhereInput | FollowWhereInput[]
    followedById?: StringFilter<"Follow"> | string
    followingId?: StringFilter<"Follow"> | string
    relationship?: StringFilter<"Follow"> | string
    followedBy?: XOR<UserRelationFilter, UserWhereInput>
    following?: XOR<UserRelationFilter, UserWhereInput>
  }, "followingId_followedById">

  export type FollowOrderByWithAggregationInput = {
    followedById?: SortOrder
    followingId?: SortOrder
    relationship?: SortOrder
    _count?: FollowCountOrderByAggregateInput
    _max?: FollowMaxOrderByAggregateInput
    _min?: FollowMinOrderByAggregateInput
  }

  export type FollowScalarWhereWithAggregatesInput = {
    AND?: FollowScalarWhereWithAggregatesInput | FollowScalarWhereWithAggregatesInput[]
    OR?: FollowScalarWhereWithAggregatesInput[]
    NOT?: FollowScalarWhereWithAggregatesInput | FollowScalarWhereWithAggregatesInput[]
    followedById?: StringWithAggregatesFilter<"Follow"> | string
    followingId?: StringWithAggregatesFilter<"Follow"> | string
    relationship?: StringWithAggregatesFilter<"Follow"> | string
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: StringFilter<"Profile"> | string
    userId?: StringFilter<"Profile"> | string
    photo?: StringFilter<"Profile"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    photo?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    photo?: StringFilter<"Profile"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    photo?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Profile"> | string
    userId?: StringWithAggregatesFilter<"Profile"> | string
    photo?: StringWithAggregatesFilter<"Profile"> | string
  }

  export type RecipeBookWhereInput = {
    AND?: RecipeBookWhereInput | RecipeBookWhereInput[]
    OR?: RecipeBookWhereInput[]
    NOT?: RecipeBookWhereInput | RecipeBookWhereInput[]
    id?: StringFilter<"RecipeBook"> | string
    name?: StringFilter<"RecipeBook"> | string
    description?: StringNullableFilter<"RecipeBook"> | string | null
    createdAt?: DateTimeFilter<"RecipeBook"> | Date | string
    editedAt?: DateTimeFilter<"RecipeBook"> | Date | string
    createdById?: StringNullableFilter<"RecipeBook"> | string | null
    editedById?: StringNullableFilter<"RecipeBook"> | string | null
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    editedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    recipeBookBuild?: RecipeBookBuildListRelationFilter
    recipeBookUser?: RecipeBookUserListRelationFilter
  }

  export type RecipeBookOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    editedById?: SortOrderInput | SortOrder
    createdBy?: UserOrderByWithRelationInput
    editedBy?: UserOrderByWithRelationInput
    recipeBookBuild?: RecipeBookBuildOrderByRelationAggregateInput
    recipeBookUser?: RecipeBookUserOrderByRelationAggregateInput
  }

  export type RecipeBookWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RecipeBookWhereInput | RecipeBookWhereInput[]
    OR?: RecipeBookWhereInput[]
    NOT?: RecipeBookWhereInput | RecipeBookWhereInput[]
    name?: StringFilter<"RecipeBook"> | string
    description?: StringNullableFilter<"RecipeBook"> | string | null
    createdAt?: DateTimeFilter<"RecipeBook"> | Date | string
    editedAt?: DateTimeFilter<"RecipeBook"> | Date | string
    createdById?: StringNullableFilter<"RecipeBook"> | string | null
    editedById?: StringNullableFilter<"RecipeBook"> | string | null
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    editedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    recipeBookBuild?: RecipeBookBuildListRelationFilter
    recipeBookUser?: RecipeBookUserListRelationFilter
  }, "id">

  export type RecipeBookOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    editedById?: SortOrderInput | SortOrder
    _count?: RecipeBookCountOrderByAggregateInput
    _max?: RecipeBookMaxOrderByAggregateInput
    _min?: RecipeBookMinOrderByAggregateInput
  }

  export type RecipeBookScalarWhereWithAggregatesInput = {
    AND?: RecipeBookScalarWhereWithAggregatesInput | RecipeBookScalarWhereWithAggregatesInput[]
    OR?: RecipeBookScalarWhereWithAggregatesInput[]
    NOT?: RecipeBookScalarWhereWithAggregatesInput | RecipeBookScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RecipeBook"> | string
    name?: StringWithAggregatesFilter<"RecipeBook"> | string
    description?: StringNullableWithAggregatesFilter<"RecipeBook"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RecipeBook"> | Date | string
    editedAt?: DateTimeWithAggregatesFilter<"RecipeBook"> | Date | string
    createdById?: StringNullableWithAggregatesFilter<"RecipeBook"> | string | null
    editedById?: StringNullableWithAggregatesFilter<"RecipeBook"> | string | null
  }

  export type RecipeBookUserWhereInput = {
    AND?: RecipeBookUserWhereInput | RecipeBookUserWhereInput[]
    OR?: RecipeBookUserWhereInput[]
    NOT?: RecipeBookUserWhereInput | RecipeBookUserWhereInput[]
    userId?: StringFilter<"RecipeBookUser"> | string
    recipeBookId?: StringFilter<"RecipeBookUser"> | string
    permission?: StringFilter<"RecipeBookUser"> | string
    recipeBook?: XOR<RecipeBookRelationFilter, RecipeBookWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RecipeBookUserOrderByWithRelationInput = {
    userId?: SortOrder
    recipeBookId?: SortOrder
    permission?: SortOrder
    recipeBook?: RecipeBookOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type RecipeBookUserWhereUniqueInput = Prisma.AtLeast<{
    userId_recipeBookId?: RecipeBookUserUserIdRecipeBookIdCompoundUniqueInput
    AND?: RecipeBookUserWhereInput | RecipeBookUserWhereInput[]
    OR?: RecipeBookUserWhereInput[]
    NOT?: RecipeBookUserWhereInput | RecipeBookUserWhereInput[]
    userId?: StringFilter<"RecipeBookUser"> | string
    recipeBookId?: StringFilter<"RecipeBookUser"> | string
    permission?: StringFilter<"RecipeBookUser"> | string
    recipeBook?: XOR<RecipeBookRelationFilter, RecipeBookWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "userId_recipeBookId">

  export type RecipeBookUserOrderByWithAggregationInput = {
    userId?: SortOrder
    recipeBookId?: SortOrder
    permission?: SortOrder
    _count?: RecipeBookUserCountOrderByAggregateInput
    _max?: RecipeBookUserMaxOrderByAggregateInput
    _min?: RecipeBookUserMinOrderByAggregateInput
  }

  export type RecipeBookUserScalarWhereWithAggregatesInput = {
    AND?: RecipeBookUserScalarWhereWithAggregatesInput | RecipeBookUserScalarWhereWithAggregatesInput[]
    OR?: RecipeBookUserScalarWhereWithAggregatesInput[]
    NOT?: RecipeBookUserScalarWhereWithAggregatesInput | RecipeBookUserScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"RecipeBookUser"> | string
    recipeBookId?: StringWithAggregatesFilter<"RecipeBookUser"> | string
    permission?: StringWithAggregatesFilter<"RecipeBookUser"> | string
  }

  export type BuildWhereInput = {
    AND?: BuildWhereInput | BuildWhereInput[]
    OR?: BuildWhereInput[]
    NOT?: BuildWhereInput | BuildWhereInput[]
    id?: StringFilter<"Build"> | string
    buildName?: StringFilter<"Build"> | string
    createdAt?: DateTimeFilter<"Build"> | Date | string
    editedAt?: DateTimeFilter<"Build"> | Date | string
    createdById?: StringNullableFilter<"Build"> | string | null
    editedById?: StringNullableFilter<"Build"> | string | null
    recipeId?: StringNullableFilter<"Build"> | string | null
    instructions?: StringNullableFilter<"Build"> | string | null
    notes?: StringNullableFilter<"Build"> | string | null
    glassware?: StringNullableFilter<"Build"> | string | null
    ice?: StringNullableFilter<"Build"> | string | null
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    editedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    recipe?: XOR<RecipeNullableRelationFilter, RecipeWhereInput> | null
    touch?: TouchListRelationFilter
    archivedTouch?: ArchivedTouchListRelationFilter
    RecipeBookBuild?: RecipeBookBuildListRelationFilter
    buildUser?: BuildUserListRelationFilter
  }

  export type BuildOrderByWithRelationInput = {
    id?: SortOrder
    buildName?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    editedById?: SortOrderInput | SortOrder
    recipeId?: SortOrderInput | SortOrder
    instructions?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    glassware?: SortOrderInput | SortOrder
    ice?: SortOrderInput | SortOrder
    createdBy?: UserOrderByWithRelationInput
    editedBy?: UserOrderByWithRelationInput
    recipe?: RecipeOrderByWithRelationInput
    touch?: TouchOrderByRelationAggregateInput
    archivedTouch?: ArchivedTouchOrderByRelationAggregateInput
    RecipeBookBuild?: RecipeBookBuildOrderByRelationAggregateInput
    buildUser?: BuildUserOrderByRelationAggregateInput
  }

  export type BuildWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BuildWhereInput | BuildWhereInput[]
    OR?: BuildWhereInput[]
    NOT?: BuildWhereInput | BuildWhereInput[]
    buildName?: StringFilter<"Build"> | string
    createdAt?: DateTimeFilter<"Build"> | Date | string
    editedAt?: DateTimeFilter<"Build"> | Date | string
    createdById?: StringNullableFilter<"Build"> | string | null
    editedById?: StringNullableFilter<"Build"> | string | null
    recipeId?: StringNullableFilter<"Build"> | string | null
    instructions?: StringNullableFilter<"Build"> | string | null
    notes?: StringNullableFilter<"Build"> | string | null
    glassware?: StringNullableFilter<"Build"> | string | null
    ice?: StringNullableFilter<"Build"> | string | null
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    editedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    recipe?: XOR<RecipeNullableRelationFilter, RecipeWhereInput> | null
    touch?: TouchListRelationFilter
    archivedTouch?: ArchivedTouchListRelationFilter
    RecipeBookBuild?: RecipeBookBuildListRelationFilter
    buildUser?: BuildUserListRelationFilter
  }, "id">

  export type BuildOrderByWithAggregationInput = {
    id?: SortOrder
    buildName?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    editedById?: SortOrderInput | SortOrder
    recipeId?: SortOrderInput | SortOrder
    instructions?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    glassware?: SortOrderInput | SortOrder
    ice?: SortOrderInput | SortOrder
    _count?: BuildCountOrderByAggregateInput
    _max?: BuildMaxOrderByAggregateInput
    _min?: BuildMinOrderByAggregateInput
  }

  export type BuildScalarWhereWithAggregatesInput = {
    AND?: BuildScalarWhereWithAggregatesInput | BuildScalarWhereWithAggregatesInput[]
    OR?: BuildScalarWhereWithAggregatesInput[]
    NOT?: BuildScalarWhereWithAggregatesInput | BuildScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Build"> | string
    buildName?: StringWithAggregatesFilter<"Build"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Build"> | Date | string
    editedAt?: DateTimeWithAggregatesFilter<"Build"> | Date | string
    createdById?: StringNullableWithAggregatesFilter<"Build"> | string | null
    editedById?: StringNullableWithAggregatesFilter<"Build"> | string | null
    recipeId?: StringNullableWithAggregatesFilter<"Build"> | string | null
    instructions?: StringNullableWithAggregatesFilter<"Build"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Build"> | string | null
    glassware?: StringNullableWithAggregatesFilter<"Build"> | string | null
    ice?: StringNullableWithAggregatesFilter<"Build"> | string | null
  }

  export type BuildUserWhereInput = {
    AND?: BuildUserWhereInput | BuildUserWhereInput[]
    OR?: BuildUserWhereInput[]
    NOT?: BuildUserWhereInput | BuildUserWhereInput[]
    userId?: StringFilter<"BuildUser"> | string
    buildId?: StringFilter<"BuildUser"> | string
    permission?: StringFilter<"BuildUser"> | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    build?: XOR<BuildNullableRelationFilter, BuildWhereInput> | null
  }

  export type BuildUserOrderByWithRelationInput = {
    userId?: SortOrder
    buildId?: SortOrder
    permission?: SortOrder
    user?: UserOrderByWithRelationInput
    build?: BuildOrderByWithRelationInput
  }

  export type BuildUserWhereUniqueInput = Prisma.AtLeast<{
    userId_buildId?: BuildUserUserIdBuildIdCompoundUniqueInput
    AND?: BuildUserWhereInput | BuildUserWhereInput[]
    OR?: BuildUserWhereInput[]
    NOT?: BuildUserWhereInput | BuildUserWhereInput[]
    userId?: StringFilter<"BuildUser"> | string
    buildId?: StringFilter<"BuildUser"> | string
    permission?: StringFilter<"BuildUser"> | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    build?: XOR<BuildNullableRelationFilter, BuildWhereInput> | null
  }, "userId_buildId">

  export type BuildUserOrderByWithAggregationInput = {
    userId?: SortOrder
    buildId?: SortOrder
    permission?: SortOrder
    _count?: BuildUserCountOrderByAggregateInput
    _max?: BuildUserMaxOrderByAggregateInput
    _min?: BuildUserMinOrderByAggregateInput
  }

  export type BuildUserScalarWhereWithAggregatesInput = {
    AND?: BuildUserScalarWhereWithAggregatesInput | BuildUserScalarWhereWithAggregatesInput[]
    OR?: BuildUserScalarWhereWithAggregatesInput[]
    NOT?: BuildUserScalarWhereWithAggregatesInput | BuildUserScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"BuildUser"> | string
    buildId?: StringWithAggregatesFilter<"BuildUser"> | string
    permission?: StringWithAggregatesFilter<"BuildUser"> | string
  }

  export type RecipeWhereInput = {
    AND?: RecipeWhereInput | RecipeWhereInput[]
    OR?: RecipeWhereInput[]
    NOT?: RecipeWhereInput | RecipeWhereInput[]
    id?: StringFilter<"Recipe"> | string
    createdAt?: DateTimeFilter<"Recipe"> | Date | string
    editedAt?: DateTimeFilter<"Recipe"> | Date | string
    name?: StringFilter<"Recipe"> | string
    origin?: StringNullableFilter<"Recipe"> | string | null
    history?: StringNullableFilter<"Recipe"> | string | null
    createdById?: StringNullableFilter<"Recipe"> | string | null
    editedById?: StringNullableFilter<"Recipe"> | string | null
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    editedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    build?: BuildListRelationFilter
  }

  export type RecipeOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    name?: SortOrder
    origin?: SortOrderInput | SortOrder
    history?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    editedById?: SortOrderInput | SortOrder
    createdBy?: UserOrderByWithRelationInput
    editedBy?: UserOrderByWithRelationInput
    build?: BuildOrderByRelationAggregateInput
  }

  export type RecipeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RecipeWhereInput | RecipeWhereInput[]
    OR?: RecipeWhereInput[]
    NOT?: RecipeWhereInput | RecipeWhereInput[]
    createdAt?: DateTimeFilter<"Recipe"> | Date | string
    editedAt?: DateTimeFilter<"Recipe"> | Date | string
    name?: StringFilter<"Recipe"> | string
    origin?: StringNullableFilter<"Recipe"> | string | null
    history?: StringNullableFilter<"Recipe"> | string | null
    createdById?: StringNullableFilter<"Recipe"> | string | null
    editedById?: StringNullableFilter<"Recipe"> | string | null
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    editedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    build?: BuildListRelationFilter
  }, "id">

  export type RecipeOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    name?: SortOrder
    origin?: SortOrderInput | SortOrder
    history?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    editedById?: SortOrderInput | SortOrder
    _count?: RecipeCountOrderByAggregateInput
    _max?: RecipeMaxOrderByAggregateInput
    _min?: RecipeMinOrderByAggregateInput
  }

  export type RecipeScalarWhereWithAggregatesInput = {
    AND?: RecipeScalarWhereWithAggregatesInput | RecipeScalarWhereWithAggregatesInput[]
    OR?: RecipeScalarWhereWithAggregatesInput[]
    NOT?: RecipeScalarWhereWithAggregatesInput | RecipeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Recipe"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Recipe"> | Date | string
    editedAt?: DateTimeWithAggregatesFilter<"Recipe"> | Date | string
    name?: StringWithAggregatesFilter<"Recipe"> | string
    origin?: StringNullableWithAggregatesFilter<"Recipe"> | string | null
    history?: StringNullableWithAggregatesFilter<"Recipe"> | string | null
    createdById?: StringNullableWithAggregatesFilter<"Recipe"> | string | null
    editedById?: StringNullableWithAggregatesFilter<"Recipe"> | string | null
  }

  export type RecipeBookBuildWhereInput = {
    AND?: RecipeBookBuildWhereInput | RecipeBookBuildWhereInput[]
    OR?: RecipeBookBuildWhereInput[]
    NOT?: RecipeBookBuildWhereInput | RecipeBookBuildWhereInput[]
    buildId?: StringFilter<"RecipeBookBuild"> | string
    recipeBookId?: StringFilter<"RecipeBookBuild"> | string
    recipeBook?: XOR<RecipeBookRelationFilter, RecipeBookWhereInput>
    build?: XOR<BuildRelationFilter, BuildWhereInput>
  }

  export type RecipeBookBuildOrderByWithRelationInput = {
    buildId?: SortOrder
    recipeBookId?: SortOrder
    recipeBook?: RecipeBookOrderByWithRelationInput
    build?: BuildOrderByWithRelationInput
  }

  export type RecipeBookBuildWhereUniqueInput = Prisma.AtLeast<{
    buildId_recipeBookId?: RecipeBookBuildBuildIdRecipeBookIdCompoundUniqueInput
    AND?: RecipeBookBuildWhereInput | RecipeBookBuildWhereInput[]
    OR?: RecipeBookBuildWhereInput[]
    NOT?: RecipeBookBuildWhereInput | RecipeBookBuildWhereInput[]
    buildId?: StringFilter<"RecipeBookBuild"> | string
    recipeBookId?: StringFilter<"RecipeBookBuild"> | string
    recipeBook?: XOR<RecipeBookRelationFilter, RecipeBookWhereInput>
    build?: XOR<BuildRelationFilter, BuildWhereInput>
  }, "buildId_recipeBookId">

  export type RecipeBookBuildOrderByWithAggregationInput = {
    buildId?: SortOrder
    recipeBookId?: SortOrder
    _count?: RecipeBookBuildCountOrderByAggregateInput
    _max?: RecipeBookBuildMaxOrderByAggregateInput
    _min?: RecipeBookBuildMinOrderByAggregateInput
  }

  export type RecipeBookBuildScalarWhereWithAggregatesInput = {
    AND?: RecipeBookBuildScalarWhereWithAggregatesInput | RecipeBookBuildScalarWhereWithAggregatesInput[]
    OR?: RecipeBookBuildScalarWhereWithAggregatesInput[]
    NOT?: RecipeBookBuildScalarWhereWithAggregatesInput | RecipeBookBuildScalarWhereWithAggregatesInput[]
    buildId?: StringWithAggregatesFilter<"RecipeBookBuild"> | string
    recipeBookId?: StringWithAggregatesFilter<"RecipeBookBuild"> | string
  }

  export type TouchWhereInput = {
    AND?: TouchWhereInput | TouchWhereInput[]
    OR?: TouchWhereInput[]
    NOT?: TouchWhereInput | TouchWhereInput[]
    id?: StringFilter<"Touch"> | string
    buildId?: StringFilter<"Touch"> | string
    order?: IntNullableFilter<"Touch"> | number | null
    amount?: FloatNullableFilter<"Touch"> | number | null
    unit?: StringNullableFilter<"Touch"> | string | null
    genericIngredientId?: StringFilter<"Touch"> | string
    specificIngredientId?: StringNullableFilter<"Touch"> | string | null
    version?: IntNullableFilter<"Touch"> | number | null
    build?: XOR<BuildRelationFilter, BuildWhereInput>
    genericIngredient?: XOR<GenericIngredientRelationFilter, GenericIngredientWhereInput>
    specificIngredient?: XOR<SpecificIngredientNullableRelationFilter, SpecificIngredientWhereInput> | null
  }

  export type TouchOrderByWithRelationInput = {
    id?: SortOrder
    buildId?: SortOrder
    order?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    genericIngredientId?: SortOrder
    specificIngredientId?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    build?: BuildOrderByWithRelationInput
    genericIngredient?: GenericIngredientOrderByWithRelationInput
    specificIngredient?: SpecificIngredientOrderByWithRelationInput
  }

  export type TouchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TouchWhereInput | TouchWhereInput[]
    OR?: TouchWhereInput[]
    NOT?: TouchWhereInput | TouchWhereInput[]
    buildId?: StringFilter<"Touch"> | string
    order?: IntNullableFilter<"Touch"> | number | null
    amount?: FloatNullableFilter<"Touch"> | number | null
    unit?: StringNullableFilter<"Touch"> | string | null
    genericIngredientId?: StringFilter<"Touch"> | string
    specificIngredientId?: StringNullableFilter<"Touch"> | string | null
    version?: IntNullableFilter<"Touch"> | number | null
    build?: XOR<BuildRelationFilter, BuildWhereInput>
    genericIngredient?: XOR<GenericIngredientRelationFilter, GenericIngredientWhereInput>
    specificIngredient?: XOR<SpecificIngredientNullableRelationFilter, SpecificIngredientWhereInput> | null
  }, "id">

  export type TouchOrderByWithAggregationInput = {
    id?: SortOrder
    buildId?: SortOrder
    order?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    genericIngredientId?: SortOrder
    specificIngredientId?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    _count?: TouchCountOrderByAggregateInput
    _avg?: TouchAvgOrderByAggregateInput
    _max?: TouchMaxOrderByAggregateInput
    _min?: TouchMinOrderByAggregateInput
    _sum?: TouchSumOrderByAggregateInput
  }

  export type TouchScalarWhereWithAggregatesInput = {
    AND?: TouchScalarWhereWithAggregatesInput | TouchScalarWhereWithAggregatesInput[]
    OR?: TouchScalarWhereWithAggregatesInput[]
    NOT?: TouchScalarWhereWithAggregatesInput | TouchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Touch"> | string
    buildId?: StringWithAggregatesFilter<"Touch"> | string
    order?: IntNullableWithAggregatesFilter<"Touch"> | number | null
    amount?: FloatNullableWithAggregatesFilter<"Touch"> | number | null
    unit?: StringNullableWithAggregatesFilter<"Touch"> | string | null
    genericIngredientId?: StringWithAggregatesFilter<"Touch"> | string
    specificIngredientId?: StringNullableWithAggregatesFilter<"Touch"> | string | null
    version?: IntNullableWithAggregatesFilter<"Touch"> | number | null
  }

  export type ArchivedTouchWhereInput = {
    AND?: ArchivedTouchWhereInput | ArchivedTouchWhereInput[]
    OR?: ArchivedTouchWhereInput[]
    NOT?: ArchivedTouchWhereInput | ArchivedTouchWhereInput[]
    id?: StringFilter<"ArchivedTouch"> | string
    buildId?: StringFilter<"ArchivedTouch"> | string
    order?: IntNullableFilter<"ArchivedTouch"> | number | null
    amount?: FloatNullableFilter<"ArchivedTouch"> | number | null
    unit?: StringNullableFilter<"ArchivedTouch"> | string | null
    genericIngredientId?: StringFilter<"ArchivedTouch"> | string
    specificIngredientId?: StringNullableFilter<"ArchivedTouch"> | string | null
    version?: IntNullableFilter<"ArchivedTouch"> | number | null
    build?: XOR<BuildRelationFilter, BuildWhereInput>
    genericIngredient?: XOR<GenericIngredientRelationFilter, GenericIngredientWhereInput>
    specificIngredient?: XOR<SpecificIngredientNullableRelationFilter, SpecificIngredientWhereInput> | null
  }

  export type ArchivedTouchOrderByWithRelationInput = {
    id?: SortOrder
    buildId?: SortOrder
    order?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    genericIngredientId?: SortOrder
    specificIngredientId?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    build?: BuildOrderByWithRelationInput
    genericIngredient?: GenericIngredientOrderByWithRelationInput
    specificIngredient?: SpecificIngredientOrderByWithRelationInput
  }

  export type ArchivedTouchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ArchivedTouchWhereInput | ArchivedTouchWhereInput[]
    OR?: ArchivedTouchWhereInput[]
    NOT?: ArchivedTouchWhereInput | ArchivedTouchWhereInput[]
    buildId?: StringFilter<"ArchivedTouch"> | string
    order?: IntNullableFilter<"ArchivedTouch"> | number | null
    amount?: FloatNullableFilter<"ArchivedTouch"> | number | null
    unit?: StringNullableFilter<"ArchivedTouch"> | string | null
    genericIngredientId?: StringFilter<"ArchivedTouch"> | string
    specificIngredientId?: StringNullableFilter<"ArchivedTouch"> | string | null
    version?: IntNullableFilter<"ArchivedTouch"> | number | null
    build?: XOR<BuildRelationFilter, BuildWhereInput>
    genericIngredient?: XOR<GenericIngredientRelationFilter, GenericIngredientWhereInput>
    specificIngredient?: XOR<SpecificIngredientNullableRelationFilter, SpecificIngredientWhereInput> | null
  }, "id">

  export type ArchivedTouchOrderByWithAggregationInput = {
    id?: SortOrder
    buildId?: SortOrder
    order?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    genericIngredientId?: SortOrder
    specificIngredientId?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    _count?: ArchivedTouchCountOrderByAggregateInput
    _avg?: ArchivedTouchAvgOrderByAggregateInput
    _max?: ArchivedTouchMaxOrderByAggregateInput
    _min?: ArchivedTouchMinOrderByAggregateInput
    _sum?: ArchivedTouchSumOrderByAggregateInput
  }

  export type ArchivedTouchScalarWhereWithAggregatesInput = {
    AND?: ArchivedTouchScalarWhereWithAggregatesInput | ArchivedTouchScalarWhereWithAggregatesInput[]
    OR?: ArchivedTouchScalarWhereWithAggregatesInput[]
    NOT?: ArchivedTouchScalarWhereWithAggregatesInput | ArchivedTouchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ArchivedTouch"> | string
    buildId?: StringWithAggregatesFilter<"ArchivedTouch"> | string
    order?: IntNullableWithAggregatesFilter<"ArchivedTouch"> | number | null
    amount?: FloatNullableWithAggregatesFilter<"ArchivedTouch"> | number | null
    unit?: StringNullableWithAggregatesFilter<"ArchivedTouch"> | string | null
    genericIngredientId?: StringWithAggregatesFilter<"ArchivedTouch"> | string
    specificIngredientId?: StringNullableWithAggregatesFilter<"ArchivedTouch"> | string | null
    version?: IntNullableWithAggregatesFilter<"ArchivedTouch"> | number | null
  }

  export type GenericIngredientWhereInput = {
    AND?: GenericIngredientWhereInput | GenericIngredientWhereInput[]
    OR?: GenericIngredientWhereInput[]
    NOT?: GenericIngredientWhereInput | GenericIngredientWhereInput[]
    id?: StringFilter<"GenericIngredient"> | string
    name?: StringFilter<"GenericIngredient"> | string
    description?: StringNullableFilter<"GenericIngredient"> | string | null
    touch?: TouchListRelationFilter
    archivedTouch?: ArchivedTouchListRelationFilter
    specificIngredient?: SpecificIngredientListRelationFilter
    ingredientPreference?: IngredientPreferenceListRelationFilter
  }

  export type GenericIngredientOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    touch?: TouchOrderByRelationAggregateInput
    archivedTouch?: ArchivedTouchOrderByRelationAggregateInput
    specificIngredient?: SpecificIngredientOrderByRelationAggregateInput
    ingredientPreference?: IngredientPreferenceOrderByRelationAggregateInput
  }

  export type GenericIngredientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GenericIngredientWhereInput | GenericIngredientWhereInput[]
    OR?: GenericIngredientWhereInput[]
    NOT?: GenericIngredientWhereInput | GenericIngredientWhereInput[]
    name?: StringFilter<"GenericIngredient"> | string
    description?: StringNullableFilter<"GenericIngredient"> | string | null
    touch?: TouchListRelationFilter
    archivedTouch?: ArchivedTouchListRelationFilter
    specificIngredient?: SpecificIngredientListRelationFilter
    ingredientPreference?: IngredientPreferenceListRelationFilter
  }, "id">

  export type GenericIngredientOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: GenericIngredientCountOrderByAggregateInput
    _max?: GenericIngredientMaxOrderByAggregateInput
    _min?: GenericIngredientMinOrderByAggregateInput
  }

  export type GenericIngredientScalarWhereWithAggregatesInput = {
    AND?: GenericIngredientScalarWhereWithAggregatesInput | GenericIngredientScalarWhereWithAggregatesInput[]
    OR?: GenericIngredientScalarWhereWithAggregatesInput[]
    NOT?: GenericIngredientScalarWhereWithAggregatesInput | GenericIngredientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GenericIngredient"> | string
    name?: StringWithAggregatesFilter<"GenericIngredient"> | string
    description?: StringNullableWithAggregatesFilter<"GenericIngredient"> | string | null
  }

  export type SpecificIngredientWhereInput = {
    AND?: SpecificIngredientWhereInput | SpecificIngredientWhereInput[]
    OR?: SpecificIngredientWhereInput[]
    NOT?: SpecificIngredientWhereInput | SpecificIngredientWhereInput[]
    id?: StringFilter<"SpecificIngredient"> | string
    dateCreated?: DateTimeFilter<"SpecificIngredient"> | Date | string
    createdById?: StringNullableFilter<"SpecificIngredient"> | string | null
    genericIngredientId?: StringFilter<"SpecificIngredient"> | string
    name?: StringFilter<"SpecificIngredient"> | string
    description?: StringFilter<"SpecificIngredient"> | string
    price?: FloatNullableFilter<"SpecificIngredient"> | number | null
    amount?: FloatNullableFilter<"SpecificIngredient"> | number | null
    unit?: StringNullableFilter<"SpecificIngredient"> | string | null
    source?: StringNullableFilter<"SpecificIngredient"> | string | null
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    genericIngredient?: XOR<GenericIngredientRelationFilter, GenericIngredientWhereInput>
    touch?: TouchListRelationFilter
    archivedTouch?: ArchivedTouchListRelationFilter
    ingredientStorage?: IngredientStorageListRelationFilter
    ingredientUser?: IngredientUserListRelationFilter
    ingredientPreference?: IngredientPreferenceListRelationFilter
  }

  export type SpecificIngredientOrderByWithRelationInput = {
    id?: SortOrder
    dateCreated?: SortOrder
    createdById?: SortOrderInput | SortOrder
    genericIngredientId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    createdBy?: UserOrderByWithRelationInput
    genericIngredient?: GenericIngredientOrderByWithRelationInput
    touch?: TouchOrderByRelationAggregateInput
    archivedTouch?: ArchivedTouchOrderByRelationAggregateInput
    ingredientStorage?: IngredientStorageOrderByRelationAggregateInput
    ingredientUser?: IngredientUserOrderByRelationAggregateInput
    ingredientPreference?: IngredientPreferenceOrderByRelationAggregateInput
  }

  export type SpecificIngredientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SpecificIngredientWhereInput | SpecificIngredientWhereInput[]
    OR?: SpecificIngredientWhereInput[]
    NOT?: SpecificIngredientWhereInput | SpecificIngredientWhereInput[]
    dateCreated?: DateTimeFilter<"SpecificIngredient"> | Date | string
    createdById?: StringNullableFilter<"SpecificIngredient"> | string | null
    genericIngredientId?: StringFilter<"SpecificIngredient"> | string
    name?: StringFilter<"SpecificIngredient"> | string
    description?: StringFilter<"SpecificIngredient"> | string
    price?: FloatNullableFilter<"SpecificIngredient"> | number | null
    amount?: FloatNullableFilter<"SpecificIngredient"> | number | null
    unit?: StringNullableFilter<"SpecificIngredient"> | string | null
    source?: StringNullableFilter<"SpecificIngredient"> | string | null
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    genericIngredient?: XOR<GenericIngredientRelationFilter, GenericIngredientWhereInput>
    touch?: TouchListRelationFilter
    archivedTouch?: ArchivedTouchListRelationFilter
    ingredientStorage?: IngredientStorageListRelationFilter
    ingredientUser?: IngredientUserListRelationFilter
    ingredientPreference?: IngredientPreferenceListRelationFilter
  }, "id">

  export type SpecificIngredientOrderByWithAggregationInput = {
    id?: SortOrder
    dateCreated?: SortOrder
    createdById?: SortOrderInput | SortOrder
    genericIngredientId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    _count?: SpecificIngredientCountOrderByAggregateInput
    _avg?: SpecificIngredientAvgOrderByAggregateInput
    _max?: SpecificIngredientMaxOrderByAggregateInput
    _min?: SpecificIngredientMinOrderByAggregateInput
    _sum?: SpecificIngredientSumOrderByAggregateInput
  }

  export type SpecificIngredientScalarWhereWithAggregatesInput = {
    AND?: SpecificIngredientScalarWhereWithAggregatesInput | SpecificIngredientScalarWhereWithAggregatesInput[]
    OR?: SpecificIngredientScalarWhereWithAggregatesInput[]
    NOT?: SpecificIngredientScalarWhereWithAggregatesInput | SpecificIngredientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SpecificIngredient"> | string
    dateCreated?: DateTimeWithAggregatesFilter<"SpecificIngredient"> | Date | string
    createdById?: StringNullableWithAggregatesFilter<"SpecificIngredient"> | string | null
    genericIngredientId?: StringWithAggregatesFilter<"SpecificIngredient"> | string
    name?: StringWithAggregatesFilter<"SpecificIngredient"> | string
    description?: StringWithAggregatesFilter<"SpecificIngredient"> | string
    price?: FloatNullableWithAggregatesFilter<"SpecificIngredient"> | number | null
    amount?: FloatNullableWithAggregatesFilter<"SpecificIngredient"> | number | null
    unit?: StringNullableWithAggregatesFilter<"SpecificIngredient"> | string | null
    source?: StringNullableWithAggregatesFilter<"SpecificIngredient"> | string | null
  }

  export type IngredientUserWhereInput = {
    AND?: IngredientUserWhereInput | IngredientUserWhereInput[]
    OR?: IngredientUserWhereInput[]
    NOT?: IngredientUserWhereInput | IngredientUserWhereInput[]
    ingredientId?: StringFilter<"IngredientUser"> | string
    userId?: StringFilter<"IngredientUser"> | string
    permission?: StringFilter<"IngredientUser"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    ingredient?: XOR<SpecificIngredientRelationFilter, SpecificIngredientWhereInput>
  }

  export type IngredientUserOrderByWithRelationInput = {
    ingredientId?: SortOrder
    userId?: SortOrder
    permission?: SortOrder
    user?: UserOrderByWithRelationInput
    ingredient?: SpecificIngredientOrderByWithRelationInput
  }

  export type IngredientUserWhereUniqueInput = Prisma.AtLeast<{
    ingredientId_userId?: IngredientUserIngredientIdUserIdCompoundUniqueInput
    AND?: IngredientUserWhereInput | IngredientUserWhereInput[]
    OR?: IngredientUserWhereInput[]
    NOT?: IngredientUserWhereInput | IngredientUserWhereInput[]
    ingredientId?: StringFilter<"IngredientUser"> | string
    userId?: StringFilter<"IngredientUser"> | string
    permission?: StringFilter<"IngredientUser"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    ingredient?: XOR<SpecificIngredientRelationFilter, SpecificIngredientWhereInput>
  }, "ingredientId_userId">

  export type IngredientUserOrderByWithAggregationInput = {
    ingredientId?: SortOrder
    userId?: SortOrder
    permission?: SortOrder
    _count?: IngredientUserCountOrderByAggregateInput
    _max?: IngredientUserMaxOrderByAggregateInput
    _min?: IngredientUserMinOrderByAggregateInput
  }

  export type IngredientUserScalarWhereWithAggregatesInput = {
    AND?: IngredientUserScalarWhereWithAggregatesInput | IngredientUserScalarWhereWithAggregatesInput[]
    OR?: IngredientUserScalarWhereWithAggregatesInput[]
    NOT?: IngredientUserScalarWhereWithAggregatesInput | IngredientUserScalarWhereWithAggregatesInput[]
    ingredientId?: StringWithAggregatesFilter<"IngredientUser"> | string
    userId?: StringWithAggregatesFilter<"IngredientUser"> | string
    permission?: StringWithAggregatesFilter<"IngredientUser"> | string
  }

  export type IngredientPreferenceWhereInput = {
    AND?: IngredientPreferenceWhereInput | IngredientPreferenceWhereInput[]
    OR?: IngredientPreferenceWhereInput[]
    NOT?: IngredientPreferenceWhereInput | IngredientPreferenceWhereInput[]
    genericIngredientId?: StringFilter<"IngredientPreference"> | string
    specificIngredientId?: StringFilter<"IngredientPreference"> | string
    userId?: StringFilter<"IngredientPreference"> | string
    genericIngredient?: XOR<GenericIngredientRelationFilter, GenericIngredientWhereInput>
    specificIngredient?: XOR<SpecificIngredientRelationFilter, SpecificIngredientWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type IngredientPreferenceOrderByWithRelationInput = {
    genericIngredientId?: SortOrder
    specificIngredientId?: SortOrder
    userId?: SortOrder
    genericIngredient?: GenericIngredientOrderByWithRelationInput
    specificIngredient?: SpecificIngredientOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type IngredientPreferenceWhereUniqueInput = Prisma.AtLeast<{
    genericIngredientId_specificIngredientId?: IngredientPreferenceGenericIngredientIdSpecificIngredientIdCompoundUniqueInput
    AND?: IngredientPreferenceWhereInput | IngredientPreferenceWhereInput[]
    OR?: IngredientPreferenceWhereInput[]
    NOT?: IngredientPreferenceWhereInput | IngredientPreferenceWhereInput[]
    genericIngredientId?: StringFilter<"IngredientPreference"> | string
    specificIngredientId?: StringFilter<"IngredientPreference"> | string
    userId?: StringFilter<"IngredientPreference"> | string
    genericIngredient?: XOR<GenericIngredientRelationFilter, GenericIngredientWhereInput>
    specificIngredient?: XOR<SpecificIngredientRelationFilter, SpecificIngredientWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "genericIngredientId_specificIngredientId">

  export type IngredientPreferenceOrderByWithAggregationInput = {
    genericIngredientId?: SortOrder
    specificIngredientId?: SortOrder
    userId?: SortOrder
    _count?: IngredientPreferenceCountOrderByAggregateInput
    _max?: IngredientPreferenceMaxOrderByAggregateInput
    _min?: IngredientPreferenceMinOrderByAggregateInput
  }

  export type IngredientPreferenceScalarWhereWithAggregatesInput = {
    AND?: IngredientPreferenceScalarWhereWithAggregatesInput | IngredientPreferenceScalarWhereWithAggregatesInput[]
    OR?: IngredientPreferenceScalarWhereWithAggregatesInput[]
    NOT?: IngredientPreferenceScalarWhereWithAggregatesInput | IngredientPreferenceScalarWhereWithAggregatesInput[]
    genericIngredientId?: StringWithAggregatesFilter<"IngredientPreference"> | string
    specificIngredientId?: StringWithAggregatesFilter<"IngredientPreference"> | string
    userId?: StringWithAggregatesFilter<"IngredientPreference"> | string
  }

  export type InventoryWhereInput = {
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    id?: StringFilter<"Inventory"> | string
    name?: StringFilter<"Inventory"> | string
    description?: StringFilter<"Inventory"> | string
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    editedAt?: DateTimeFilter<"Inventory"> | Date | string
    createdById?: StringFilter<"Inventory"> | string
    editedById?: StringFilter<"Inventory"> | string
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    editedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    inventoryStorage?: InventoryStorageListRelationFilter
    inventoryUser?: InventoryUserListRelationFilter
  }

  export type InventoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    editedBy?: UserOrderByWithRelationInput
    inventoryStorage?: InventoryStorageOrderByRelationAggregateInput
    inventoryUser?: InventoryUserOrderByRelationAggregateInput
  }

  export type InventoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    name?: StringFilter<"Inventory"> | string
    description?: StringFilter<"Inventory"> | string
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    editedAt?: DateTimeFilter<"Inventory"> | Date | string
    createdById?: StringFilter<"Inventory"> | string
    editedById?: StringFilter<"Inventory"> | string
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    editedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    inventoryStorage?: InventoryStorageListRelationFilter
    inventoryUser?: InventoryUserListRelationFilter
  }, "id">

  export type InventoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    _count?: InventoryCountOrderByAggregateInput
    _max?: InventoryMaxOrderByAggregateInput
    _min?: InventoryMinOrderByAggregateInput
  }

  export type InventoryScalarWhereWithAggregatesInput = {
    AND?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    OR?: InventoryScalarWhereWithAggregatesInput[]
    NOT?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Inventory"> | string
    name?: StringWithAggregatesFilter<"Inventory"> | string
    description?: StringWithAggregatesFilter<"Inventory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string
    editedAt?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string
    createdById?: StringWithAggregatesFilter<"Inventory"> | string
    editedById?: StringWithAggregatesFilter<"Inventory"> | string
  }

  export type InventoryUserWhereInput = {
    AND?: InventoryUserWhereInput | InventoryUserWhereInput[]
    OR?: InventoryUserWhereInput[]
    NOT?: InventoryUserWhereInput | InventoryUserWhereInput[]
    userId?: StringFilter<"InventoryUser"> | string
    inventoryId?: StringFilter<"InventoryUser"> | string
    permission?: StringFilter<"InventoryUser"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    inventory?: XOR<InventoryRelationFilter, InventoryWhereInput>
  }

  export type InventoryUserOrderByWithRelationInput = {
    userId?: SortOrder
    inventoryId?: SortOrder
    permission?: SortOrder
    user?: UserOrderByWithRelationInput
    inventory?: InventoryOrderByWithRelationInput
  }

  export type InventoryUserWhereUniqueInput = Prisma.AtLeast<{
    userId_inventoryId?: InventoryUserUserIdInventoryIdCompoundUniqueInput
    AND?: InventoryUserWhereInput | InventoryUserWhereInput[]
    OR?: InventoryUserWhereInput[]
    NOT?: InventoryUserWhereInput | InventoryUserWhereInput[]
    userId?: StringFilter<"InventoryUser"> | string
    inventoryId?: StringFilter<"InventoryUser"> | string
    permission?: StringFilter<"InventoryUser"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    inventory?: XOR<InventoryRelationFilter, InventoryWhereInput>
  }, "userId_inventoryId">

  export type InventoryUserOrderByWithAggregationInput = {
    userId?: SortOrder
    inventoryId?: SortOrder
    permission?: SortOrder
    _count?: InventoryUserCountOrderByAggregateInput
    _max?: InventoryUserMaxOrderByAggregateInput
    _min?: InventoryUserMinOrderByAggregateInput
  }

  export type InventoryUserScalarWhereWithAggregatesInput = {
    AND?: InventoryUserScalarWhereWithAggregatesInput | InventoryUserScalarWhereWithAggregatesInput[]
    OR?: InventoryUserScalarWhereWithAggregatesInput[]
    NOT?: InventoryUserScalarWhereWithAggregatesInput | InventoryUserScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"InventoryUser"> | string
    inventoryId?: StringWithAggregatesFilter<"InventoryUser"> | string
    permission?: StringWithAggregatesFilter<"InventoryUser"> | string
  }

  export type StorageWhereInput = {
    AND?: StorageWhereInput | StorageWhereInput[]
    OR?: StorageWhereInput[]
    NOT?: StorageWhereInput | StorageWhereInput[]
    id?: StringFilter<"Storage"> | string
    name?: StringFilter<"Storage"> | string
    description?: StringFilter<"Storage"> | string
    createdAt?: DateTimeFilter<"Storage"> | Date | string
    editedAt?: DateTimeFilter<"Storage"> | Date | string
    createdById?: StringFilter<"Storage"> | string
    editedById?: StringFilter<"Storage"> | string
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    editedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    inventoryStorage?: InventoryStorageListRelationFilter
    ingredientStorage?: IngredientStorageListRelationFilter
    storageUser?: StorageUserListRelationFilter
  }

  export type StorageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    editedBy?: UserOrderByWithRelationInput
    inventoryStorage?: InventoryStorageOrderByRelationAggregateInput
    ingredientStorage?: IngredientStorageOrderByRelationAggregateInput
    storageUser?: StorageUserOrderByRelationAggregateInput
  }

  export type StorageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StorageWhereInput | StorageWhereInput[]
    OR?: StorageWhereInput[]
    NOT?: StorageWhereInput | StorageWhereInput[]
    name?: StringFilter<"Storage"> | string
    description?: StringFilter<"Storage"> | string
    createdAt?: DateTimeFilter<"Storage"> | Date | string
    editedAt?: DateTimeFilter<"Storage"> | Date | string
    createdById?: StringFilter<"Storage"> | string
    editedById?: StringFilter<"Storage"> | string
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    editedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    inventoryStorage?: InventoryStorageListRelationFilter
    ingredientStorage?: IngredientStorageListRelationFilter
    storageUser?: StorageUserListRelationFilter
  }, "id">

  export type StorageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    _count?: StorageCountOrderByAggregateInput
    _max?: StorageMaxOrderByAggregateInput
    _min?: StorageMinOrderByAggregateInput
  }

  export type StorageScalarWhereWithAggregatesInput = {
    AND?: StorageScalarWhereWithAggregatesInput | StorageScalarWhereWithAggregatesInput[]
    OR?: StorageScalarWhereWithAggregatesInput[]
    NOT?: StorageScalarWhereWithAggregatesInput | StorageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Storage"> | string
    name?: StringWithAggregatesFilter<"Storage"> | string
    description?: StringWithAggregatesFilter<"Storage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Storage"> | Date | string
    editedAt?: DateTimeWithAggregatesFilter<"Storage"> | Date | string
    createdById?: StringWithAggregatesFilter<"Storage"> | string
    editedById?: StringWithAggregatesFilter<"Storage"> | string
  }

  export type InventoryStorageWhereInput = {
    AND?: InventoryStorageWhereInput | InventoryStorageWhereInput[]
    OR?: InventoryStorageWhereInput[]
    NOT?: InventoryStorageWhereInput | InventoryStorageWhereInput[]
    inventoryId?: StringFilter<"InventoryStorage"> | string
    storageId?: StringFilter<"InventoryStorage"> | string
    storage?: XOR<StorageRelationFilter, StorageWhereInput>
    inventory?: XOR<InventoryRelationFilter, InventoryWhereInput>
  }

  export type InventoryStorageOrderByWithRelationInput = {
    inventoryId?: SortOrder
    storageId?: SortOrder
    storage?: StorageOrderByWithRelationInput
    inventory?: InventoryOrderByWithRelationInput
  }

  export type InventoryStorageWhereUniqueInput = Prisma.AtLeast<{
    inventoryId_storageId?: InventoryStorageInventoryIdStorageIdCompoundUniqueInput
    AND?: InventoryStorageWhereInput | InventoryStorageWhereInput[]
    OR?: InventoryStorageWhereInput[]
    NOT?: InventoryStorageWhereInput | InventoryStorageWhereInput[]
    inventoryId?: StringFilter<"InventoryStorage"> | string
    storageId?: StringFilter<"InventoryStorage"> | string
    storage?: XOR<StorageRelationFilter, StorageWhereInput>
    inventory?: XOR<InventoryRelationFilter, InventoryWhereInput>
  }, "inventoryId_storageId">

  export type InventoryStorageOrderByWithAggregationInput = {
    inventoryId?: SortOrder
    storageId?: SortOrder
    _count?: InventoryStorageCountOrderByAggregateInput
    _max?: InventoryStorageMaxOrderByAggregateInput
    _min?: InventoryStorageMinOrderByAggregateInput
  }

  export type InventoryStorageScalarWhereWithAggregatesInput = {
    AND?: InventoryStorageScalarWhereWithAggregatesInput | InventoryStorageScalarWhereWithAggregatesInput[]
    OR?: InventoryStorageScalarWhereWithAggregatesInput[]
    NOT?: InventoryStorageScalarWhereWithAggregatesInput | InventoryStorageScalarWhereWithAggregatesInput[]
    inventoryId?: StringWithAggregatesFilter<"InventoryStorage"> | string
    storageId?: StringWithAggregatesFilter<"InventoryStorage"> | string
  }

  export type IngredientStorageWhereInput = {
    AND?: IngredientStorageWhereInput | IngredientStorageWhereInput[]
    OR?: IngredientStorageWhereInput[]
    NOT?: IngredientStorageWhereInput | IngredientStorageWhereInput[]
    ingredientId?: StringFilter<"IngredientStorage"> | string
    storageId?: StringFilter<"IngredientStorage"> | string
    quantity?: FloatNullableFilter<"IngredientStorage"> | number | null
    ingredient?: XOR<SpecificIngredientRelationFilter, SpecificIngredientWhereInput>
    Storage?: XOR<StorageRelationFilter, StorageWhereInput>
  }

  export type IngredientStorageOrderByWithRelationInput = {
    ingredientId?: SortOrder
    storageId?: SortOrder
    quantity?: SortOrderInput | SortOrder
    ingredient?: SpecificIngredientOrderByWithRelationInput
    Storage?: StorageOrderByWithRelationInput
  }

  export type IngredientStorageWhereUniqueInput = Prisma.AtLeast<{
    ingredientId_storageId?: IngredientStorageIngredientIdStorageIdCompoundUniqueInput
    AND?: IngredientStorageWhereInput | IngredientStorageWhereInput[]
    OR?: IngredientStorageWhereInput[]
    NOT?: IngredientStorageWhereInput | IngredientStorageWhereInput[]
    ingredientId?: StringFilter<"IngredientStorage"> | string
    storageId?: StringFilter<"IngredientStorage"> | string
    quantity?: FloatNullableFilter<"IngredientStorage"> | number | null
    ingredient?: XOR<SpecificIngredientRelationFilter, SpecificIngredientWhereInput>
    Storage?: XOR<StorageRelationFilter, StorageWhereInput>
  }, "ingredientId_storageId">

  export type IngredientStorageOrderByWithAggregationInput = {
    ingredientId?: SortOrder
    storageId?: SortOrder
    quantity?: SortOrderInput | SortOrder
    _count?: IngredientStorageCountOrderByAggregateInput
    _avg?: IngredientStorageAvgOrderByAggregateInput
    _max?: IngredientStorageMaxOrderByAggregateInput
    _min?: IngredientStorageMinOrderByAggregateInput
    _sum?: IngredientStorageSumOrderByAggregateInput
  }

  export type IngredientStorageScalarWhereWithAggregatesInput = {
    AND?: IngredientStorageScalarWhereWithAggregatesInput | IngredientStorageScalarWhereWithAggregatesInput[]
    OR?: IngredientStorageScalarWhereWithAggregatesInput[]
    NOT?: IngredientStorageScalarWhereWithAggregatesInput | IngredientStorageScalarWhereWithAggregatesInput[]
    ingredientId?: StringWithAggregatesFilter<"IngredientStorage"> | string
    storageId?: StringWithAggregatesFilter<"IngredientStorage"> | string
    quantity?: FloatNullableWithAggregatesFilter<"IngredientStorage"> | number | null
  }

  export type StorageUserWhereInput = {
    AND?: StorageUserWhereInput | StorageUserWhereInput[]
    OR?: StorageUserWhereInput[]
    NOT?: StorageUserWhereInput | StorageUserWhereInput[]
    userId?: StringFilter<"StorageUser"> | string
    storageId?: StringFilter<"StorageUser"> | string
    permission?: StringFilter<"StorageUser"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    Storage?: XOR<StorageRelationFilter, StorageWhereInput>
  }

  export type StorageUserOrderByWithRelationInput = {
    userId?: SortOrder
    storageId?: SortOrder
    permission?: SortOrder
    user?: UserOrderByWithRelationInput
    Storage?: StorageOrderByWithRelationInput
  }

  export type StorageUserWhereUniqueInput = Prisma.AtLeast<{
    userId_storageId?: StorageUserUserIdStorageIdCompoundUniqueInput
    AND?: StorageUserWhereInput | StorageUserWhereInput[]
    OR?: StorageUserWhereInput[]
    NOT?: StorageUserWhereInput | StorageUserWhereInput[]
    userId?: StringFilter<"StorageUser"> | string
    storageId?: StringFilter<"StorageUser"> | string
    permission?: StringFilter<"StorageUser"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    Storage?: XOR<StorageRelationFilter, StorageWhereInput>
  }, "userId_storageId">

  export type StorageUserOrderByWithAggregationInput = {
    userId?: SortOrder
    storageId?: SortOrder
    permission?: SortOrder
    _count?: StorageUserCountOrderByAggregateInput
    _max?: StorageUserMaxOrderByAggregateInput
    _min?: StorageUserMinOrderByAggregateInput
  }

  export type StorageUserScalarWhereWithAggregatesInput = {
    AND?: StorageUserScalarWhereWithAggregatesInput | StorageUserScalarWhereWithAggregatesInput[]
    OR?: StorageUserScalarWhereWithAggregatesInput[]
    NOT?: StorageUserScalarWhereWithAggregatesInput | StorageUserScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"StorageUser"> | string
    storageId?: StringWithAggregatesFilter<"StorageUser"> | string
    permission?: StringWithAggregatesFilter<"StorageUser"> | string
  }

  export type CrewWhereInput = {
    AND?: CrewWhereInput | CrewWhereInput[]
    OR?: CrewWhereInput[]
    NOT?: CrewWhereInput | CrewWhereInput[]
    id?: StringFilter<"Crew"> | string
    name?: StringFilter<"Crew"> | string
    description?: StringFilter<"Crew"> | string
    createdAt?: DateTimeFilter<"Crew"> | Date | string
    editedAt?: DateTimeFilter<"Crew"> | Date | string
    createdById?: StringFilter<"Crew"> | string
    editedById?: StringFilter<"Crew"> | string
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    editedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    userCrew?: CrewUserListRelationFilter
  }

  export type CrewOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    editedBy?: UserOrderByWithRelationInput
    userCrew?: CrewUserOrderByRelationAggregateInput
  }

  export type CrewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CrewWhereInput | CrewWhereInput[]
    OR?: CrewWhereInput[]
    NOT?: CrewWhereInput | CrewWhereInput[]
    name?: StringFilter<"Crew"> | string
    description?: StringFilter<"Crew"> | string
    createdAt?: DateTimeFilter<"Crew"> | Date | string
    editedAt?: DateTimeFilter<"Crew"> | Date | string
    createdById?: StringFilter<"Crew"> | string
    editedById?: StringFilter<"Crew"> | string
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    editedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    userCrew?: CrewUserListRelationFilter
  }, "id">

  export type CrewOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    _count?: CrewCountOrderByAggregateInput
    _max?: CrewMaxOrderByAggregateInput
    _min?: CrewMinOrderByAggregateInput
  }

  export type CrewScalarWhereWithAggregatesInput = {
    AND?: CrewScalarWhereWithAggregatesInput | CrewScalarWhereWithAggregatesInput[]
    OR?: CrewScalarWhereWithAggregatesInput[]
    NOT?: CrewScalarWhereWithAggregatesInput | CrewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Crew"> | string
    name?: StringWithAggregatesFilter<"Crew"> | string
    description?: StringWithAggregatesFilter<"Crew"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Crew"> | Date | string
    editedAt?: DateTimeWithAggregatesFilter<"Crew"> | Date | string
    createdById?: StringWithAggregatesFilter<"Crew"> | string
    editedById?: StringWithAggregatesFilter<"Crew"> | string
  }

  export type CrewUserWhereInput = {
    AND?: CrewUserWhereInput | CrewUserWhereInput[]
    OR?: CrewUserWhereInput[]
    NOT?: CrewUserWhereInput | CrewUserWhereInput[]
    userId?: StringFilter<"CrewUser"> | string
    crewId?: StringFilter<"CrewUser"> | string
    permission?: StringFilter<"CrewUser"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    crew?: XOR<CrewRelationFilter, CrewWhereInput>
  }

  export type CrewUserOrderByWithRelationInput = {
    userId?: SortOrder
    crewId?: SortOrder
    permission?: SortOrder
    user?: UserOrderByWithRelationInput
    crew?: CrewOrderByWithRelationInput
  }

  export type CrewUserWhereUniqueInput = Prisma.AtLeast<{
    userId_crewId?: CrewUserUserIdCrewIdCompoundUniqueInput
    AND?: CrewUserWhereInput | CrewUserWhereInput[]
    OR?: CrewUserWhereInput[]
    NOT?: CrewUserWhereInput | CrewUserWhereInput[]
    userId?: StringFilter<"CrewUser"> | string
    crewId?: StringFilter<"CrewUser"> | string
    permission?: StringFilter<"CrewUser"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    crew?: XOR<CrewRelationFilter, CrewWhereInput>
  }, "userId_crewId">

  export type CrewUserOrderByWithAggregationInput = {
    userId?: SortOrder
    crewId?: SortOrder
    permission?: SortOrder
    _count?: CrewUserCountOrderByAggregateInput
    _max?: CrewUserMaxOrderByAggregateInput
    _min?: CrewUserMinOrderByAggregateInput
  }

  export type CrewUserScalarWhereWithAggregatesInput = {
    AND?: CrewUserScalarWhereWithAggregatesInput | CrewUserScalarWhereWithAggregatesInput[]
    OR?: CrewUserScalarWhereWithAggregatesInput[]
    NOT?: CrewUserScalarWhereWithAggregatesInput | CrewUserScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"CrewUser"> | string
    crewId?: StringWithAggregatesFilter<"CrewUser"> | string
    permission?: StringWithAggregatesFilter<"CrewUser"> | string
  }

  export type UserCreateInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type FollowCreateInput = {
    relationship: string
    followedBy: UserCreateNestedOneWithoutFollowedByInput
    following: UserCreateNestedOneWithoutFollowingInput
  }

  export type FollowUncheckedCreateInput = {
    followedById: string
    followingId: string
    relationship: string
  }

  export type FollowUpdateInput = {
    relationship?: StringFieldUpdateOperationsInput | string
    followedBy?: UserUpdateOneRequiredWithoutFollowedByNestedInput
    following?: UserUpdateOneRequiredWithoutFollowingNestedInput
  }

  export type FollowUncheckedUpdateInput = {
    followedById?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
  }

  export type FollowCreateManyInput = {
    followedById: string
    followingId: string
    relationship: string
  }

  export type FollowUpdateManyMutationInput = {
    relationship?: StringFieldUpdateOperationsInput | string
  }

  export type FollowUncheckedUpdateManyInput = {
    followedById?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileCreateInput = {
    id?: string
    photo: string
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: string
    userId: string
    photo: string
  }

  export type ProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileCreateManyInput = {
    id?: string
    userId: string
    photo: string
  }

  export type ProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutRecipeBookInput
    editedBy?: UserCreateNestedOneWithoutRecipeBookEditedByInput
    recipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutRecipeBookInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    editedById?: string | null
    recipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutRecipeBookInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutRecipeBookNestedInput
    editedBy?: UserUpdateOneWithoutRecipeBookEditedByNestedInput
    recipeBookBuild?: RecipeBookBuildUpdateManyWithoutRecipeBookNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutRecipeBookNestedInput
  }

  export type RecipeBookUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutRecipeBookNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutRecipeBookNestedInput
  }

  export type RecipeBookCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    editedById?: string | null
  }

  export type RecipeBookUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipeBookUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeBookUserCreateInput = {
    permission: string
    recipeBook: RecipeBookCreateNestedOneWithoutRecipeBookUserInput
    user: UserCreateNestedOneWithoutRecipeBookUserInput
  }

  export type RecipeBookUserUncheckedCreateInput = {
    userId: string
    recipeBookId: string
    permission: string
  }

  export type RecipeBookUserUpdateInput = {
    permission?: StringFieldUpdateOperationsInput | string
    recipeBook?: RecipeBookUpdateOneRequiredWithoutRecipeBookUserNestedInput
    user?: UserUpdateOneRequiredWithoutRecipeBookUserNestedInput
  }

  export type RecipeBookUserUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    recipeBookId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookUserCreateManyInput = {
    userId: string
    recipeBookId: string
    permission: string
  }

  export type RecipeBookUserUpdateManyMutationInput = {
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookUserUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    recipeBookId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type BuildCreateInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    createdBy?: UserCreateNestedOneWithoutBuildInput
    editedBy?: UserCreateNestedOneWithoutBuildEditedByInput
    recipe?: RecipeCreateNestedOneWithoutBuildInput
    touch?: TouchCreateNestedManyWithoutBuildInput
    archivedTouch?: ArchivedTouchCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserCreateNestedManyWithoutBuildInput
  }

  export type BuildUncheckedCreateInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    editedById?: string | null
    recipeId?: string | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutBuildInput
    archivedTouch?: ArchivedTouchUncheckedCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutBuildInput
  }

  export type BuildUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutBuildNestedInput
    editedBy?: UserUpdateOneWithoutBuildEditedByNestedInput
    recipe?: RecipeUpdateOneWithoutBuildNestedInput
    touch?: TouchUpdateManyWithoutBuildNestedInput
    archivedTouch?: ArchivedTouchUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeId?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutBuildNestedInput
    archivedTouch?: ArchivedTouchUncheckedUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutBuildNestedInput
  }

  export type BuildCreateManyInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    editedById?: string | null
    recipeId?: string | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
  }

  export type BuildUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BuildUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeId?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BuildUserCreateInput = {
    permission: string
    user?: UserCreateNestedOneWithoutBuildUserInput
    build?: BuildCreateNestedOneWithoutBuildUserInput
  }

  export type BuildUserUncheckedCreateInput = {
    userId: string
    buildId: string
    permission: string
  }

  export type BuildUserUpdateInput = {
    permission?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneWithoutBuildUserNestedInput
    build?: BuildUpdateOneWithoutBuildUserNestedInput
  }

  export type BuildUserUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    buildId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type BuildUserCreateManyInput = {
    userId: string
    buildId: string
    permission: string
  }

  export type BuildUserUpdateManyMutationInput = {
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type BuildUserUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    buildId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeCreateInput = {
    id?: string
    createdAt?: Date | string
    editedAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    createdBy?: UserCreateNestedOneWithoutRecipeInput
    editedBy?: UserCreateNestedOneWithoutRecipeEditedByInput
    build?: BuildCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    editedAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    createdById?: string | null
    editedById?: string | null
    build?: BuildUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutRecipeNestedInput
    editedBy?: UserUpdateOneWithoutRecipeEditedByNestedInput
    build?: BuildUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    build?: BuildUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeCreateManyInput = {
    id?: string
    createdAt?: Date | string
    editedAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    createdById?: string | null
    editedById?: string | null
  }

  export type RecipeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeBookBuildCreateInput = {
    recipeBook: RecipeBookCreateNestedOneWithoutRecipeBookBuildInput
    build: BuildCreateNestedOneWithoutRecipeBookBuildInput
  }

  export type RecipeBookBuildUncheckedCreateInput = {
    buildId: string
    recipeBookId: string
  }

  export type RecipeBookBuildUpdateInput = {
    recipeBook?: RecipeBookUpdateOneRequiredWithoutRecipeBookBuildNestedInput
    build?: BuildUpdateOneRequiredWithoutRecipeBookBuildNestedInput
  }

  export type RecipeBookBuildUncheckedUpdateInput = {
    buildId?: StringFieldUpdateOperationsInput | string
    recipeBookId?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookBuildCreateManyInput = {
    buildId: string
    recipeBookId: string
  }

  export type RecipeBookBuildUpdateManyMutationInput = {

  }

  export type RecipeBookBuildUncheckedUpdateManyInput = {
    buildId?: StringFieldUpdateOperationsInput | string
    recipeBookId?: StringFieldUpdateOperationsInput | string
  }

  export type TouchCreateInput = {
    id?: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    version?: number | null
    build: BuildCreateNestedOneWithoutTouchInput
    genericIngredient: GenericIngredientCreateNestedOneWithoutTouchInput
    specificIngredient?: SpecificIngredientCreateNestedOneWithoutTouchInput
  }

  export type TouchUncheckedCreateInput = {
    id?: string
    buildId: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    genericIngredientId: string
    specificIngredientId?: string | null
    version?: number | null
  }

  export type TouchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    build?: BuildUpdateOneRequiredWithoutTouchNestedInput
    genericIngredient?: GenericIngredientUpdateOneRequiredWithoutTouchNestedInput
    specificIngredient?: SpecificIngredientUpdateOneWithoutTouchNestedInput
  }

  export type TouchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    genericIngredientId?: StringFieldUpdateOperationsInput | string
    specificIngredientId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TouchCreateManyInput = {
    id?: string
    buildId: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    genericIngredientId: string
    specificIngredientId?: string | null
    version?: number | null
  }

  export type TouchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TouchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    genericIngredientId?: StringFieldUpdateOperationsInput | string
    specificIngredientId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ArchivedTouchCreateInput = {
    id?: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    version?: number | null
    build: BuildCreateNestedOneWithoutArchivedTouchInput
    genericIngredient: GenericIngredientCreateNestedOneWithoutArchivedTouchInput
    specificIngredient?: SpecificIngredientCreateNestedOneWithoutArchivedTouchInput
  }

  export type ArchivedTouchUncheckedCreateInput = {
    id?: string
    buildId: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    genericIngredientId: string
    specificIngredientId?: string | null
    version?: number | null
  }

  export type ArchivedTouchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    build?: BuildUpdateOneRequiredWithoutArchivedTouchNestedInput
    genericIngredient?: GenericIngredientUpdateOneRequiredWithoutArchivedTouchNestedInput
    specificIngredient?: SpecificIngredientUpdateOneWithoutArchivedTouchNestedInput
  }

  export type ArchivedTouchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    genericIngredientId?: StringFieldUpdateOperationsInput | string
    specificIngredientId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ArchivedTouchCreateManyInput = {
    id?: string
    buildId: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    genericIngredientId: string
    specificIngredientId?: string | null
    version?: number | null
  }

  export type ArchivedTouchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ArchivedTouchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    genericIngredientId?: StringFieldUpdateOperationsInput | string
    specificIngredientId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GenericIngredientCreateInput = {
    id?: string
    name: string
    description?: string | null
    touch?: TouchCreateNestedManyWithoutGenericIngredientInput
    archivedTouch?: ArchivedTouchCreateNestedManyWithoutGenericIngredientInput
    specificIngredient?: SpecificIngredientCreateNestedManyWithoutGenericIngredientInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutGenericIngredientInput
  }

  export type GenericIngredientUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutGenericIngredientInput
    archivedTouch?: ArchivedTouchUncheckedCreateNestedManyWithoutGenericIngredientInput
    specificIngredient?: SpecificIngredientUncheckedCreateNestedManyWithoutGenericIngredientInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutGenericIngredientInput
  }

  export type GenericIngredientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUpdateManyWithoutGenericIngredientNestedInput
    archivedTouch?: ArchivedTouchUpdateManyWithoutGenericIngredientNestedInput
    specificIngredient?: SpecificIngredientUpdateManyWithoutGenericIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutGenericIngredientNestedInput
  }

  export type GenericIngredientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutGenericIngredientNestedInput
    archivedTouch?: ArchivedTouchUncheckedUpdateManyWithoutGenericIngredientNestedInput
    specificIngredient?: SpecificIngredientUncheckedUpdateManyWithoutGenericIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutGenericIngredientNestedInput
  }

  export type GenericIngredientCreateManyInput = {
    id?: string
    name: string
    description?: string | null
  }

  export type GenericIngredientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GenericIngredientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpecificIngredientCreateInput = {
    id?: string
    dateCreated?: Date | string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    createdBy?: UserCreateNestedOneWithoutIngredientInput
    genericIngredient: GenericIngredientCreateNestedOneWithoutSpecificIngredientInput
    touch?: TouchCreateNestedManyWithoutSpecificIngredientInput
    archivedTouch?: ArchivedTouchCreateNestedManyWithoutSpecificIngredientInput
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutIngredientInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutSpecificIngredientInput
  }

  export type SpecificIngredientUncheckedCreateInput = {
    id?: string
    dateCreated?: Date | string
    createdById?: string | null
    genericIngredientId: string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutSpecificIngredientInput
    archivedTouch?: ArchivedTouchUncheckedCreateNestedManyWithoutSpecificIngredientInput
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutIngredientInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutSpecificIngredientInput
  }

  export type SpecificIngredientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutIngredientNestedInput
    genericIngredient?: GenericIngredientUpdateOneRequiredWithoutSpecificIngredientNestedInput
    touch?: TouchUpdateManyWithoutSpecificIngredientNestedInput
    archivedTouch?: ArchivedTouchUpdateManyWithoutSpecificIngredientNestedInput
    ingredientStorage?: IngredientStorageUpdateManyWithoutIngredientNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutSpecificIngredientNestedInput
  }

  export type SpecificIngredientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    genericIngredientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutSpecificIngredientNestedInput
    archivedTouch?: ArchivedTouchUncheckedUpdateManyWithoutSpecificIngredientNestedInput
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutSpecificIngredientNestedInput
  }

  export type SpecificIngredientCreateManyInput = {
    id?: string
    dateCreated?: Date | string
    createdById?: string | null
    genericIngredientId: string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
  }

  export type SpecificIngredientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpecificIngredientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    genericIngredientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IngredientUserCreateInput = {
    permission: string
    user: UserCreateNestedOneWithoutIngredientUserInput
    ingredient: SpecificIngredientCreateNestedOneWithoutIngredientUserInput
  }

  export type IngredientUserUncheckedCreateInput = {
    ingredientId: string
    userId: string
    permission: string
  }

  export type IngredientUserUpdateInput = {
    permission?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutIngredientUserNestedInput
    ingredient?: SpecificIngredientUpdateOneRequiredWithoutIngredientUserNestedInput
  }

  export type IngredientUserUncheckedUpdateInput = {
    ingredientId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type IngredientUserCreateManyInput = {
    ingredientId: string
    userId: string
    permission: string
  }

  export type IngredientUserUpdateManyMutationInput = {
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type IngredientUserUncheckedUpdateManyInput = {
    ingredientId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type IngredientPreferenceCreateInput = {
    genericIngredient: GenericIngredientCreateNestedOneWithoutIngredientPreferenceInput
    specificIngredient: SpecificIngredientCreateNestedOneWithoutIngredientPreferenceInput
    user: UserCreateNestedOneWithoutIngredientPreferenceInput
  }

  export type IngredientPreferenceUncheckedCreateInput = {
    genericIngredientId: string
    specificIngredientId: string
    userId: string
  }

  export type IngredientPreferenceUpdateInput = {
    genericIngredient?: GenericIngredientUpdateOneRequiredWithoutIngredientPreferenceNestedInput
    specificIngredient?: SpecificIngredientUpdateOneRequiredWithoutIngredientPreferenceNestedInput
    user?: UserUpdateOneRequiredWithoutIngredientPreferenceNestedInput
  }

  export type IngredientPreferenceUncheckedUpdateInput = {
    genericIngredientId?: StringFieldUpdateOperationsInput | string
    specificIngredientId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type IngredientPreferenceCreateManyInput = {
    genericIngredientId: string
    specificIngredientId: string
    userId: string
  }

  export type IngredientPreferenceUpdateManyMutationInput = {

  }

  export type IngredientPreferenceUncheckedUpdateManyInput = {
    genericIngredientId?: StringFieldUpdateOperationsInput | string
    specificIngredientId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryCreateInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutInventoryInput
    editedBy?: UserCreateNestedOneWithoutInventoryEditedByInput
    inventoryStorage?: InventoryStorageCreateNestedManyWithoutInventoryInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    inventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutInventoryInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutInventoryNestedInput
    editedBy?: UserUpdateOneWithoutInventoryEditedByNestedInput
    inventoryStorage?: InventoryStorageUpdateManyWithoutInventoryNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    inventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutInventoryNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryCreateManyInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
  }

  export type InventoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryUserCreateInput = {
    permission: string
    user: UserCreateNestedOneWithoutInventoryUserInput
    inventory: InventoryCreateNestedOneWithoutInventoryUserInput
  }

  export type InventoryUserUncheckedCreateInput = {
    userId: string
    inventoryId: string
    permission: string
  }

  export type InventoryUserUpdateInput = {
    permission?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutInventoryUserNestedInput
    inventory?: InventoryUpdateOneRequiredWithoutInventoryUserNestedInput
  }

  export type InventoryUserUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    inventoryId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryUserCreateManyInput = {
    userId: string
    inventoryId: string
    permission: string
  }

  export type InventoryUserUpdateManyMutationInput = {
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryUserUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    inventoryId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type StorageCreateInput = {
    id?: string
    name: string
    description?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutStorageInput
    editedBy?: UserCreateNestedOneWithoutStorageEditedByInput
    inventoryStorage?: InventoryStorageCreateNestedManyWithoutStorageInput
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutStorageInput
    storageUser?: StorageUserCreateNestedManyWithoutStorageInput
  }

  export type StorageUncheckedCreateInput = {
    id?: string
    name: string
    description?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    inventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutStorageInput
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutStorageInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutStorageInput
  }

  export type StorageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutStorageNestedInput
    editedBy?: UserUpdateOneWithoutStorageEditedByNestedInput
    inventoryStorage?: InventoryStorageUpdateManyWithoutStorageNestedInput
    ingredientStorage?: IngredientStorageUpdateManyWithoutStorageNestedInput
    storageUser?: StorageUserUpdateManyWithoutStorageNestedInput
  }

  export type StorageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    inventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutStorageNestedInput
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutStorageNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutStorageNestedInput
  }

  export type StorageCreateManyInput = {
    id?: string
    name: string
    description?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
  }

  export type StorageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryStorageCreateInput = {
    storage: StorageCreateNestedOneWithoutInventoryStorageInput
    inventory: InventoryCreateNestedOneWithoutInventoryStorageInput
  }

  export type InventoryStorageUncheckedCreateInput = {
    inventoryId: string
    storageId: string
  }

  export type InventoryStorageUpdateInput = {
    storage?: StorageUpdateOneRequiredWithoutInventoryStorageNestedInput
    inventory?: InventoryUpdateOneRequiredWithoutInventoryStorageNestedInput
  }

  export type InventoryStorageUncheckedUpdateInput = {
    inventoryId?: StringFieldUpdateOperationsInput | string
    storageId?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryStorageCreateManyInput = {
    inventoryId: string
    storageId: string
  }

  export type InventoryStorageUpdateManyMutationInput = {

  }

  export type InventoryStorageUncheckedUpdateManyInput = {
    inventoryId?: StringFieldUpdateOperationsInput | string
    storageId?: StringFieldUpdateOperationsInput | string
  }

  export type IngredientStorageCreateInput = {
    quantity?: number | null
    ingredient: SpecificIngredientCreateNestedOneWithoutIngredientStorageInput
    Storage: StorageCreateNestedOneWithoutIngredientStorageInput
  }

  export type IngredientStorageUncheckedCreateInput = {
    ingredientId: string
    storageId: string
    quantity?: number | null
  }

  export type IngredientStorageUpdateInput = {
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    ingredient?: SpecificIngredientUpdateOneRequiredWithoutIngredientStorageNestedInput
    Storage?: StorageUpdateOneRequiredWithoutIngredientStorageNestedInput
  }

  export type IngredientStorageUncheckedUpdateInput = {
    ingredientId?: StringFieldUpdateOperationsInput | string
    storageId?: StringFieldUpdateOperationsInput | string
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type IngredientStorageCreateManyInput = {
    ingredientId: string
    storageId: string
    quantity?: number | null
  }

  export type IngredientStorageUpdateManyMutationInput = {
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type IngredientStorageUncheckedUpdateManyInput = {
    ingredientId?: StringFieldUpdateOperationsInput | string
    storageId?: StringFieldUpdateOperationsInput | string
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type StorageUserCreateInput = {
    permission: string
    user: UserCreateNestedOneWithoutStorageUserInput
    Storage: StorageCreateNestedOneWithoutStorageUserInput
  }

  export type StorageUserUncheckedCreateInput = {
    userId: string
    storageId: string
    permission: string
  }

  export type StorageUserUpdateInput = {
    permission?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutStorageUserNestedInput
    Storage?: StorageUpdateOneRequiredWithoutStorageUserNestedInput
  }

  export type StorageUserUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    storageId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type StorageUserCreateManyInput = {
    userId: string
    storageId: string
    permission: string
  }

  export type StorageUserUpdateManyMutationInput = {
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type StorageUserUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    storageId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type CrewCreateInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCrewInput
    editedBy?: UserCreateNestedOneWithoutCrewEditedByInput
    userCrew?: CrewUserCreateNestedManyWithoutCrewInput
  }

  export type CrewUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    userCrew?: CrewUserUncheckedCreateNestedManyWithoutCrewInput
  }

  export type CrewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCrewNestedInput
    editedBy?: UserUpdateOneWithoutCrewEditedByNestedInput
    userCrew?: CrewUserUpdateManyWithoutCrewNestedInput
  }

  export type CrewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    userCrew?: CrewUserUncheckedUpdateManyWithoutCrewNestedInput
  }

  export type CrewCreateManyInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
  }

  export type CrewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
  }

  export type CrewUserCreateInput = {
    permission: string
    user: UserCreateNestedOneWithoutCrewUserInput
    crew: CrewCreateNestedOneWithoutUserCrewInput
  }

  export type CrewUserUncheckedCreateInput = {
    userId: string
    crewId: string
    permission: string
  }

  export type CrewUserUpdateInput = {
    permission?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutCrewUserNestedInput
    crew?: CrewUpdateOneRequiredWithoutUserCrewNestedInput
  }

  export type CrewUserUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type CrewUserCreateManyInput = {
    userId: string
    crewId: string
    permission: string
  }

  export type CrewUserUpdateManyMutationInput = {
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type CrewUserUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ProfileNullableRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type RecipeBookUserListRelationFilter = {
    every?: RecipeBookUserWhereInput
    some?: RecipeBookUserWhereInput
    none?: RecipeBookUserWhereInput
  }

  export type RecipeBookListRelationFilter = {
    every?: RecipeBookWhereInput
    some?: RecipeBookWhereInput
    none?: RecipeBookWhereInput
  }

  export type RecipeListRelationFilter = {
    every?: RecipeWhereInput
    some?: RecipeWhereInput
    none?: RecipeWhereInput
  }

  export type BuildUserListRelationFilter = {
    every?: BuildUserWhereInput
    some?: BuildUserWhereInput
    none?: BuildUserWhereInput
  }

  export type BuildListRelationFilter = {
    every?: BuildWhereInput
    some?: BuildWhereInput
    none?: BuildWhereInput
  }

  export type CrewUserListRelationFilter = {
    every?: CrewUserWhereInput
    some?: CrewUserWhereInput
    none?: CrewUserWhereInput
  }

  export type CrewListRelationFilter = {
    every?: CrewWhereInput
    some?: CrewWhereInput
    none?: CrewWhereInput
  }

  export type SpecificIngredientListRelationFilter = {
    every?: SpecificIngredientWhereInput
    some?: SpecificIngredientWhereInput
    none?: SpecificIngredientWhereInput
  }

  export type IngredientPreferenceListRelationFilter = {
    every?: IngredientPreferenceWhereInput
    some?: IngredientPreferenceWhereInput
    none?: IngredientPreferenceWhereInput
  }

  export type IngredientUserListRelationFilter = {
    every?: IngredientUserWhereInput
    some?: IngredientUserWhereInput
    none?: IngredientUserWhereInput
  }

  export type StorageUserListRelationFilter = {
    every?: StorageUserWhereInput
    some?: StorageUserWhereInput
    none?: StorageUserWhereInput
  }

  export type StorageListRelationFilter = {
    every?: StorageWhereInput
    some?: StorageWhereInput
    none?: StorageWhereInput
  }

  export type InventoryListRelationFilter = {
    every?: InventoryWhereInput
    some?: InventoryWhereInput
    none?: InventoryWhereInput
  }

  export type InventoryUserListRelationFilter = {
    every?: InventoryUserWhereInput
    some?: InventoryUserWhereInput
    none?: InventoryUserWhereInput
  }

  export type FollowListRelationFilter = {
    every?: FollowWhereInput
    some?: FollowWhereInput
    none?: FollowWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type RecipeBookUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipeBookOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BuildUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BuildOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CrewUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CrewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpecificIngredientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IngredientPreferenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IngredientUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StorageUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StorageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FollowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    userName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateJoined?: SortOrder
    lastEdited?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    userName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateJoined?: SortOrder
    lastEdited?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    userName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateJoined?: SortOrder
    lastEdited?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type FollowFollowingIdFollowedByIdCompoundUniqueInput = {
    followingId: string
    followedById: string
  }

  export type FollowCountOrderByAggregateInput = {
    followedById?: SortOrder
    followingId?: SortOrder
    relationship?: SortOrder
  }

  export type FollowMaxOrderByAggregateInput = {
    followedById?: SortOrder
    followingId?: SortOrder
    relationship?: SortOrder
  }

  export type FollowMinOrderByAggregateInput = {
    followedById?: SortOrder
    followingId?: SortOrder
    relationship?: SortOrder
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    photo?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    photo?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    photo?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type RecipeBookBuildListRelationFilter = {
    every?: RecipeBookBuildWhereInput
    some?: RecipeBookBuildWhereInput
    none?: RecipeBookBuildWhereInput
  }

  export type RecipeBookBuildOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipeBookCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type RecipeBookMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type RecipeBookMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type RecipeBookRelationFilter = {
    is?: RecipeBookWhereInput
    isNot?: RecipeBookWhereInput
  }

  export type RecipeBookUserUserIdRecipeBookIdCompoundUniqueInput = {
    userId: string
    recipeBookId: string
  }

  export type RecipeBookUserCountOrderByAggregateInput = {
    userId?: SortOrder
    recipeBookId?: SortOrder
    permission?: SortOrder
  }

  export type RecipeBookUserMaxOrderByAggregateInput = {
    userId?: SortOrder
    recipeBookId?: SortOrder
    permission?: SortOrder
  }

  export type RecipeBookUserMinOrderByAggregateInput = {
    userId?: SortOrder
    recipeBookId?: SortOrder
    permission?: SortOrder
  }

  export type RecipeNullableRelationFilter = {
    is?: RecipeWhereInput | null
    isNot?: RecipeWhereInput | null
  }

  export type TouchListRelationFilter = {
    every?: TouchWhereInput
    some?: TouchWhereInput
    none?: TouchWhereInput
  }

  export type ArchivedTouchListRelationFilter = {
    every?: ArchivedTouchWhereInput
    some?: ArchivedTouchWhereInput
    none?: ArchivedTouchWhereInput
  }

  export type TouchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArchivedTouchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BuildCountOrderByAggregateInput = {
    id?: SortOrder
    buildName?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    recipeId?: SortOrder
    instructions?: SortOrder
    notes?: SortOrder
    glassware?: SortOrder
    ice?: SortOrder
  }

  export type BuildMaxOrderByAggregateInput = {
    id?: SortOrder
    buildName?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    recipeId?: SortOrder
    instructions?: SortOrder
    notes?: SortOrder
    glassware?: SortOrder
    ice?: SortOrder
  }

  export type BuildMinOrderByAggregateInput = {
    id?: SortOrder
    buildName?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    recipeId?: SortOrder
    instructions?: SortOrder
    notes?: SortOrder
    glassware?: SortOrder
    ice?: SortOrder
  }

  export type BuildNullableRelationFilter = {
    is?: BuildWhereInput | null
    isNot?: BuildWhereInput | null
  }

  export type BuildUserUserIdBuildIdCompoundUniqueInput = {
    userId: string
    buildId: string
  }

  export type BuildUserCountOrderByAggregateInput = {
    userId?: SortOrder
    buildId?: SortOrder
    permission?: SortOrder
  }

  export type BuildUserMaxOrderByAggregateInput = {
    userId?: SortOrder
    buildId?: SortOrder
    permission?: SortOrder
  }

  export type BuildUserMinOrderByAggregateInput = {
    userId?: SortOrder
    buildId?: SortOrder
    permission?: SortOrder
  }

  export type RecipeCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    name?: SortOrder
    origin?: SortOrder
    history?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type RecipeMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    name?: SortOrder
    origin?: SortOrder
    history?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type RecipeMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    name?: SortOrder
    origin?: SortOrder
    history?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type BuildRelationFilter = {
    is?: BuildWhereInput
    isNot?: BuildWhereInput
  }

  export type RecipeBookBuildBuildIdRecipeBookIdCompoundUniqueInput = {
    buildId: string
    recipeBookId: string
  }

  export type RecipeBookBuildCountOrderByAggregateInput = {
    buildId?: SortOrder
    recipeBookId?: SortOrder
  }

  export type RecipeBookBuildMaxOrderByAggregateInput = {
    buildId?: SortOrder
    recipeBookId?: SortOrder
  }

  export type RecipeBookBuildMinOrderByAggregateInput = {
    buildId?: SortOrder
    recipeBookId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type GenericIngredientRelationFilter = {
    is?: GenericIngredientWhereInput
    isNot?: GenericIngredientWhereInput
  }

  export type SpecificIngredientNullableRelationFilter = {
    is?: SpecificIngredientWhereInput | null
    isNot?: SpecificIngredientWhereInput | null
  }

  export type TouchCountOrderByAggregateInput = {
    id?: SortOrder
    buildId?: SortOrder
    order?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    genericIngredientId?: SortOrder
    specificIngredientId?: SortOrder
    version?: SortOrder
  }

  export type TouchAvgOrderByAggregateInput = {
    order?: SortOrder
    amount?: SortOrder
    version?: SortOrder
  }

  export type TouchMaxOrderByAggregateInput = {
    id?: SortOrder
    buildId?: SortOrder
    order?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    genericIngredientId?: SortOrder
    specificIngredientId?: SortOrder
    version?: SortOrder
  }

  export type TouchMinOrderByAggregateInput = {
    id?: SortOrder
    buildId?: SortOrder
    order?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    genericIngredientId?: SortOrder
    specificIngredientId?: SortOrder
    version?: SortOrder
  }

  export type TouchSumOrderByAggregateInput = {
    order?: SortOrder
    amount?: SortOrder
    version?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ArchivedTouchCountOrderByAggregateInput = {
    id?: SortOrder
    buildId?: SortOrder
    order?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    genericIngredientId?: SortOrder
    specificIngredientId?: SortOrder
    version?: SortOrder
  }

  export type ArchivedTouchAvgOrderByAggregateInput = {
    order?: SortOrder
    amount?: SortOrder
    version?: SortOrder
  }

  export type ArchivedTouchMaxOrderByAggregateInput = {
    id?: SortOrder
    buildId?: SortOrder
    order?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    genericIngredientId?: SortOrder
    specificIngredientId?: SortOrder
    version?: SortOrder
  }

  export type ArchivedTouchMinOrderByAggregateInput = {
    id?: SortOrder
    buildId?: SortOrder
    order?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    genericIngredientId?: SortOrder
    specificIngredientId?: SortOrder
    version?: SortOrder
  }

  export type ArchivedTouchSumOrderByAggregateInput = {
    order?: SortOrder
    amount?: SortOrder
    version?: SortOrder
  }

  export type GenericIngredientCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type GenericIngredientMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type GenericIngredientMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type IngredientStorageListRelationFilter = {
    every?: IngredientStorageWhereInput
    some?: IngredientStorageWhereInput
    none?: IngredientStorageWhereInput
  }

  export type IngredientStorageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpecificIngredientCountOrderByAggregateInput = {
    id?: SortOrder
    dateCreated?: SortOrder
    createdById?: SortOrder
    genericIngredientId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    source?: SortOrder
  }

  export type SpecificIngredientAvgOrderByAggregateInput = {
    price?: SortOrder
    amount?: SortOrder
  }

  export type SpecificIngredientMaxOrderByAggregateInput = {
    id?: SortOrder
    dateCreated?: SortOrder
    createdById?: SortOrder
    genericIngredientId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    source?: SortOrder
  }

  export type SpecificIngredientMinOrderByAggregateInput = {
    id?: SortOrder
    dateCreated?: SortOrder
    createdById?: SortOrder
    genericIngredientId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    source?: SortOrder
  }

  export type SpecificIngredientSumOrderByAggregateInput = {
    price?: SortOrder
    amount?: SortOrder
  }

  export type SpecificIngredientRelationFilter = {
    is?: SpecificIngredientWhereInput
    isNot?: SpecificIngredientWhereInput
  }

  export type IngredientUserIngredientIdUserIdCompoundUniqueInput = {
    ingredientId: string
    userId: string
  }

  export type IngredientUserCountOrderByAggregateInput = {
    ingredientId?: SortOrder
    userId?: SortOrder
    permission?: SortOrder
  }

  export type IngredientUserMaxOrderByAggregateInput = {
    ingredientId?: SortOrder
    userId?: SortOrder
    permission?: SortOrder
  }

  export type IngredientUserMinOrderByAggregateInput = {
    ingredientId?: SortOrder
    userId?: SortOrder
    permission?: SortOrder
  }

  export type IngredientPreferenceGenericIngredientIdSpecificIngredientIdCompoundUniqueInput = {
    genericIngredientId: string
    specificIngredientId: string
  }

  export type IngredientPreferenceCountOrderByAggregateInput = {
    genericIngredientId?: SortOrder
    specificIngredientId?: SortOrder
    userId?: SortOrder
  }

  export type IngredientPreferenceMaxOrderByAggregateInput = {
    genericIngredientId?: SortOrder
    specificIngredientId?: SortOrder
    userId?: SortOrder
  }

  export type IngredientPreferenceMinOrderByAggregateInput = {
    genericIngredientId?: SortOrder
    specificIngredientId?: SortOrder
    userId?: SortOrder
  }

  export type InventoryStorageListRelationFilter = {
    every?: InventoryStorageWhereInput
    some?: InventoryStorageWhereInput
    none?: InventoryStorageWhereInput
  }

  export type InventoryStorageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type InventoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type InventoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type InventoryRelationFilter = {
    is?: InventoryWhereInput
    isNot?: InventoryWhereInput
  }

  export type InventoryUserUserIdInventoryIdCompoundUniqueInput = {
    userId: string
    inventoryId: string
  }

  export type InventoryUserCountOrderByAggregateInput = {
    userId?: SortOrder
    inventoryId?: SortOrder
    permission?: SortOrder
  }

  export type InventoryUserMaxOrderByAggregateInput = {
    userId?: SortOrder
    inventoryId?: SortOrder
    permission?: SortOrder
  }

  export type InventoryUserMinOrderByAggregateInput = {
    userId?: SortOrder
    inventoryId?: SortOrder
    permission?: SortOrder
  }

  export type StorageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type StorageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type StorageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type StorageRelationFilter = {
    is?: StorageWhereInput
    isNot?: StorageWhereInput
  }

  export type InventoryStorageInventoryIdStorageIdCompoundUniqueInput = {
    inventoryId: string
    storageId: string
  }

  export type InventoryStorageCountOrderByAggregateInput = {
    inventoryId?: SortOrder
    storageId?: SortOrder
  }

  export type InventoryStorageMaxOrderByAggregateInput = {
    inventoryId?: SortOrder
    storageId?: SortOrder
  }

  export type InventoryStorageMinOrderByAggregateInput = {
    inventoryId?: SortOrder
    storageId?: SortOrder
  }

  export type IngredientStorageIngredientIdStorageIdCompoundUniqueInput = {
    ingredientId: string
    storageId: string
  }

  export type IngredientStorageCountOrderByAggregateInput = {
    ingredientId?: SortOrder
    storageId?: SortOrder
    quantity?: SortOrder
  }

  export type IngredientStorageAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type IngredientStorageMaxOrderByAggregateInput = {
    ingredientId?: SortOrder
    storageId?: SortOrder
    quantity?: SortOrder
  }

  export type IngredientStorageMinOrderByAggregateInput = {
    ingredientId?: SortOrder
    storageId?: SortOrder
    quantity?: SortOrder
  }

  export type IngredientStorageSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type StorageUserUserIdStorageIdCompoundUniqueInput = {
    userId: string
    storageId: string
  }

  export type StorageUserCountOrderByAggregateInput = {
    userId?: SortOrder
    storageId?: SortOrder
    permission?: SortOrder
  }

  export type StorageUserMaxOrderByAggregateInput = {
    userId?: SortOrder
    storageId?: SortOrder
    permission?: SortOrder
  }

  export type StorageUserMinOrderByAggregateInput = {
    userId?: SortOrder
    storageId?: SortOrder
    permission?: SortOrder
  }

  export type CrewCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type CrewMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type CrewMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type CrewRelationFilter = {
    is?: CrewWhereInput
    isNot?: CrewWhereInput
  }

  export type CrewUserUserIdCrewIdCompoundUniqueInput = {
    userId: string
    crewId: string
  }

  export type CrewUserCountOrderByAggregateInput = {
    userId?: SortOrder
    crewId?: SortOrder
    permission?: SortOrder
  }

  export type CrewUserMaxOrderByAggregateInput = {
    userId?: SortOrder
    crewId?: SortOrder
    permission?: SortOrder
  }

  export type CrewUserMinOrderByAggregateInput = {
    userId?: SortOrder
    crewId?: SortOrder
    permission?: SortOrder
  }

  export type ProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type RecipeBookUserCreateNestedManyWithoutUserInput = {
    create?: XOR<RecipeBookUserCreateWithoutUserInput, RecipeBookUserUncheckedCreateWithoutUserInput> | RecipeBookUserCreateWithoutUserInput[] | RecipeBookUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecipeBookUserCreateOrConnectWithoutUserInput | RecipeBookUserCreateOrConnectWithoutUserInput[]
    createMany?: RecipeBookUserCreateManyUserInputEnvelope
    connect?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
  }

  export type RecipeBookCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<RecipeBookCreateWithoutCreatedByInput, RecipeBookUncheckedCreateWithoutCreatedByInput> | RecipeBookCreateWithoutCreatedByInput[] | RecipeBookUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RecipeBookCreateOrConnectWithoutCreatedByInput | RecipeBookCreateOrConnectWithoutCreatedByInput[]
    createMany?: RecipeBookCreateManyCreatedByInputEnvelope
    connect?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
  }

  export type RecipeBookCreateNestedManyWithoutEditedByInput = {
    create?: XOR<RecipeBookCreateWithoutEditedByInput, RecipeBookUncheckedCreateWithoutEditedByInput> | RecipeBookCreateWithoutEditedByInput[] | RecipeBookUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: RecipeBookCreateOrConnectWithoutEditedByInput | RecipeBookCreateOrConnectWithoutEditedByInput[]
    createMany?: RecipeBookCreateManyEditedByInputEnvelope
    connect?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
  }

  export type RecipeCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<RecipeCreateWithoutCreatedByInput, RecipeUncheckedCreateWithoutCreatedByInput> | RecipeCreateWithoutCreatedByInput[] | RecipeUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutCreatedByInput | RecipeCreateOrConnectWithoutCreatedByInput[]
    createMany?: RecipeCreateManyCreatedByInputEnvelope
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
  }

  export type RecipeCreateNestedManyWithoutEditedByInput = {
    create?: XOR<RecipeCreateWithoutEditedByInput, RecipeUncheckedCreateWithoutEditedByInput> | RecipeCreateWithoutEditedByInput[] | RecipeUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutEditedByInput | RecipeCreateOrConnectWithoutEditedByInput[]
    createMany?: RecipeCreateManyEditedByInputEnvelope
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
  }

  export type BuildUserCreateNestedManyWithoutUserInput = {
    create?: XOR<BuildUserCreateWithoutUserInput, BuildUserUncheckedCreateWithoutUserInput> | BuildUserCreateWithoutUserInput[] | BuildUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BuildUserCreateOrConnectWithoutUserInput | BuildUserCreateOrConnectWithoutUserInput[]
    createMany?: BuildUserCreateManyUserInputEnvelope
    connect?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
  }

  export type BuildCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<BuildCreateWithoutCreatedByInput, BuildUncheckedCreateWithoutCreatedByInput> | BuildCreateWithoutCreatedByInput[] | BuildUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BuildCreateOrConnectWithoutCreatedByInput | BuildCreateOrConnectWithoutCreatedByInput[]
    createMany?: BuildCreateManyCreatedByInputEnvelope
    connect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
  }

  export type BuildCreateNestedManyWithoutEditedByInput = {
    create?: XOR<BuildCreateWithoutEditedByInput, BuildUncheckedCreateWithoutEditedByInput> | BuildCreateWithoutEditedByInput[] | BuildUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: BuildCreateOrConnectWithoutEditedByInput | BuildCreateOrConnectWithoutEditedByInput[]
    createMany?: BuildCreateManyEditedByInputEnvelope
    connect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
  }

  export type CrewUserCreateNestedManyWithoutUserInput = {
    create?: XOR<CrewUserCreateWithoutUserInput, CrewUserUncheckedCreateWithoutUserInput> | CrewUserCreateWithoutUserInput[] | CrewUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CrewUserCreateOrConnectWithoutUserInput | CrewUserCreateOrConnectWithoutUserInput[]
    createMany?: CrewUserCreateManyUserInputEnvelope
    connect?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
  }

  export type CrewCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<CrewCreateWithoutCreatedByInput, CrewUncheckedCreateWithoutCreatedByInput> | CrewCreateWithoutCreatedByInput[] | CrewUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutCreatedByInput | CrewCreateOrConnectWithoutCreatedByInput[]
    createMany?: CrewCreateManyCreatedByInputEnvelope
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
  }

  export type CrewCreateNestedManyWithoutEditedByInput = {
    create?: XOR<CrewCreateWithoutEditedByInput, CrewUncheckedCreateWithoutEditedByInput> | CrewCreateWithoutEditedByInput[] | CrewUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutEditedByInput | CrewCreateOrConnectWithoutEditedByInput[]
    createMany?: CrewCreateManyEditedByInputEnvelope
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
  }

  export type SpecificIngredientCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<SpecificIngredientCreateWithoutCreatedByInput, SpecificIngredientUncheckedCreateWithoutCreatedByInput> | SpecificIngredientCreateWithoutCreatedByInput[] | SpecificIngredientUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SpecificIngredientCreateOrConnectWithoutCreatedByInput | SpecificIngredientCreateOrConnectWithoutCreatedByInput[]
    createMany?: SpecificIngredientCreateManyCreatedByInputEnvelope
    connect?: SpecificIngredientWhereUniqueInput | SpecificIngredientWhereUniqueInput[]
  }

  export type IngredientPreferenceCreateNestedManyWithoutUserInput = {
    create?: XOR<IngredientPreferenceCreateWithoutUserInput, IngredientPreferenceUncheckedCreateWithoutUserInput> | IngredientPreferenceCreateWithoutUserInput[] | IngredientPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IngredientPreferenceCreateOrConnectWithoutUserInput | IngredientPreferenceCreateOrConnectWithoutUserInput[]
    createMany?: IngredientPreferenceCreateManyUserInputEnvelope
    connect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
  }

  export type IngredientUserCreateNestedManyWithoutUserInput = {
    create?: XOR<IngredientUserCreateWithoutUserInput, IngredientUserUncheckedCreateWithoutUserInput> | IngredientUserCreateWithoutUserInput[] | IngredientUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IngredientUserCreateOrConnectWithoutUserInput | IngredientUserCreateOrConnectWithoutUserInput[]
    createMany?: IngredientUserCreateManyUserInputEnvelope
    connect?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
  }

  export type StorageUserCreateNestedManyWithoutUserInput = {
    create?: XOR<StorageUserCreateWithoutUserInput, StorageUserUncheckedCreateWithoutUserInput> | StorageUserCreateWithoutUserInput[] | StorageUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StorageUserCreateOrConnectWithoutUserInput | StorageUserCreateOrConnectWithoutUserInput[]
    createMany?: StorageUserCreateManyUserInputEnvelope
    connect?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
  }

  export type StorageCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<StorageCreateWithoutCreatedByInput, StorageUncheckedCreateWithoutCreatedByInput> | StorageCreateWithoutCreatedByInput[] | StorageUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StorageCreateOrConnectWithoutCreatedByInput | StorageCreateOrConnectWithoutCreatedByInput[]
    createMany?: StorageCreateManyCreatedByInputEnvelope
    connect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
  }

  export type StorageCreateNestedManyWithoutEditedByInput = {
    create?: XOR<StorageCreateWithoutEditedByInput, StorageUncheckedCreateWithoutEditedByInput> | StorageCreateWithoutEditedByInput[] | StorageUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: StorageCreateOrConnectWithoutEditedByInput | StorageCreateOrConnectWithoutEditedByInput[]
    createMany?: StorageCreateManyEditedByInputEnvelope
    connect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
  }

  export type InventoryCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<InventoryCreateWithoutCreatedByInput, InventoryUncheckedCreateWithoutCreatedByInput> | InventoryCreateWithoutCreatedByInput[] | InventoryUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutCreatedByInput | InventoryCreateOrConnectWithoutCreatedByInput[]
    createMany?: InventoryCreateManyCreatedByInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type InventoryCreateNestedManyWithoutEditedByInput = {
    create?: XOR<InventoryCreateWithoutEditedByInput, InventoryUncheckedCreateWithoutEditedByInput> | InventoryCreateWithoutEditedByInput[] | InventoryUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutEditedByInput | InventoryCreateOrConnectWithoutEditedByInput[]
    createMany?: InventoryCreateManyEditedByInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type InventoryUserCreateNestedManyWithoutUserInput = {
    create?: XOR<InventoryUserCreateWithoutUserInput, InventoryUserUncheckedCreateWithoutUserInput> | InventoryUserCreateWithoutUserInput[] | InventoryUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryUserCreateOrConnectWithoutUserInput | InventoryUserCreateOrConnectWithoutUserInput[]
    createMany?: InventoryUserCreateManyUserInputEnvelope
    connect?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
  }

  export type FollowCreateNestedManyWithoutFollowedByInput = {
    create?: XOR<FollowCreateWithoutFollowedByInput, FollowUncheckedCreateWithoutFollowedByInput> | FollowCreateWithoutFollowedByInput[] | FollowUncheckedCreateWithoutFollowedByInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowedByInput | FollowCreateOrConnectWithoutFollowedByInput[]
    createMany?: FollowCreateManyFollowedByInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type FollowCreateNestedManyWithoutFollowingInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type RecipeBookUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RecipeBookUserCreateWithoutUserInput, RecipeBookUserUncheckedCreateWithoutUserInput> | RecipeBookUserCreateWithoutUserInput[] | RecipeBookUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecipeBookUserCreateOrConnectWithoutUserInput | RecipeBookUserCreateOrConnectWithoutUserInput[]
    createMany?: RecipeBookUserCreateManyUserInputEnvelope
    connect?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
  }

  export type RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<RecipeBookCreateWithoutCreatedByInput, RecipeBookUncheckedCreateWithoutCreatedByInput> | RecipeBookCreateWithoutCreatedByInput[] | RecipeBookUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RecipeBookCreateOrConnectWithoutCreatedByInput | RecipeBookCreateOrConnectWithoutCreatedByInput[]
    createMany?: RecipeBookCreateManyCreatedByInputEnvelope
    connect?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
  }

  export type RecipeBookUncheckedCreateNestedManyWithoutEditedByInput = {
    create?: XOR<RecipeBookCreateWithoutEditedByInput, RecipeBookUncheckedCreateWithoutEditedByInput> | RecipeBookCreateWithoutEditedByInput[] | RecipeBookUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: RecipeBookCreateOrConnectWithoutEditedByInput | RecipeBookCreateOrConnectWithoutEditedByInput[]
    createMany?: RecipeBookCreateManyEditedByInputEnvelope
    connect?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
  }

  export type RecipeUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<RecipeCreateWithoutCreatedByInput, RecipeUncheckedCreateWithoutCreatedByInput> | RecipeCreateWithoutCreatedByInput[] | RecipeUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutCreatedByInput | RecipeCreateOrConnectWithoutCreatedByInput[]
    createMany?: RecipeCreateManyCreatedByInputEnvelope
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
  }

  export type RecipeUncheckedCreateNestedManyWithoutEditedByInput = {
    create?: XOR<RecipeCreateWithoutEditedByInput, RecipeUncheckedCreateWithoutEditedByInput> | RecipeCreateWithoutEditedByInput[] | RecipeUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutEditedByInput | RecipeCreateOrConnectWithoutEditedByInput[]
    createMany?: RecipeCreateManyEditedByInputEnvelope
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
  }

  export type BuildUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BuildUserCreateWithoutUserInput, BuildUserUncheckedCreateWithoutUserInput> | BuildUserCreateWithoutUserInput[] | BuildUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BuildUserCreateOrConnectWithoutUserInput | BuildUserCreateOrConnectWithoutUserInput[]
    createMany?: BuildUserCreateManyUserInputEnvelope
    connect?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
  }

  export type BuildUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<BuildCreateWithoutCreatedByInput, BuildUncheckedCreateWithoutCreatedByInput> | BuildCreateWithoutCreatedByInput[] | BuildUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BuildCreateOrConnectWithoutCreatedByInput | BuildCreateOrConnectWithoutCreatedByInput[]
    createMany?: BuildCreateManyCreatedByInputEnvelope
    connect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
  }

  export type BuildUncheckedCreateNestedManyWithoutEditedByInput = {
    create?: XOR<BuildCreateWithoutEditedByInput, BuildUncheckedCreateWithoutEditedByInput> | BuildCreateWithoutEditedByInput[] | BuildUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: BuildCreateOrConnectWithoutEditedByInput | BuildCreateOrConnectWithoutEditedByInput[]
    createMany?: BuildCreateManyEditedByInputEnvelope
    connect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
  }

  export type CrewUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CrewUserCreateWithoutUserInput, CrewUserUncheckedCreateWithoutUserInput> | CrewUserCreateWithoutUserInput[] | CrewUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CrewUserCreateOrConnectWithoutUserInput | CrewUserCreateOrConnectWithoutUserInput[]
    createMany?: CrewUserCreateManyUserInputEnvelope
    connect?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
  }

  export type CrewUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<CrewCreateWithoutCreatedByInput, CrewUncheckedCreateWithoutCreatedByInput> | CrewCreateWithoutCreatedByInput[] | CrewUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutCreatedByInput | CrewCreateOrConnectWithoutCreatedByInput[]
    createMany?: CrewCreateManyCreatedByInputEnvelope
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
  }

  export type CrewUncheckedCreateNestedManyWithoutEditedByInput = {
    create?: XOR<CrewCreateWithoutEditedByInput, CrewUncheckedCreateWithoutEditedByInput> | CrewCreateWithoutEditedByInput[] | CrewUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutEditedByInput | CrewCreateOrConnectWithoutEditedByInput[]
    createMany?: CrewCreateManyEditedByInputEnvelope
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
  }

  export type SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<SpecificIngredientCreateWithoutCreatedByInput, SpecificIngredientUncheckedCreateWithoutCreatedByInput> | SpecificIngredientCreateWithoutCreatedByInput[] | SpecificIngredientUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SpecificIngredientCreateOrConnectWithoutCreatedByInput | SpecificIngredientCreateOrConnectWithoutCreatedByInput[]
    createMany?: SpecificIngredientCreateManyCreatedByInputEnvelope
    connect?: SpecificIngredientWhereUniqueInput | SpecificIngredientWhereUniqueInput[]
  }

  export type IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<IngredientPreferenceCreateWithoutUserInput, IngredientPreferenceUncheckedCreateWithoutUserInput> | IngredientPreferenceCreateWithoutUserInput[] | IngredientPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IngredientPreferenceCreateOrConnectWithoutUserInput | IngredientPreferenceCreateOrConnectWithoutUserInput[]
    createMany?: IngredientPreferenceCreateManyUserInputEnvelope
    connect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
  }

  export type IngredientUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<IngredientUserCreateWithoutUserInput, IngredientUserUncheckedCreateWithoutUserInput> | IngredientUserCreateWithoutUserInput[] | IngredientUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IngredientUserCreateOrConnectWithoutUserInput | IngredientUserCreateOrConnectWithoutUserInput[]
    createMany?: IngredientUserCreateManyUserInputEnvelope
    connect?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
  }

  export type StorageUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StorageUserCreateWithoutUserInput, StorageUserUncheckedCreateWithoutUserInput> | StorageUserCreateWithoutUserInput[] | StorageUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StorageUserCreateOrConnectWithoutUserInput | StorageUserCreateOrConnectWithoutUserInput[]
    createMany?: StorageUserCreateManyUserInputEnvelope
    connect?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
  }

  export type StorageUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<StorageCreateWithoutCreatedByInput, StorageUncheckedCreateWithoutCreatedByInput> | StorageCreateWithoutCreatedByInput[] | StorageUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StorageCreateOrConnectWithoutCreatedByInput | StorageCreateOrConnectWithoutCreatedByInput[]
    createMany?: StorageCreateManyCreatedByInputEnvelope
    connect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
  }

  export type StorageUncheckedCreateNestedManyWithoutEditedByInput = {
    create?: XOR<StorageCreateWithoutEditedByInput, StorageUncheckedCreateWithoutEditedByInput> | StorageCreateWithoutEditedByInput[] | StorageUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: StorageCreateOrConnectWithoutEditedByInput | StorageCreateOrConnectWithoutEditedByInput[]
    createMany?: StorageCreateManyEditedByInputEnvelope
    connect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
  }

  export type InventoryUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<InventoryCreateWithoutCreatedByInput, InventoryUncheckedCreateWithoutCreatedByInput> | InventoryCreateWithoutCreatedByInput[] | InventoryUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutCreatedByInput | InventoryCreateOrConnectWithoutCreatedByInput[]
    createMany?: InventoryCreateManyCreatedByInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type InventoryUncheckedCreateNestedManyWithoutEditedByInput = {
    create?: XOR<InventoryCreateWithoutEditedByInput, InventoryUncheckedCreateWithoutEditedByInput> | InventoryCreateWithoutEditedByInput[] | InventoryUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutEditedByInput | InventoryCreateOrConnectWithoutEditedByInput[]
    createMany?: InventoryCreateManyEditedByInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type InventoryUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InventoryUserCreateWithoutUserInput, InventoryUserUncheckedCreateWithoutUserInput> | InventoryUserCreateWithoutUserInput[] | InventoryUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryUserCreateOrConnectWithoutUserInput | InventoryUserCreateOrConnectWithoutUserInput[]
    createMany?: InventoryUserCreateManyUserInputEnvelope
    connect?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
  }

  export type FollowUncheckedCreateNestedManyWithoutFollowedByInput = {
    create?: XOR<FollowCreateWithoutFollowedByInput, FollowUncheckedCreateWithoutFollowedByInput> | FollowCreateWithoutFollowedByInput[] | FollowUncheckedCreateWithoutFollowedByInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowedByInput | FollowCreateOrConnectWithoutFollowedByInput[]
    createMany?: FollowCreateManyFollowedByInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type FollowUncheckedCreateNestedManyWithoutFollowingInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type RecipeBookUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<RecipeBookUserCreateWithoutUserInput, RecipeBookUserUncheckedCreateWithoutUserInput> | RecipeBookUserCreateWithoutUserInput[] | RecipeBookUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecipeBookUserCreateOrConnectWithoutUserInput | RecipeBookUserCreateOrConnectWithoutUserInput[]
    upsert?: RecipeBookUserUpsertWithWhereUniqueWithoutUserInput | RecipeBookUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RecipeBookUserCreateManyUserInputEnvelope
    set?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
    disconnect?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
    delete?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
    connect?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
    update?: RecipeBookUserUpdateWithWhereUniqueWithoutUserInput | RecipeBookUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RecipeBookUserUpdateManyWithWhereWithoutUserInput | RecipeBookUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RecipeBookUserScalarWhereInput | RecipeBookUserScalarWhereInput[]
  }

  export type RecipeBookUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<RecipeBookCreateWithoutCreatedByInput, RecipeBookUncheckedCreateWithoutCreatedByInput> | RecipeBookCreateWithoutCreatedByInput[] | RecipeBookUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RecipeBookCreateOrConnectWithoutCreatedByInput | RecipeBookCreateOrConnectWithoutCreatedByInput[]
    upsert?: RecipeBookUpsertWithWhereUniqueWithoutCreatedByInput | RecipeBookUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: RecipeBookCreateManyCreatedByInputEnvelope
    set?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
    disconnect?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
    delete?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
    connect?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
    update?: RecipeBookUpdateWithWhereUniqueWithoutCreatedByInput | RecipeBookUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: RecipeBookUpdateManyWithWhereWithoutCreatedByInput | RecipeBookUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: RecipeBookScalarWhereInput | RecipeBookScalarWhereInput[]
  }

  export type RecipeBookUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<RecipeBookCreateWithoutEditedByInput, RecipeBookUncheckedCreateWithoutEditedByInput> | RecipeBookCreateWithoutEditedByInput[] | RecipeBookUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: RecipeBookCreateOrConnectWithoutEditedByInput | RecipeBookCreateOrConnectWithoutEditedByInput[]
    upsert?: RecipeBookUpsertWithWhereUniqueWithoutEditedByInput | RecipeBookUpsertWithWhereUniqueWithoutEditedByInput[]
    createMany?: RecipeBookCreateManyEditedByInputEnvelope
    set?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
    disconnect?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
    delete?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
    connect?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
    update?: RecipeBookUpdateWithWhereUniqueWithoutEditedByInput | RecipeBookUpdateWithWhereUniqueWithoutEditedByInput[]
    updateMany?: RecipeBookUpdateManyWithWhereWithoutEditedByInput | RecipeBookUpdateManyWithWhereWithoutEditedByInput[]
    deleteMany?: RecipeBookScalarWhereInput | RecipeBookScalarWhereInput[]
  }

  export type RecipeUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<RecipeCreateWithoutCreatedByInput, RecipeUncheckedCreateWithoutCreatedByInput> | RecipeCreateWithoutCreatedByInput[] | RecipeUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutCreatedByInput | RecipeCreateOrConnectWithoutCreatedByInput[]
    upsert?: RecipeUpsertWithWhereUniqueWithoutCreatedByInput | RecipeUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: RecipeCreateManyCreatedByInputEnvelope
    set?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    disconnect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    delete?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    update?: RecipeUpdateWithWhereUniqueWithoutCreatedByInput | RecipeUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: RecipeUpdateManyWithWhereWithoutCreatedByInput | RecipeUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
  }

  export type RecipeUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<RecipeCreateWithoutEditedByInput, RecipeUncheckedCreateWithoutEditedByInput> | RecipeCreateWithoutEditedByInput[] | RecipeUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutEditedByInput | RecipeCreateOrConnectWithoutEditedByInput[]
    upsert?: RecipeUpsertWithWhereUniqueWithoutEditedByInput | RecipeUpsertWithWhereUniqueWithoutEditedByInput[]
    createMany?: RecipeCreateManyEditedByInputEnvelope
    set?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    disconnect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    delete?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    update?: RecipeUpdateWithWhereUniqueWithoutEditedByInput | RecipeUpdateWithWhereUniqueWithoutEditedByInput[]
    updateMany?: RecipeUpdateManyWithWhereWithoutEditedByInput | RecipeUpdateManyWithWhereWithoutEditedByInput[]
    deleteMany?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
  }

  export type BuildUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<BuildUserCreateWithoutUserInput, BuildUserUncheckedCreateWithoutUserInput> | BuildUserCreateWithoutUserInput[] | BuildUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BuildUserCreateOrConnectWithoutUserInput | BuildUserCreateOrConnectWithoutUserInput[]
    upsert?: BuildUserUpsertWithWhereUniqueWithoutUserInput | BuildUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BuildUserCreateManyUserInputEnvelope
    set?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
    disconnect?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
    delete?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
    connect?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
    update?: BuildUserUpdateWithWhereUniqueWithoutUserInput | BuildUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BuildUserUpdateManyWithWhereWithoutUserInput | BuildUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BuildUserScalarWhereInput | BuildUserScalarWhereInput[]
  }

  export type BuildUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<BuildCreateWithoutCreatedByInput, BuildUncheckedCreateWithoutCreatedByInput> | BuildCreateWithoutCreatedByInput[] | BuildUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BuildCreateOrConnectWithoutCreatedByInput | BuildCreateOrConnectWithoutCreatedByInput[]
    upsert?: BuildUpsertWithWhereUniqueWithoutCreatedByInput | BuildUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: BuildCreateManyCreatedByInputEnvelope
    set?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    disconnect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    delete?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    connect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    update?: BuildUpdateWithWhereUniqueWithoutCreatedByInput | BuildUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: BuildUpdateManyWithWhereWithoutCreatedByInput | BuildUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: BuildScalarWhereInput | BuildScalarWhereInput[]
  }

  export type BuildUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<BuildCreateWithoutEditedByInput, BuildUncheckedCreateWithoutEditedByInput> | BuildCreateWithoutEditedByInput[] | BuildUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: BuildCreateOrConnectWithoutEditedByInput | BuildCreateOrConnectWithoutEditedByInput[]
    upsert?: BuildUpsertWithWhereUniqueWithoutEditedByInput | BuildUpsertWithWhereUniqueWithoutEditedByInput[]
    createMany?: BuildCreateManyEditedByInputEnvelope
    set?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    disconnect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    delete?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    connect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    update?: BuildUpdateWithWhereUniqueWithoutEditedByInput | BuildUpdateWithWhereUniqueWithoutEditedByInput[]
    updateMany?: BuildUpdateManyWithWhereWithoutEditedByInput | BuildUpdateManyWithWhereWithoutEditedByInput[]
    deleteMany?: BuildScalarWhereInput | BuildScalarWhereInput[]
  }

  export type CrewUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<CrewUserCreateWithoutUserInput, CrewUserUncheckedCreateWithoutUserInput> | CrewUserCreateWithoutUserInput[] | CrewUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CrewUserCreateOrConnectWithoutUserInput | CrewUserCreateOrConnectWithoutUserInput[]
    upsert?: CrewUserUpsertWithWhereUniqueWithoutUserInput | CrewUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CrewUserCreateManyUserInputEnvelope
    set?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
    disconnect?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
    delete?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
    connect?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
    update?: CrewUserUpdateWithWhereUniqueWithoutUserInput | CrewUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CrewUserUpdateManyWithWhereWithoutUserInput | CrewUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CrewUserScalarWhereInput | CrewUserScalarWhereInput[]
  }

  export type CrewUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<CrewCreateWithoutCreatedByInput, CrewUncheckedCreateWithoutCreatedByInput> | CrewCreateWithoutCreatedByInput[] | CrewUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutCreatedByInput | CrewCreateOrConnectWithoutCreatedByInput[]
    upsert?: CrewUpsertWithWhereUniqueWithoutCreatedByInput | CrewUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: CrewCreateManyCreatedByInputEnvelope
    set?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    disconnect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    delete?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    update?: CrewUpdateWithWhereUniqueWithoutCreatedByInput | CrewUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: CrewUpdateManyWithWhereWithoutCreatedByInput | CrewUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: CrewScalarWhereInput | CrewScalarWhereInput[]
  }

  export type CrewUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<CrewCreateWithoutEditedByInput, CrewUncheckedCreateWithoutEditedByInput> | CrewCreateWithoutEditedByInput[] | CrewUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutEditedByInput | CrewCreateOrConnectWithoutEditedByInput[]
    upsert?: CrewUpsertWithWhereUniqueWithoutEditedByInput | CrewUpsertWithWhereUniqueWithoutEditedByInput[]
    createMany?: CrewCreateManyEditedByInputEnvelope
    set?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    disconnect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    delete?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    update?: CrewUpdateWithWhereUniqueWithoutEditedByInput | CrewUpdateWithWhereUniqueWithoutEditedByInput[]
    updateMany?: CrewUpdateManyWithWhereWithoutEditedByInput | CrewUpdateManyWithWhereWithoutEditedByInput[]
    deleteMany?: CrewScalarWhereInput | CrewScalarWhereInput[]
  }

  export type SpecificIngredientUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<SpecificIngredientCreateWithoutCreatedByInput, SpecificIngredientUncheckedCreateWithoutCreatedByInput> | SpecificIngredientCreateWithoutCreatedByInput[] | SpecificIngredientUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SpecificIngredientCreateOrConnectWithoutCreatedByInput | SpecificIngredientCreateOrConnectWithoutCreatedByInput[]
    upsert?: SpecificIngredientUpsertWithWhereUniqueWithoutCreatedByInput | SpecificIngredientUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: SpecificIngredientCreateManyCreatedByInputEnvelope
    set?: SpecificIngredientWhereUniqueInput | SpecificIngredientWhereUniqueInput[]
    disconnect?: SpecificIngredientWhereUniqueInput | SpecificIngredientWhereUniqueInput[]
    delete?: SpecificIngredientWhereUniqueInput | SpecificIngredientWhereUniqueInput[]
    connect?: SpecificIngredientWhereUniqueInput | SpecificIngredientWhereUniqueInput[]
    update?: SpecificIngredientUpdateWithWhereUniqueWithoutCreatedByInput | SpecificIngredientUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: SpecificIngredientUpdateManyWithWhereWithoutCreatedByInput | SpecificIngredientUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: SpecificIngredientScalarWhereInput | SpecificIngredientScalarWhereInput[]
  }

  export type IngredientPreferenceUpdateManyWithoutUserNestedInput = {
    create?: XOR<IngredientPreferenceCreateWithoutUserInput, IngredientPreferenceUncheckedCreateWithoutUserInput> | IngredientPreferenceCreateWithoutUserInput[] | IngredientPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IngredientPreferenceCreateOrConnectWithoutUserInput | IngredientPreferenceCreateOrConnectWithoutUserInput[]
    upsert?: IngredientPreferenceUpsertWithWhereUniqueWithoutUserInput | IngredientPreferenceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IngredientPreferenceCreateManyUserInputEnvelope
    set?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    disconnect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    delete?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    connect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    update?: IngredientPreferenceUpdateWithWhereUniqueWithoutUserInput | IngredientPreferenceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IngredientPreferenceUpdateManyWithWhereWithoutUserInput | IngredientPreferenceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IngredientPreferenceScalarWhereInput | IngredientPreferenceScalarWhereInput[]
  }

  export type IngredientUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<IngredientUserCreateWithoutUserInput, IngredientUserUncheckedCreateWithoutUserInput> | IngredientUserCreateWithoutUserInput[] | IngredientUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IngredientUserCreateOrConnectWithoutUserInput | IngredientUserCreateOrConnectWithoutUserInput[]
    upsert?: IngredientUserUpsertWithWhereUniqueWithoutUserInput | IngredientUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IngredientUserCreateManyUserInputEnvelope
    set?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
    disconnect?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
    delete?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
    connect?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
    update?: IngredientUserUpdateWithWhereUniqueWithoutUserInput | IngredientUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IngredientUserUpdateManyWithWhereWithoutUserInput | IngredientUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IngredientUserScalarWhereInput | IngredientUserScalarWhereInput[]
  }

  export type StorageUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<StorageUserCreateWithoutUserInput, StorageUserUncheckedCreateWithoutUserInput> | StorageUserCreateWithoutUserInput[] | StorageUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StorageUserCreateOrConnectWithoutUserInput | StorageUserCreateOrConnectWithoutUserInput[]
    upsert?: StorageUserUpsertWithWhereUniqueWithoutUserInput | StorageUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StorageUserCreateManyUserInputEnvelope
    set?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
    disconnect?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
    delete?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
    connect?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
    update?: StorageUserUpdateWithWhereUniqueWithoutUserInput | StorageUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StorageUserUpdateManyWithWhereWithoutUserInput | StorageUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StorageUserScalarWhereInput | StorageUserScalarWhereInput[]
  }

  export type StorageUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<StorageCreateWithoutCreatedByInput, StorageUncheckedCreateWithoutCreatedByInput> | StorageCreateWithoutCreatedByInput[] | StorageUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StorageCreateOrConnectWithoutCreatedByInput | StorageCreateOrConnectWithoutCreatedByInput[]
    upsert?: StorageUpsertWithWhereUniqueWithoutCreatedByInput | StorageUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: StorageCreateManyCreatedByInputEnvelope
    set?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    disconnect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    delete?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    connect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    update?: StorageUpdateWithWhereUniqueWithoutCreatedByInput | StorageUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: StorageUpdateManyWithWhereWithoutCreatedByInput | StorageUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: StorageScalarWhereInput | StorageScalarWhereInput[]
  }

  export type StorageUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<StorageCreateWithoutEditedByInput, StorageUncheckedCreateWithoutEditedByInput> | StorageCreateWithoutEditedByInput[] | StorageUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: StorageCreateOrConnectWithoutEditedByInput | StorageCreateOrConnectWithoutEditedByInput[]
    upsert?: StorageUpsertWithWhereUniqueWithoutEditedByInput | StorageUpsertWithWhereUniqueWithoutEditedByInput[]
    createMany?: StorageCreateManyEditedByInputEnvelope
    set?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    disconnect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    delete?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    connect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    update?: StorageUpdateWithWhereUniqueWithoutEditedByInput | StorageUpdateWithWhereUniqueWithoutEditedByInput[]
    updateMany?: StorageUpdateManyWithWhereWithoutEditedByInput | StorageUpdateManyWithWhereWithoutEditedByInput[]
    deleteMany?: StorageScalarWhereInput | StorageScalarWhereInput[]
  }

  export type InventoryUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<InventoryCreateWithoutCreatedByInput, InventoryUncheckedCreateWithoutCreatedByInput> | InventoryCreateWithoutCreatedByInput[] | InventoryUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutCreatedByInput | InventoryCreateOrConnectWithoutCreatedByInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutCreatedByInput | InventoryUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: InventoryCreateManyCreatedByInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutCreatedByInput | InventoryUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutCreatedByInput | InventoryUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type InventoryUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<InventoryCreateWithoutEditedByInput, InventoryUncheckedCreateWithoutEditedByInput> | InventoryCreateWithoutEditedByInput[] | InventoryUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutEditedByInput | InventoryCreateOrConnectWithoutEditedByInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutEditedByInput | InventoryUpsertWithWhereUniqueWithoutEditedByInput[]
    createMany?: InventoryCreateManyEditedByInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutEditedByInput | InventoryUpdateWithWhereUniqueWithoutEditedByInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutEditedByInput | InventoryUpdateManyWithWhereWithoutEditedByInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type InventoryUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<InventoryUserCreateWithoutUserInput, InventoryUserUncheckedCreateWithoutUserInput> | InventoryUserCreateWithoutUserInput[] | InventoryUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryUserCreateOrConnectWithoutUserInput | InventoryUserCreateOrConnectWithoutUserInput[]
    upsert?: InventoryUserUpsertWithWhereUniqueWithoutUserInput | InventoryUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InventoryUserCreateManyUserInputEnvelope
    set?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
    disconnect?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
    delete?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
    connect?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
    update?: InventoryUserUpdateWithWhereUniqueWithoutUserInput | InventoryUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InventoryUserUpdateManyWithWhereWithoutUserInput | InventoryUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InventoryUserScalarWhereInput | InventoryUserScalarWhereInput[]
  }

  export type FollowUpdateManyWithoutFollowedByNestedInput = {
    create?: XOR<FollowCreateWithoutFollowedByInput, FollowUncheckedCreateWithoutFollowedByInput> | FollowCreateWithoutFollowedByInput[] | FollowUncheckedCreateWithoutFollowedByInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowedByInput | FollowCreateOrConnectWithoutFollowedByInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowedByInput | FollowUpsertWithWhereUniqueWithoutFollowedByInput[]
    createMany?: FollowCreateManyFollowedByInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowedByInput | FollowUpdateWithWhereUniqueWithoutFollowedByInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowedByInput | FollowUpdateManyWithWhereWithoutFollowedByInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type FollowUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowingInput | FollowUpsertWithWhereUniqueWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowingInput | FollowUpdateWithWhereUniqueWithoutFollowingInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowingInput | FollowUpdateManyWithWhereWithoutFollowingInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type ProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RecipeBookUserCreateWithoutUserInput, RecipeBookUserUncheckedCreateWithoutUserInput> | RecipeBookUserCreateWithoutUserInput[] | RecipeBookUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecipeBookUserCreateOrConnectWithoutUserInput | RecipeBookUserCreateOrConnectWithoutUserInput[]
    upsert?: RecipeBookUserUpsertWithWhereUniqueWithoutUserInput | RecipeBookUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RecipeBookUserCreateManyUserInputEnvelope
    set?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
    disconnect?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
    delete?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
    connect?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
    update?: RecipeBookUserUpdateWithWhereUniqueWithoutUserInput | RecipeBookUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RecipeBookUserUpdateManyWithWhereWithoutUserInput | RecipeBookUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RecipeBookUserScalarWhereInput | RecipeBookUserScalarWhereInput[]
  }

  export type RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<RecipeBookCreateWithoutCreatedByInput, RecipeBookUncheckedCreateWithoutCreatedByInput> | RecipeBookCreateWithoutCreatedByInput[] | RecipeBookUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RecipeBookCreateOrConnectWithoutCreatedByInput | RecipeBookCreateOrConnectWithoutCreatedByInput[]
    upsert?: RecipeBookUpsertWithWhereUniqueWithoutCreatedByInput | RecipeBookUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: RecipeBookCreateManyCreatedByInputEnvelope
    set?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
    disconnect?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
    delete?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
    connect?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
    update?: RecipeBookUpdateWithWhereUniqueWithoutCreatedByInput | RecipeBookUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: RecipeBookUpdateManyWithWhereWithoutCreatedByInput | RecipeBookUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: RecipeBookScalarWhereInput | RecipeBookScalarWhereInput[]
  }

  export type RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<RecipeBookCreateWithoutEditedByInput, RecipeBookUncheckedCreateWithoutEditedByInput> | RecipeBookCreateWithoutEditedByInput[] | RecipeBookUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: RecipeBookCreateOrConnectWithoutEditedByInput | RecipeBookCreateOrConnectWithoutEditedByInput[]
    upsert?: RecipeBookUpsertWithWhereUniqueWithoutEditedByInput | RecipeBookUpsertWithWhereUniqueWithoutEditedByInput[]
    createMany?: RecipeBookCreateManyEditedByInputEnvelope
    set?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
    disconnect?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
    delete?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
    connect?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
    update?: RecipeBookUpdateWithWhereUniqueWithoutEditedByInput | RecipeBookUpdateWithWhereUniqueWithoutEditedByInput[]
    updateMany?: RecipeBookUpdateManyWithWhereWithoutEditedByInput | RecipeBookUpdateManyWithWhereWithoutEditedByInput[]
    deleteMany?: RecipeBookScalarWhereInput | RecipeBookScalarWhereInput[]
  }

  export type RecipeUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<RecipeCreateWithoutCreatedByInput, RecipeUncheckedCreateWithoutCreatedByInput> | RecipeCreateWithoutCreatedByInput[] | RecipeUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutCreatedByInput | RecipeCreateOrConnectWithoutCreatedByInput[]
    upsert?: RecipeUpsertWithWhereUniqueWithoutCreatedByInput | RecipeUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: RecipeCreateManyCreatedByInputEnvelope
    set?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    disconnect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    delete?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    update?: RecipeUpdateWithWhereUniqueWithoutCreatedByInput | RecipeUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: RecipeUpdateManyWithWhereWithoutCreatedByInput | RecipeUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
  }

  export type RecipeUncheckedUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<RecipeCreateWithoutEditedByInput, RecipeUncheckedCreateWithoutEditedByInput> | RecipeCreateWithoutEditedByInput[] | RecipeUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutEditedByInput | RecipeCreateOrConnectWithoutEditedByInput[]
    upsert?: RecipeUpsertWithWhereUniqueWithoutEditedByInput | RecipeUpsertWithWhereUniqueWithoutEditedByInput[]
    createMany?: RecipeCreateManyEditedByInputEnvelope
    set?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    disconnect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    delete?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    update?: RecipeUpdateWithWhereUniqueWithoutEditedByInput | RecipeUpdateWithWhereUniqueWithoutEditedByInput[]
    updateMany?: RecipeUpdateManyWithWhereWithoutEditedByInput | RecipeUpdateManyWithWhereWithoutEditedByInput[]
    deleteMany?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
  }

  export type BuildUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BuildUserCreateWithoutUserInput, BuildUserUncheckedCreateWithoutUserInput> | BuildUserCreateWithoutUserInput[] | BuildUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BuildUserCreateOrConnectWithoutUserInput | BuildUserCreateOrConnectWithoutUserInput[]
    upsert?: BuildUserUpsertWithWhereUniqueWithoutUserInput | BuildUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BuildUserCreateManyUserInputEnvelope
    set?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
    disconnect?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
    delete?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
    connect?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
    update?: BuildUserUpdateWithWhereUniqueWithoutUserInput | BuildUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BuildUserUpdateManyWithWhereWithoutUserInput | BuildUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BuildUserScalarWhereInput | BuildUserScalarWhereInput[]
  }

  export type BuildUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<BuildCreateWithoutCreatedByInput, BuildUncheckedCreateWithoutCreatedByInput> | BuildCreateWithoutCreatedByInput[] | BuildUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BuildCreateOrConnectWithoutCreatedByInput | BuildCreateOrConnectWithoutCreatedByInput[]
    upsert?: BuildUpsertWithWhereUniqueWithoutCreatedByInput | BuildUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: BuildCreateManyCreatedByInputEnvelope
    set?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    disconnect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    delete?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    connect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    update?: BuildUpdateWithWhereUniqueWithoutCreatedByInput | BuildUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: BuildUpdateManyWithWhereWithoutCreatedByInput | BuildUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: BuildScalarWhereInput | BuildScalarWhereInput[]
  }

  export type BuildUncheckedUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<BuildCreateWithoutEditedByInput, BuildUncheckedCreateWithoutEditedByInput> | BuildCreateWithoutEditedByInput[] | BuildUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: BuildCreateOrConnectWithoutEditedByInput | BuildCreateOrConnectWithoutEditedByInput[]
    upsert?: BuildUpsertWithWhereUniqueWithoutEditedByInput | BuildUpsertWithWhereUniqueWithoutEditedByInput[]
    createMany?: BuildCreateManyEditedByInputEnvelope
    set?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    disconnect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    delete?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    connect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    update?: BuildUpdateWithWhereUniqueWithoutEditedByInput | BuildUpdateWithWhereUniqueWithoutEditedByInput[]
    updateMany?: BuildUpdateManyWithWhereWithoutEditedByInput | BuildUpdateManyWithWhereWithoutEditedByInput[]
    deleteMany?: BuildScalarWhereInput | BuildScalarWhereInput[]
  }

  export type CrewUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CrewUserCreateWithoutUserInput, CrewUserUncheckedCreateWithoutUserInput> | CrewUserCreateWithoutUserInput[] | CrewUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CrewUserCreateOrConnectWithoutUserInput | CrewUserCreateOrConnectWithoutUserInput[]
    upsert?: CrewUserUpsertWithWhereUniqueWithoutUserInput | CrewUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CrewUserCreateManyUserInputEnvelope
    set?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
    disconnect?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
    delete?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
    connect?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
    update?: CrewUserUpdateWithWhereUniqueWithoutUserInput | CrewUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CrewUserUpdateManyWithWhereWithoutUserInput | CrewUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CrewUserScalarWhereInput | CrewUserScalarWhereInput[]
  }

  export type CrewUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<CrewCreateWithoutCreatedByInput, CrewUncheckedCreateWithoutCreatedByInput> | CrewCreateWithoutCreatedByInput[] | CrewUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutCreatedByInput | CrewCreateOrConnectWithoutCreatedByInput[]
    upsert?: CrewUpsertWithWhereUniqueWithoutCreatedByInput | CrewUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: CrewCreateManyCreatedByInputEnvelope
    set?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    disconnect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    delete?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    update?: CrewUpdateWithWhereUniqueWithoutCreatedByInput | CrewUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: CrewUpdateManyWithWhereWithoutCreatedByInput | CrewUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: CrewScalarWhereInput | CrewScalarWhereInput[]
  }

  export type CrewUncheckedUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<CrewCreateWithoutEditedByInput, CrewUncheckedCreateWithoutEditedByInput> | CrewCreateWithoutEditedByInput[] | CrewUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutEditedByInput | CrewCreateOrConnectWithoutEditedByInput[]
    upsert?: CrewUpsertWithWhereUniqueWithoutEditedByInput | CrewUpsertWithWhereUniqueWithoutEditedByInput[]
    createMany?: CrewCreateManyEditedByInputEnvelope
    set?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    disconnect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    delete?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    update?: CrewUpdateWithWhereUniqueWithoutEditedByInput | CrewUpdateWithWhereUniqueWithoutEditedByInput[]
    updateMany?: CrewUpdateManyWithWhereWithoutEditedByInput | CrewUpdateManyWithWhereWithoutEditedByInput[]
    deleteMany?: CrewScalarWhereInput | CrewScalarWhereInput[]
  }

  export type SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<SpecificIngredientCreateWithoutCreatedByInput, SpecificIngredientUncheckedCreateWithoutCreatedByInput> | SpecificIngredientCreateWithoutCreatedByInput[] | SpecificIngredientUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SpecificIngredientCreateOrConnectWithoutCreatedByInput | SpecificIngredientCreateOrConnectWithoutCreatedByInput[]
    upsert?: SpecificIngredientUpsertWithWhereUniqueWithoutCreatedByInput | SpecificIngredientUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: SpecificIngredientCreateManyCreatedByInputEnvelope
    set?: SpecificIngredientWhereUniqueInput | SpecificIngredientWhereUniqueInput[]
    disconnect?: SpecificIngredientWhereUniqueInput | SpecificIngredientWhereUniqueInput[]
    delete?: SpecificIngredientWhereUniqueInput | SpecificIngredientWhereUniqueInput[]
    connect?: SpecificIngredientWhereUniqueInput | SpecificIngredientWhereUniqueInput[]
    update?: SpecificIngredientUpdateWithWhereUniqueWithoutCreatedByInput | SpecificIngredientUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: SpecificIngredientUpdateManyWithWhereWithoutCreatedByInput | SpecificIngredientUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: SpecificIngredientScalarWhereInput | SpecificIngredientScalarWhereInput[]
  }

  export type IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<IngredientPreferenceCreateWithoutUserInput, IngredientPreferenceUncheckedCreateWithoutUserInput> | IngredientPreferenceCreateWithoutUserInput[] | IngredientPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IngredientPreferenceCreateOrConnectWithoutUserInput | IngredientPreferenceCreateOrConnectWithoutUserInput[]
    upsert?: IngredientPreferenceUpsertWithWhereUniqueWithoutUserInput | IngredientPreferenceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IngredientPreferenceCreateManyUserInputEnvelope
    set?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    disconnect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    delete?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    connect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    update?: IngredientPreferenceUpdateWithWhereUniqueWithoutUserInput | IngredientPreferenceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IngredientPreferenceUpdateManyWithWhereWithoutUserInput | IngredientPreferenceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IngredientPreferenceScalarWhereInput | IngredientPreferenceScalarWhereInput[]
  }

  export type IngredientUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<IngredientUserCreateWithoutUserInput, IngredientUserUncheckedCreateWithoutUserInput> | IngredientUserCreateWithoutUserInput[] | IngredientUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IngredientUserCreateOrConnectWithoutUserInput | IngredientUserCreateOrConnectWithoutUserInput[]
    upsert?: IngredientUserUpsertWithWhereUniqueWithoutUserInput | IngredientUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IngredientUserCreateManyUserInputEnvelope
    set?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
    disconnect?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
    delete?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
    connect?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
    update?: IngredientUserUpdateWithWhereUniqueWithoutUserInput | IngredientUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IngredientUserUpdateManyWithWhereWithoutUserInput | IngredientUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IngredientUserScalarWhereInput | IngredientUserScalarWhereInput[]
  }

  export type StorageUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StorageUserCreateWithoutUserInput, StorageUserUncheckedCreateWithoutUserInput> | StorageUserCreateWithoutUserInput[] | StorageUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StorageUserCreateOrConnectWithoutUserInput | StorageUserCreateOrConnectWithoutUserInput[]
    upsert?: StorageUserUpsertWithWhereUniqueWithoutUserInput | StorageUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StorageUserCreateManyUserInputEnvelope
    set?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
    disconnect?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
    delete?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
    connect?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
    update?: StorageUserUpdateWithWhereUniqueWithoutUserInput | StorageUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StorageUserUpdateManyWithWhereWithoutUserInput | StorageUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StorageUserScalarWhereInput | StorageUserScalarWhereInput[]
  }

  export type StorageUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<StorageCreateWithoutCreatedByInput, StorageUncheckedCreateWithoutCreatedByInput> | StorageCreateWithoutCreatedByInput[] | StorageUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StorageCreateOrConnectWithoutCreatedByInput | StorageCreateOrConnectWithoutCreatedByInput[]
    upsert?: StorageUpsertWithWhereUniqueWithoutCreatedByInput | StorageUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: StorageCreateManyCreatedByInputEnvelope
    set?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    disconnect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    delete?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    connect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    update?: StorageUpdateWithWhereUniqueWithoutCreatedByInput | StorageUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: StorageUpdateManyWithWhereWithoutCreatedByInput | StorageUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: StorageScalarWhereInput | StorageScalarWhereInput[]
  }

  export type StorageUncheckedUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<StorageCreateWithoutEditedByInput, StorageUncheckedCreateWithoutEditedByInput> | StorageCreateWithoutEditedByInput[] | StorageUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: StorageCreateOrConnectWithoutEditedByInput | StorageCreateOrConnectWithoutEditedByInput[]
    upsert?: StorageUpsertWithWhereUniqueWithoutEditedByInput | StorageUpsertWithWhereUniqueWithoutEditedByInput[]
    createMany?: StorageCreateManyEditedByInputEnvelope
    set?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    disconnect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    delete?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    connect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    update?: StorageUpdateWithWhereUniqueWithoutEditedByInput | StorageUpdateWithWhereUniqueWithoutEditedByInput[]
    updateMany?: StorageUpdateManyWithWhereWithoutEditedByInput | StorageUpdateManyWithWhereWithoutEditedByInput[]
    deleteMany?: StorageScalarWhereInput | StorageScalarWhereInput[]
  }

  export type InventoryUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<InventoryCreateWithoutCreatedByInput, InventoryUncheckedCreateWithoutCreatedByInput> | InventoryCreateWithoutCreatedByInput[] | InventoryUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutCreatedByInput | InventoryCreateOrConnectWithoutCreatedByInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutCreatedByInput | InventoryUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: InventoryCreateManyCreatedByInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutCreatedByInput | InventoryUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutCreatedByInput | InventoryUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type InventoryUncheckedUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<InventoryCreateWithoutEditedByInput, InventoryUncheckedCreateWithoutEditedByInput> | InventoryCreateWithoutEditedByInput[] | InventoryUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutEditedByInput | InventoryCreateOrConnectWithoutEditedByInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutEditedByInput | InventoryUpsertWithWhereUniqueWithoutEditedByInput[]
    createMany?: InventoryCreateManyEditedByInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutEditedByInput | InventoryUpdateWithWhereUniqueWithoutEditedByInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutEditedByInput | InventoryUpdateManyWithWhereWithoutEditedByInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type InventoryUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InventoryUserCreateWithoutUserInput, InventoryUserUncheckedCreateWithoutUserInput> | InventoryUserCreateWithoutUserInput[] | InventoryUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryUserCreateOrConnectWithoutUserInput | InventoryUserCreateOrConnectWithoutUserInput[]
    upsert?: InventoryUserUpsertWithWhereUniqueWithoutUserInput | InventoryUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InventoryUserCreateManyUserInputEnvelope
    set?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
    disconnect?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
    delete?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
    connect?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
    update?: InventoryUserUpdateWithWhereUniqueWithoutUserInput | InventoryUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InventoryUserUpdateManyWithWhereWithoutUserInput | InventoryUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InventoryUserScalarWhereInput | InventoryUserScalarWhereInput[]
  }

  export type FollowUncheckedUpdateManyWithoutFollowedByNestedInput = {
    create?: XOR<FollowCreateWithoutFollowedByInput, FollowUncheckedCreateWithoutFollowedByInput> | FollowCreateWithoutFollowedByInput[] | FollowUncheckedCreateWithoutFollowedByInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowedByInput | FollowCreateOrConnectWithoutFollowedByInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowedByInput | FollowUpsertWithWhereUniqueWithoutFollowedByInput[]
    createMany?: FollowCreateManyFollowedByInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowedByInput | FollowUpdateWithWhereUniqueWithoutFollowedByInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowedByInput | FollowUpdateManyWithWhereWithoutFollowedByInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type FollowUncheckedUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowingInput | FollowUpsertWithWhereUniqueWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowingInput | FollowUpdateWithWhereUniqueWithoutFollowingInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowingInput | FollowUpdateManyWithWhereWithoutFollowingInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutFollowedByInput = {
    create?: XOR<UserCreateWithoutFollowedByInput, UserUncheckedCreateWithoutFollowedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowedByInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFollowingInput = {
    create?: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFollowedByNestedInput = {
    create?: XOR<UserCreateWithoutFollowedByInput, UserUncheckedCreateWithoutFollowedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowedByInput
    upsert?: UserUpsertWithoutFollowedByInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFollowedByInput, UserUpdateWithoutFollowedByInput>, UserUncheckedUpdateWithoutFollowedByInput>
  }

  export type UserUpdateOneRequiredWithoutFollowingNestedInput = {
    create?: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingInput
    upsert?: UserUpsertWithoutFollowingInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFollowingInput, UserUpdateWithoutFollowingInput>, UserUncheckedUpdateWithoutFollowingInput>
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileInput, UserUpdateWithoutProfileInput>, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserCreateNestedOneWithoutRecipeBookInput = {
    create?: XOR<UserCreateWithoutRecipeBookInput, UserUncheckedCreateWithoutRecipeBookInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeBookInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRecipeBookEditedByInput = {
    create?: XOR<UserCreateWithoutRecipeBookEditedByInput, UserUncheckedCreateWithoutRecipeBookEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeBookEditedByInput
    connect?: UserWhereUniqueInput
  }

  export type RecipeBookBuildCreateNestedManyWithoutRecipeBookInput = {
    create?: XOR<RecipeBookBuildCreateWithoutRecipeBookInput, RecipeBookBuildUncheckedCreateWithoutRecipeBookInput> | RecipeBookBuildCreateWithoutRecipeBookInput[] | RecipeBookBuildUncheckedCreateWithoutRecipeBookInput[]
    connectOrCreate?: RecipeBookBuildCreateOrConnectWithoutRecipeBookInput | RecipeBookBuildCreateOrConnectWithoutRecipeBookInput[]
    createMany?: RecipeBookBuildCreateManyRecipeBookInputEnvelope
    connect?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
  }

  export type RecipeBookUserCreateNestedManyWithoutRecipeBookInput = {
    create?: XOR<RecipeBookUserCreateWithoutRecipeBookInput, RecipeBookUserUncheckedCreateWithoutRecipeBookInput> | RecipeBookUserCreateWithoutRecipeBookInput[] | RecipeBookUserUncheckedCreateWithoutRecipeBookInput[]
    connectOrCreate?: RecipeBookUserCreateOrConnectWithoutRecipeBookInput | RecipeBookUserCreateOrConnectWithoutRecipeBookInput[]
    createMany?: RecipeBookUserCreateManyRecipeBookInputEnvelope
    connect?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
  }

  export type RecipeBookBuildUncheckedCreateNestedManyWithoutRecipeBookInput = {
    create?: XOR<RecipeBookBuildCreateWithoutRecipeBookInput, RecipeBookBuildUncheckedCreateWithoutRecipeBookInput> | RecipeBookBuildCreateWithoutRecipeBookInput[] | RecipeBookBuildUncheckedCreateWithoutRecipeBookInput[]
    connectOrCreate?: RecipeBookBuildCreateOrConnectWithoutRecipeBookInput | RecipeBookBuildCreateOrConnectWithoutRecipeBookInput[]
    createMany?: RecipeBookBuildCreateManyRecipeBookInputEnvelope
    connect?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
  }

  export type RecipeBookUserUncheckedCreateNestedManyWithoutRecipeBookInput = {
    create?: XOR<RecipeBookUserCreateWithoutRecipeBookInput, RecipeBookUserUncheckedCreateWithoutRecipeBookInput> | RecipeBookUserCreateWithoutRecipeBookInput[] | RecipeBookUserUncheckedCreateWithoutRecipeBookInput[]
    connectOrCreate?: RecipeBookUserCreateOrConnectWithoutRecipeBookInput | RecipeBookUserCreateOrConnectWithoutRecipeBookInput[]
    createMany?: RecipeBookUserCreateManyRecipeBookInputEnvelope
    connect?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutRecipeBookNestedInput = {
    create?: XOR<UserCreateWithoutRecipeBookInput, UserUncheckedCreateWithoutRecipeBookInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeBookInput
    upsert?: UserUpsertWithoutRecipeBookInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRecipeBookInput, UserUpdateWithoutRecipeBookInput>, UserUncheckedUpdateWithoutRecipeBookInput>
  }

  export type UserUpdateOneWithoutRecipeBookEditedByNestedInput = {
    create?: XOR<UserCreateWithoutRecipeBookEditedByInput, UserUncheckedCreateWithoutRecipeBookEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeBookEditedByInput
    upsert?: UserUpsertWithoutRecipeBookEditedByInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRecipeBookEditedByInput, UserUpdateWithoutRecipeBookEditedByInput>, UserUncheckedUpdateWithoutRecipeBookEditedByInput>
  }

  export type RecipeBookBuildUpdateManyWithoutRecipeBookNestedInput = {
    create?: XOR<RecipeBookBuildCreateWithoutRecipeBookInput, RecipeBookBuildUncheckedCreateWithoutRecipeBookInput> | RecipeBookBuildCreateWithoutRecipeBookInput[] | RecipeBookBuildUncheckedCreateWithoutRecipeBookInput[]
    connectOrCreate?: RecipeBookBuildCreateOrConnectWithoutRecipeBookInput | RecipeBookBuildCreateOrConnectWithoutRecipeBookInput[]
    upsert?: RecipeBookBuildUpsertWithWhereUniqueWithoutRecipeBookInput | RecipeBookBuildUpsertWithWhereUniqueWithoutRecipeBookInput[]
    createMany?: RecipeBookBuildCreateManyRecipeBookInputEnvelope
    set?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
    disconnect?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
    delete?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
    connect?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
    update?: RecipeBookBuildUpdateWithWhereUniqueWithoutRecipeBookInput | RecipeBookBuildUpdateWithWhereUniqueWithoutRecipeBookInput[]
    updateMany?: RecipeBookBuildUpdateManyWithWhereWithoutRecipeBookInput | RecipeBookBuildUpdateManyWithWhereWithoutRecipeBookInput[]
    deleteMany?: RecipeBookBuildScalarWhereInput | RecipeBookBuildScalarWhereInput[]
  }

  export type RecipeBookUserUpdateManyWithoutRecipeBookNestedInput = {
    create?: XOR<RecipeBookUserCreateWithoutRecipeBookInput, RecipeBookUserUncheckedCreateWithoutRecipeBookInput> | RecipeBookUserCreateWithoutRecipeBookInput[] | RecipeBookUserUncheckedCreateWithoutRecipeBookInput[]
    connectOrCreate?: RecipeBookUserCreateOrConnectWithoutRecipeBookInput | RecipeBookUserCreateOrConnectWithoutRecipeBookInput[]
    upsert?: RecipeBookUserUpsertWithWhereUniqueWithoutRecipeBookInput | RecipeBookUserUpsertWithWhereUniqueWithoutRecipeBookInput[]
    createMany?: RecipeBookUserCreateManyRecipeBookInputEnvelope
    set?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
    disconnect?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
    delete?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
    connect?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
    update?: RecipeBookUserUpdateWithWhereUniqueWithoutRecipeBookInput | RecipeBookUserUpdateWithWhereUniqueWithoutRecipeBookInput[]
    updateMany?: RecipeBookUserUpdateManyWithWhereWithoutRecipeBookInput | RecipeBookUserUpdateManyWithWhereWithoutRecipeBookInput[]
    deleteMany?: RecipeBookUserScalarWhereInput | RecipeBookUserScalarWhereInput[]
  }

  export type RecipeBookBuildUncheckedUpdateManyWithoutRecipeBookNestedInput = {
    create?: XOR<RecipeBookBuildCreateWithoutRecipeBookInput, RecipeBookBuildUncheckedCreateWithoutRecipeBookInput> | RecipeBookBuildCreateWithoutRecipeBookInput[] | RecipeBookBuildUncheckedCreateWithoutRecipeBookInput[]
    connectOrCreate?: RecipeBookBuildCreateOrConnectWithoutRecipeBookInput | RecipeBookBuildCreateOrConnectWithoutRecipeBookInput[]
    upsert?: RecipeBookBuildUpsertWithWhereUniqueWithoutRecipeBookInput | RecipeBookBuildUpsertWithWhereUniqueWithoutRecipeBookInput[]
    createMany?: RecipeBookBuildCreateManyRecipeBookInputEnvelope
    set?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
    disconnect?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
    delete?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
    connect?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
    update?: RecipeBookBuildUpdateWithWhereUniqueWithoutRecipeBookInput | RecipeBookBuildUpdateWithWhereUniqueWithoutRecipeBookInput[]
    updateMany?: RecipeBookBuildUpdateManyWithWhereWithoutRecipeBookInput | RecipeBookBuildUpdateManyWithWhereWithoutRecipeBookInput[]
    deleteMany?: RecipeBookBuildScalarWhereInput | RecipeBookBuildScalarWhereInput[]
  }

  export type RecipeBookUserUncheckedUpdateManyWithoutRecipeBookNestedInput = {
    create?: XOR<RecipeBookUserCreateWithoutRecipeBookInput, RecipeBookUserUncheckedCreateWithoutRecipeBookInput> | RecipeBookUserCreateWithoutRecipeBookInput[] | RecipeBookUserUncheckedCreateWithoutRecipeBookInput[]
    connectOrCreate?: RecipeBookUserCreateOrConnectWithoutRecipeBookInput | RecipeBookUserCreateOrConnectWithoutRecipeBookInput[]
    upsert?: RecipeBookUserUpsertWithWhereUniqueWithoutRecipeBookInput | RecipeBookUserUpsertWithWhereUniqueWithoutRecipeBookInput[]
    createMany?: RecipeBookUserCreateManyRecipeBookInputEnvelope
    set?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
    disconnect?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
    delete?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
    connect?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
    update?: RecipeBookUserUpdateWithWhereUniqueWithoutRecipeBookInput | RecipeBookUserUpdateWithWhereUniqueWithoutRecipeBookInput[]
    updateMany?: RecipeBookUserUpdateManyWithWhereWithoutRecipeBookInput | RecipeBookUserUpdateManyWithWhereWithoutRecipeBookInput[]
    deleteMany?: RecipeBookUserScalarWhereInput | RecipeBookUserScalarWhereInput[]
  }

  export type RecipeBookCreateNestedOneWithoutRecipeBookUserInput = {
    create?: XOR<RecipeBookCreateWithoutRecipeBookUserInput, RecipeBookUncheckedCreateWithoutRecipeBookUserInput>
    connectOrCreate?: RecipeBookCreateOrConnectWithoutRecipeBookUserInput
    connect?: RecipeBookWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRecipeBookUserInput = {
    create?: XOR<UserCreateWithoutRecipeBookUserInput, UserUncheckedCreateWithoutRecipeBookUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeBookUserInput
    connect?: UserWhereUniqueInput
  }

  export type RecipeBookUpdateOneRequiredWithoutRecipeBookUserNestedInput = {
    create?: XOR<RecipeBookCreateWithoutRecipeBookUserInput, RecipeBookUncheckedCreateWithoutRecipeBookUserInput>
    connectOrCreate?: RecipeBookCreateOrConnectWithoutRecipeBookUserInput
    upsert?: RecipeBookUpsertWithoutRecipeBookUserInput
    connect?: RecipeBookWhereUniqueInput
    update?: XOR<XOR<RecipeBookUpdateToOneWithWhereWithoutRecipeBookUserInput, RecipeBookUpdateWithoutRecipeBookUserInput>, RecipeBookUncheckedUpdateWithoutRecipeBookUserInput>
  }

  export type UserUpdateOneRequiredWithoutRecipeBookUserNestedInput = {
    create?: XOR<UserCreateWithoutRecipeBookUserInput, UserUncheckedCreateWithoutRecipeBookUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeBookUserInput
    upsert?: UserUpsertWithoutRecipeBookUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRecipeBookUserInput, UserUpdateWithoutRecipeBookUserInput>, UserUncheckedUpdateWithoutRecipeBookUserInput>
  }

  export type UserCreateNestedOneWithoutBuildInput = {
    create?: XOR<UserCreateWithoutBuildInput, UserUncheckedCreateWithoutBuildInput>
    connectOrCreate?: UserCreateOrConnectWithoutBuildInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBuildEditedByInput = {
    create?: XOR<UserCreateWithoutBuildEditedByInput, UserUncheckedCreateWithoutBuildEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutBuildEditedByInput
    connect?: UserWhereUniqueInput
  }

  export type RecipeCreateNestedOneWithoutBuildInput = {
    create?: XOR<RecipeCreateWithoutBuildInput, RecipeUncheckedCreateWithoutBuildInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutBuildInput
    connect?: RecipeWhereUniqueInput
  }

  export type TouchCreateNestedManyWithoutBuildInput = {
    create?: XOR<TouchCreateWithoutBuildInput, TouchUncheckedCreateWithoutBuildInput> | TouchCreateWithoutBuildInput[] | TouchUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: TouchCreateOrConnectWithoutBuildInput | TouchCreateOrConnectWithoutBuildInput[]
    createMany?: TouchCreateManyBuildInputEnvelope
    connect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
  }

  export type ArchivedTouchCreateNestedManyWithoutBuildInput = {
    create?: XOR<ArchivedTouchCreateWithoutBuildInput, ArchivedTouchUncheckedCreateWithoutBuildInput> | ArchivedTouchCreateWithoutBuildInput[] | ArchivedTouchUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: ArchivedTouchCreateOrConnectWithoutBuildInput | ArchivedTouchCreateOrConnectWithoutBuildInput[]
    createMany?: ArchivedTouchCreateManyBuildInputEnvelope
    connect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
  }

  export type RecipeBookBuildCreateNestedManyWithoutBuildInput = {
    create?: XOR<RecipeBookBuildCreateWithoutBuildInput, RecipeBookBuildUncheckedCreateWithoutBuildInput> | RecipeBookBuildCreateWithoutBuildInput[] | RecipeBookBuildUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: RecipeBookBuildCreateOrConnectWithoutBuildInput | RecipeBookBuildCreateOrConnectWithoutBuildInput[]
    createMany?: RecipeBookBuildCreateManyBuildInputEnvelope
    connect?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
  }

  export type BuildUserCreateNestedManyWithoutBuildInput = {
    create?: XOR<BuildUserCreateWithoutBuildInput, BuildUserUncheckedCreateWithoutBuildInput> | BuildUserCreateWithoutBuildInput[] | BuildUserUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: BuildUserCreateOrConnectWithoutBuildInput | BuildUserCreateOrConnectWithoutBuildInput[]
    createMany?: BuildUserCreateManyBuildInputEnvelope
    connect?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
  }

  export type TouchUncheckedCreateNestedManyWithoutBuildInput = {
    create?: XOR<TouchCreateWithoutBuildInput, TouchUncheckedCreateWithoutBuildInput> | TouchCreateWithoutBuildInput[] | TouchUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: TouchCreateOrConnectWithoutBuildInput | TouchCreateOrConnectWithoutBuildInput[]
    createMany?: TouchCreateManyBuildInputEnvelope
    connect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
  }

  export type ArchivedTouchUncheckedCreateNestedManyWithoutBuildInput = {
    create?: XOR<ArchivedTouchCreateWithoutBuildInput, ArchivedTouchUncheckedCreateWithoutBuildInput> | ArchivedTouchCreateWithoutBuildInput[] | ArchivedTouchUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: ArchivedTouchCreateOrConnectWithoutBuildInput | ArchivedTouchCreateOrConnectWithoutBuildInput[]
    createMany?: ArchivedTouchCreateManyBuildInputEnvelope
    connect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
  }

  export type RecipeBookBuildUncheckedCreateNestedManyWithoutBuildInput = {
    create?: XOR<RecipeBookBuildCreateWithoutBuildInput, RecipeBookBuildUncheckedCreateWithoutBuildInput> | RecipeBookBuildCreateWithoutBuildInput[] | RecipeBookBuildUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: RecipeBookBuildCreateOrConnectWithoutBuildInput | RecipeBookBuildCreateOrConnectWithoutBuildInput[]
    createMany?: RecipeBookBuildCreateManyBuildInputEnvelope
    connect?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
  }

  export type BuildUserUncheckedCreateNestedManyWithoutBuildInput = {
    create?: XOR<BuildUserCreateWithoutBuildInput, BuildUserUncheckedCreateWithoutBuildInput> | BuildUserCreateWithoutBuildInput[] | BuildUserUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: BuildUserCreateOrConnectWithoutBuildInput | BuildUserCreateOrConnectWithoutBuildInput[]
    createMany?: BuildUserCreateManyBuildInputEnvelope
    connect?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutBuildNestedInput = {
    create?: XOR<UserCreateWithoutBuildInput, UserUncheckedCreateWithoutBuildInput>
    connectOrCreate?: UserCreateOrConnectWithoutBuildInput
    upsert?: UserUpsertWithoutBuildInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBuildInput, UserUpdateWithoutBuildInput>, UserUncheckedUpdateWithoutBuildInput>
  }

  export type UserUpdateOneWithoutBuildEditedByNestedInput = {
    create?: XOR<UserCreateWithoutBuildEditedByInput, UserUncheckedCreateWithoutBuildEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutBuildEditedByInput
    upsert?: UserUpsertWithoutBuildEditedByInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBuildEditedByInput, UserUpdateWithoutBuildEditedByInput>, UserUncheckedUpdateWithoutBuildEditedByInput>
  }

  export type RecipeUpdateOneWithoutBuildNestedInput = {
    create?: XOR<RecipeCreateWithoutBuildInput, RecipeUncheckedCreateWithoutBuildInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutBuildInput
    upsert?: RecipeUpsertWithoutBuildInput
    disconnect?: RecipeWhereInput | boolean
    delete?: RecipeWhereInput | boolean
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutBuildInput, RecipeUpdateWithoutBuildInput>, RecipeUncheckedUpdateWithoutBuildInput>
  }

  export type TouchUpdateManyWithoutBuildNestedInput = {
    create?: XOR<TouchCreateWithoutBuildInput, TouchUncheckedCreateWithoutBuildInput> | TouchCreateWithoutBuildInput[] | TouchUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: TouchCreateOrConnectWithoutBuildInput | TouchCreateOrConnectWithoutBuildInput[]
    upsert?: TouchUpsertWithWhereUniqueWithoutBuildInput | TouchUpsertWithWhereUniqueWithoutBuildInput[]
    createMany?: TouchCreateManyBuildInputEnvelope
    set?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    disconnect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    delete?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    connect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    update?: TouchUpdateWithWhereUniqueWithoutBuildInput | TouchUpdateWithWhereUniqueWithoutBuildInput[]
    updateMany?: TouchUpdateManyWithWhereWithoutBuildInput | TouchUpdateManyWithWhereWithoutBuildInput[]
    deleteMany?: TouchScalarWhereInput | TouchScalarWhereInput[]
  }

  export type ArchivedTouchUpdateManyWithoutBuildNestedInput = {
    create?: XOR<ArchivedTouchCreateWithoutBuildInput, ArchivedTouchUncheckedCreateWithoutBuildInput> | ArchivedTouchCreateWithoutBuildInput[] | ArchivedTouchUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: ArchivedTouchCreateOrConnectWithoutBuildInput | ArchivedTouchCreateOrConnectWithoutBuildInput[]
    upsert?: ArchivedTouchUpsertWithWhereUniqueWithoutBuildInput | ArchivedTouchUpsertWithWhereUniqueWithoutBuildInput[]
    createMany?: ArchivedTouchCreateManyBuildInputEnvelope
    set?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    disconnect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    delete?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    connect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    update?: ArchivedTouchUpdateWithWhereUniqueWithoutBuildInput | ArchivedTouchUpdateWithWhereUniqueWithoutBuildInput[]
    updateMany?: ArchivedTouchUpdateManyWithWhereWithoutBuildInput | ArchivedTouchUpdateManyWithWhereWithoutBuildInput[]
    deleteMany?: ArchivedTouchScalarWhereInput | ArchivedTouchScalarWhereInput[]
  }

  export type RecipeBookBuildUpdateManyWithoutBuildNestedInput = {
    create?: XOR<RecipeBookBuildCreateWithoutBuildInput, RecipeBookBuildUncheckedCreateWithoutBuildInput> | RecipeBookBuildCreateWithoutBuildInput[] | RecipeBookBuildUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: RecipeBookBuildCreateOrConnectWithoutBuildInput | RecipeBookBuildCreateOrConnectWithoutBuildInput[]
    upsert?: RecipeBookBuildUpsertWithWhereUniqueWithoutBuildInput | RecipeBookBuildUpsertWithWhereUniqueWithoutBuildInput[]
    createMany?: RecipeBookBuildCreateManyBuildInputEnvelope
    set?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
    disconnect?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
    delete?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
    connect?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
    update?: RecipeBookBuildUpdateWithWhereUniqueWithoutBuildInput | RecipeBookBuildUpdateWithWhereUniqueWithoutBuildInput[]
    updateMany?: RecipeBookBuildUpdateManyWithWhereWithoutBuildInput | RecipeBookBuildUpdateManyWithWhereWithoutBuildInput[]
    deleteMany?: RecipeBookBuildScalarWhereInput | RecipeBookBuildScalarWhereInput[]
  }

  export type BuildUserUpdateManyWithoutBuildNestedInput = {
    create?: XOR<BuildUserCreateWithoutBuildInput, BuildUserUncheckedCreateWithoutBuildInput> | BuildUserCreateWithoutBuildInput[] | BuildUserUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: BuildUserCreateOrConnectWithoutBuildInput | BuildUserCreateOrConnectWithoutBuildInput[]
    upsert?: BuildUserUpsertWithWhereUniqueWithoutBuildInput | BuildUserUpsertWithWhereUniqueWithoutBuildInput[]
    createMany?: BuildUserCreateManyBuildInputEnvelope
    set?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
    disconnect?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
    delete?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
    connect?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
    update?: BuildUserUpdateWithWhereUniqueWithoutBuildInput | BuildUserUpdateWithWhereUniqueWithoutBuildInput[]
    updateMany?: BuildUserUpdateManyWithWhereWithoutBuildInput | BuildUserUpdateManyWithWhereWithoutBuildInput[]
    deleteMany?: BuildUserScalarWhereInput | BuildUserScalarWhereInput[]
  }

  export type TouchUncheckedUpdateManyWithoutBuildNestedInput = {
    create?: XOR<TouchCreateWithoutBuildInput, TouchUncheckedCreateWithoutBuildInput> | TouchCreateWithoutBuildInput[] | TouchUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: TouchCreateOrConnectWithoutBuildInput | TouchCreateOrConnectWithoutBuildInput[]
    upsert?: TouchUpsertWithWhereUniqueWithoutBuildInput | TouchUpsertWithWhereUniqueWithoutBuildInput[]
    createMany?: TouchCreateManyBuildInputEnvelope
    set?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    disconnect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    delete?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    connect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    update?: TouchUpdateWithWhereUniqueWithoutBuildInput | TouchUpdateWithWhereUniqueWithoutBuildInput[]
    updateMany?: TouchUpdateManyWithWhereWithoutBuildInput | TouchUpdateManyWithWhereWithoutBuildInput[]
    deleteMany?: TouchScalarWhereInput | TouchScalarWhereInput[]
  }

  export type ArchivedTouchUncheckedUpdateManyWithoutBuildNestedInput = {
    create?: XOR<ArchivedTouchCreateWithoutBuildInput, ArchivedTouchUncheckedCreateWithoutBuildInput> | ArchivedTouchCreateWithoutBuildInput[] | ArchivedTouchUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: ArchivedTouchCreateOrConnectWithoutBuildInput | ArchivedTouchCreateOrConnectWithoutBuildInput[]
    upsert?: ArchivedTouchUpsertWithWhereUniqueWithoutBuildInput | ArchivedTouchUpsertWithWhereUniqueWithoutBuildInput[]
    createMany?: ArchivedTouchCreateManyBuildInputEnvelope
    set?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    disconnect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    delete?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    connect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    update?: ArchivedTouchUpdateWithWhereUniqueWithoutBuildInput | ArchivedTouchUpdateWithWhereUniqueWithoutBuildInput[]
    updateMany?: ArchivedTouchUpdateManyWithWhereWithoutBuildInput | ArchivedTouchUpdateManyWithWhereWithoutBuildInput[]
    deleteMany?: ArchivedTouchScalarWhereInput | ArchivedTouchScalarWhereInput[]
  }

  export type RecipeBookBuildUncheckedUpdateManyWithoutBuildNestedInput = {
    create?: XOR<RecipeBookBuildCreateWithoutBuildInput, RecipeBookBuildUncheckedCreateWithoutBuildInput> | RecipeBookBuildCreateWithoutBuildInput[] | RecipeBookBuildUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: RecipeBookBuildCreateOrConnectWithoutBuildInput | RecipeBookBuildCreateOrConnectWithoutBuildInput[]
    upsert?: RecipeBookBuildUpsertWithWhereUniqueWithoutBuildInput | RecipeBookBuildUpsertWithWhereUniqueWithoutBuildInput[]
    createMany?: RecipeBookBuildCreateManyBuildInputEnvelope
    set?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
    disconnect?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
    delete?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
    connect?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
    update?: RecipeBookBuildUpdateWithWhereUniqueWithoutBuildInput | RecipeBookBuildUpdateWithWhereUniqueWithoutBuildInput[]
    updateMany?: RecipeBookBuildUpdateManyWithWhereWithoutBuildInput | RecipeBookBuildUpdateManyWithWhereWithoutBuildInput[]
    deleteMany?: RecipeBookBuildScalarWhereInput | RecipeBookBuildScalarWhereInput[]
  }

  export type BuildUserUncheckedUpdateManyWithoutBuildNestedInput = {
    create?: XOR<BuildUserCreateWithoutBuildInput, BuildUserUncheckedCreateWithoutBuildInput> | BuildUserCreateWithoutBuildInput[] | BuildUserUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: BuildUserCreateOrConnectWithoutBuildInput | BuildUserCreateOrConnectWithoutBuildInput[]
    upsert?: BuildUserUpsertWithWhereUniqueWithoutBuildInput | BuildUserUpsertWithWhereUniqueWithoutBuildInput[]
    createMany?: BuildUserCreateManyBuildInputEnvelope
    set?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
    disconnect?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
    delete?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
    connect?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
    update?: BuildUserUpdateWithWhereUniqueWithoutBuildInput | BuildUserUpdateWithWhereUniqueWithoutBuildInput[]
    updateMany?: BuildUserUpdateManyWithWhereWithoutBuildInput | BuildUserUpdateManyWithWhereWithoutBuildInput[]
    deleteMany?: BuildUserScalarWhereInput | BuildUserScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBuildUserInput = {
    create?: XOR<UserCreateWithoutBuildUserInput, UserUncheckedCreateWithoutBuildUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutBuildUserInput
    connect?: UserWhereUniqueInput
  }

  export type BuildCreateNestedOneWithoutBuildUserInput = {
    create?: XOR<BuildCreateWithoutBuildUserInput, BuildUncheckedCreateWithoutBuildUserInput>
    connectOrCreate?: BuildCreateOrConnectWithoutBuildUserInput
    connect?: BuildWhereUniqueInput
  }

  export type UserUpdateOneWithoutBuildUserNestedInput = {
    create?: XOR<UserCreateWithoutBuildUserInput, UserUncheckedCreateWithoutBuildUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutBuildUserInput
    upsert?: UserUpsertWithoutBuildUserInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBuildUserInput, UserUpdateWithoutBuildUserInput>, UserUncheckedUpdateWithoutBuildUserInput>
  }

  export type BuildUpdateOneWithoutBuildUserNestedInput = {
    create?: XOR<BuildCreateWithoutBuildUserInput, BuildUncheckedCreateWithoutBuildUserInput>
    connectOrCreate?: BuildCreateOrConnectWithoutBuildUserInput
    upsert?: BuildUpsertWithoutBuildUserInput
    disconnect?: BuildWhereInput | boolean
    delete?: BuildWhereInput | boolean
    connect?: BuildWhereUniqueInput
    update?: XOR<XOR<BuildUpdateToOneWithWhereWithoutBuildUserInput, BuildUpdateWithoutBuildUserInput>, BuildUncheckedUpdateWithoutBuildUserInput>
  }

  export type UserCreateNestedOneWithoutRecipeInput = {
    create?: XOR<UserCreateWithoutRecipeInput, UserUncheckedCreateWithoutRecipeInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRecipeEditedByInput = {
    create?: XOR<UserCreateWithoutRecipeEditedByInput, UserUncheckedCreateWithoutRecipeEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeEditedByInput
    connect?: UserWhereUniqueInput
  }

  export type BuildCreateNestedManyWithoutRecipeInput = {
    create?: XOR<BuildCreateWithoutRecipeInput, BuildUncheckedCreateWithoutRecipeInput> | BuildCreateWithoutRecipeInput[] | BuildUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: BuildCreateOrConnectWithoutRecipeInput | BuildCreateOrConnectWithoutRecipeInput[]
    createMany?: BuildCreateManyRecipeInputEnvelope
    connect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
  }

  export type BuildUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<BuildCreateWithoutRecipeInput, BuildUncheckedCreateWithoutRecipeInput> | BuildCreateWithoutRecipeInput[] | BuildUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: BuildCreateOrConnectWithoutRecipeInput | BuildCreateOrConnectWithoutRecipeInput[]
    createMany?: BuildCreateManyRecipeInputEnvelope
    connect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutRecipeNestedInput = {
    create?: XOR<UserCreateWithoutRecipeInput, UserUncheckedCreateWithoutRecipeInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeInput
    upsert?: UserUpsertWithoutRecipeInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRecipeInput, UserUpdateWithoutRecipeInput>, UserUncheckedUpdateWithoutRecipeInput>
  }

  export type UserUpdateOneWithoutRecipeEditedByNestedInput = {
    create?: XOR<UserCreateWithoutRecipeEditedByInput, UserUncheckedCreateWithoutRecipeEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeEditedByInput
    upsert?: UserUpsertWithoutRecipeEditedByInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRecipeEditedByInput, UserUpdateWithoutRecipeEditedByInput>, UserUncheckedUpdateWithoutRecipeEditedByInput>
  }

  export type BuildUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<BuildCreateWithoutRecipeInput, BuildUncheckedCreateWithoutRecipeInput> | BuildCreateWithoutRecipeInput[] | BuildUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: BuildCreateOrConnectWithoutRecipeInput | BuildCreateOrConnectWithoutRecipeInput[]
    upsert?: BuildUpsertWithWhereUniqueWithoutRecipeInput | BuildUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: BuildCreateManyRecipeInputEnvelope
    set?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    disconnect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    delete?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    connect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    update?: BuildUpdateWithWhereUniqueWithoutRecipeInput | BuildUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: BuildUpdateManyWithWhereWithoutRecipeInput | BuildUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: BuildScalarWhereInput | BuildScalarWhereInput[]
  }

  export type BuildUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<BuildCreateWithoutRecipeInput, BuildUncheckedCreateWithoutRecipeInput> | BuildCreateWithoutRecipeInput[] | BuildUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: BuildCreateOrConnectWithoutRecipeInput | BuildCreateOrConnectWithoutRecipeInput[]
    upsert?: BuildUpsertWithWhereUniqueWithoutRecipeInput | BuildUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: BuildCreateManyRecipeInputEnvelope
    set?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    disconnect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    delete?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    connect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    update?: BuildUpdateWithWhereUniqueWithoutRecipeInput | BuildUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: BuildUpdateManyWithWhereWithoutRecipeInput | BuildUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: BuildScalarWhereInput | BuildScalarWhereInput[]
  }

  export type RecipeBookCreateNestedOneWithoutRecipeBookBuildInput = {
    create?: XOR<RecipeBookCreateWithoutRecipeBookBuildInput, RecipeBookUncheckedCreateWithoutRecipeBookBuildInput>
    connectOrCreate?: RecipeBookCreateOrConnectWithoutRecipeBookBuildInput
    connect?: RecipeBookWhereUniqueInput
  }

  export type BuildCreateNestedOneWithoutRecipeBookBuildInput = {
    create?: XOR<BuildCreateWithoutRecipeBookBuildInput, BuildUncheckedCreateWithoutRecipeBookBuildInput>
    connectOrCreate?: BuildCreateOrConnectWithoutRecipeBookBuildInput
    connect?: BuildWhereUniqueInput
  }

  export type RecipeBookUpdateOneRequiredWithoutRecipeBookBuildNestedInput = {
    create?: XOR<RecipeBookCreateWithoutRecipeBookBuildInput, RecipeBookUncheckedCreateWithoutRecipeBookBuildInput>
    connectOrCreate?: RecipeBookCreateOrConnectWithoutRecipeBookBuildInput
    upsert?: RecipeBookUpsertWithoutRecipeBookBuildInput
    connect?: RecipeBookWhereUniqueInput
    update?: XOR<XOR<RecipeBookUpdateToOneWithWhereWithoutRecipeBookBuildInput, RecipeBookUpdateWithoutRecipeBookBuildInput>, RecipeBookUncheckedUpdateWithoutRecipeBookBuildInput>
  }

  export type BuildUpdateOneRequiredWithoutRecipeBookBuildNestedInput = {
    create?: XOR<BuildCreateWithoutRecipeBookBuildInput, BuildUncheckedCreateWithoutRecipeBookBuildInput>
    connectOrCreate?: BuildCreateOrConnectWithoutRecipeBookBuildInput
    upsert?: BuildUpsertWithoutRecipeBookBuildInput
    connect?: BuildWhereUniqueInput
    update?: XOR<XOR<BuildUpdateToOneWithWhereWithoutRecipeBookBuildInput, BuildUpdateWithoutRecipeBookBuildInput>, BuildUncheckedUpdateWithoutRecipeBookBuildInput>
  }

  export type BuildCreateNestedOneWithoutTouchInput = {
    create?: XOR<BuildCreateWithoutTouchInput, BuildUncheckedCreateWithoutTouchInput>
    connectOrCreate?: BuildCreateOrConnectWithoutTouchInput
    connect?: BuildWhereUniqueInput
  }

  export type GenericIngredientCreateNestedOneWithoutTouchInput = {
    create?: XOR<GenericIngredientCreateWithoutTouchInput, GenericIngredientUncheckedCreateWithoutTouchInput>
    connectOrCreate?: GenericIngredientCreateOrConnectWithoutTouchInput
    connect?: GenericIngredientWhereUniqueInput
  }

  export type SpecificIngredientCreateNestedOneWithoutTouchInput = {
    create?: XOR<SpecificIngredientCreateWithoutTouchInput, SpecificIngredientUncheckedCreateWithoutTouchInput>
    connectOrCreate?: SpecificIngredientCreateOrConnectWithoutTouchInput
    connect?: SpecificIngredientWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BuildUpdateOneRequiredWithoutTouchNestedInput = {
    create?: XOR<BuildCreateWithoutTouchInput, BuildUncheckedCreateWithoutTouchInput>
    connectOrCreate?: BuildCreateOrConnectWithoutTouchInput
    upsert?: BuildUpsertWithoutTouchInput
    connect?: BuildWhereUniqueInput
    update?: XOR<XOR<BuildUpdateToOneWithWhereWithoutTouchInput, BuildUpdateWithoutTouchInput>, BuildUncheckedUpdateWithoutTouchInput>
  }

  export type GenericIngredientUpdateOneRequiredWithoutTouchNestedInput = {
    create?: XOR<GenericIngredientCreateWithoutTouchInput, GenericIngredientUncheckedCreateWithoutTouchInput>
    connectOrCreate?: GenericIngredientCreateOrConnectWithoutTouchInput
    upsert?: GenericIngredientUpsertWithoutTouchInput
    connect?: GenericIngredientWhereUniqueInput
    update?: XOR<XOR<GenericIngredientUpdateToOneWithWhereWithoutTouchInput, GenericIngredientUpdateWithoutTouchInput>, GenericIngredientUncheckedUpdateWithoutTouchInput>
  }

  export type SpecificIngredientUpdateOneWithoutTouchNestedInput = {
    create?: XOR<SpecificIngredientCreateWithoutTouchInput, SpecificIngredientUncheckedCreateWithoutTouchInput>
    connectOrCreate?: SpecificIngredientCreateOrConnectWithoutTouchInput
    upsert?: SpecificIngredientUpsertWithoutTouchInput
    disconnect?: SpecificIngredientWhereInput | boolean
    delete?: SpecificIngredientWhereInput | boolean
    connect?: SpecificIngredientWhereUniqueInput
    update?: XOR<XOR<SpecificIngredientUpdateToOneWithWhereWithoutTouchInput, SpecificIngredientUpdateWithoutTouchInput>, SpecificIngredientUncheckedUpdateWithoutTouchInput>
  }

  export type BuildCreateNestedOneWithoutArchivedTouchInput = {
    create?: XOR<BuildCreateWithoutArchivedTouchInput, BuildUncheckedCreateWithoutArchivedTouchInput>
    connectOrCreate?: BuildCreateOrConnectWithoutArchivedTouchInput
    connect?: BuildWhereUniqueInput
  }

  export type GenericIngredientCreateNestedOneWithoutArchivedTouchInput = {
    create?: XOR<GenericIngredientCreateWithoutArchivedTouchInput, GenericIngredientUncheckedCreateWithoutArchivedTouchInput>
    connectOrCreate?: GenericIngredientCreateOrConnectWithoutArchivedTouchInput
    connect?: GenericIngredientWhereUniqueInput
  }

  export type SpecificIngredientCreateNestedOneWithoutArchivedTouchInput = {
    create?: XOR<SpecificIngredientCreateWithoutArchivedTouchInput, SpecificIngredientUncheckedCreateWithoutArchivedTouchInput>
    connectOrCreate?: SpecificIngredientCreateOrConnectWithoutArchivedTouchInput
    connect?: SpecificIngredientWhereUniqueInput
  }

  export type BuildUpdateOneRequiredWithoutArchivedTouchNestedInput = {
    create?: XOR<BuildCreateWithoutArchivedTouchInput, BuildUncheckedCreateWithoutArchivedTouchInput>
    connectOrCreate?: BuildCreateOrConnectWithoutArchivedTouchInput
    upsert?: BuildUpsertWithoutArchivedTouchInput
    connect?: BuildWhereUniqueInput
    update?: XOR<XOR<BuildUpdateToOneWithWhereWithoutArchivedTouchInput, BuildUpdateWithoutArchivedTouchInput>, BuildUncheckedUpdateWithoutArchivedTouchInput>
  }

  export type GenericIngredientUpdateOneRequiredWithoutArchivedTouchNestedInput = {
    create?: XOR<GenericIngredientCreateWithoutArchivedTouchInput, GenericIngredientUncheckedCreateWithoutArchivedTouchInput>
    connectOrCreate?: GenericIngredientCreateOrConnectWithoutArchivedTouchInput
    upsert?: GenericIngredientUpsertWithoutArchivedTouchInput
    connect?: GenericIngredientWhereUniqueInput
    update?: XOR<XOR<GenericIngredientUpdateToOneWithWhereWithoutArchivedTouchInput, GenericIngredientUpdateWithoutArchivedTouchInput>, GenericIngredientUncheckedUpdateWithoutArchivedTouchInput>
  }

  export type SpecificIngredientUpdateOneWithoutArchivedTouchNestedInput = {
    create?: XOR<SpecificIngredientCreateWithoutArchivedTouchInput, SpecificIngredientUncheckedCreateWithoutArchivedTouchInput>
    connectOrCreate?: SpecificIngredientCreateOrConnectWithoutArchivedTouchInput
    upsert?: SpecificIngredientUpsertWithoutArchivedTouchInput
    disconnect?: SpecificIngredientWhereInput | boolean
    delete?: SpecificIngredientWhereInput | boolean
    connect?: SpecificIngredientWhereUniqueInput
    update?: XOR<XOR<SpecificIngredientUpdateToOneWithWhereWithoutArchivedTouchInput, SpecificIngredientUpdateWithoutArchivedTouchInput>, SpecificIngredientUncheckedUpdateWithoutArchivedTouchInput>
  }

  export type TouchCreateNestedManyWithoutGenericIngredientInput = {
    create?: XOR<TouchCreateWithoutGenericIngredientInput, TouchUncheckedCreateWithoutGenericIngredientInput> | TouchCreateWithoutGenericIngredientInput[] | TouchUncheckedCreateWithoutGenericIngredientInput[]
    connectOrCreate?: TouchCreateOrConnectWithoutGenericIngredientInput | TouchCreateOrConnectWithoutGenericIngredientInput[]
    createMany?: TouchCreateManyGenericIngredientInputEnvelope
    connect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
  }

  export type ArchivedTouchCreateNestedManyWithoutGenericIngredientInput = {
    create?: XOR<ArchivedTouchCreateWithoutGenericIngredientInput, ArchivedTouchUncheckedCreateWithoutGenericIngredientInput> | ArchivedTouchCreateWithoutGenericIngredientInput[] | ArchivedTouchUncheckedCreateWithoutGenericIngredientInput[]
    connectOrCreate?: ArchivedTouchCreateOrConnectWithoutGenericIngredientInput | ArchivedTouchCreateOrConnectWithoutGenericIngredientInput[]
    createMany?: ArchivedTouchCreateManyGenericIngredientInputEnvelope
    connect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
  }

  export type SpecificIngredientCreateNestedManyWithoutGenericIngredientInput = {
    create?: XOR<SpecificIngredientCreateWithoutGenericIngredientInput, SpecificIngredientUncheckedCreateWithoutGenericIngredientInput> | SpecificIngredientCreateWithoutGenericIngredientInput[] | SpecificIngredientUncheckedCreateWithoutGenericIngredientInput[]
    connectOrCreate?: SpecificIngredientCreateOrConnectWithoutGenericIngredientInput | SpecificIngredientCreateOrConnectWithoutGenericIngredientInput[]
    createMany?: SpecificIngredientCreateManyGenericIngredientInputEnvelope
    connect?: SpecificIngredientWhereUniqueInput | SpecificIngredientWhereUniqueInput[]
  }

  export type IngredientPreferenceCreateNestedManyWithoutGenericIngredientInput = {
    create?: XOR<IngredientPreferenceCreateWithoutGenericIngredientInput, IngredientPreferenceUncheckedCreateWithoutGenericIngredientInput> | IngredientPreferenceCreateWithoutGenericIngredientInput[] | IngredientPreferenceUncheckedCreateWithoutGenericIngredientInput[]
    connectOrCreate?: IngredientPreferenceCreateOrConnectWithoutGenericIngredientInput | IngredientPreferenceCreateOrConnectWithoutGenericIngredientInput[]
    createMany?: IngredientPreferenceCreateManyGenericIngredientInputEnvelope
    connect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
  }

  export type TouchUncheckedCreateNestedManyWithoutGenericIngredientInput = {
    create?: XOR<TouchCreateWithoutGenericIngredientInput, TouchUncheckedCreateWithoutGenericIngredientInput> | TouchCreateWithoutGenericIngredientInput[] | TouchUncheckedCreateWithoutGenericIngredientInput[]
    connectOrCreate?: TouchCreateOrConnectWithoutGenericIngredientInput | TouchCreateOrConnectWithoutGenericIngredientInput[]
    createMany?: TouchCreateManyGenericIngredientInputEnvelope
    connect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
  }

  export type ArchivedTouchUncheckedCreateNestedManyWithoutGenericIngredientInput = {
    create?: XOR<ArchivedTouchCreateWithoutGenericIngredientInput, ArchivedTouchUncheckedCreateWithoutGenericIngredientInput> | ArchivedTouchCreateWithoutGenericIngredientInput[] | ArchivedTouchUncheckedCreateWithoutGenericIngredientInput[]
    connectOrCreate?: ArchivedTouchCreateOrConnectWithoutGenericIngredientInput | ArchivedTouchCreateOrConnectWithoutGenericIngredientInput[]
    createMany?: ArchivedTouchCreateManyGenericIngredientInputEnvelope
    connect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
  }

  export type SpecificIngredientUncheckedCreateNestedManyWithoutGenericIngredientInput = {
    create?: XOR<SpecificIngredientCreateWithoutGenericIngredientInput, SpecificIngredientUncheckedCreateWithoutGenericIngredientInput> | SpecificIngredientCreateWithoutGenericIngredientInput[] | SpecificIngredientUncheckedCreateWithoutGenericIngredientInput[]
    connectOrCreate?: SpecificIngredientCreateOrConnectWithoutGenericIngredientInput | SpecificIngredientCreateOrConnectWithoutGenericIngredientInput[]
    createMany?: SpecificIngredientCreateManyGenericIngredientInputEnvelope
    connect?: SpecificIngredientWhereUniqueInput | SpecificIngredientWhereUniqueInput[]
  }

  export type IngredientPreferenceUncheckedCreateNestedManyWithoutGenericIngredientInput = {
    create?: XOR<IngredientPreferenceCreateWithoutGenericIngredientInput, IngredientPreferenceUncheckedCreateWithoutGenericIngredientInput> | IngredientPreferenceCreateWithoutGenericIngredientInput[] | IngredientPreferenceUncheckedCreateWithoutGenericIngredientInput[]
    connectOrCreate?: IngredientPreferenceCreateOrConnectWithoutGenericIngredientInput | IngredientPreferenceCreateOrConnectWithoutGenericIngredientInput[]
    createMany?: IngredientPreferenceCreateManyGenericIngredientInputEnvelope
    connect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
  }

  export type TouchUpdateManyWithoutGenericIngredientNestedInput = {
    create?: XOR<TouchCreateWithoutGenericIngredientInput, TouchUncheckedCreateWithoutGenericIngredientInput> | TouchCreateWithoutGenericIngredientInput[] | TouchUncheckedCreateWithoutGenericIngredientInput[]
    connectOrCreate?: TouchCreateOrConnectWithoutGenericIngredientInput | TouchCreateOrConnectWithoutGenericIngredientInput[]
    upsert?: TouchUpsertWithWhereUniqueWithoutGenericIngredientInput | TouchUpsertWithWhereUniqueWithoutGenericIngredientInput[]
    createMany?: TouchCreateManyGenericIngredientInputEnvelope
    set?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    disconnect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    delete?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    connect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    update?: TouchUpdateWithWhereUniqueWithoutGenericIngredientInput | TouchUpdateWithWhereUniqueWithoutGenericIngredientInput[]
    updateMany?: TouchUpdateManyWithWhereWithoutGenericIngredientInput | TouchUpdateManyWithWhereWithoutGenericIngredientInput[]
    deleteMany?: TouchScalarWhereInput | TouchScalarWhereInput[]
  }

  export type ArchivedTouchUpdateManyWithoutGenericIngredientNestedInput = {
    create?: XOR<ArchivedTouchCreateWithoutGenericIngredientInput, ArchivedTouchUncheckedCreateWithoutGenericIngredientInput> | ArchivedTouchCreateWithoutGenericIngredientInput[] | ArchivedTouchUncheckedCreateWithoutGenericIngredientInput[]
    connectOrCreate?: ArchivedTouchCreateOrConnectWithoutGenericIngredientInput | ArchivedTouchCreateOrConnectWithoutGenericIngredientInput[]
    upsert?: ArchivedTouchUpsertWithWhereUniqueWithoutGenericIngredientInput | ArchivedTouchUpsertWithWhereUniqueWithoutGenericIngredientInput[]
    createMany?: ArchivedTouchCreateManyGenericIngredientInputEnvelope
    set?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    disconnect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    delete?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    connect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    update?: ArchivedTouchUpdateWithWhereUniqueWithoutGenericIngredientInput | ArchivedTouchUpdateWithWhereUniqueWithoutGenericIngredientInput[]
    updateMany?: ArchivedTouchUpdateManyWithWhereWithoutGenericIngredientInput | ArchivedTouchUpdateManyWithWhereWithoutGenericIngredientInput[]
    deleteMany?: ArchivedTouchScalarWhereInput | ArchivedTouchScalarWhereInput[]
  }

  export type SpecificIngredientUpdateManyWithoutGenericIngredientNestedInput = {
    create?: XOR<SpecificIngredientCreateWithoutGenericIngredientInput, SpecificIngredientUncheckedCreateWithoutGenericIngredientInput> | SpecificIngredientCreateWithoutGenericIngredientInput[] | SpecificIngredientUncheckedCreateWithoutGenericIngredientInput[]
    connectOrCreate?: SpecificIngredientCreateOrConnectWithoutGenericIngredientInput | SpecificIngredientCreateOrConnectWithoutGenericIngredientInput[]
    upsert?: SpecificIngredientUpsertWithWhereUniqueWithoutGenericIngredientInput | SpecificIngredientUpsertWithWhereUniqueWithoutGenericIngredientInput[]
    createMany?: SpecificIngredientCreateManyGenericIngredientInputEnvelope
    set?: SpecificIngredientWhereUniqueInput | SpecificIngredientWhereUniqueInput[]
    disconnect?: SpecificIngredientWhereUniqueInput | SpecificIngredientWhereUniqueInput[]
    delete?: SpecificIngredientWhereUniqueInput | SpecificIngredientWhereUniqueInput[]
    connect?: SpecificIngredientWhereUniqueInput | SpecificIngredientWhereUniqueInput[]
    update?: SpecificIngredientUpdateWithWhereUniqueWithoutGenericIngredientInput | SpecificIngredientUpdateWithWhereUniqueWithoutGenericIngredientInput[]
    updateMany?: SpecificIngredientUpdateManyWithWhereWithoutGenericIngredientInput | SpecificIngredientUpdateManyWithWhereWithoutGenericIngredientInput[]
    deleteMany?: SpecificIngredientScalarWhereInput | SpecificIngredientScalarWhereInput[]
  }

  export type IngredientPreferenceUpdateManyWithoutGenericIngredientNestedInput = {
    create?: XOR<IngredientPreferenceCreateWithoutGenericIngredientInput, IngredientPreferenceUncheckedCreateWithoutGenericIngredientInput> | IngredientPreferenceCreateWithoutGenericIngredientInput[] | IngredientPreferenceUncheckedCreateWithoutGenericIngredientInput[]
    connectOrCreate?: IngredientPreferenceCreateOrConnectWithoutGenericIngredientInput | IngredientPreferenceCreateOrConnectWithoutGenericIngredientInput[]
    upsert?: IngredientPreferenceUpsertWithWhereUniqueWithoutGenericIngredientInput | IngredientPreferenceUpsertWithWhereUniqueWithoutGenericIngredientInput[]
    createMany?: IngredientPreferenceCreateManyGenericIngredientInputEnvelope
    set?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    disconnect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    delete?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    connect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    update?: IngredientPreferenceUpdateWithWhereUniqueWithoutGenericIngredientInput | IngredientPreferenceUpdateWithWhereUniqueWithoutGenericIngredientInput[]
    updateMany?: IngredientPreferenceUpdateManyWithWhereWithoutGenericIngredientInput | IngredientPreferenceUpdateManyWithWhereWithoutGenericIngredientInput[]
    deleteMany?: IngredientPreferenceScalarWhereInput | IngredientPreferenceScalarWhereInput[]
  }

  export type TouchUncheckedUpdateManyWithoutGenericIngredientNestedInput = {
    create?: XOR<TouchCreateWithoutGenericIngredientInput, TouchUncheckedCreateWithoutGenericIngredientInput> | TouchCreateWithoutGenericIngredientInput[] | TouchUncheckedCreateWithoutGenericIngredientInput[]
    connectOrCreate?: TouchCreateOrConnectWithoutGenericIngredientInput | TouchCreateOrConnectWithoutGenericIngredientInput[]
    upsert?: TouchUpsertWithWhereUniqueWithoutGenericIngredientInput | TouchUpsertWithWhereUniqueWithoutGenericIngredientInput[]
    createMany?: TouchCreateManyGenericIngredientInputEnvelope
    set?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    disconnect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    delete?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    connect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    update?: TouchUpdateWithWhereUniqueWithoutGenericIngredientInput | TouchUpdateWithWhereUniqueWithoutGenericIngredientInput[]
    updateMany?: TouchUpdateManyWithWhereWithoutGenericIngredientInput | TouchUpdateManyWithWhereWithoutGenericIngredientInput[]
    deleteMany?: TouchScalarWhereInput | TouchScalarWhereInput[]
  }

  export type ArchivedTouchUncheckedUpdateManyWithoutGenericIngredientNestedInput = {
    create?: XOR<ArchivedTouchCreateWithoutGenericIngredientInput, ArchivedTouchUncheckedCreateWithoutGenericIngredientInput> | ArchivedTouchCreateWithoutGenericIngredientInput[] | ArchivedTouchUncheckedCreateWithoutGenericIngredientInput[]
    connectOrCreate?: ArchivedTouchCreateOrConnectWithoutGenericIngredientInput | ArchivedTouchCreateOrConnectWithoutGenericIngredientInput[]
    upsert?: ArchivedTouchUpsertWithWhereUniqueWithoutGenericIngredientInput | ArchivedTouchUpsertWithWhereUniqueWithoutGenericIngredientInput[]
    createMany?: ArchivedTouchCreateManyGenericIngredientInputEnvelope
    set?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    disconnect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    delete?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    connect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    update?: ArchivedTouchUpdateWithWhereUniqueWithoutGenericIngredientInput | ArchivedTouchUpdateWithWhereUniqueWithoutGenericIngredientInput[]
    updateMany?: ArchivedTouchUpdateManyWithWhereWithoutGenericIngredientInput | ArchivedTouchUpdateManyWithWhereWithoutGenericIngredientInput[]
    deleteMany?: ArchivedTouchScalarWhereInput | ArchivedTouchScalarWhereInput[]
  }

  export type SpecificIngredientUncheckedUpdateManyWithoutGenericIngredientNestedInput = {
    create?: XOR<SpecificIngredientCreateWithoutGenericIngredientInput, SpecificIngredientUncheckedCreateWithoutGenericIngredientInput> | SpecificIngredientCreateWithoutGenericIngredientInput[] | SpecificIngredientUncheckedCreateWithoutGenericIngredientInput[]
    connectOrCreate?: SpecificIngredientCreateOrConnectWithoutGenericIngredientInput | SpecificIngredientCreateOrConnectWithoutGenericIngredientInput[]
    upsert?: SpecificIngredientUpsertWithWhereUniqueWithoutGenericIngredientInput | SpecificIngredientUpsertWithWhereUniqueWithoutGenericIngredientInput[]
    createMany?: SpecificIngredientCreateManyGenericIngredientInputEnvelope
    set?: SpecificIngredientWhereUniqueInput | SpecificIngredientWhereUniqueInput[]
    disconnect?: SpecificIngredientWhereUniqueInput | SpecificIngredientWhereUniqueInput[]
    delete?: SpecificIngredientWhereUniqueInput | SpecificIngredientWhereUniqueInput[]
    connect?: SpecificIngredientWhereUniqueInput | SpecificIngredientWhereUniqueInput[]
    update?: SpecificIngredientUpdateWithWhereUniqueWithoutGenericIngredientInput | SpecificIngredientUpdateWithWhereUniqueWithoutGenericIngredientInput[]
    updateMany?: SpecificIngredientUpdateManyWithWhereWithoutGenericIngredientInput | SpecificIngredientUpdateManyWithWhereWithoutGenericIngredientInput[]
    deleteMany?: SpecificIngredientScalarWhereInput | SpecificIngredientScalarWhereInput[]
  }

  export type IngredientPreferenceUncheckedUpdateManyWithoutGenericIngredientNestedInput = {
    create?: XOR<IngredientPreferenceCreateWithoutGenericIngredientInput, IngredientPreferenceUncheckedCreateWithoutGenericIngredientInput> | IngredientPreferenceCreateWithoutGenericIngredientInput[] | IngredientPreferenceUncheckedCreateWithoutGenericIngredientInput[]
    connectOrCreate?: IngredientPreferenceCreateOrConnectWithoutGenericIngredientInput | IngredientPreferenceCreateOrConnectWithoutGenericIngredientInput[]
    upsert?: IngredientPreferenceUpsertWithWhereUniqueWithoutGenericIngredientInput | IngredientPreferenceUpsertWithWhereUniqueWithoutGenericIngredientInput[]
    createMany?: IngredientPreferenceCreateManyGenericIngredientInputEnvelope
    set?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    disconnect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    delete?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    connect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    update?: IngredientPreferenceUpdateWithWhereUniqueWithoutGenericIngredientInput | IngredientPreferenceUpdateWithWhereUniqueWithoutGenericIngredientInput[]
    updateMany?: IngredientPreferenceUpdateManyWithWhereWithoutGenericIngredientInput | IngredientPreferenceUpdateManyWithWhereWithoutGenericIngredientInput[]
    deleteMany?: IngredientPreferenceScalarWhereInput | IngredientPreferenceScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutIngredientInput = {
    create?: XOR<UserCreateWithoutIngredientInput, UserUncheckedCreateWithoutIngredientInput>
    connectOrCreate?: UserCreateOrConnectWithoutIngredientInput
    connect?: UserWhereUniqueInput
  }

  export type GenericIngredientCreateNestedOneWithoutSpecificIngredientInput = {
    create?: XOR<GenericIngredientCreateWithoutSpecificIngredientInput, GenericIngredientUncheckedCreateWithoutSpecificIngredientInput>
    connectOrCreate?: GenericIngredientCreateOrConnectWithoutSpecificIngredientInput
    connect?: GenericIngredientWhereUniqueInput
  }

  export type TouchCreateNestedManyWithoutSpecificIngredientInput = {
    create?: XOR<TouchCreateWithoutSpecificIngredientInput, TouchUncheckedCreateWithoutSpecificIngredientInput> | TouchCreateWithoutSpecificIngredientInput[] | TouchUncheckedCreateWithoutSpecificIngredientInput[]
    connectOrCreate?: TouchCreateOrConnectWithoutSpecificIngredientInput | TouchCreateOrConnectWithoutSpecificIngredientInput[]
    createMany?: TouchCreateManySpecificIngredientInputEnvelope
    connect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
  }

  export type ArchivedTouchCreateNestedManyWithoutSpecificIngredientInput = {
    create?: XOR<ArchivedTouchCreateWithoutSpecificIngredientInput, ArchivedTouchUncheckedCreateWithoutSpecificIngredientInput> | ArchivedTouchCreateWithoutSpecificIngredientInput[] | ArchivedTouchUncheckedCreateWithoutSpecificIngredientInput[]
    connectOrCreate?: ArchivedTouchCreateOrConnectWithoutSpecificIngredientInput | ArchivedTouchCreateOrConnectWithoutSpecificIngredientInput[]
    createMany?: ArchivedTouchCreateManySpecificIngredientInputEnvelope
    connect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
  }

  export type IngredientStorageCreateNestedManyWithoutIngredientInput = {
    create?: XOR<IngredientStorageCreateWithoutIngredientInput, IngredientStorageUncheckedCreateWithoutIngredientInput> | IngredientStorageCreateWithoutIngredientInput[] | IngredientStorageUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: IngredientStorageCreateOrConnectWithoutIngredientInput | IngredientStorageCreateOrConnectWithoutIngredientInput[]
    createMany?: IngredientStorageCreateManyIngredientInputEnvelope
    connect?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
  }

  export type IngredientUserCreateNestedManyWithoutIngredientInput = {
    create?: XOR<IngredientUserCreateWithoutIngredientInput, IngredientUserUncheckedCreateWithoutIngredientInput> | IngredientUserCreateWithoutIngredientInput[] | IngredientUserUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: IngredientUserCreateOrConnectWithoutIngredientInput | IngredientUserCreateOrConnectWithoutIngredientInput[]
    createMany?: IngredientUserCreateManyIngredientInputEnvelope
    connect?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
  }

  export type IngredientPreferenceCreateNestedManyWithoutSpecificIngredientInput = {
    create?: XOR<IngredientPreferenceCreateWithoutSpecificIngredientInput, IngredientPreferenceUncheckedCreateWithoutSpecificIngredientInput> | IngredientPreferenceCreateWithoutSpecificIngredientInput[] | IngredientPreferenceUncheckedCreateWithoutSpecificIngredientInput[]
    connectOrCreate?: IngredientPreferenceCreateOrConnectWithoutSpecificIngredientInput | IngredientPreferenceCreateOrConnectWithoutSpecificIngredientInput[]
    createMany?: IngredientPreferenceCreateManySpecificIngredientInputEnvelope
    connect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
  }

  export type TouchUncheckedCreateNestedManyWithoutSpecificIngredientInput = {
    create?: XOR<TouchCreateWithoutSpecificIngredientInput, TouchUncheckedCreateWithoutSpecificIngredientInput> | TouchCreateWithoutSpecificIngredientInput[] | TouchUncheckedCreateWithoutSpecificIngredientInput[]
    connectOrCreate?: TouchCreateOrConnectWithoutSpecificIngredientInput | TouchCreateOrConnectWithoutSpecificIngredientInput[]
    createMany?: TouchCreateManySpecificIngredientInputEnvelope
    connect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
  }

  export type ArchivedTouchUncheckedCreateNestedManyWithoutSpecificIngredientInput = {
    create?: XOR<ArchivedTouchCreateWithoutSpecificIngredientInput, ArchivedTouchUncheckedCreateWithoutSpecificIngredientInput> | ArchivedTouchCreateWithoutSpecificIngredientInput[] | ArchivedTouchUncheckedCreateWithoutSpecificIngredientInput[]
    connectOrCreate?: ArchivedTouchCreateOrConnectWithoutSpecificIngredientInput | ArchivedTouchCreateOrConnectWithoutSpecificIngredientInput[]
    createMany?: ArchivedTouchCreateManySpecificIngredientInputEnvelope
    connect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
  }

  export type IngredientStorageUncheckedCreateNestedManyWithoutIngredientInput = {
    create?: XOR<IngredientStorageCreateWithoutIngredientInput, IngredientStorageUncheckedCreateWithoutIngredientInput> | IngredientStorageCreateWithoutIngredientInput[] | IngredientStorageUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: IngredientStorageCreateOrConnectWithoutIngredientInput | IngredientStorageCreateOrConnectWithoutIngredientInput[]
    createMany?: IngredientStorageCreateManyIngredientInputEnvelope
    connect?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
  }

  export type IngredientUserUncheckedCreateNestedManyWithoutIngredientInput = {
    create?: XOR<IngredientUserCreateWithoutIngredientInput, IngredientUserUncheckedCreateWithoutIngredientInput> | IngredientUserCreateWithoutIngredientInput[] | IngredientUserUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: IngredientUserCreateOrConnectWithoutIngredientInput | IngredientUserCreateOrConnectWithoutIngredientInput[]
    createMany?: IngredientUserCreateManyIngredientInputEnvelope
    connect?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
  }

  export type IngredientPreferenceUncheckedCreateNestedManyWithoutSpecificIngredientInput = {
    create?: XOR<IngredientPreferenceCreateWithoutSpecificIngredientInput, IngredientPreferenceUncheckedCreateWithoutSpecificIngredientInput> | IngredientPreferenceCreateWithoutSpecificIngredientInput[] | IngredientPreferenceUncheckedCreateWithoutSpecificIngredientInput[]
    connectOrCreate?: IngredientPreferenceCreateOrConnectWithoutSpecificIngredientInput | IngredientPreferenceCreateOrConnectWithoutSpecificIngredientInput[]
    createMany?: IngredientPreferenceCreateManySpecificIngredientInputEnvelope
    connect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutIngredientNestedInput = {
    create?: XOR<UserCreateWithoutIngredientInput, UserUncheckedCreateWithoutIngredientInput>
    connectOrCreate?: UserCreateOrConnectWithoutIngredientInput
    upsert?: UserUpsertWithoutIngredientInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIngredientInput, UserUpdateWithoutIngredientInput>, UserUncheckedUpdateWithoutIngredientInput>
  }

  export type GenericIngredientUpdateOneRequiredWithoutSpecificIngredientNestedInput = {
    create?: XOR<GenericIngredientCreateWithoutSpecificIngredientInput, GenericIngredientUncheckedCreateWithoutSpecificIngredientInput>
    connectOrCreate?: GenericIngredientCreateOrConnectWithoutSpecificIngredientInput
    upsert?: GenericIngredientUpsertWithoutSpecificIngredientInput
    connect?: GenericIngredientWhereUniqueInput
    update?: XOR<XOR<GenericIngredientUpdateToOneWithWhereWithoutSpecificIngredientInput, GenericIngredientUpdateWithoutSpecificIngredientInput>, GenericIngredientUncheckedUpdateWithoutSpecificIngredientInput>
  }

  export type TouchUpdateManyWithoutSpecificIngredientNestedInput = {
    create?: XOR<TouchCreateWithoutSpecificIngredientInput, TouchUncheckedCreateWithoutSpecificIngredientInput> | TouchCreateWithoutSpecificIngredientInput[] | TouchUncheckedCreateWithoutSpecificIngredientInput[]
    connectOrCreate?: TouchCreateOrConnectWithoutSpecificIngredientInput | TouchCreateOrConnectWithoutSpecificIngredientInput[]
    upsert?: TouchUpsertWithWhereUniqueWithoutSpecificIngredientInput | TouchUpsertWithWhereUniqueWithoutSpecificIngredientInput[]
    createMany?: TouchCreateManySpecificIngredientInputEnvelope
    set?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    disconnect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    delete?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    connect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    update?: TouchUpdateWithWhereUniqueWithoutSpecificIngredientInput | TouchUpdateWithWhereUniqueWithoutSpecificIngredientInput[]
    updateMany?: TouchUpdateManyWithWhereWithoutSpecificIngredientInput | TouchUpdateManyWithWhereWithoutSpecificIngredientInput[]
    deleteMany?: TouchScalarWhereInput | TouchScalarWhereInput[]
  }

  export type ArchivedTouchUpdateManyWithoutSpecificIngredientNestedInput = {
    create?: XOR<ArchivedTouchCreateWithoutSpecificIngredientInput, ArchivedTouchUncheckedCreateWithoutSpecificIngredientInput> | ArchivedTouchCreateWithoutSpecificIngredientInput[] | ArchivedTouchUncheckedCreateWithoutSpecificIngredientInput[]
    connectOrCreate?: ArchivedTouchCreateOrConnectWithoutSpecificIngredientInput | ArchivedTouchCreateOrConnectWithoutSpecificIngredientInput[]
    upsert?: ArchivedTouchUpsertWithWhereUniqueWithoutSpecificIngredientInput | ArchivedTouchUpsertWithWhereUniqueWithoutSpecificIngredientInput[]
    createMany?: ArchivedTouchCreateManySpecificIngredientInputEnvelope
    set?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    disconnect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    delete?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    connect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    update?: ArchivedTouchUpdateWithWhereUniqueWithoutSpecificIngredientInput | ArchivedTouchUpdateWithWhereUniqueWithoutSpecificIngredientInput[]
    updateMany?: ArchivedTouchUpdateManyWithWhereWithoutSpecificIngredientInput | ArchivedTouchUpdateManyWithWhereWithoutSpecificIngredientInput[]
    deleteMany?: ArchivedTouchScalarWhereInput | ArchivedTouchScalarWhereInput[]
  }

  export type IngredientStorageUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<IngredientStorageCreateWithoutIngredientInput, IngredientStorageUncheckedCreateWithoutIngredientInput> | IngredientStorageCreateWithoutIngredientInput[] | IngredientStorageUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: IngredientStorageCreateOrConnectWithoutIngredientInput | IngredientStorageCreateOrConnectWithoutIngredientInput[]
    upsert?: IngredientStorageUpsertWithWhereUniqueWithoutIngredientInput | IngredientStorageUpsertWithWhereUniqueWithoutIngredientInput[]
    createMany?: IngredientStorageCreateManyIngredientInputEnvelope
    set?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
    disconnect?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
    delete?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
    connect?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
    update?: IngredientStorageUpdateWithWhereUniqueWithoutIngredientInput | IngredientStorageUpdateWithWhereUniqueWithoutIngredientInput[]
    updateMany?: IngredientStorageUpdateManyWithWhereWithoutIngredientInput | IngredientStorageUpdateManyWithWhereWithoutIngredientInput[]
    deleteMany?: IngredientStorageScalarWhereInput | IngredientStorageScalarWhereInput[]
  }

  export type IngredientUserUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<IngredientUserCreateWithoutIngredientInput, IngredientUserUncheckedCreateWithoutIngredientInput> | IngredientUserCreateWithoutIngredientInput[] | IngredientUserUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: IngredientUserCreateOrConnectWithoutIngredientInput | IngredientUserCreateOrConnectWithoutIngredientInput[]
    upsert?: IngredientUserUpsertWithWhereUniqueWithoutIngredientInput | IngredientUserUpsertWithWhereUniqueWithoutIngredientInput[]
    createMany?: IngredientUserCreateManyIngredientInputEnvelope
    set?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
    disconnect?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
    delete?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
    connect?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
    update?: IngredientUserUpdateWithWhereUniqueWithoutIngredientInput | IngredientUserUpdateWithWhereUniqueWithoutIngredientInput[]
    updateMany?: IngredientUserUpdateManyWithWhereWithoutIngredientInput | IngredientUserUpdateManyWithWhereWithoutIngredientInput[]
    deleteMany?: IngredientUserScalarWhereInput | IngredientUserScalarWhereInput[]
  }

  export type IngredientPreferenceUpdateManyWithoutSpecificIngredientNestedInput = {
    create?: XOR<IngredientPreferenceCreateWithoutSpecificIngredientInput, IngredientPreferenceUncheckedCreateWithoutSpecificIngredientInput> | IngredientPreferenceCreateWithoutSpecificIngredientInput[] | IngredientPreferenceUncheckedCreateWithoutSpecificIngredientInput[]
    connectOrCreate?: IngredientPreferenceCreateOrConnectWithoutSpecificIngredientInput | IngredientPreferenceCreateOrConnectWithoutSpecificIngredientInput[]
    upsert?: IngredientPreferenceUpsertWithWhereUniqueWithoutSpecificIngredientInput | IngredientPreferenceUpsertWithWhereUniqueWithoutSpecificIngredientInput[]
    createMany?: IngredientPreferenceCreateManySpecificIngredientInputEnvelope
    set?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    disconnect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    delete?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    connect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    update?: IngredientPreferenceUpdateWithWhereUniqueWithoutSpecificIngredientInput | IngredientPreferenceUpdateWithWhereUniqueWithoutSpecificIngredientInput[]
    updateMany?: IngredientPreferenceUpdateManyWithWhereWithoutSpecificIngredientInput | IngredientPreferenceUpdateManyWithWhereWithoutSpecificIngredientInput[]
    deleteMany?: IngredientPreferenceScalarWhereInput | IngredientPreferenceScalarWhereInput[]
  }

  export type TouchUncheckedUpdateManyWithoutSpecificIngredientNestedInput = {
    create?: XOR<TouchCreateWithoutSpecificIngredientInput, TouchUncheckedCreateWithoutSpecificIngredientInput> | TouchCreateWithoutSpecificIngredientInput[] | TouchUncheckedCreateWithoutSpecificIngredientInput[]
    connectOrCreate?: TouchCreateOrConnectWithoutSpecificIngredientInput | TouchCreateOrConnectWithoutSpecificIngredientInput[]
    upsert?: TouchUpsertWithWhereUniqueWithoutSpecificIngredientInput | TouchUpsertWithWhereUniqueWithoutSpecificIngredientInput[]
    createMany?: TouchCreateManySpecificIngredientInputEnvelope
    set?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    disconnect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    delete?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    connect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    update?: TouchUpdateWithWhereUniqueWithoutSpecificIngredientInput | TouchUpdateWithWhereUniqueWithoutSpecificIngredientInput[]
    updateMany?: TouchUpdateManyWithWhereWithoutSpecificIngredientInput | TouchUpdateManyWithWhereWithoutSpecificIngredientInput[]
    deleteMany?: TouchScalarWhereInput | TouchScalarWhereInput[]
  }

  export type ArchivedTouchUncheckedUpdateManyWithoutSpecificIngredientNestedInput = {
    create?: XOR<ArchivedTouchCreateWithoutSpecificIngredientInput, ArchivedTouchUncheckedCreateWithoutSpecificIngredientInput> | ArchivedTouchCreateWithoutSpecificIngredientInput[] | ArchivedTouchUncheckedCreateWithoutSpecificIngredientInput[]
    connectOrCreate?: ArchivedTouchCreateOrConnectWithoutSpecificIngredientInput | ArchivedTouchCreateOrConnectWithoutSpecificIngredientInput[]
    upsert?: ArchivedTouchUpsertWithWhereUniqueWithoutSpecificIngredientInput | ArchivedTouchUpsertWithWhereUniqueWithoutSpecificIngredientInput[]
    createMany?: ArchivedTouchCreateManySpecificIngredientInputEnvelope
    set?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    disconnect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    delete?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    connect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    update?: ArchivedTouchUpdateWithWhereUniqueWithoutSpecificIngredientInput | ArchivedTouchUpdateWithWhereUniqueWithoutSpecificIngredientInput[]
    updateMany?: ArchivedTouchUpdateManyWithWhereWithoutSpecificIngredientInput | ArchivedTouchUpdateManyWithWhereWithoutSpecificIngredientInput[]
    deleteMany?: ArchivedTouchScalarWhereInput | ArchivedTouchScalarWhereInput[]
  }

  export type IngredientStorageUncheckedUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<IngredientStorageCreateWithoutIngredientInput, IngredientStorageUncheckedCreateWithoutIngredientInput> | IngredientStorageCreateWithoutIngredientInput[] | IngredientStorageUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: IngredientStorageCreateOrConnectWithoutIngredientInput | IngredientStorageCreateOrConnectWithoutIngredientInput[]
    upsert?: IngredientStorageUpsertWithWhereUniqueWithoutIngredientInput | IngredientStorageUpsertWithWhereUniqueWithoutIngredientInput[]
    createMany?: IngredientStorageCreateManyIngredientInputEnvelope
    set?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
    disconnect?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
    delete?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
    connect?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
    update?: IngredientStorageUpdateWithWhereUniqueWithoutIngredientInput | IngredientStorageUpdateWithWhereUniqueWithoutIngredientInput[]
    updateMany?: IngredientStorageUpdateManyWithWhereWithoutIngredientInput | IngredientStorageUpdateManyWithWhereWithoutIngredientInput[]
    deleteMany?: IngredientStorageScalarWhereInput | IngredientStorageScalarWhereInput[]
  }

  export type IngredientUserUncheckedUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<IngredientUserCreateWithoutIngredientInput, IngredientUserUncheckedCreateWithoutIngredientInput> | IngredientUserCreateWithoutIngredientInput[] | IngredientUserUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: IngredientUserCreateOrConnectWithoutIngredientInput | IngredientUserCreateOrConnectWithoutIngredientInput[]
    upsert?: IngredientUserUpsertWithWhereUniqueWithoutIngredientInput | IngredientUserUpsertWithWhereUniqueWithoutIngredientInput[]
    createMany?: IngredientUserCreateManyIngredientInputEnvelope
    set?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
    disconnect?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
    delete?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
    connect?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
    update?: IngredientUserUpdateWithWhereUniqueWithoutIngredientInput | IngredientUserUpdateWithWhereUniqueWithoutIngredientInput[]
    updateMany?: IngredientUserUpdateManyWithWhereWithoutIngredientInput | IngredientUserUpdateManyWithWhereWithoutIngredientInput[]
    deleteMany?: IngredientUserScalarWhereInput | IngredientUserScalarWhereInput[]
  }

  export type IngredientPreferenceUncheckedUpdateManyWithoutSpecificIngredientNestedInput = {
    create?: XOR<IngredientPreferenceCreateWithoutSpecificIngredientInput, IngredientPreferenceUncheckedCreateWithoutSpecificIngredientInput> | IngredientPreferenceCreateWithoutSpecificIngredientInput[] | IngredientPreferenceUncheckedCreateWithoutSpecificIngredientInput[]
    connectOrCreate?: IngredientPreferenceCreateOrConnectWithoutSpecificIngredientInput | IngredientPreferenceCreateOrConnectWithoutSpecificIngredientInput[]
    upsert?: IngredientPreferenceUpsertWithWhereUniqueWithoutSpecificIngredientInput | IngredientPreferenceUpsertWithWhereUniqueWithoutSpecificIngredientInput[]
    createMany?: IngredientPreferenceCreateManySpecificIngredientInputEnvelope
    set?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    disconnect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    delete?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    connect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    update?: IngredientPreferenceUpdateWithWhereUniqueWithoutSpecificIngredientInput | IngredientPreferenceUpdateWithWhereUniqueWithoutSpecificIngredientInput[]
    updateMany?: IngredientPreferenceUpdateManyWithWhereWithoutSpecificIngredientInput | IngredientPreferenceUpdateManyWithWhereWithoutSpecificIngredientInput[]
    deleteMany?: IngredientPreferenceScalarWhereInput | IngredientPreferenceScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutIngredientUserInput = {
    create?: XOR<UserCreateWithoutIngredientUserInput, UserUncheckedCreateWithoutIngredientUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutIngredientUserInput
    connect?: UserWhereUniqueInput
  }

  export type SpecificIngredientCreateNestedOneWithoutIngredientUserInput = {
    create?: XOR<SpecificIngredientCreateWithoutIngredientUserInput, SpecificIngredientUncheckedCreateWithoutIngredientUserInput>
    connectOrCreate?: SpecificIngredientCreateOrConnectWithoutIngredientUserInput
    connect?: SpecificIngredientWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutIngredientUserNestedInput = {
    create?: XOR<UserCreateWithoutIngredientUserInput, UserUncheckedCreateWithoutIngredientUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutIngredientUserInput
    upsert?: UserUpsertWithoutIngredientUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIngredientUserInput, UserUpdateWithoutIngredientUserInput>, UserUncheckedUpdateWithoutIngredientUserInput>
  }

  export type SpecificIngredientUpdateOneRequiredWithoutIngredientUserNestedInput = {
    create?: XOR<SpecificIngredientCreateWithoutIngredientUserInput, SpecificIngredientUncheckedCreateWithoutIngredientUserInput>
    connectOrCreate?: SpecificIngredientCreateOrConnectWithoutIngredientUserInput
    upsert?: SpecificIngredientUpsertWithoutIngredientUserInput
    connect?: SpecificIngredientWhereUniqueInput
    update?: XOR<XOR<SpecificIngredientUpdateToOneWithWhereWithoutIngredientUserInput, SpecificIngredientUpdateWithoutIngredientUserInput>, SpecificIngredientUncheckedUpdateWithoutIngredientUserInput>
  }

  export type GenericIngredientCreateNestedOneWithoutIngredientPreferenceInput = {
    create?: XOR<GenericIngredientCreateWithoutIngredientPreferenceInput, GenericIngredientUncheckedCreateWithoutIngredientPreferenceInput>
    connectOrCreate?: GenericIngredientCreateOrConnectWithoutIngredientPreferenceInput
    connect?: GenericIngredientWhereUniqueInput
  }

  export type SpecificIngredientCreateNestedOneWithoutIngredientPreferenceInput = {
    create?: XOR<SpecificIngredientCreateWithoutIngredientPreferenceInput, SpecificIngredientUncheckedCreateWithoutIngredientPreferenceInput>
    connectOrCreate?: SpecificIngredientCreateOrConnectWithoutIngredientPreferenceInput
    connect?: SpecificIngredientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutIngredientPreferenceInput = {
    create?: XOR<UserCreateWithoutIngredientPreferenceInput, UserUncheckedCreateWithoutIngredientPreferenceInput>
    connectOrCreate?: UserCreateOrConnectWithoutIngredientPreferenceInput
    connect?: UserWhereUniqueInput
  }

  export type GenericIngredientUpdateOneRequiredWithoutIngredientPreferenceNestedInput = {
    create?: XOR<GenericIngredientCreateWithoutIngredientPreferenceInput, GenericIngredientUncheckedCreateWithoutIngredientPreferenceInput>
    connectOrCreate?: GenericIngredientCreateOrConnectWithoutIngredientPreferenceInput
    upsert?: GenericIngredientUpsertWithoutIngredientPreferenceInput
    connect?: GenericIngredientWhereUniqueInput
    update?: XOR<XOR<GenericIngredientUpdateToOneWithWhereWithoutIngredientPreferenceInput, GenericIngredientUpdateWithoutIngredientPreferenceInput>, GenericIngredientUncheckedUpdateWithoutIngredientPreferenceInput>
  }

  export type SpecificIngredientUpdateOneRequiredWithoutIngredientPreferenceNestedInput = {
    create?: XOR<SpecificIngredientCreateWithoutIngredientPreferenceInput, SpecificIngredientUncheckedCreateWithoutIngredientPreferenceInput>
    connectOrCreate?: SpecificIngredientCreateOrConnectWithoutIngredientPreferenceInput
    upsert?: SpecificIngredientUpsertWithoutIngredientPreferenceInput
    connect?: SpecificIngredientWhereUniqueInput
    update?: XOR<XOR<SpecificIngredientUpdateToOneWithWhereWithoutIngredientPreferenceInput, SpecificIngredientUpdateWithoutIngredientPreferenceInput>, SpecificIngredientUncheckedUpdateWithoutIngredientPreferenceInput>
  }

  export type UserUpdateOneRequiredWithoutIngredientPreferenceNestedInput = {
    create?: XOR<UserCreateWithoutIngredientPreferenceInput, UserUncheckedCreateWithoutIngredientPreferenceInput>
    connectOrCreate?: UserCreateOrConnectWithoutIngredientPreferenceInput
    upsert?: UserUpsertWithoutIngredientPreferenceInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIngredientPreferenceInput, UserUpdateWithoutIngredientPreferenceInput>, UserUncheckedUpdateWithoutIngredientPreferenceInput>
  }

  export type UserCreateNestedOneWithoutInventoryInput = {
    create?: XOR<UserCreateWithoutInventoryInput, UserUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInventoryEditedByInput = {
    create?: XOR<UserCreateWithoutInventoryEditedByInput, UserUncheckedCreateWithoutInventoryEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryEditedByInput
    connect?: UserWhereUniqueInput
  }

  export type InventoryStorageCreateNestedManyWithoutInventoryInput = {
    create?: XOR<InventoryStorageCreateWithoutInventoryInput, InventoryStorageUncheckedCreateWithoutInventoryInput> | InventoryStorageCreateWithoutInventoryInput[] | InventoryStorageUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryStorageCreateOrConnectWithoutInventoryInput | InventoryStorageCreateOrConnectWithoutInventoryInput[]
    createMany?: InventoryStorageCreateManyInventoryInputEnvelope
    connect?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
  }

  export type InventoryUserCreateNestedManyWithoutInventoryInput = {
    create?: XOR<InventoryUserCreateWithoutInventoryInput, InventoryUserUncheckedCreateWithoutInventoryInput> | InventoryUserCreateWithoutInventoryInput[] | InventoryUserUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryUserCreateOrConnectWithoutInventoryInput | InventoryUserCreateOrConnectWithoutInventoryInput[]
    createMany?: InventoryUserCreateManyInventoryInputEnvelope
    connect?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
  }

  export type InventoryStorageUncheckedCreateNestedManyWithoutInventoryInput = {
    create?: XOR<InventoryStorageCreateWithoutInventoryInput, InventoryStorageUncheckedCreateWithoutInventoryInput> | InventoryStorageCreateWithoutInventoryInput[] | InventoryStorageUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryStorageCreateOrConnectWithoutInventoryInput | InventoryStorageCreateOrConnectWithoutInventoryInput[]
    createMany?: InventoryStorageCreateManyInventoryInputEnvelope
    connect?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
  }

  export type InventoryUserUncheckedCreateNestedManyWithoutInventoryInput = {
    create?: XOR<InventoryUserCreateWithoutInventoryInput, InventoryUserUncheckedCreateWithoutInventoryInput> | InventoryUserCreateWithoutInventoryInput[] | InventoryUserUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryUserCreateOrConnectWithoutInventoryInput | InventoryUserCreateOrConnectWithoutInventoryInput[]
    createMany?: InventoryUserCreateManyInventoryInputEnvelope
    connect?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutInventoryNestedInput = {
    create?: XOR<UserCreateWithoutInventoryInput, UserUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryInput
    upsert?: UserUpsertWithoutInventoryInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInventoryInput, UserUpdateWithoutInventoryInput>, UserUncheckedUpdateWithoutInventoryInput>
  }

  export type UserUpdateOneWithoutInventoryEditedByNestedInput = {
    create?: XOR<UserCreateWithoutInventoryEditedByInput, UserUncheckedCreateWithoutInventoryEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryEditedByInput
    upsert?: UserUpsertWithoutInventoryEditedByInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInventoryEditedByInput, UserUpdateWithoutInventoryEditedByInput>, UserUncheckedUpdateWithoutInventoryEditedByInput>
  }

  export type InventoryStorageUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<InventoryStorageCreateWithoutInventoryInput, InventoryStorageUncheckedCreateWithoutInventoryInput> | InventoryStorageCreateWithoutInventoryInput[] | InventoryStorageUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryStorageCreateOrConnectWithoutInventoryInput | InventoryStorageCreateOrConnectWithoutInventoryInput[]
    upsert?: InventoryStorageUpsertWithWhereUniqueWithoutInventoryInput | InventoryStorageUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: InventoryStorageCreateManyInventoryInputEnvelope
    set?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
    disconnect?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
    delete?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
    connect?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
    update?: InventoryStorageUpdateWithWhereUniqueWithoutInventoryInput | InventoryStorageUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: InventoryStorageUpdateManyWithWhereWithoutInventoryInput | InventoryStorageUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: InventoryStorageScalarWhereInput | InventoryStorageScalarWhereInput[]
  }

  export type InventoryUserUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<InventoryUserCreateWithoutInventoryInput, InventoryUserUncheckedCreateWithoutInventoryInput> | InventoryUserCreateWithoutInventoryInput[] | InventoryUserUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryUserCreateOrConnectWithoutInventoryInput | InventoryUserCreateOrConnectWithoutInventoryInput[]
    upsert?: InventoryUserUpsertWithWhereUniqueWithoutInventoryInput | InventoryUserUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: InventoryUserCreateManyInventoryInputEnvelope
    set?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
    disconnect?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
    delete?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
    connect?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
    update?: InventoryUserUpdateWithWhereUniqueWithoutInventoryInput | InventoryUserUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: InventoryUserUpdateManyWithWhereWithoutInventoryInput | InventoryUserUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: InventoryUserScalarWhereInput | InventoryUserScalarWhereInput[]
  }

  export type InventoryStorageUncheckedUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<InventoryStorageCreateWithoutInventoryInput, InventoryStorageUncheckedCreateWithoutInventoryInput> | InventoryStorageCreateWithoutInventoryInput[] | InventoryStorageUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryStorageCreateOrConnectWithoutInventoryInput | InventoryStorageCreateOrConnectWithoutInventoryInput[]
    upsert?: InventoryStorageUpsertWithWhereUniqueWithoutInventoryInput | InventoryStorageUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: InventoryStorageCreateManyInventoryInputEnvelope
    set?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
    disconnect?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
    delete?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
    connect?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
    update?: InventoryStorageUpdateWithWhereUniqueWithoutInventoryInput | InventoryStorageUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: InventoryStorageUpdateManyWithWhereWithoutInventoryInput | InventoryStorageUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: InventoryStorageScalarWhereInput | InventoryStorageScalarWhereInput[]
  }

  export type InventoryUserUncheckedUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<InventoryUserCreateWithoutInventoryInput, InventoryUserUncheckedCreateWithoutInventoryInput> | InventoryUserCreateWithoutInventoryInput[] | InventoryUserUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryUserCreateOrConnectWithoutInventoryInput | InventoryUserCreateOrConnectWithoutInventoryInput[]
    upsert?: InventoryUserUpsertWithWhereUniqueWithoutInventoryInput | InventoryUserUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: InventoryUserCreateManyInventoryInputEnvelope
    set?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
    disconnect?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
    delete?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
    connect?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
    update?: InventoryUserUpdateWithWhereUniqueWithoutInventoryInput | InventoryUserUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: InventoryUserUpdateManyWithWhereWithoutInventoryInput | InventoryUserUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: InventoryUserScalarWhereInput | InventoryUserScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutInventoryUserInput = {
    create?: XOR<UserCreateWithoutInventoryUserInput, UserUncheckedCreateWithoutInventoryUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryUserInput
    connect?: UserWhereUniqueInput
  }

  export type InventoryCreateNestedOneWithoutInventoryUserInput = {
    create?: XOR<InventoryCreateWithoutInventoryUserInput, InventoryUncheckedCreateWithoutInventoryUserInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutInventoryUserInput
    connect?: InventoryWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutInventoryUserNestedInput = {
    create?: XOR<UserCreateWithoutInventoryUserInput, UserUncheckedCreateWithoutInventoryUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryUserInput
    upsert?: UserUpsertWithoutInventoryUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInventoryUserInput, UserUpdateWithoutInventoryUserInput>, UserUncheckedUpdateWithoutInventoryUserInput>
  }

  export type InventoryUpdateOneRequiredWithoutInventoryUserNestedInput = {
    create?: XOR<InventoryCreateWithoutInventoryUserInput, InventoryUncheckedCreateWithoutInventoryUserInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutInventoryUserInput
    upsert?: InventoryUpsertWithoutInventoryUserInput
    connect?: InventoryWhereUniqueInput
    update?: XOR<XOR<InventoryUpdateToOneWithWhereWithoutInventoryUserInput, InventoryUpdateWithoutInventoryUserInput>, InventoryUncheckedUpdateWithoutInventoryUserInput>
  }

  export type UserCreateNestedOneWithoutStorageInput = {
    create?: XOR<UserCreateWithoutStorageInput, UserUncheckedCreateWithoutStorageInput>
    connectOrCreate?: UserCreateOrConnectWithoutStorageInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStorageEditedByInput = {
    create?: XOR<UserCreateWithoutStorageEditedByInput, UserUncheckedCreateWithoutStorageEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutStorageEditedByInput
    connect?: UserWhereUniqueInput
  }

  export type InventoryStorageCreateNestedManyWithoutStorageInput = {
    create?: XOR<InventoryStorageCreateWithoutStorageInput, InventoryStorageUncheckedCreateWithoutStorageInput> | InventoryStorageCreateWithoutStorageInput[] | InventoryStorageUncheckedCreateWithoutStorageInput[]
    connectOrCreate?: InventoryStorageCreateOrConnectWithoutStorageInput | InventoryStorageCreateOrConnectWithoutStorageInput[]
    createMany?: InventoryStorageCreateManyStorageInputEnvelope
    connect?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
  }

  export type IngredientStorageCreateNestedManyWithoutStorageInput = {
    create?: XOR<IngredientStorageCreateWithoutStorageInput, IngredientStorageUncheckedCreateWithoutStorageInput> | IngredientStorageCreateWithoutStorageInput[] | IngredientStorageUncheckedCreateWithoutStorageInput[]
    connectOrCreate?: IngredientStorageCreateOrConnectWithoutStorageInput | IngredientStorageCreateOrConnectWithoutStorageInput[]
    createMany?: IngredientStorageCreateManyStorageInputEnvelope
    connect?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
  }

  export type StorageUserCreateNestedManyWithoutStorageInput = {
    create?: XOR<StorageUserCreateWithoutStorageInput, StorageUserUncheckedCreateWithoutStorageInput> | StorageUserCreateWithoutStorageInput[] | StorageUserUncheckedCreateWithoutStorageInput[]
    connectOrCreate?: StorageUserCreateOrConnectWithoutStorageInput | StorageUserCreateOrConnectWithoutStorageInput[]
    createMany?: StorageUserCreateManyStorageInputEnvelope
    connect?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
  }

  export type InventoryStorageUncheckedCreateNestedManyWithoutStorageInput = {
    create?: XOR<InventoryStorageCreateWithoutStorageInput, InventoryStorageUncheckedCreateWithoutStorageInput> | InventoryStorageCreateWithoutStorageInput[] | InventoryStorageUncheckedCreateWithoutStorageInput[]
    connectOrCreate?: InventoryStorageCreateOrConnectWithoutStorageInput | InventoryStorageCreateOrConnectWithoutStorageInput[]
    createMany?: InventoryStorageCreateManyStorageInputEnvelope
    connect?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
  }

  export type IngredientStorageUncheckedCreateNestedManyWithoutStorageInput = {
    create?: XOR<IngredientStorageCreateWithoutStorageInput, IngredientStorageUncheckedCreateWithoutStorageInput> | IngredientStorageCreateWithoutStorageInput[] | IngredientStorageUncheckedCreateWithoutStorageInput[]
    connectOrCreate?: IngredientStorageCreateOrConnectWithoutStorageInput | IngredientStorageCreateOrConnectWithoutStorageInput[]
    createMany?: IngredientStorageCreateManyStorageInputEnvelope
    connect?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
  }

  export type StorageUserUncheckedCreateNestedManyWithoutStorageInput = {
    create?: XOR<StorageUserCreateWithoutStorageInput, StorageUserUncheckedCreateWithoutStorageInput> | StorageUserCreateWithoutStorageInput[] | StorageUserUncheckedCreateWithoutStorageInput[]
    connectOrCreate?: StorageUserCreateOrConnectWithoutStorageInput | StorageUserCreateOrConnectWithoutStorageInput[]
    createMany?: StorageUserCreateManyStorageInputEnvelope
    connect?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutStorageNestedInput = {
    create?: XOR<UserCreateWithoutStorageInput, UserUncheckedCreateWithoutStorageInput>
    connectOrCreate?: UserCreateOrConnectWithoutStorageInput
    upsert?: UserUpsertWithoutStorageInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStorageInput, UserUpdateWithoutStorageInput>, UserUncheckedUpdateWithoutStorageInput>
  }

  export type UserUpdateOneWithoutStorageEditedByNestedInput = {
    create?: XOR<UserCreateWithoutStorageEditedByInput, UserUncheckedCreateWithoutStorageEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutStorageEditedByInput
    upsert?: UserUpsertWithoutStorageEditedByInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStorageEditedByInput, UserUpdateWithoutStorageEditedByInput>, UserUncheckedUpdateWithoutStorageEditedByInput>
  }

  export type InventoryStorageUpdateManyWithoutStorageNestedInput = {
    create?: XOR<InventoryStorageCreateWithoutStorageInput, InventoryStorageUncheckedCreateWithoutStorageInput> | InventoryStorageCreateWithoutStorageInput[] | InventoryStorageUncheckedCreateWithoutStorageInput[]
    connectOrCreate?: InventoryStorageCreateOrConnectWithoutStorageInput | InventoryStorageCreateOrConnectWithoutStorageInput[]
    upsert?: InventoryStorageUpsertWithWhereUniqueWithoutStorageInput | InventoryStorageUpsertWithWhereUniqueWithoutStorageInput[]
    createMany?: InventoryStorageCreateManyStorageInputEnvelope
    set?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
    disconnect?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
    delete?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
    connect?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
    update?: InventoryStorageUpdateWithWhereUniqueWithoutStorageInput | InventoryStorageUpdateWithWhereUniqueWithoutStorageInput[]
    updateMany?: InventoryStorageUpdateManyWithWhereWithoutStorageInput | InventoryStorageUpdateManyWithWhereWithoutStorageInput[]
    deleteMany?: InventoryStorageScalarWhereInput | InventoryStorageScalarWhereInput[]
  }

  export type IngredientStorageUpdateManyWithoutStorageNestedInput = {
    create?: XOR<IngredientStorageCreateWithoutStorageInput, IngredientStorageUncheckedCreateWithoutStorageInput> | IngredientStorageCreateWithoutStorageInput[] | IngredientStorageUncheckedCreateWithoutStorageInput[]
    connectOrCreate?: IngredientStorageCreateOrConnectWithoutStorageInput | IngredientStorageCreateOrConnectWithoutStorageInput[]
    upsert?: IngredientStorageUpsertWithWhereUniqueWithoutStorageInput | IngredientStorageUpsertWithWhereUniqueWithoutStorageInput[]
    createMany?: IngredientStorageCreateManyStorageInputEnvelope
    set?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
    disconnect?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
    delete?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
    connect?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
    update?: IngredientStorageUpdateWithWhereUniqueWithoutStorageInput | IngredientStorageUpdateWithWhereUniqueWithoutStorageInput[]
    updateMany?: IngredientStorageUpdateManyWithWhereWithoutStorageInput | IngredientStorageUpdateManyWithWhereWithoutStorageInput[]
    deleteMany?: IngredientStorageScalarWhereInput | IngredientStorageScalarWhereInput[]
  }

  export type StorageUserUpdateManyWithoutStorageNestedInput = {
    create?: XOR<StorageUserCreateWithoutStorageInput, StorageUserUncheckedCreateWithoutStorageInput> | StorageUserCreateWithoutStorageInput[] | StorageUserUncheckedCreateWithoutStorageInput[]
    connectOrCreate?: StorageUserCreateOrConnectWithoutStorageInput | StorageUserCreateOrConnectWithoutStorageInput[]
    upsert?: StorageUserUpsertWithWhereUniqueWithoutStorageInput | StorageUserUpsertWithWhereUniqueWithoutStorageInput[]
    createMany?: StorageUserCreateManyStorageInputEnvelope
    set?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
    disconnect?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
    delete?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
    connect?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
    update?: StorageUserUpdateWithWhereUniqueWithoutStorageInput | StorageUserUpdateWithWhereUniqueWithoutStorageInput[]
    updateMany?: StorageUserUpdateManyWithWhereWithoutStorageInput | StorageUserUpdateManyWithWhereWithoutStorageInput[]
    deleteMany?: StorageUserScalarWhereInput | StorageUserScalarWhereInput[]
  }

  export type InventoryStorageUncheckedUpdateManyWithoutStorageNestedInput = {
    create?: XOR<InventoryStorageCreateWithoutStorageInput, InventoryStorageUncheckedCreateWithoutStorageInput> | InventoryStorageCreateWithoutStorageInput[] | InventoryStorageUncheckedCreateWithoutStorageInput[]
    connectOrCreate?: InventoryStorageCreateOrConnectWithoutStorageInput | InventoryStorageCreateOrConnectWithoutStorageInput[]
    upsert?: InventoryStorageUpsertWithWhereUniqueWithoutStorageInput | InventoryStorageUpsertWithWhereUniqueWithoutStorageInput[]
    createMany?: InventoryStorageCreateManyStorageInputEnvelope
    set?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
    disconnect?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
    delete?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
    connect?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
    update?: InventoryStorageUpdateWithWhereUniqueWithoutStorageInput | InventoryStorageUpdateWithWhereUniqueWithoutStorageInput[]
    updateMany?: InventoryStorageUpdateManyWithWhereWithoutStorageInput | InventoryStorageUpdateManyWithWhereWithoutStorageInput[]
    deleteMany?: InventoryStorageScalarWhereInput | InventoryStorageScalarWhereInput[]
  }

  export type IngredientStorageUncheckedUpdateManyWithoutStorageNestedInput = {
    create?: XOR<IngredientStorageCreateWithoutStorageInput, IngredientStorageUncheckedCreateWithoutStorageInput> | IngredientStorageCreateWithoutStorageInput[] | IngredientStorageUncheckedCreateWithoutStorageInput[]
    connectOrCreate?: IngredientStorageCreateOrConnectWithoutStorageInput | IngredientStorageCreateOrConnectWithoutStorageInput[]
    upsert?: IngredientStorageUpsertWithWhereUniqueWithoutStorageInput | IngredientStorageUpsertWithWhereUniqueWithoutStorageInput[]
    createMany?: IngredientStorageCreateManyStorageInputEnvelope
    set?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
    disconnect?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
    delete?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
    connect?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
    update?: IngredientStorageUpdateWithWhereUniqueWithoutStorageInput | IngredientStorageUpdateWithWhereUniqueWithoutStorageInput[]
    updateMany?: IngredientStorageUpdateManyWithWhereWithoutStorageInput | IngredientStorageUpdateManyWithWhereWithoutStorageInput[]
    deleteMany?: IngredientStorageScalarWhereInput | IngredientStorageScalarWhereInput[]
  }

  export type StorageUserUncheckedUpdateManyWithoutStorageNestedInput = {
    create?: XOR<StorageUserCreateWithoutStorageInput, StorageUserUncheckedCreateWithoutStorageInput> | StorageUserCreateWithoutStorageInput[] | StorageUserUncheckedCreateWithoutStorageInput[]
    connectOrCreate?: StorageUserCreateOrConnectWithoutStorageInput | StorageUserCreateOrConnectWithoutStorageInput[]
    upsert?: StorageUserUpsertWithWhereUniqueWithoutStorageInput | StorageUserUpsertWithWhereUniqueWithoutStorageInput[]
    createMany?: StorageUserCreateManyStorageInputEnvelope
    set?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
    disconnect?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
    delete?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
    connect?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
    update?: StorageUserUpdateWithWhereUniqueWithoutStorageInput | StorageUserUpdateWithWhereUniqueWithoutStorageInput[]
    updateMany?: StorageUserUpdateManyWithWhereWithoutStorageInput | StorageUserUpdateManyWithWhereWithoutStorageInput[]
    deleteMany?: StorageUserScalarWhereInput | StorageUserScalarWhereInput[]
  }

  export type StorageCreateNestedOneWithoutInventoryStorageInput = {
    create?: XOR<StorageCreateWithoutInventoryStorageInput, StorageUncheckedCreateWithoutInventoryStorageInput>
    connectOrCreate?: StorageCreateOrConnectWithoutInventoryStorageInput
    connect?: StorageWhereUniqueInput
  }

  export type InventoryCreateNestedOneWithoutInventoryStorageInput = {
    create?: XOR<InventoryCreateWithoutInventoryStorageInput, InventoryUncheckedCreateWithoutInventoryStorageInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutInventoryStorageInput
    connect?: InventoryWhereUniqueInput
  }

  export type StorageUpdateOneRequiredWithoutInventoryStorageNestedInput = {
    create?: XOR<StorageCreateWithoutInventoryStorageInput, StorageUncheckedCreateWithoutInventoryStorageInput>
    connectOrCreate?: StorageCreateOrConnectWithoutInventoryStorageInput
    upsert?: StorageUpsertWithoutInventoryStorageInput
    connect?: StorageWhereUniqueInput
    update?: XOR<XOR<StorageUpdateToOneWithWhereWithoutInventoryStorageInput, StorageUpdateWithoutInventoryStorageInput>, StorageUncheckedUpdateWithoutInventoryStorageInput>
  }

  export type InventoryUpdateOneRequiredWithoutInventoryStorageNestedInput = {
    create?: XOR<InventoryCreateWithoutInventoryStorageInput, InventoryUncheckedCreateWithoutInventoryStorageInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutInventoryStorageInput
    upsert?: InventoryUpsertWithoutInventoryStorageInput
    connect?: InventoryWhereUniqueInput
    update?: XOR<XOR<InventoryUpdateToOneWithWhereWithoutInventoryStorageInput, InventoryUpdateWithoutInventoryStorageInput>, InventoryUncheckedUpdateWithoutInventoryStorageInput>
  }

  export type SpecificIngredientCreateNestedOneWithoutIngredientStorageInput = {
    create?: XOR<SpecificIngredientCreateWithoutIngredientStorageInput, SpecificIngredientUncheckedCreateWithoutIngredientStorageInput>
    connectOrCreate?: SpecificIngredientCreateOrConnectWithoutIngredientStorageInput
    connect?: SpecificIngredientWhereUniqueInput
  }

  export type StorageCreateNestedOneWithoutIngredientStorageInput = {
    create?: XOR<StorageCreateWithoutIngredientStorageInput, StorageUncheckedCreateWithoutIngredientStorageInput>
    connectOrCreate?: StorageCreateOrConnectWithoutIngredientStorageInput
    connect?: StorageWhereUniqueInput
  }

  export type SpecificIngredientUpdateOneRequiredWithoutIngredientStorageNestedInput = {
    create?: XOR<SpecificIngredientCreateWithoutIngredientStorageInput, SpecificIngredientUncheckedCreateWithoutIngredientStorageInput>
    connectOrCreate?: SpecificIngredientCreateOrConnectWithoutIngredientStorageInput
    upsert?: SpecificIngredientUpsertWithoutIngredientStorageInput
    connect?: SpecificIngredientWhereUniqueInput
    update?: XOR<XOR<SpecificIngredientUpdateToOneWithWhereWithoutIngredientStorageInput, SpecificIngredientUpdateWithoutIngredientStorageInput>, SpecificIngredientUncheckedUpdateWithoutIngredientStorageInput>
  }

  export type StorageUpdateOneRequiredWithoutIngredientStorageNestedInput = {
    create?: XOR<StorageCreateWithoutIngredientStorageInput, StorageUncheckedCreateWithoutIngredientStorageInput>
    connectOrCreate?: StorageCreateOrConnectWithoutIngredientStorageInput
    upsert?: StorageUpsertWithoutIngredientStorageInput
    connect?: StorageWhereUniqueInput
    update?: XOR<XOR<StorageUpdateToOneWithWhereWithoutIngredientStorageInput, StorageUpdateWithoutIngredientStorageInput>, StorageUncheckedUpdateWithoutIngredientStorageInput>
  }

  export type UserCreateNestedOneWithoutStorageUserInput = {
    create?: XOR<UserCreateWithoutStorageUserInput, UserUncheckedCreateWithoutStorageUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutStorageUserInput
    connect?: UserWhereUniqueInput
  }

  export type StorageCreateNestedOneWithoutStorageUserInput = {
    create?: XOR<StorageCreateWithoutStorageUserInput, StorageUncheckedCreateWithoutStorageUserInput>
    connectOrCreate?: StorageCreateOrConnectWithoutStorageUserInput
    connect?: StorageWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutStorageUserNestedInput = {
    create?: XOR<UserCreateWithoutStorageUserInput, UserUncheckedCreateWithoutStorageUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutStorageUserInput
    upsert?: UserUpsertWithoutStorageUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStorageUserInput, UserUpdateWithoutStorageUserInput>, UserUncheckedUpdateWithoutStorageUserInput>
  }

  export type StorageUpdateOneRequiredWithoutStorageUserNestedInput = {
    create?: XOR<StorageCreateWithoutStorageUserInput, StorageUncheckedCreateWithoutStorageUserInput>
    connectOrCreate?: StorageCreateOrConnectWithoutStorageUserInput
    upsert?: StorageUpsertWithoutStorageUserInput
    connect?: StorageWhereUniqueInput
    update?: XOR<XOR<StorageUpdateToOneWithWhereWithoutStorageUserInput, StorageUpdateWithoutStorageUserInput>, StorageUncheckedUpdateWithoutStorageUserInput>
  }

  export type UserCreateNestedOneWithoutCrewInput = {
    create?: XOR<UserCreateWithoutCrewInput, UserUncheckedCreateWithoutCrewInput>
    connectOrCreate?: UserCreateOrConnectWithoutCrewInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCrewEditedByInput = {
    create?: XOR<UserCreateWithoutCrewEditedByInput, UserUncheckedCreateWithoutCrewEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutCrewEditedByInput
    connect?: UserWhereUniqueInput
  }

  export type CrewUserCreateNestedManyWithoutCrewInput = {
    create?: XOR<CrewUserCreateWithoutCrewInput, CrewUserUncheckedCreateWithoutCrewInput> | CrewUserCreateWithoutCrewInput[] | CrewUserUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CrewUserCreateOrConnectWithoutCrewInput | CrewUserCreateOrConnectWithoutCrewInput[]
    createMany?: CrewUserCreateManyCrewInputEnvelope
    connect?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
  }

  export type CrewUserUncheckedCreateNestedManyWithoutCrewInput = {
    create?: XOR<CrewUserCreateWithoutCrewInput, CrewUserUncheckedCreateWithoutCrewInput> | CrewUserCreateWithoutCrewInput[] | CrewUserUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CrewUserCreateOrConnectWithoutCrewInput | CrewUserCreateOrConnectWithoutCrewInput[]
    createMany?: CrewUserCreateManyCrewInputEnvelope
    connect?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutCrewNestedInput = {
    create?: XOR<UserCreateWithoutCrewInput, UserUncheckedCreateWithoutCrewInput>
    connectOrCreate?: UserCreateOrConnectWithoutCrewInput
    upsert?: UserUpsertWithoutCrewInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCrewInput, UserUpdateWithoutCrewInput>, UserUncheckedUpdateWithoutCrewInput>
  }

  export type UserUpdateOneWithoutCrewEditedByNestedInput = {
    create?: XOR<UserCreateWithoutCrewEditedByInput, UserUncheckedCreateWithoutCrewEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutCrewEditedByInput
    upsert?: UserUpsertWithoutCrewEditedByInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCrewEditedByInput, UserUpdateWithoutCrewEditedByInput>, UserUncheckedUpdateWithoutCrewEditedByInput>
  }

  export type CrewUserUpdateManyWithoutCrewNestedInput = {
    create?: XOR<CrewUserCreateWithoutCrewInput, CrewUserUncheckedCreateWithoutCrewInput> | CrewUserCreateWithoutCrewInput[] | CrewUserUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CrewUserCreateOrConnectWithoutCrewInput | CrewUserCreateOrConnectWithoutCrewInput[]
    upsert?: CrewUserUpsertWithWhereUniqueWithoutCrewInput | CrewUserUpsertWithWhereUniqueWithoutCrewInput[]
    createMany?: CrewUserCreateManyCrewInputEnvelope
    set?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
    disconnect?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
    delete?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
    connect?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
    update?: CrewUserUpdateWithWhereUniqueWithoutCrewInput | CrewUserUpdateWithWhereUniqueWithoutCrewInput[]
    updateMany?: CrewUserUpdateManyWithWhereWithoutCrewInput | CrewUserUpdateManyWithWhereWithoutCrewInput[]
    deleteMany?: CrewUserScalarWhereInput | CrewUserScalarWhereInput[]
  }

  export type CrewUserUncheckedUpdateManyWithoutCrewNestedInput = {
    create?: XOR<CrewUserCreateWithoutCrewInput, CrewUserUncheckedCreateWithoutCrewInput> | CrewUserCreateWithoutCrewInput[] | CrewUserUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CrewUserCreateOrConnectWithoutCrewInput | CrewUserCreateOrConnectWithoutCrewInput[]
    upsert?: CrewUserUpsertWithWhereUniqueWithoutCrewInput | CrewUserUpsertWithWhereUniqueWithoutCrewInput[]
    createMany?: CrewUserCreateManyCrewInputEnvelope
    set?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
    disconnect?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
    delete?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
    connect?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
    update?: CrewUserUpdateWithWhereUniqueWithoutCrewInput | CrewUserUpdateWithWhereUniqueWithoutCrewInput[]
    updateMany?: CrewUserUpdateManyWithWhereWithoutCrewInput | CrewUserUpdateManyWithWhereWithoutCrewInput[]
    deleteMany?: CrewUserScalarWhereInput | CrewUserScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCrewUserInput = {
    create?: XOR<UserCreateWithoutCrewUserInput, UserUncheckedCreateWithoutCrewUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutCrewUserInput
    connect?: UserWhereUniqueInput
  }

  export type CrewCreateNestedOneWithoutUserCrewInput = {
    create?: XOR<CrewCreateWithoutUserCrewInput, CrewUncheckedCreateWithoutUserCrewInput>
    connectOrCreate?: CrewCreateOrConnectWithoutUserCrewInput
    connect?: CrewWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCrewUserNestedInput = {
    create?: XOR<UserCreateWithoutCrewUserInput, UserUncheckedCreateWithoutCrewUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutCrewUserInput
    upsert?: UserUpsertWithoutCrewUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCrewUserInput, UserUpdateWithoutCrewUserInput>, UserUncheckedUpdateWithoutCrewUserInput>
  }

  export type CrewUpdateOneRequiredWithoutUserCrewNestedInput = {
    create?: XOR<CrewCreateWithoutUserCrewInput, CrewUncheckedCreateWithoutUserCrewInput>
    connectOrCreate?: CrewCreateOrConnectWithoutUserCrewInput
    upsert?: CrewUpsertWithoutUserCrewInput
    connect?: CrewWhereUniqueInput
    update?: XOR<XOR<CrewUpdateToOneWithWhereWithoutUserCrewInput, CrewUpdateWithoutUserCrewInput>, CrewUncheckedUpdateWithoutUserCrewInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ProfileCreateWithoutUserInput = {
    id?: string
    photo: string
  }

  export type ProfileUncheckedCreateWithoutUserInput = {
    id?: string
    photo: string
  }

  export type ProfileCreateOrConnectWithoutUserInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type RecipeBookUserCreateWithoutUserInput = {
    permission: string
    recipeBook: RecipeBookCreateNestedOneWithoutRecipeBookUserInput
  }

  export type RecipeBookUserUncheckedCreateWithoutUserInput = {
    recipeBookId: string
    permission: string
  }

  export type RecipeBookUserCreateOrConnectWithoutUserInput = {
    where: RecipeBookUserWhereUniqueInput
    create: XOR<RecipeBookUserCreateWithoutUserInput, RecipeBookUserUncheckedCreateWithoutUserInput>
  }

  export type RecipeBookUserCreateManyUserInputEnvelope = {
    data: RecipeBookUserCreateManyUserInput | RecipeBookUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RecipeBookCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    editedBy?: UserCreateNestedOneWithoutRecipeBookEditedByInput
    recipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutRecipeBookInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    editedById?: string | null
    recipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutRecipeBookInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookCreateOrConnectWithoutCreatedByInput = {
    where: RecipeBookWhereUniqueInput
    create: XOR<RecipeBookCreateWithoutCreatedByInput, RecipeBookUncheckedCreateWithoutCreatedByInput>
  }

  export type RecipeBookCreateManyCreatedByInputEnvelope = {
    data: RecipeBookCreateManyCreatedByInput | RecipeBookCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type RecipeBookCreateWithoutEditedByInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutRecipeBookInput
    recipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutRecipeBookInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookUncheckedCreateWithoutEditedByInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    recipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutRecipeBookInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookCreateOrConnectWithoutEditedByInput = {
    where: RecipeBookWhereUniqueInput
    create: XOR<RecipeBookCreateWithoutEditedByInput, RecipeBookUncheckedCreateWithoutEditedByInput>
  }

  export type RecipeBookCreateManyEditedByInputEnvelope = {
    data: RecipeBookCreateManyEditedByInput | RecipeBookCreateManyEditedByInput[]
    skipDuplicates?: boolean
  }

  export type RecipeCreateWithoutCreatedByInput = {
    id?: string
    createdAt?: Date | string
    editedAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    editedBy?: UserCreateNestedOneWithoutRecipeEditedByInput
    build?: BuildCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutCreatedByInput = {
    id?: string
    createdAt?: Date | string
    editedAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    editedById?: string | null
    build?: BuildUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutCreatedByInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutCreatedByInput, RecipeUncheckedCreateWithoutCreatedByInput>
  }

  export type RecipeCreateManyCreatedByInputEnvelope = {
    data: RecipeCreateManyCreatedByInput | RecipeCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type RecipeCreateWithoutEditedByInput = {
    id?: string
    createdAt?: Date | string
    editedAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    createdBy?: UserCreateNestedOneWithoutRecipeInput
    build?: BuildCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutEditedByInput = {
    id?: string
    createdAt?: Date | string
    editedAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    createdById?: string | null
    build?: BuildUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutEditedByInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutEditedByInput, RecipeUncheckedCreateWithoutEditedByInput>
  }

  export type RecipeCreateManyEditedByInputEnvelope = {
    data: RecipeCreateManyEditedByInput | RecipeCreateManyEditedByInput[]
    skipDuplicates?: boolean
  }

  export type BuildUserCreateWithoutUserInput = {
    permission: string
    build?: BuildCreateNestedOneWithoutBuildUserInput
  }

  export type BuildUserUncheckedCreateWithoutUserInput = {
    buildId: string
    permission: string
  }

  export type BuildUserCreateOrConnectWithoutUserInput = {
    where: BuildUserWhereUniqueInput
    create: XOR<BuildUserCreateWithoutUserInput, BuildUserUncheckedCreateWithoutUserInput>
  }

  export type BuildUserCreateManyUserInputEnvelope = {
    data: BuildUserCreateManyUserInput | BuildUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BuildCreateWithoutCreatedByInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    editedBy?: UserCreateNestedOneWithoutBuildEditedByInput
    recipe?: RecipeCreateNestedOneWithoutBuildInput
    touch?: TouchCreateNestedManyWithoutBuildInput
    archivedTouch?: ArchivedTouchCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserCreateNestedManyWithoutBuildInput
  }

  export type BuildUncheckedCreateWithoutCreatedByInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedById?: string | null
    recipeId?: string | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutBuildInput
    archivedTouch?: ArchivedTouchUncheckedCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutBuildInput
  }

  export type BuildCreateOrConnectWithoutCreatedByInput = {
    where: BuildWhereUniqueInput
    create: XOR<BuildCreateWithoutCreatedByInput, BuildUncheckedCreateWithoutCreatedByInput>
  }

  export type BuildCreateManyCreatedByInputEnvelope = {
    data: BuildCreateManyCreatedByInput | BuildCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type BuildCreateWithoutEditedByInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    createdBy?: UserCreateNestedOneWithoutBuildInput
    recipe?: RecipeCreateNestedOneWithoutBuildInput
    touch?: TouchCreateNestedManyWithoutBuildInput
    archivedTouch?: ArchivedTouchCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserCreateNestedManyWithoutBuildInput
  }

  export type BuildUncheckedCreateWithoutEditedByInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    recipeId?: string | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutBuildInput
    archivedTouch?: ArchivedTouchUncheckedCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutBuildInput
  }

  export type BuildCreateOrConnectWithoutEditedByInput = {
    where: BuildWhereUniqueInput
    create: XOR<BuildCreateWithoutEditedByInput, BuildUncheckedCreateWithoutEditedByInput>
  }

  export type BuildCreateManyEditedByInputEnvelope = {
    data: BuildCreateManyEditedByInput | BuildCreateManyEditedByInput[]
    skipDuplicates?: boolean
  }

  export type CrewUserCreateWithoutUserInput = {
    permission: string
    crew: CrewCreateNestedOneWithoutUserCrewInput
  }

  export type CrewUserUncheckedCreateWithoutUserInput = {
    crewId: string
    permission: string
  }

  export type CrewUserCreateOrConnectWithoutUserInput = {
    where: CrewUserWhereUniqueInput
    create: XOR<CrewUserCreateWithoutUserInput, CrewUserUncheckedCreateWithoutUserInput>
  }

  export type CrewUserCreateManyUserInputEnvelope = {
    data: CrewUserCreateManyUserInput | CrewUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CrewCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedBy?: UserCreateNestedOneWithoutCrewEditedByInput
    userCrew?: CrewUserCreateNestedManyWithoutCrewInput
  }

  export type CrewUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedById: string
    userCrew?: CrewUserUncheckedCreateNestedManyWithoutCrewInput
  }

  export type CrewCreateOrConnectWithoutCreatedByInput = {
    where: CrewWhereUniqueInput
    create: XOR<CrewCreateWithoutCreatedByInput, CrewUncheckedCreateWithoutCreatedByInput>
  }

  export type CrewCreateManyCreatedByInputEnvelope = {
    data: CrewCreateManyCreatedByInput | CrewCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type CrewCreateWithoutEditedByInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCrewInput
    userCrew?: CrewUserCreateNestedManyWithoutCrewInput
  }

  export type CrewUncheckedCreateWithoutEditedByInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    userCrew?: CrewUserUncheckedCreateNestedManyWithoutCrewInput
  }

  export type CrewCreateOrConnectWithoutEditedByInput = {
    where: CrewWhereUniqueInput
    create: XOR<CrewCreateWithoutEditedByInput, CrewUncheckedCreateWithoutEditedByInput>
  }

  export type CrewCreateManyEditedByInputEnvelope = {
    data: CrewCreateManyEditedByInput | CrewCreateManyEditedByInput[]
    skipDuplicates?: boolean
  }

  export type SpecificIngredientCreateWithoutCreatedByInput = {
    id?: string
    dateCreated?: Date | string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    genericIngredient: GenericIngredientCreateNestedOneWithoutSpecificIngredientInput
    touch?: TouchCreateNestedManyWithoutSpecificIngredientInput
    archivedTouch?: ArchivedTouchCreateNestedManyWithoutSpecificIngredientInput
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutIngredientInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutSpecificIngredientInput
  }

  export type SpecificIngredientUncheckedCreateWithoutCreatedByInput = {
    id?: string
    dateCreated?: Date | string
    genericIngredientId: string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutSpecificIngredientInput
    archivedTouch?: ArchivedTouchUncheckedCreateNestedManyWithoutSpecificIngredientInput
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutIngredientInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutSpecificIngredientInput
  }

  export type SpecificIngredientCreateOrConnectWithoutCreatedByInput = {
    where: SpecificIngredientWhereUniqueInput
    create: XOR<SpecificIngredientCreateWithoutCreatedByInput, SpecificIngredientUncheckedCreateWithoutCreatedByInput>
  }

  export type SpecificIngredientCreateManyCreatedByInputEnvelope = {
    data: SpecificIngredientCreateManyCreatedByInput | SpecificIngredientCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type IngredientPreferenceCreateWithoutUserInput = {
    genericIngredient: GenericIngredientCreateNestedOneWithoutIngredientPreferenceInput
    specificIngredient: SpecificIngredientCreateNestedOneWithoutIngredientPreferenceInput
  }

  export type IngredientPreferenceUncheckedCreateWithoutUserInput = {
    genericIngredientId: string
    specificIngredientId: string
  }

  export type IngredientPreferenceCreateOrConnectWithoutUserInput = {
    where: IngredientPreferenceWhereUniqueInput
    create: XOR<IngredientPreferenceCreateWithoutUserInput, IngredientPreferenceUncheckedCreateWithoutUserInput>
  }

  export type IngredientPreferenceCreateManyUserInputEnvelope = {
    data: IngredientPreferenceCreateManyUserInput | IngredientPreferenceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type IngredientUserCreateWithoutUserInput = {
    permission: string
    ingredient: SpecificIngredientCreateNestedOneWithoutIngredientUserInput
  }

  export type IngredientUserUncheckedCreateWithoutUserInput = {
    ingredientId: string
    permission: string
  }

  export type IngredientUserCreateOrConnectWithoutUserInput = {
    where: IngredientUserWhereUniqueInput
    create: XOR<IngredientUserCreateWithoutUserInput, IngredientUserUncheckedCreateWithoutUserInput>
  }

  export type IngredientUserCreateManyUserInputEnvelope = {
    data: IngredientUserCreateManyUserInput | IngredientUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StorageUserCreateWithoutUserInput = {
    permission: string
    Storage: StorageCreateNestedOneWithoutStorageUserInput
  }

  export type StorageUserUncheckedCreateWithoutUserInput = {
    storageId: string
    permission: string
  }

  export type StorageUserCreateOrConnectWithoutUserInput = {
    where: StorageUserWhereUniqueInput
    create: XOR<StorageUserCreateWithoutUserInput, StorageUserUncheckedCreateWithoutUserInput>
  }

  export type StorageUserCreateManyUserInputEnvelope = {
    data: StorageUserCreateManyUserInput | StorageUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StorageCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedBy?: UserCreateNestedOneWithoutStorageEditedByInput
    inventoryStorage?: InventoryStorageCreateNestedManyWithoutStorageInput
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutStorageInput
    storageUser?: StorageUserCreateNestedManyWithoutStorageInput
  }

  export type StorageUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedById: string
    inventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutStorageInput
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutStorageInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutStorageInput
  }

  export type StorageCreateOrConnectWithoutCreatedByInput = {
    where: StorageWhereUniqueInput
    create: XOR<StorageCreateWithoutCreatedByInput, StorageUncheckedCreateWithoutCreatedByInput>
  }

  export type StorageCreateManyCreatedByInputEnvelope = {
    data: StorageCreateManyCreatedByInput | StorageCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type StorageCreateWithoutEditedByInput = {
    id?: string
    name: string
    description?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutStorageInput
    inventoryStorage?: InventoryStorageCreateNestedManyWithoutStorageInput
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutStorageInput
    storageUser?: StorageUserCreateNestedManyWithoutStorageInput
  }

  export type StorageUncheckedCreateWithoutEditedByInput = {
    id?: string
    name: string
    description?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    inventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutStorageInput
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutStorageInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutStorageInput
  }

  export type StorageCreateOrConnectWithoutEditedByInput = {
    where: StorageWhereUniqueInput
    create: XOR<StorageCreateWithoutEditedByInput, StorageUncheckedCreateWithoutEditedByInput>
  }

  export type StorageCreateManyEditedByInputEnvelope = {
    data: StorageCreateManyEditedByInput | StorageCreateManyEditedByInput[]
    skipDuplicates?: boolean
  }

  export type InventoryCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedBy?: UserCreateNestedOneWithoutInventoryEditedByInput
    inventoryStorage?: InventoryStorageCreateNestedManyWithoutInventoryInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedById: string
    inventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutInventoryInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryCreateOrConnectWithoutCreatedByInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutCreatedByInput, InventoryUncheckedCreateWithoutCreatedByInput>
  }

  export type InventoryCreateManyCreatedByInputEnvelope = {
    data: InventoryCreateManyCreatedByInput | InventoryCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type InventoryCreateWithoutEditedByInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutInventoryInput
    inventoryStorage?: InventoryStorageCreateNestedManyWithoutInventoryInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutEditedByInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    inventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutInventoryInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryCreateOrConnectWithoutEditedByInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutEditedByInput, InventoryUncheckedCreateWithoutEditedByInput>
  }

  export type InventoryCreateManyEditedByInputEnvelope = {
    data: InventoryCreateManyEditedByInput | InventoryCreateManyEditedByInput[]
    skipDuplicates?: boolean
  }

  export type InventoryUserCreateWithoutUserInput = {
    permission: string
    inventory: InventoryCreateNestedOneWithoutInventoryUserInput
  }

  export type InventoryUserUncheckedCreateWithoutUserInput = {
    inventoryId: string
    permission: string
  }

  export type InventoryUserCreateOrConnectWithoutUserInput = {
    where: InventoryUserWhereUniqueInput
    create: XOR<InventoryUserCreateWithoutUserInput, InventoryUserUncheckedCreateWithoutUserInput>
  }

  export type InventoryUserCreateManyUserInputEnvelope = {
    data: InventoryUserCreateManyUserInput | InventoryUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FollowCreateWithoutFollowedByInput = {
    relationship: string
    following: UserCreateNestedOneWithoutFollowingInput
  }

  export type FollowUncheckedCreateWithoutFollowedByInput = {
    followingId: string
    relationship: string
  }

  export type FollowCreateOrConnectWithoutFollowedByInput = {
    where: FollowWhereUniqueInput
    create: XOR<FollowCreateWithoutFollowedByInput, FollowUncheckedCreateWithoutFollowedByInput>
  }

  export type FollowCreateManyFollowedByInputEnvelope = {
    data: FollowCreateManyFollowedByInput | FollowCreateManyFollowedByInput[]
    skipDuplicates?: boolean
  }

  export type FollowCreateWithoutFollowingInput = {
    relationship: string
    followedBy: UserCreateNestedOneWithoutFollowedByInput
  }

  export type FollowUncheckedCreateWithoutFollowingInput = {
    followedById: string
    relationship: string
  }

  export type FollowCreateOrConnectWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    create: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput>
  }

  export type FollowCreateManyFollowingInputEnvelope = {
    data: FollowCreateManyFollowingInput | FollowCreateManyFollowingInput[]
    skipDuplicates?: boolean
  }

  export type ProfileUpsertWithoutUserInput = {
    update: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type ProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookUserUpsertWithWhereUniqueWithoutUserInput = {
    where: RecipeBookUserWhereUniqueInput
    update: XOR<RecipeBookUserUpdateWithoutUserInput, RecipeBookUserUncheckedUpdateWithoutUserInput>
    create: XOR<RecipeBookUserCreateWithoutUserInput, RecipeBookUserUncheckedCreateWithoutUserInput>
  }

  export type RecipeBookUserUpdateWithWhereUniqueWithoutUserInput = {
    where: RecipeBookUserWhereUniqueInput
    data: XOR<RecipeBookUserUpdateWithoutUserInput, RecipeBookUserUncheckedUpdateWithoutUserInput>
  }

  export type RecipeBookUserUpdateManyWithWhereWithoutUserInput = {
    where: RecipeBookUserScalarWhereInput
    data: XOR<RecipeBookUserUpdateManyMutationInput, RecipeBookUserUncheckedUpdateManyWithoutUserInput>
  }

  export type RecipeBookUserScalarWhereInput = {
    AND?: RecipeBookUserScalarWhereInput | RecipeBookUserScalarWhereInput[]
    OR?: RecipeBookUserScalarWhereInput[]
    NOT?: RecipeBookUserScalarWhereInput | RecipeBookUserScalarWhereInput[]
    userId?: StringFilter<"RecipeBookUser"> | string
    recipeBookId?: StringFilter<"RecipeBookUser"> | string
    permission?: StringFilter<"RecipeBookUser"> | string
  }

  export type RecipeBookUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: RecipeBookWhereUniqueInput
    update: XOR<RecipeBookUpdateWithoutCreatedByInput, RecipeBookUncheckedUpdateWithoutCreatedByInput>
    create: XOR<RecipeBookCreateWithoutCreatedByInput, RecipeBookUncheckedCreateWithoutCreatedByInput>
  }

  export type RecipeBookUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: RecipeBookWhereUniqueInput
    data: XOR<RecipeBookUpdateWithoutCreatedByInput, RecipeBookUncheckedUpdateWithoutCreatedByInput>
  }

  export type RecipeBookUpdateManyWithWhereWithoutCreatedByInput = {
    where: RecipeBookScalarWhereInput
    data: XOR<RecipeBookUpdateManyMutationInput, RecipeBookUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type RecipeBookScalarWhereInput = {
    AND?: RecipeBookScalarWhereInput | RecipeBookScalarWhereInput[]
    OR?: RecipeBookScalarWhereInput[]
    NOT?: RecipeBookScalarWhereInput | RecipeBookScalarWhereInput[]
    id?: StringFilter<"RecipeBook"> | string
    name?: StringFilter<"RecipeBook"> | string
    description?: StringNullableFilter<"RecipeBook"> | string | null
    createdAt?: DateTimeFilter<"RecipeBook"> | Date | string
    editedAt?: DateTimeFilter<"RecipeBook"> | Date | string
    createdById?: StringNullableFilter<"RecipeBook"> | string | null
    editedById?: StringNullableFilter<"RecipeBook"> | string | null
  }

  export type RecipeBookUpsertWithWhereUniqueWithoutEditedByInput = {
    where: RecipeBookWhereUniqueInput
    update: XOR<RecipeBookUpdateWithoutEditedByInput, RecipeBookUncheckedUpdateWithoutEditedByInput>
    create: XOR<RecipeBookCreateWithoutEditedByInput, RecipeBookUncheckedCreateWithoutEditedByInput>
  }

  export type RecipeBookUpdateWithWhereUniqueWithoutEditedByInput = {
    where: RecipeBookWhereUniqueInput
    data: XOR<RecipeBookUpdateWithoutEditedByInput, RecipeBookUncheckedUpdateWithoutEditedByInput>
  }

  export type RecipeBookUpdateManyWithWhereWithoutEditedByInput = {
    where: RecipeBookScalarWhereInput
    data: XOR<RecipeBookUpdateManyMutationInput, RecipeBookUncheckedUpdateManyWithoutEditedByInput>
  }

  export type RecipeUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: RecipeWhereUniqueInput
    update: XOR<RecipeUpdateWithoutCreatedByInput, RecipeUncheckedUpdateWithoutCreatedByInput>
    create: XOR<RecipeCreateWithoutCreatedByInput, RecipeUncheckedCreateWithoutCreatedByInput>
  }

  export type RecipeUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: RecipeWhereUniqueInput
    data: XOR<RecipeUpdateWithoutCreatedByInput, RecipeUncheckedUpdateWithoutCreatedByInput>
  }

  export type RecipeUpdateManyWithWhereWithoutCreatedByInput = {
    where: RecipeScalarWhereInput
    data: XOR<RecipeUpdateManyMutationInput, RecipeUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type RecipeScalarWhereInput = {
    AND?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
    OR?: RecipeScalarWhereInput[]
    NOT?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
    id?: StringFilter<"Recipe"> | string
    createdAt?: DateTimeFilter<"Recipe"> | Date | string
    editedAt?: DateTimeFilter<"Recipe"> | Date | string
    name?: StringFilter<"Recipe"> | string
    origin?: StringNullableFilter<"Recipe"> | string | null
    history?: StringNullableFilter<"Recipe"> | string | null
    createdById?: StringNullableFilter<"Recipe"> | string | null
    editedById?: StringNullableFilter<"Recipe"> | string | null
  }

  export type RecipeUpsertWithWhereUniqueWithoutEditedByInput = {
    where: RecipeWhereUniqueInput
    update: XOR<RecipeUpdateWithoutEditedByInput, RecipeUncheckedUpdateWithoutEditedByInput>
    create: XOR<RecipeCreateWithoutEditedByInput, RecipeUncheckedCreateWithoutEditedByInput>
  }

  export type RecipeUpdateWithWhereUniqueWithoutEditedByInput = {
    where: RecipeWhereUniqueInput
    data: XOR<RecipeUpdateWithoutEditedByInput, RecipeUncheckedUpdateWithoutEditedByInput>
  }

  export type RecipeUpdateManyWithWhereWithoutEditedByInput = {
    where: RecipeScalarWhereInput
    data: XOR<RecipeUpdateManyMutationInput, RecipeUncheckedUpdateManyWithoutEditedByInput>
  }

  export type BuildUserUpsertWithWhereUniqueWithoutUserInput = {
    where: BuildUserWhereUniqueInput
    update: XOR<BuildUserUpdateWithoutUserInput, BuildUserUncheckedUpdateWithoutUserInput>
    create: XOR<BuildUserCreateWithoutUserInput, BuildUserUncheckedCreateWithoutUserInput>
  }

  export type BuildUserUpdateWithWhereUniqueWithoutUserInput = {
    where: BuildUserWhereUniqueInput
    data: XOR<BuildUserUpdateWithoutUserInput, BuildUserUncheckedUpdateWithoutUserInput>
  }

  export type BuildUserUpdateManyWithWhereWithoutUserInput = {
    where: BuildUserScalarWhereInput
    data: XOR<BuildUserUpdateManyMutationInput, BuildUserUncheckedUpdateManyWithoutUserInput>
  }

  export type BuildUserScalarWhereInput = {
    AND?: BuildUserScalarWhereInput | BuildUserScalarWhereInput[]
    OR?: BuildUserScalarWhereInput[]
    NOT?: BuildUserScalarWhereInput | BuildUserScalarWhereInput[]
    userId?: StringFilter<"BuildUser"> | string
    buildId?: StringFilter<"BuildUser"> | string
    permission?: StringFilter<"BuildUser"> | string
  }

  export type BuildUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: BuildWhereUniqueInput
    update: XOR<BuildUpdateWithoutCreatedByInput, BuildUncheckedUpdateWithoutCreatedByInput>
    create: XOR<BuildCreateWithoutCreatedByInput, BuildUncheckedCreateWithoutCreatedByInput>
  }

  export type BuildUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: BuildWhereUniqueInput
    data: XOR<BuildUpdateWithoutCreatedByInput, BuildUncheckedUpdateWithoutCreatedByInput>
  }

  export type BuildUpdateManyWithWhereWithoutCreatedByInput = {
    where: BuildScalarWhereInput
    data: XOR<BuildUpdateManyMutationInput, BuildUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type BuildScalarWhereInput = {
    AND?: BuildScalarWhereInput | BuildScalarWhereInput[]
    OR?: BuildScalarWhereInput[]
    NOT?: BuildScalarWhereInput | BuildScalarWhereInput[]
    id?: StringFilter<"Build"> | string
    buildName?: StringFilter<"Build"> | string
    createdAt?: DateTimeFilter<"Build"> | Date | string
    editedAt?: DateTimeFilter<"Build"> | Date | string
    createdById?: StringNullableFilter<"Build"> | string | null
    editedById?: StringNullableFilter<"Build"> | string | null
    recipeId?: StringNullableFilter<"Build"> | string | null
    instructions?: StringNullableFilter<"Build"> | string | null
    notes?: StringNullableFilter<"Build"> | string | null
    glassware?: StringNullableFilter<"Build"> | string | null
    ice?: StringNullableFilter<"Build"> | string | null
  }

  export type BuildUpsertWithWhereUniqueWithoutEditedByInput = {
    where: BuildWhereUniqueInput
    update: XOR<BuildUpdateWithoutEditedByInput, BuildUncheckedUpdateWithoutEditedByInput>
    create: XOR<BuildCreateWithoutEditedByInput, BuildUncheckedCreateWithoutEditedByInput>
  }

  export type BuildUpdateWithWhereUniqueWithoutEditedByInput = {
    where: BuildWhereUniqueInput
    data: XOR<BuildUpdateWithoutEditedByInput, BuildUncheckedUpdateWithoutEditedByInput>
  }

  export type BuildUpdateManyWithWhereWithoutEditedByInput = {
    where: BuildScalarWhereInput
    data: XOR<BuildUpdateManyMutationInput, BuildUncheckedUpdateManyWithoutEditedByInput>
  }

  export type CrewUserUpsertWithWhereUniqueWithoutUserInput = {
    where: CrewUserWhereUniqueInput
    update: XOR<CrewUserUpdateWithoutUserInput, CrewUserUncheckedUpdateWithoutUserInput>
    create: XOR<CrewUserCreateWithoutUserInput, CrewUserUncheckedCreateWithoutUserInput>
  }

  export type CrewUserUpdateWithWhereUniqueWithoutUserInput = {
    where: CrewUserWhereUniqueInput
    data: XOR<CrewUserUpdateWithoutUserInput, CrewUserUncheckedUpdateWithoutUserInput>
  }

  export type CrewUserUpdateManyWithWhereWithoutUserInput = {
    where: CrewUserScalarWhereInput
    data: XOR<CrewUserUpdateManyMutationInput, CrewUserUncheckedUpdateManyWithoutUserInput>
  }

  export type CrewUserScalarWhereInput = {
    AND?: CrewUserScalarWhereInput | CrewUserScalarWhereInput[]
    OR?: CrewUserScalarWhereInput[]
    NOT?: CrewUserScalarWhereInput | CrewUserScalarWhereInput[]
    userId?: StringFilter<"CrewUser"> | string
    crewId?: StringFilter<"CrewUser"> | string
    permission?: StringFilter<"CrewUser"> | string
  }

  export type CrewUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: CrewWhereUniqueInput
    update: XOR<CrewUpdateWithoutCreatedByInput, CrewUncheckedUpdateWithoutCreatedByInput>
    create: XOR<CrewCreateWithoutCreatedByInput, CrewUncheckedCreateWithoutCreatedByInput>
  }

  export type CrewUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: CrewWhereUniqueInput
    data: XOR<CrewUpdateWithoutCreatedByInput, CrewUncheckedUpdateWithoutCreatedByInput>
  }

  export type CrewUpdateManyWithWhereWithoutCreatedByInput = {
    where: CrewScalarWhereInput
    data: XOR<CrewUpdateManyMutationInput, CrewUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type CrewScalarWhereInput = {
    AND?: CrewScalarWhereInput | CrewScalarWhereInput[]
    OR?: CrewScalarWhereInput[]
    NOT?: CrewScalarWhereInput | CrewScalarWhereInput[]
    id?: StringFilter<"Crew"> | string
    name?: StringFilter<"Crew"> | string
    description?: StringFilter<"Crew"> | string
    createdAt?: DateTimeFilter<"Crew"> | Date | string
    editedAt?: DateTimeFilter<"Crew"> | Date | string
    createdById?: StringFilter<"Crew"> | string
    editedById?: StringFilter<"Crew"> | string
  }

  export type CrewUpsertWithWhereUniqueWithoutEditedByInput = {
    where: CrewWhereUniqueInput
    update: XOR<CrewUpdateWithoutEditedByInput, CrewUncheckedUpdateWithoutEditedByInput>
    create: XOR<CrewCreateWithoutEditedByInput, CrewUncheckedCreateWithoutEditedByInput>
  }

  export type CrewUpdateWithWhereUniqueWithoutEditedByInput = {
    where: CrewWhereUniqueInput
    data: XOR<CrewUpdateWithoutEditedByInput, CrewUncheckedUpdateWithoutEditedByInput>
  }

  export type CrewUpdateManyWithWhereWithoutEditedByInput = {
    where: CrewScalarWhereInput
    data: XOR<CrewUpdateManyMutationInput, CrewUncheckedUpdateManyWithoutEditedByInput>
  }

  export type SpecificIngredientUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: SpecificIngredientWhereUniqueInput
    update: XOR<SpecificIngredientUpdateWithoutCreatedByInput, SpecificIngredientUncheckedUpdateWithoutCreatedByInput>
    create: XOR<SpecificIngredientCreateWithoutCreatedByInput, SpecificIngredientUncheckedCreateWithoutCreatedByInput>
  }

  export type SpecificIngredientUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: SpecificIngredientWhereUniqueInput
    data: XOR<SpecificIngredientUpdateWithoutCreatedByInput, SpecificIngredientUncheckedUpdateWithoutCreatedByInput>
  }

  export type SpecificIngredientUpdateManyWithWhereWithoutCreatedByInput = {
    where: SpecificIngredientScalarWhereInput
    data: XOR<SpecificIngredientUpdateManyMutationInput, SpecificIngredientUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type SpecificIngredientScalarWhereInput = {
    AND?: SpecificIngredientScalarWhereInput | SpecificIngredientScalarWhereInput[]
    OR?: SpecificIngredientScalarWhereInput[]
    NOT?: SpecificIngredientScalarWhereInput | SpecificIngredientScalarWhereInput[]
    id?: StringFilter<"SpecificIngredient"> | string
    dateCreated?: DateTimeFilter<"SpecificIngredient"> | Date | string
    createdById?: StringNullableFilter<"SpecificIngredient"> | string | null
    genericIngredientId?: StringFilter<"SpecificIngredient"> | string
    name?: StringFilter<"SpecificIngredient"> | string
    description?: StringFilter<"SpecificIngredient"> | string
    price?: FloatNullableFilter<"SpecificIngredient"> | number | null
    amount?: FloatNullableFilter<"SpecificIngredient"> | number | null
    unit?: StringNullableFilter<"SpecificIngredient"> | string | null
    source?: StringNullableFilter<"SpecificIngredient"> | string | null
  }

  export type IngredientPreferenceUpsertWithWhereUniqueWithoutUserInput = {
    where: IngredientPreferenceWhereUniqueInput
    update: XOR<IngredientPreferenceUpdateWithoutUserInput, IngredientPreferenceUncheckedUpdateWithoutUserInput>
    create: XOR<IngredientPreferenceCreateWithoutUserInput, IngredientPreferenceUncheckedCreateWithoutUserInput>
  }

  export type IngredientPreferenceUpdateWithWhereUniqueWithoutUserInput = {
    where: IngredientPreferenceWhereUniqueInput
    data: XOR<IngredientPreferenceUpdateWithoutUserInput, IngredientPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type IngredientPreferenceUpdateManyWithWhereWithoutUserInput = {
    where: IngredientPreferenceScalarWhereInput
    data: XOR<IngredientPreferenceUpdateManyMutationInput, IngredientPreferenceUncheckedUpdateManyWithoutUserInput>
  }

  export type IngredientPreferenceScalarWhereInput = {
    AND?: IngredientPreferenceScalarWhereInput | IngredientPreferenceScalarWhereInput[]
    OR?: IngredientPreferenceScalarWhereInput[]
    NOT?: IngredientPreferenceScalarWhereInput | IngredientPreferenceScalarWhereInput[]
    genericIngredientId?: StringFilter<"IngredientPreference"> | string
    specificIngredientId?: StringFilter<"IngredientPreference"> | string
    userId?: StringFilter<"IngredientPreference"> | string
  }

  export type IngredientUserUpsertWithWhereUniqueWithoutUserInput = {
    where: IngredientUserWhereUniqueInput
    update: XOR<IngredientUserUpdateWithoutUserInput, IngredientUserUncheckedUpdateWithoutUserInput>
    create: XOR<IngredientUserCreateWithoutUserInput, IngredientUserUncheckedCreateWithoutUserInput>
  }

  export type IngredientUserUpdateWithWhereUniqueWithoutUserInput = {
    where: IngredientUserWhereUniqueInput
    data: XOR<IngredientUserUpdateWithoutUserInput, IngredientUserUncheckedUpdateWithoutUserInput>
  }

  export type IngredientUserUpdateManyWithWhereWithoutUserInput = {
    where: IngredientUserScalarWhereInput
    data: XOR<IngredientUserUpdateManyMutationInput, IngredientUserUncheckedUpdateManyWithoutUserInput>
  }

  export type IngredientUserScalarWhereInput = {
    AND?: IngredientUserScalarWhereInput | IngredientUserScalarWhereInput[]
    OR?: IngredientUserScalarWhereInput[]
    NOT?: IngredientUserScalarWhereInput | IngredientUserScalarWhereInput[]
    ingredientId?: StringFilter<"IngredientUser"> | string
    userId?: StringFilter<"IngredientUser"> | string
    permission?: StringFilter<"IngredientUser"> | string
  }

  export type StorageUserUpsertWithWhereUniqueWithoutUserInput = {
    where: StorageUserWhereUniqueInput
    update: XOR<StorageUserUpdateWithoutUserInput, StorageUserUncheckedUpdateWithoutUserInput>
    create: XOR<StorageUserCreateWithoutUserInput, StorageUserUncheckedCreateWithoutUserInput>
  }

  export type StorageUserUpdateWithWhereUniqueWithoutUserInput = {
    where: StorageUserWhereUniqueInput
    data: XOR<StorageUserUpdateWithoutUserInput, StorageUserUncheckedUpdateWithoutUserInput>
  }

  export type StorageUserUpdateManyWithWhereWithoutUserInput = {
    where: StorageUserScalarWhereInput
    data: XOR<StorageUserUpdateManyMutationInput, StorageUserUncheckedUpdateManyWithoutUserInput>
  }

  export type StorageUserScalarWhereInput = {
    AND?: StorageUserScalarWhereInput | StorageUserScalarWhereInput[]
    OR?: StorageUserScalarWhereInput[]
    NOT?: StorageUserScalarWhereInput | StorageUserScalarWhereInput[]
    userId?: StringFilter<"StorageUser"> | string
    storageId?: StringFilter<"StorageUser"> | string
    permission?: StringFilter<"StorageUser"> | string
  }

  export type StorageUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: StorageWhereUniqueInput
    update: XOR<StorageUpdateWithoutCreatedByInput, StorageUncheckedUpdateWithoutCreatedByInput>
    create: XOR<StorageCreateWithoutCreatedByInput, StorageUncheckedCreateWithoutCreatedByInput>
  }

  export type StorageUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: StorageWhereUniqueInput
    data: XOR<StorageUpdateWithoutCreatedByInput, StorageUncheckedUpdateWithoutCreatedByInput>
  }

  export type StorageUpdateManyWithWhereWithoutCreatedByInput = {
    where: StorageScalarWhereInput
    data: XOR<StorageUpdateManyMutationInput, StorageUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type StorageScalarWhereInput = {
    AND?: StorageScalarWhereInput | StorageScalarWhereInput[]
    OR?: StorageScalarWhereInput[]
    NOT?: StorageScalarWhereInput | StorageScalarWhereInput[]
    id?: StringFilter<"Storage"> | string
    name?: StringFilter<"Storage"> | string
    description?: StringFilter<"Storage"> | string
    createdAt?: DateTimeFilter<"Storage"> | Date | string
    editedAt?: DateTimeFilter<"Storage"> | Date | string
    createdById?: StringFilter<"Storage"> | string
    editedById?: StringFilter<"Storage"> | string
  }

  export type StorageUpsertWithWhereUniqueWithoutEditedByInput = {
    where: StorageWhereUniqueInput
    update: XOR<StorageUpdateWithoutEditedByInput, StorageUncheckedUpdateWithoutEditedByInput>
    create: XOR<StorageCreateWithoutEditedByInput, StorageUncheckedCreateWithoutEditedByInput>
  }

  export type StorageUpdateWithWhereUniqueWithoutEditedByInput = {
    where: StorageWhereUniqueInput
    data: XOR<StorageUpdateWithoutEditedByInput, StorageUncheckedUpdateWithoutEditedByInput>
  }

  export type StorageUpdateManyWithWhereWithoutEditedByInput = {
    where: StorageScalarWhereInput
    data: XOR<StorageUpdateManyMutationInput, StorageUncheckedUpdateManyWithoutEditedByInput>
  }

  export type InventoryUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: InventoryWhereUniqueInput
    update: XOR<InventoryUpdateWithoutCreatedByInput, InventoryUncheckedUpdateWithoutCreatedByInput>
    create: XOR<InventoryCreateWithoutCreatedByInput, InventoryUncheckedCreateWithoutCreatedByInput>
  }

  export type InventoryUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: InventoryWhereUniqueInput
    data: XOR<InventoryUpdateWithoutCreatedByInput, InventoryUncheckedUpdateWithoutCreatedByInput>
  }

  export type InventoryUpdateManyWithWhereWithoutCreatedByInput = {
    where: InventoryScalarWhereInput
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type InventoryScalarWhereInput = {
    AND?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
    OR?: InventoryScalarWhereInput[]
    NOT?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
    id?: StringFilter<"Inventory"> | string
    name?: StringFilter<"Inventory"> | string
    description?: StringFilter<"Inventory"> | string
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    editedAt?: DateTimeFilter<"Inventory"> | Date | string
    createdById?: StringFilter<"Inventory"> | string
    editedById?: StringFilter<"Inventory"> | string
  }

  export type InventoryUpsertWithWhereUniqueWithoutEditedByInput = {
    where: InventoryWhereUniqueInput
    update: XOR<InventoryUpdateWithoutEditedByInput, InventoryUncheckedUpdateWithoutEditedByInput>
    create: XOR<InventoryCreateWithoutEditedByInput, InventoryUncheckedCreateWithoutEditedByInput>
  }

  export type InventoryUpdateWithWhereUniqueWithoutEditedByInput = {
    where: InventoryWhereUniqueInput
    data: XOR<InventoryUpdateWithoutEditedByInput, InventoryUncheckedUpdateWithoutEditedByInput>
  }

  export type InventoryUpdateManyWithWhereWithoutEditedByInput = {
    where: InventoryScalarWhereInput
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyWithoutEditedByInput>
  }

  export type InventoryUserUpsertWithWhereUniqueWithoutUserInput = {
    where: InventoryUserWhereUniqueInput
    update: XOR<InventoryUserUpdateWithoutUserInput, InventoryUserUncheckedUpdateWithoutUserInput>
    create: XOR<InventoryUserCreateWithoutUserInput, InventoryUserUncheckedCreateWithoutUserInput>
  }

  export type InventoryUserUpdateWithWhereUniqueWithoutUserInput = {
    where: InventoryUserWhereUniqueInput
    data: XOR<InventoryUserUpdateWithoutUserInput, InventoryUserUncheckedUpdateWithoutUserInput>
  }

  export type InventoryUserUpdateManyWithWhereWithoutUserInput = {
    where: InventoryUserScalarWhereInput
    data: XOR<InventoryUserUpdateManyMutationInput, InventoryUserUncheckedUpdateManyWithoutUserInput>
  }

  export type InventoryUserScalarWhereInput = {
    AND?: InventoryUserScalarWhereInput | InventoryUserScalarWhereInput[]
    OR?: InventoryUserScalarWhereInput[]
    NOT?: InventoryUserScalarWhereInput | InventoryUserScalarWhereInput[]
    userId?: StringFilter<"InventoryUser"> | string
    inventoryId?: StringFilter<"InventoryUser"> | string
    permission?: StringFilter<"InventoryUser"> | string
  }

  export type FollowUpsertWithWhereUniqueWithoutFollowedByInput = {
    where: FollowWhereUniqueInput
    update: XOR<FollowUpdateWithoutFollowedByInput, FollowUncheckedUpdateWithoutFollowedByInput>
    create: XOR<FollowCreateWithoutFollowedByInput, FollowUncheckedCreateWithoutFollowedByInput>
  }

  export type FollowUpdateWithWhereUniqueWithoutFollowedByInput = {
    where: FollowWhereUniqueInput
    data: XOR<FollowUpdateWithoutFollowedByInput, FollowUncheckedUpdateWithoutFollowedByInput>
  }

  export type FollowUpdateManyWithWhereWithoutFollowedByInput = {
    where: FollowScalarWhereInput
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyWithoutFollowedByInput>
  }

  export type FollowScalarWhereInput = {
    AND?: FollowScalarWhereInput | FollowScalarWhereInput[]
    OR?: FollowScalarWhereInput[]
    NOT?: FollowScalarWhereInput | FollowScalarWhereInput[]
    followedById?: StringFilter<"Follow"> | string
    followingId?: StringFilter<"Follow"> | string
    relationship?: StringFilter<"Follow"> | string
  }

  export type FollowUpsertWithWhereUniqueWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    update: XOR<FollowUpdateWithoutFollowingInput, FollowUncheckedUpdateWithoutFollowingInput>
    create: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput>
  }

  export type FollowUpdateWithWhereUniqueWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    data: XOR<FollowUpdateWithoutFollowingInput, FollowUncheckedUpdateWithoutFollowingInput>
  }

  export type FollowUpdateManyWithWhereWithoutFollowingInput = {
    where: FollowScalarWhereInput
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyWithoutFollowingInput>
  }

  export type UserCreateWithoutFollowedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutFollowedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutFollowedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowedByInput, UserUncheckedCreateWithoutFollowedByInput>
  }

  export type UserCreateWithoutFollowingInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
  }

  export type UserUncheckedCreateWithoutFollowingInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
  }

  export type UserCreateOrConnectWithoutFollowingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
  }

  export type UserUpsertWithoutFollowedByInput = {
    update: XOR<UserUpdateWithoutFollowedByInput, UserUncheckedUpdateWithoutFollowedByInput>
    create: XOR<UserCreateWithoutFollowedByInput, UserUncheckedCreateWithoutFollowedByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFollowedByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFollowedByInput, UserUncheckedUpdateWithoutFollowedByInput>
  }

  export type UserUpdateWithoutFollowedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type UserUpsertWithoutFollowingInput = {
    update: XOR<UserUpdateWithoutFollowingInput, UserUncheckedUpdateWithoutFollowingInput>
    create: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFollowingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFollowingInput, UserUncheckedUpdateWithoutFollowingInput>
  }

  export type UserUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
  }

  export type UserCreateWithoutProfileInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type UserCreateWithoutRecipeBookInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutRecipeBookInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutRecipeBookInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecipeBookInput, UserUncheckedCreateWithoutRecipeBookInput>
  }

  export type UserCreateWithoutRecipeBookEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutRecipeBookEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutRecipeBookEditedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecipeBookEditedByInput, UserUncheckedCreateWithoutRecipeBookEditedByInput>
  }

  export type RecipeBookBuildCreateWithoutRecipeBookInput = {
    build: BuildCreateNestedOneWithoutRecipeBookBuildInput
  }

  export type RecipeBookBuildUncheckedCreateWithoutRecipeBookInput = {
    buildId: string
  }

  export type RecipeBookBuildCreateOrConnectWithoutRecipeBookInput = {
    where: RecipeBookBuildWhereUniqueInput
    create: XOR<RecipeBookBuildCreateWithoutRecipeBookInput, RecipeBookBuildUncheckedCreateWithoutRecipeBookInput>
  }

  export type RecipeBookBuildCreateManyRecipeBookInputEnvelope = {
    data: RecipeBookBuildCreateManyRecipeBookInput | RecipeBookBuildCreateManyRecipeBookInput[]
    skipDuplicates?: boolean
  }

  export type RecipeBookUserCreateWithoutRecipeBookInput = {
    permission: string
    user: UserCreateNestedOneWithoutRecipeBookUserInput
  }

  export type RecipeBookUserUncheckedCreateWithoutRecipeBookInput = {
    userId: string
    permission: string
  }

  export type RecipeBookUserCreateOrConnectWithoutRecipeBookInput = {
    where: RecipeBookUserWhereUniqueInput
    create: XOR<RecipeBookUserCreateWithoutRecipeBookInput, RecipeBookUserUncheckedCreateWithoutRecipeBookInput>
  }

  export type RecipeBookUserCreateManyRecipeBookInputEnvelope = {
    data: RecipeBookUserCreateManyRecipeBookInput | RecipeBookUserCreateManyRecipeBookInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutRecipeBookInput = {
    update: XOR<UserUpdateWithoutRecipeBookInput, UserUncheckedUpdateWithoutRecipeBookInput>
    create: XOR<UserCreateWithoutRecipeBookInput, UserUncheckedCreateWithoutRecipeBookInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRecipeBookInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRecipeBookInput, UserUncheckedUpdateWithoutRecipeBookInput>
  }

  export type UserUpdateWithoutRecipeBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutRecipeBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type UserUpsertWithoutRecipeBookEditedByInput = {
    update: XOR<UserUpdateWithoutRecipeBookEditedByInput, UserUncheckedUpdateWithoutRecipeBookEditedByInput>
    create: XOR<UserCreateWithoutRecipeBookEditedByInput, UserUncheckedCreateWithoutRecipeBookEditedByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRecipeBookEditedByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRecipeBookEditedByInput, UserUncheckedUpdateWithoutRecipeBookEditedByInput>
  }

  export type UserUpdateWithoutRecipeBookEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutRecipeBookEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type RecipeBookBuildUpsertWithWhereUniqueWithoutRecipeBookInput = {
    where: RecipeBookBuildWhereUniqueInput
    update: XOR<RecipeBookBuildUpdateWithoutRecipeBookInput, RecipeBookBuildUncheckedUpdateWithoutRecipeBookInput>
    create: XOR<RecipeBookBuildCreateWithoutRecipeBookInput, RecipeBookBuildUncheckedCreateWithoutRecipeBookInput>
  }

  export type RecipeBookBuildUpdateWithWhereUniqueWithoutRecipeBookInput = {
    where: RecipeBookBuildWhereUniqueInput
    data: XOR<RecipeBookBuildUpdateWithoutRecipeBookInput, RecipeBookBuildUncheckedUpdateWithoutRecipeBookInput>
  }

  export type RecipeBookBuildUpdateManyWithWhereWithoutRecipeBookInput = {
    where: RecipeBookBuildScalarWhereInput
    data: XOR<RecipeBookBuildUpdateManyMutationInput, RecipeBookBuildUncheckedUpdateManyWithoutRecipeBookInput>
  }

  export type RecipeBookBuildScalarWhereInput = {
    AND?: RecipeBookBuildScalarWhereInput | RecipeBookBuildScalarWhereInput[]
    OR?: RecipeBookBuildScalarWhereInput[]
    NOT?: RecipeBookBuildScalarWhereInput | RecipeBookBuildScalarWhereInput[]
    buildId?: StringFilter<"RecipeBookBuild"> | string
    recipeBookId?: StringFilter<"RecipeBookBuild"> | string
  }

  export type RecipeBookUserUpsertWithWhereUniqueWithoutRecipeBookInput = {
    where: RecipeBookUserWhereUniqueInput
    update: XOR<RecipeBookUserUpdateWithoutRecipeBookInput, RecipeBookUserUncheckedUpdateWithoutRecipeBookInput>
    create: XOR<RecipeBookUserCreateWithoutRecipeBookInput, RecipeBookUserUncheckedCreateWithoutRecipeBookInput>
  }

  export type RecipeBookUserUpdateWithWhereUniqueWithoutRecipeBookInput = {
    where: RecipeBookUserWhereUniqueInput
    data: XOR<RecipeBookUserUpdateWithoutRecipeBookInput, RecipeBookUserUncheckedUpdateWithoutRecipeBookInput>
  }

  export type RecipeBookUserUpdateManyWithWhereWithoutRecipeBookInput = {
    where: RecipeBookUserScalarWhereInput
    data: XOR<RecipeBookUserUpdateManyMutationInput, RecipeBookUserUncheckedUpdateManyWithoutRecipeBookInput>
  }

  export type RecipeBookCreateWithoutRecipeBookUserInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutRecipeBookInput
    editedBy?: UserCreateNestedOneWithoutRecipeBookEditedByInput
    recipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookUncheckedCreateWithoutRecipeBookUserInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    editedById?: string | null
    recipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookCreateOrConnectWithoutRecipeBookUserInput = {
    where: RecipeBookWhereUniqueInput
    create: XOR<RecipeBookCreateWithoutRecipeBookUserInput, RecipeBookUncheckedCreateWithoutRecipeBookUserInput>
  }

  export type UserCreateWithoutRecipeBookUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutRecipeBookUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutRecipeBookUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecipeBookUserInput, UserUncheckedCreateWithoutRecipeBookUserInput>
  }

  export type RecipeBookUpsertWithoutRecipeBookUserInput = {
    update: XOR<RecipeBookUpdateWithoutRecipeBookUserInput, RecipeBookUncheckedUpdateWithoutRecipeBookUserInput>
    create: XOR<RecipeBookCreateWithoutRecipeBookUserInput, RecipeBookUncheckedCreateWithoutRecipeBookUserInput>
    where?: RecipeBookWhereInput
  }

  export type RecipeBookUpdateToOneWithWhereWithoutRecipeBookUserInput = {
    where?: RecipeBookWhereInput
    data: XOR<RecipeBookUpdateWithoutRecipeBookUserInput, RecipeBookUncheckedUpdateWithoutRecipeBookUserInput>
  }

  export type RecipeBookUpdateWithoutRecipeBookUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutRecipeBookNestedInput
    editedBy?: UserUpdateOneWithoutRecipeBookEditedByNestedInput
    recipeBookBuild?: RecipeBookBuildUpdateManyWithoutRecipeBookNestedInput
  }

  export type RecipeBookUncheckedUpdateWithoutRecipeBookUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutRecipeBookNestedInput
  }

  export type UserUpsertWithoutRecipeBookUserInput = {
    update: XOR<UserUpdateWithoutRecipeBookUserInput, UserUncheckedUpdateWithoutRecipeBookUserInput>
    create: XOR<UserCreateWithoutRecipeBookUserInput, UserUncheckedCreateWithoutRecipeBookUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRecipeBookUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRecipeBookUserInput, UserUncheckedUpdateWithoutRecipeBookUserInput>
  }

  export type UserUpdateWithoutRecipeBookUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutRecipeBookUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type UserCreateWithoutBuildInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutBuildInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutBuildInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBuildInput, UserUncheckedCreateWithoutBuildInput>
  }

  export type UserCreateWithoutBuildEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    CrewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutBuildEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    CrewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutBuildEditedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBuildEditedByInput, UserUncheckedCreateWithoutBuildEditedByInput>
  }

  export type RecipeCreateWithoutBuildInput = {
    id?: string
    createdAt?: Date | string
    editedAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    createdBy?: UserCreateNestedOneWithoutRecipeInput
    editedBy?: UserCreateNestedOneWithoutRecipeEditedByInput
  }

  export type RecipeUncheckedCreateWithoutBuildInput = {
    id?: string
    createdAt?: Date | string
    editedAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    createdById?: string | null
    editedById?: string | null
  }

  export type RecipeCreateOrConnectWithoutBuildInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutBuildInput, RecipeUncheckedCreateWithoutBuildInput>
  }

  export type TouchCreateWithoutBuildInput = {
    id?: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    version?: number | null
    genericIngredient: GenericIngredientCreateNestedOneWithoutTouchInput
    specificIngredient?: SpecificIngredientCreateNestedOneWithoutTouchInput
  }

  export type TouchUncheckedCreateWithoutBuildInput = {
    id?: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    genericIngredientId: string
    specificIngredientId?: string | null
    version?: number | null
  }

  export type TouchCreateOrConnectWithoutBuildInput = {
    where: TouchWhereUniqueInput
    create: XOR<TouchCreateWithoutBuildInput, TouchUncheckedCreateWithoutBuildInput>
  }

  export type TouchCreateManyBuildInputEnvelope = {
    data: TouchCreateManyBuildInput | TouchCreateManyBuildInput[]
    skipDuplicates?: boolean
  }

  export type ArchivedTouchCreateWithoutBuildInput = {
    id?: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    version?: number | null
    genericIngredient: GenericIngredientCreateNestedOneWithoutArchivedTouchInput
    specificIngredient?: SpecificIngredientCreateNestedOneWithoutArchivedTouchInput
  }

  export type ArchivedTouchUncheckedCreateWithoutBuildInput = {
    id?: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    genericIngredientId: string
    specificIngredientId?: string | null
    version?: number | null
  }

  export type ArchivedTouchCreateOrConnectWithoutBuildInput = {
    where: ArchivedTouchWhereUniqueInput
    create: XOR<ArchivedTouchCreateWithoutBuildInput, ArchivedTouchUncheckedCreateWithoutBuildInput>
  }

  export type ArchivedTouchCreateManyBuildInputEnvelope = {
    data: ArchivedTouchCreateManyBuildInput | ArchivedTouchCreateManyBuildInput[]
    skipDuplicates?: boolean
  }

  export type RecipeBookBuildCreateWithoutBuildInput = {
    recipeBook: RecipeBookCreateNestedOneWithoutRecipeBookBuildInput
  }

  export type RecipeBookBuildUncheckedCreateWithoutBuildInput = {
    recipeBookId: string
  }

  export type RecipeBookBuildCreateOrConnectWithoutBuildInput = {
    where: RecipeBookBuildWhereUniqueInput
    create: XOR<RecipeBookBuildCreateWithoutBuildInput, RecipeBookBuildUncheckedCreateWithoutBuildInput>
  }

  export type RecipeBookBuildCreateManyBuildInputEnvelope = {
    data: RecipeBookBuildCreateManyBuildInput | RecipeBookBuildCreateManyBuildInput[]
    skipDuplicates?: boolean
  }

  export type BuildUserCreateWithoutBuildInput = {
    permission: string
    user?: UserCreateNestedOneWithoutBuildUserInput
  }

  export type BuildUserUncheckedCreateWithoutBuildInput = {
    userId: string
    permission: string
  }

  export type BuildUserCreateOrConnectWithoutBuildInput = {
    where: BuildUserWhereUniqueInput
    create: XOR<BuildUserCreateWithoutBuildInput, BuildUserUncheckedCreateWithoutBuildInput>
  }

  export type BuildUserCreateManyBuildInputEnvelope = {
    data: BuildUserCreateManyBuildInput | BuildUserCreateManyBuildInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBuildInput = {
    update: XOR<UserUpdateWithoutBuildInput, UserUncheckedUpdateWithoutBuildInput>
    create: XOR<UserCreateWithoutBuildInput, UserUncheckedCreateWithoutBuildInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBuildInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBuildInput, UserUncheckedUpdateWithoutBuildInput>
  }

  export type UserUpdateWithoutBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type UserUpsertWithoutBuildEditedByInput = {
    update: XOR<UserUpdateWithoutBuildEditedByInput, UserUncheckedUpdateWithoutBuildEditedByInput>
    create: XOR<UserCreateWithoutBuildEditedByInput, UserUncheckedCreateWithoutBuildEditedByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBuildEditedByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBuildEditedByInput, UserUncheckedUpdateWithoutBuildEditedByInput>
  }

  export type UserUpdateWithoutBuildEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    CrewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutBuildEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    CrewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type RecipeUpsertWithoutBuildInput = {
    update: XOR<RecipeUpdateWithoutBuildInput, RecipeUncheckedUpdateWithoutBuildInput>
    create: XOR<RecipeCreateWithoutBuildInput, RecipeUncheckedCreateWithoutBuildInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutBuildInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutBuildInput, RecipeUncheckedUpdateWithoutBuildInput>
  }

  export type RecipeUpdateWithoutBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutRecipeNestedInput
    editedBy?: UserUpdateOneWithoutRecipeEditedByNestedInput
  }

  export type RecipeUncheckedUpdateWithoutBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TouchUpsertWithWhereUniqueWithoutBuildInput = {
    where: TouchWhereUniqueInput
    update: XOR<TouchUpdateWithoutBuildInput, TouchUncheckedUpdateWithoutBuildInput>
    create: XOR<TouchCreateWithoutBuildInput, TouchUncheckedCreateWithoutBuildInput>
  }

  export type TouchUpdateWithWhereUniqueWithoutBuildInput = {
    where: TouchWhereUniqueInput
    data: XOR<TouchUpdateWithoutBuildInput, TouchUncheckedUpdateWithoutBuildInput>
  }

  export type TouchUpdateManyWithWhereWithoutBuildInput = {
    where: TouchScalarWhereInput
    data: XOR<TouchUpdateManyMutationInput, TouchUncheckedUpdateManyWithoutBuildInput>
  }

  export type TouchScalarWhereInput = {
    AND?: TouchScalarWhereInput | TouchScalarWhereInput[]
    OR?: TouchScalarWhereInput[]
    NOT?: TouchScalarWhereInput | TouchScalarWhereInput[]
    id?: StringFilter<"Touch"> | string
    buildId?: StringFilter<"Touch"> | string
    order?: IntNullableFilter<"Touch"> | number | null
    amount?: FloatNullableFilter<"Touch"> | number | null
    unit?: StringNullableFilter<"Touch"> | string | null
    genericIngredientId?: StringFilter<"Touch"> | string
    specificIngredientId?: StringNullableFilter<"Touch"> | string | null
    version?: IntNullableFilter<"Touch"> | number | null
  }

  export type ArchivedTouchUpsertWithWhereUniqueWithoutBuildInput = {
    where: ArchivedTouchWhereUniqueInput
    update: XOR<ArchivedTouchUpdateWithoutBuildInput, ArchivedTouchUncheckedUpdateWithoutBuildInput>
    create: XOR<ArchivedTouchCreateWithoutBuildInput, ArchivedTouchUncheckedCreateWithoutBuildInput>
  }

  export type ArchivedTouchUpdateWithWhereUniqueWithoutBuildInput = {
    where: ArchivedTouchWhereUniqueInput
    data: XOR<ArchivedTouchUpdateWithoutBuildInput, ArchivedTouchUncheckedUpdateWithoutBuildInput>
  }

  export type ArchivedTouchUpdateManyWithWhereWithoutBuildInput = {
    where: ArchivedTouchScalarWhereInput
    data: XOR<ArchivedTouchUpdateManyMutationInput, ArchivedTouchUncheckedUpdateManyWithoutBuildInput>
  }

  export type ArchivedTouchScalarWhereInput = {
    AND?: ArchivedTouchScalarWhereInput | ArchivedTouchScalarWhereInput[]
    OR?: ArchivedTouchScalarWhereInput[]
    NOT?: ArchivedTouchScalarWhereInput | ArchivedTouchScalarWhereInput[]
    id?: StringFilter<"ArchivedTouch"> | string
    buildId?: StringFilter<"ArchivedTouch"> | string
    order?: IntNullableFilter<"ArchivedTouch"> | number | null
    amount?: FloatNullableFilter<"ArchivedTouch"> | number | null
    unit?: StringNullableFilter<"ArchivedTouch"> | string | null
    genericIngredientId?: StringFilter<"ArchivedTouch"> | string
    specificIngredientId?: StringNullableFilter<"ArchivedTouch"> | string | null
    version?: IntNullableFilter<"ArchivedTouch"> | number | null
  }

  export type RecipeBookBuildUpsertWithWhereUniqueWithoutBuildInput = {
    where: RecipeBookBuildWhereUniqueInput
    update: XOR<RecipeBookBuildUpdateWithoutBuildInput, RecipeBookBuildUncheckedUpdateWithoutBuildInput>
    create: XOR<RecipeBookBuildCreateWithoutBuildInput, RecipeBookBuildUncheckedCreateWithoutBuildInput>
  }

  export type RecipeBookBuildUpdateWithWhereUniqueWithoutBuildInput = {
    where: RecipeBookBuildWhereUniqueInput
    data: XOR<RecipeBookBuildUpdateWithoutBuildInput, RecipeBookBuildUncheckedUpdateWithoutBuildInput>
  }

  export type RecipeBookBuildUpdateManyWithWhereWithoutBuildInput = {
    where: RecipeBookBuildScalarWhereInput
    data: XOR<RecipeBookBuildUpdateManyMutationInput, RecipeBookBuildUncheckedUpdateManyWithoutBuildInput>
  }

  export type BuildUserUpsertWithWhereUniqueWithoutBuildInput = {
    where: BuildUserWhereUniqueInput
    update: XOR<BuildUserUpdateWithoutBuildInput, BuildUserUncheckedUpdateWithoutBuildInput>
    create: XOR<BuildUserCreateWithoutBuildInput, BuildUserUncheckedCreateWithoutBuildInput>
  }

  export type BuildUserUpdateWithWhereUniqueWithoutBuildInput = {
    where: BuildUserWhereUniqueInput
    data: XOR<BuildUserUpdateWithoutBuildInput, BuildUserUncheckedUpdateWithoutBuildInput>
  }

  export type BuildUserUpdateManyWithWhereWithoutBuildInput = {
    where: BuildUserScalarWhereInput
    data: XOR<BuildUserUpdateManyMutationInput, BuildUserUncheckedUpdateManyWithoutBuildInput>
  }

  export type UserCreateWithoutBuildUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutBuildUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutBuildUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBuildUserInput, UserUncheckedCreateWithoutBuildUserInput>
  }

  export type BuildCreateWithoutBuildUserInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    createdBy?: UserCreateNestedOneWithoutBuildInput
    editedBy?: UserCreateNestedOneWithoutBuildEditedByInput
    recipe?: RecipeCreateNestedOneWithoutBuildInput
    touch?: TouchCreateNestedManyWithoutBuildInput
    archivedTouch?: ArchivedTouchCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutBuildInput
  }

  export type BuildUncheckedCreateWithoutBuildUserInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    editedById?: string | null
    recipeId?: string | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutBuildInput
    archivedTouch?: ArchivedTouchUncheckedCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutBuildInput
  }

  export type BuildCreateOrConnectWithoutBuildUserInput = {
    where: BuildWhereUniqueInput
    create: XOR<BuildCreateWithoutBuildUserInput, BuildUncheckedCreateWithoutBuildUserInput>
  }

  export type UserUpsertWithoutBuildUserInput = {
    update: XOR<UserUpdateWithoutBuildUserInput, UserUncheckedUpdateWithoutBuildUserInput>
    create: XOR<UserCreateWithoutBuildUserInput, UserUncheckedCreateWithoutBuildUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBuildUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBuildUserInput, UserUncheckedUpdateWithoutBuildUserInput>
  }

  export type UserUpdateWithoutBuildUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutBuildUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type BuildUpsertWithoutBuildUserInput = {
    update: XOR<BuildUpdateWithoutBuildUserInput, BuildUncheckedUpdateWithoutBuildUserInput>
    create: XOR<BuildCreateWithoutBuildUserInput, BuildUncheckedCreateWithoutBuildUserInput>
    where?: BuildWhereInput
  }

  export type BuildUpdateToOneWithWhereWithoutBuildUserInput = {
    where?: BuildWhereInput
    data: XOR<BuildUpdateWithoutBuildUserInput, BuildUncheckedUpdateWithoutBuildUserInput>
  }

  export type BuildUpdateWithoutBuildUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutBuildNestedInput
    editedBy?: UserUpdateOneWithoutBuildEditedByNestedInput
    recipe?: RecipeUpdateOneWithoutBuildNestedInput
    touch?: TouchUpdateManyWithoutBuildNestedInput
    archivedTouch?: ArchivedTouchUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateWithoutBuildUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeId?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutBuildNestedInput
    archivedTouch?: ArchivedTouchUncheckedUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutBuildNestedInput
  }

  export type UserCreateWithoutRecipeInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutRecipeInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutRecipeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecipeInput, UserUncheckedCreateWithoutRecipeInput>
  }

  export type UserCreateWithoutRecipeEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutRecipeEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutRecipeEditedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecipeEditedByInput, UserUncheckedCreateWithoutRecipeEditedByInput>
  }

  export type BuildCreateWithoutRecipeInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    createdBy?: UserCreateNestedOneWithoutBuildInput
    editedBy?: UserCreateNestedOneWithoutBuildEditedByInput
    touch?: TouchCreateNestedManyWithoutBuildInput
    archivedTouch?: ArchivedTouchCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserCreateNestedManyWithoutBuildInput
  }

  export type BuildUncheckedCreateWithoutRecipeInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    editedById?: string | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutBuildInput
    archivedTouch?: ArchivedTouchUncheckedCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutBuildInput
  }

  export type BuildCreateOrConnectWithoutRecipeInput = {
    where: BuildWhereUniqueInput
    create: XOR<BuildCreateWithoutRecipeInput, BuildUncheckedCreateWithoutRecipeInput>
  }

  export type BuildCreateManyRecipeInputEnvelope = {
    data: BuildCreateManyRecipeInput | BuildCreateManyRecipeInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutRecipeInput = {
    update: XOR<UserUpdateWithoutRecipeInput, UserUncheckedUpdateWithoutRecipeInput>
    create: XOR<UserCreateWithoutRecipeInput, UserUncheckedCreateWithoutRecipeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRecipeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRecipeInput, UserUncheckedUpdateWithoutRecipeInput>
  }

  export type UserUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type UserUpsertWithoutRecipeEditedByInput = {
    update: XOR<UserUpdateWithoutRecipeEditedByInput, UserUncheckedUpdateWithoutRecipeEditedByInput>
    create: XOR<UserCreateWithoutRecipeEditedByInput, UserUncheckedCreateWithoutRecipeEditedByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRecipeEditedByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRecipeEditedByInput, UserUncheckedUpdateWithoutRecipeEditedByInput>
  }

  export type UserUpdateWithoutRecipeEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutRecipeEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type BuildUpsertWithWhereUniqueWithoutRecipeInput = {
    where: BuildWhereUniqueInput
    update: XOR<BuildUpdateWithoutRecipeInput, BuildUncheckedUpdateWithoutRecipeInput>
    create: XOR<BuildCreateWithoutRecipeInput, BuildUncheckedCreateWithoutRecipeInput>
  }

  export type BuildUpdateWithWhereUniqueWithoutRecipeInput = {
    where: BuildWhereUniqueInput
    data: XOR<BuildUpdateWithoutRecipeInput, BuildUncheckedUpdateWithoutRecipeInput>
  }

  export type BuildUpdateManyWithWhereWithoutRecipeInput = {
    where: BuildScalarWhereInput
    data: XOR<BuildUpdateManyMutationInput, BuildUncheckedUpdateManyWithoutRecipeInput>
  }

  export type RecipeBookCreateWithoutRecipeBookBuildInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutRecipeBookInput
    editedBy?: UserCreateNestedOneWithoutRecipeBookEditedByInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookUncheckedCreateWithoutRecipeBookBuildInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    editedById?: string | null
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookCreateOrConnectWithoutRecipeBookBuildInput = {
    where: RecipeBookWhereUniqueInput
    create: XOR<RecipeBookCreateWithoutRecipeBookBuildInput, RecipeBookUncheckedCreateWithoutRecipeBookBuildInput>
  }

  export type BuildCreateWithoutRecipeBookBuildInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    createdBy?: UserCreateNestedOneWithoutBuildInput
    editedBy?: UserCreateNestedOneWithoutBuildEditedByInput
    recipe?: RecipeCreateNestedOneWithoutBuildInput
    touch?: TouchCreateNestedManyWithoutBuildInput
    archivedTouch?: ArchivedTouchCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserCreateNestedManyWithoutBuildInput
  }

  export type BuildUncheckedCreateWithoutRecipeBookBuildInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    editedById?: string | null
    recipeId?: string | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutBuildInput
    archivedTouch?: ArchivedTouchUncheckedCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutBuildInput
  }

  export type BuildCreateOrConnectWithoutRecipeBookBuildInput = {
    where: BuildWhereUniqueInput
    create: XOR<BuildCreateWithoutRecipeBookBuildInput, BuildUncheckedCreateWithoutRecipeBookBuildInput>
  }

  export type RecipeBookUpsertWithoutRecipeBookBuildInput = {
    update: XOR<RecipeBookUpdateWithoutRecipeBookBuildInput, RecipeBookUncheckedUpdateWithoutRecipeBookBuildInput>
    create: XOR<RecipeBookCreateWithoutRecipeBookBuildInput, RecipeBookUncheckedCreateWithoutRecipeBookBuildInput>
    where?: RecipeBookWhereInput
  }

  export type RecipeBookUpdateToOneWithWhereWithoutRecipeBookBuildInput = {
    where?: RecipeBookWhereInput
    data: XOR<RecipeBookUpdateWithoutRecipeBookBuildInput, RecipeBookUncheckedUpdateWithoutRecipeBookBuildInput>
  }

  export type RecipeBookUpdateWithoutRecipeBookBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutRecipeBookNestedInput
    editedBy?: UserUpdateOneWithoutRecipeBookEditedByNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutRecipeBookNestedInput
  }

  export type RecipeBookUncheckedUpdateWithoutRecipeBookBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutRecipeBookNestedInput
  }

  export type BuildUpsertWithoutRecipeBookBuildInput = {
    update: XOR<BuildUpdateWithoutRecipeBookBuildInput, BuildUncheckedUpdateWithoutRecipeBookBuildInput>
    create: XOR<BuildCreateWithoutRecipeBookBuildInput, BuildUncheckedCreateWithoutRecipeBookBuildInput>
    where?: BuildWhereInput
  }

  export type BuildUpdateToOneWithWhereWithoutRecipeBookBuildInput = {
    where?: BuildWhereInput
    data: XOR<BuildUpdateWithoutRecipeBookBuildInput, BuildUncheckedUpdateWithoutRecipeBookBuildInput>
  }

  export type BuildUpdateWithoutRecipeBookBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutBuildNestedInput
    editedBy?: UserUpdateOneWithoutBuildEditedByNestedInput
    recipe?: RecipeUpdateOneWithoutBuildNestedInput
    touch?: TouchUpdateManyWithoutBuildNestedInput
    archivedTouch?: ArchivedTouchUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateWithoutRecipeBookBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeId?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutBuildNestedInput
    archivedTouch?: ArchivedTouchUncheckedUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutBuildNestedInput
  }

  export type BuildCreateWithoutTouchInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    createdBy?: UserCreateNestedOneWithoutBuildInput
    editedBy?: UserCreateNestedOneWithoutBuildEditedByInput
    recipe?: RecipeCreateNestedOneWithoutBuildInput
    archivedTouch?: ArchivedTouchCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserCreateNestedManyWithoutBuildInput
  }

  export type BuildUncheckedCreateWithoutTouchInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    editedById?: string | null
    recipeId?: string | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    archivedTouch?: ArchivedTouchUncheckedCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutBuildInput
  }

  export type BuildCreateOrConnectWithoutTouchInput = {
    where: BuildWhereUniqueInput
    create: XOR<BuildCreateWithoutTouchInput, BuildUncheckedCreateWithoutTouchInput>
  }

  export type GenericIngredientCreateWithoutTouchInput = {
    id?: string
    name: string
    description?: string | null
    archivedTouch?: ArchivedTouchCreateNestedManyWithoutGenericIngredientInput
    specificIngredient?: SpecificIngredientCreateNestedManyWithoutGenericIngredientInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutGenericIngredientInput
  }

  export type GenericIngredientUncheckedCreateWithoutTouchInput = {
    id?: string
    name: string
    description?: string | null
    archivedTouch?: ArchivedTouchUncheckedCreateNestedManyWithoutGenericIngredientInput
    specificIngredient?: SpecificIngredientUncheckedCreateNestedManyWithoutGenericIngredientInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutGenericIngredientInput
  }

  export type GenericIngredientCreateOrConnectWithoutTouchInput = {
    where: GenericIngredientWhereUniqueInput
    create: XOR<GenericIngredientCreateWithoutTouchInput, GenericIngredientUncheckedCreateWithoutTouchInput>
  }

  export type SpecificIngredientCreateWithoutTouchInput = {
    id?: string
    dateCreated?: Date | string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    createdBy?: UserCreateNestedOneWithoutIngredientInput
    genericIngredient: GenericIngredientCreateNestedOneWithoutSpecificIngredientInput
    archivedTouch?: ArchivedTouchCreateNestedManyWithoutSpecificIngredientInput
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutIngredientInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutSpecificIngredientInput
  }

  export type SpecificIngredientUncheckedCreateWithoutTouchInput = {
    id?: string
    dateCreated?: Date | string
    createdById?: string | null
    genericIngredientId: string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    archivedTouch?: ArchivedTouchUncheckedCreateNestedManyWithoutSpecificIngredientInput
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutIngredientInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutSpecificIngredientInput
  }

  export type SpecificIngredientCreateOrConnectWithoutTouchInput = {
    where: SpecificIngredientWhereUniqueInput
    create: XOR<SpecificIngredientCreateWithoutTouchInput, SpecificIngredientUncheckedCreateWithoutTouchInput>
  }

  export type BuildUpsertWithoutTouchInput = {
    update: XOR<BuildUpdateWithoutTouchInput, BuildUncheckedUpdateWithoutTouchInput>
    create: XOR<BuildCreateWithoutTouchInput, BuildUncheckedCreateWithoutTouchInput>
    where?: BuildWhereInput
  }

  export type BuildUpdateToOneWithWhereWithoutTouchInput = {
    where?: BuildWhereInput
    data: XOR<BuildUpdateWithoutTouchInput, BuildUncheckedUpdateWithoutTouchInput>
  }

  export type BuildUpdateWithoutTouchInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutBuildNestedInput
    editedBy?: UserUpdateOneWithoutBuildEditedByNestedInput
    recipe?: RecipeUpdateOneWithoutBuildNestedInput
    archivedTouch?: ArchivedTouchUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateWithoutTouchInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeId?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    archivedTouch?: ArchivedTouchUncheckedUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutBuildNestedInput
  }

  export type GenericIngredientUpsertWithoutTouchInput = {
    update: XOR<GenericIngredientUpdateWithoutTouchInput, GenericIngredientUncheckedUpdateWithoutTouchInput>
    create: XOR<GenericIngredientCreateWithoutTouchInput, GenericIngredientUncheckedCreateWithoutTouchInput>
    where?: GenericIngredientWhereInput
  }

  export type GenericIngredientUpdateToOneWithWhereWithoutTouchInput = {
    where?: GenericIngredientWhereInput
    data: XOR<GenericIngredientUpdateWithoutTouchInput, GenericIngredientUncheckedUpdateWithoutTouchInput>
  }

  export type GenericIngredientUpdateWithoutTouchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    archivedTouch?: ArchivedTouchUpdateManyWithoutGenericIngredientNestedInput
    specificIngredient?: SpecificIngredientUpdateManyWithoutGenericIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutGenericIngredientNestedInput
  }

  export type GenericIngredientUncheckedUpdateWithoutTouchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    archivedTouch?: ArchivedTouchUncheckedUpdateManyWithoutGenericIngredientNestedInput
    specificIngredient?: SpecificIngredientUncheckedUpdateManyWithoutGenericIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutGenericIngredientNestedInput
  }

  export type SpecificIngredientUpsertWithoutTouchInput = {
    update: XOR<SpecificIngredientUpdateWithoutTouchInput, SpecificIngredientUncheckedUpdateWithoutTouchInput>
    create: XOR<SpecificIngredientCreateWithoutTouchInput, SpecificIngredientUncheckedCreateWithoutTouchInput>
    where?: SpecificIngredientWhereInput
  }

  export type SpecificIngredientUpdateToOneWithWhereWithoutTouchInput = {
    where?: SpecificIngredientWhereInput
    data: XOR<SpecificIngredientUpdateWithoutTouchInput, SpecificIngredientUncheckedUpdateWithoutTouchInput>
  }

  export type SpecificIngredientUpdateWithoutTouchInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutIngredientNestedInput
    genericIngredient?: GenericIngredientUpdateOneRequiredWithoutSpecificIngredientNestedInput
    archivedTouch?: ArchivedTouchUpdateManyWithoutSpecificIngredientNestedInput
    ingredientStorage?: IngredientStorageUpdateManyWithoutIngredientNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutSpecificIngredientNestedInput
  }

  export type SpecificIngredientUncheckedUpdateWithoutTouchInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    genericIngredientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    archivedTouch?: ArchivedTouchUncheckedUpdateManyWithoutSpecificIngredientNestedInput
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutSpecificIngredientNestedInput
  }

  export type BuildCreateWithoutArchivedTouchInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    createdBy?: UserCreateNestedOneWithoutBuildInput
    editedBy?: UserCreateNestedOneWithoutBuildEditedByInput
    recipe?: RecipeCreateNestedOneWithoutBuildInput
    touch?: TouchCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserCreateNestedManyWithoutBuildInput
  }

  export type BuildUncheckedCreateWithoutArchivedTouchInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    editedById?: string | null
    recipeId?: string | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutBuildInput
  }

  export type BuildCreateOrConnectWithoutArchivedTouchInput = {
    where: BuildWhereUniqueInput
    create: XOR<BuildCreateWithoutArchivedTouchInput, BuildUncheckedCreateWithoutArchivedTouchInput>
  }

  export type GenericIngredientCreateWithoutArchivedTouchInput = {
    id?: string
    name: string
    description?: string | null
    touch?: TouchCreateNestedManyWithoutGenericIngredientInput
    specificIngredient?: SpecificIngredientCreateNestedManyWithoutGenericIngredientInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutGenericIngredientInput
  }

  export type GenericIngredientUncheckedCreateWithoutArchivedTouchInput = {
    id?: string
    name: string
    description?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutGenericIngredientInput
    specificIngredient?: SpecificIngredientUncheckedCreateNestedManyWithoutGenericIngredientInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutGenericIngredientInput
  }

  export type GenericIngredientCreateOrConnectWithoutArchivedTouchInput = {
    where: GenericIngredientWhereUniqueInput
    create: XOR<GenericIngredientCreateWithoutArchivedTouchInput, GenericIngredientUncheckedCreateWithoutArchivedTouchInput>
  }

  export type SpecificIngredientCreateWithoutArchivedTouchInput = {
    id?: string
    dateCreated?: Date | string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    createdBy?: UserCreateNestedOneWithoutIngredientInput
    genericIngredient: GenericIngredientCreateNestedOneWithoutSpecificIngredientInput
    touch?: TouchCreateNestedManyWithoutSpecificIngredientInput
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutIngredientInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutSpecificIngredientInput
  }

  export type SpecificIngredientUncheckedCreateWithoutArchivedTouchInput = {
    id?: string
    dateCreated?: Date | string
    createdById?: string | null
    genericIngredientId: string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutSpecificIngredientInput
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutIngredientInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutSpecificIngredientInput
  }

  export type SpecificIngredientCreateOrConnectWithoutArchivedTouchInput = {
    where: SpecificIngredientWhereUniqueInput
    create: XOR<SpecificIngredientCreateWithoutArchivedTouchInput, SpecificIngredientUncheckedCreateWithoutArchivedTouchInput>
  }

  export type BuildUpsertWithoutArchivedTouchInput = {
    update: XOR<BuildUpdateWithoutArchivedTouchInput, BuildUncheckedUpdateWithoutArchivedTouchInput>
    create: XOR<BuildCreateWithoutArchivedTouchInput, BuildUncheckedCreateWithoutArchivedTouchInput>
    where?: BuildWhereInput
  }

  export type BuildUpdateToOneWithWhereWithoutArchivedTouchInput = {
    where?: BuildWhereInput
    data: XOR<BuildUpdateWithoutArchivedTouchInput, BuildUncheckedUpdateWithoutArchivedTouchInput>
  }

  export type BuildUpdateWithoutArchivedTouchInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutBuildNestedInput
    editedBy?: UserUpdateOneWithoutBuildEditedByNestedInput
    recipe?: RecipeUpdateOneWithoutBuildNestedInput
    touch?: TouchUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateWithoutArchivedTouchInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeId?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutBuildNestedInput
  }

  export type GenericIngredientUpsertWithoutArchivedTouchInput = {
    update: XOR<GenericIngredientUpdateWithoutArchivedTouchInput, GenericIngredientUncheckedUpdateWithoutArchivedTouchInput>
    create: XOR<GenericIngredientCreateWithoutArchivedTouchInput, GenericIngredientUncheckedCreateWithoutArchivedTouchInput>
    where?: GenericIngredientWhereInput
  }

  export type GenericIngredientUpdateToOneWithWhereWithoutArchivedTouchInput = {
    where?: GenericIngredientWhereInput
    data: XOR<GenericIngredientUpdateWithoutArchivedTouchInput, GenericIngredientUncheckedUpdateWithoutArchivedTouchInput>
  }

  export type GenericIngredientUpdateWithoutArchivedTouchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUpdateManyWithoutGenericIngredientNestedInput
    specificIngredient?: SpecificIngredientUpdateManyWithoutGenericIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutGenericIngredientNestedInput
  }

  export type GenericIngredientUncheckedUpdateWithoutArchivedTouchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutGenericIngredientNestedInput
    specificIngredient?: SpecificIngredientUncheckedUpdateManyWithoutGenericIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutGenericIngredientNestedInput
  }

  export type SpecificIngredientUpsertWithoutArchivedTouchInput = {
    update: XOR<SpecificIngredientUpdateWithoutArchivedTouchInput, SpecificIngredientUncheckedUpdateWithoutArchivedTouchInput>
    create: XOR<SpecificIngredientCreateWithoutArchivedTouchInput, SpecificIngredientUncheckedCreateWithoutArchivedTouchInput>
    where?: SpecificIngredientWhereInput
  }

  export type SpecificIngredientUpdateToOneWithWhereWithoutArchivedTouchInput = {
    where?: SpecificIngredientWhereInput
    data: XOR<SpecificIngredientUpdateWithoutArchivedTouchInput, SpecificIngredientUncheckedUpdateWithoutArchivedTouchInput>
  }

  export type SpecificIngredientUpdateWithoutArchivedTouchInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutIngredientNestedInput
    genericIngredient?: GenericIngredientUpdateOneRequiredWithoutSpecificIngredientNestedInput
    touch?: TouchUpdateManyWithoutSpecificIngredientNestedInput
    ingredientStorage?: IngredientStorageUpdateManyWithoutIngredientNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutSpecificIngredientNestedInput
  }

  export type SpecificIngredientUncheckedUpdateWithoutArchivedTouchInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    genericIngredientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutSpecificIngredientNestedInput
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutSpecificIngredientNestedInput
  }

  export type TouchCreateWithoutGenericIngredientInput = {
    id?: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    version?: number | null
    build: BuildCreateNestedOneWithoutTouchInput
    specificIngredient?: SpecificIngredientCreateNestedOneWithoutTouchInput
  }

  export type TouchUncheckedCreateWithoutGenericIngredientInput = {
    id?: string
    buildId: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    specificIngredientId?: string | null
    version?: number | null
  }

  export type TouchCreateOrConnectWithoutGenericIngredientInput = {
    where: TouchWhereUniqueInput
    create: XOR<TouchCreateWithoutGenericIngredientInput, TouchUncheckedCreateWithoutGenericIngredientInput>
  }

  export type TouchCreateManyGenericIngredientInputEnvelope = {
    data: TouchCreateManyGenericIngredientInput | TouchCreateManyGenericIngredientInput[]
    skipDuplicates?: boolean
  }

  export type ArchivedTouchCreateWithoutGenericIngredientInput = {
    id?: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    version?: number | null
    build: BuildCreateNestedOneWithoutArchivedTouchInput
    specificIngredient?: SpecificIngredientCreateNestedOneWithoutArchivedTouchInput
  }

  export type ArchivedTouchUncheckedCreateWithoutGenericIngredientInput = {
    id?: string
    buildId: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    specificIngredientId?: string | null
    version?: number | null
  }

  export type ArchivedTouchCreateOrConnectWithoutGenericIngredientInput = {
    where: ArchivedTouchWhereUniqueInput
    create: XOR<ArchivedTouchCreateWithoutGenericIngredientInput, ArchivedTouchUncheckedCreateWithoutGenericIngredientInput>
  }

  export type ArchivedTouchCreateManyGenericIngredientInputEnvelope = {
    data: ArchivedTouchCreateManyGenericIngredientInput | ArchivedTouchCreateManyGenericIngredientInput[]
    skipDuplicates?: boolean
  }

  export type SpecificIngredientCreateWithoutGenericIngredientInput = {
    id?: string
    dateCreated?: Date | string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    createdBy?: UserCreateNestedOneWithoutIngredientInput
    touch?: TouchCreateNestedManyWithoutSpecificIngredientInput
    archivedTouch?: ArchivedTouchCreateNestedManyWithoutSpecificIngredientInput
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutIngredientInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutSpecificIngredientInput
  }

  export type SpecificIngredientUncheckedCreateWithoutGenericIngredientInput = {
    id?: string
    dateCreated?: Date | string
    createdById?: string | null
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutSpecificIngredientInput
    archivedTouch?: ArchivedTouchUncheckedCreateNestedManyWithoutSpecificIngredientInput
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutIngredientInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutSpecificIngredientInput
  }

  export type SpecificIngredientCreateOrConnectWithoutGenericIngredientInput = {
    where: SpecificIngredientWhereUniqueInput
    create: XOR<SpecificIngredientCreateWithoutGenericIngredientInput, SpecificIngredientUncheckedCreateWithoutGenericIngredientInput>
  }

  export type SpecificIngredientCreateManyGenericIngredientInputEnvelope = {
    data: SpecificIngredientCreateManyGenericIngredientInput | SpecificIngredientCreateManyGenericIngredientInput[]
    skipDuplicates?: boolean
  }

  export type IngredientPreferenceCreateWithoutGenericIngredientInput = {
    specificIngredient: SpecificIngredientCreateNestedOneWithoutIngredientPreferenceInput
    user: UserCreateNestedOneWithoutIngredientPreferenceInput
  }

  export type IngredientPreferenceUncheckedCreateWithoutGenericIngredientInput = {
    specificIngredientId: string
    userId: string
  }

  export type IngredientPreferenceCreateOrConnectWithoutGenericIngredientInput = {
    where: IngredientPreferenceWhereUniqueInput
    create: XOR<IngredientPreferenceCreateWithoutGenericIngredientInput, IngredientPreferenceUncheckedCreateWithoutGenericIngredientInput>
  }

  export type IngredientPreferenceCreateManyGenericIngredientInputEnvelope = {
    data: IngredientPreferenceCreateManyGenericIngredientInput | IngredientPreferenceCreateManyGenericIngredientInput[]
    skipDuplicates?: boolean
  }

  export type TouchUpsertWithWhereUniqueWithoutGenericIngredientInput = {
    where: TouchWhereUniqueInput
    update: XOR<TouchUpdateWithoutGenericIngredientInput, TouchUncheckedUpdateWithoutGenericIngredientInput>
    create: XOR<TouchCreateWithoutGenericIngredientInput, TouchUncheckedCreateWithoutGenericIngredientInput>
  }

  export type TouchUpdateWithWhereUniqueWithoutGenericIngredientInput = {
    where: TouchWhereUniqueInput
    data: XOR<TouchUpdateWithoutGenericIngredientInput, TouchUncheckedUpdateWithoutGenericIngredientInput>
  }

  export type TouchUpdateManyWithWhereWithoutGenericIngredientInput = {
    where: TouchScalarWhereInput
    data: XOR<TouchUpdateManyMutationInput, TouchUncheckedUpdateManyWithoutGenericIngredientInput>
  }

  export type ArchivedTouchUpsertWithWhereUniqueWithoutGenericIngredientInput = {
    where: ArchivedTouchWhereUniqueInput
    update: XOR<ArchivedTouchUpdateWithoutGenericIngredientInput, ArchivedTouchUncheckedUpdateWithoutGenericIngredientInput>
    create: XOR<ArchivedTouchCreateWithoutGenericIngredientInput, ArchivedTouchUncheckedCreateWithoutGenericIngredientInput>
  }

  export type ArchivedTouchUpdateWithWhereUniqueWithoutGenericIngredientInput = {
    where: ArchivedTouchWhereUniqueInput
    data: XOR<ArchivedTouchUpdateWithoutGenericIngredientInput, ArchivedTouchUncheckedUpdateWithoutGenericIngredientInput>
  }

  export type ArchivedTouchUpdateManyWithWhereWithoutGenericIngredientInput = {
    where: ArchivedTouchScalarWhereInput
    data: XOR<ArchivedTouchUpdateManyMutationInput, ArchivedTouchUncheckedUpdateManyWithoutGenericIngredientInput>
  }

  export type SpecificIngredientUpsertWithWhereUniqueWithoutGenericIngredientInput = {
    where: SpecificIngredientWhereUniqueInput
    update: XOR<SpecificIngredientUpdateWithoutGenericIngredientInput, SpecificIngredientUncheckedUpdateWithoutGenericIngredientInput>
    create: XOR<SpecificIngredientCreateWithoutGenericIngredientInput, SpecificIngredientUncheckedCreateWithoutGenericIngredientInput>
  }

  export type SpecificIngredientUpdateWithWhereUniqueWithoutGenericIngredientInput = {
    where: SpecificIngredientWhereUniqueInput
    data: XOR<SpecificIngredientUpdateWithoutGenericIngredientInput, SpecificIngredientUncheckedUpdateWithoutGenericIngredientInput>
  }

  export type SpecificIngredientUpdateManyWithWhereWithoutGenericIngredientInput = {
    where: SpecificIngredientScalarWhereInput
    data: XOR<SpecificIngredientUpdateManyMutationInput, SpecificIngredientUncheckedUpdateManyWithoutGenericIngredientInput>
  }

  export type IngredientPreferenceUpsertWithWhereUniqueWithoutGenericIngredientInput = {
    where: IngredientPreferenceWhereUniqueInput
    update: XOR<IngredientPreferenceUpdateWithoutGenericIngredientInput, IngredientPreferenceUncheckedUpdateWithoutGenericIngredientInput>
    create: XOR<IngredientPreferenceCreateWithoutGenericIngredientInput, IngredientPreferenceUncheckedCreateWithoutGenericIngredientInput>
  }

  export type IngredientPreferenceUpdateWithWhereUniqueWithoutGenericIngredientInput = {
    where: IngredientPreferenceWhereUniqueInput
    data: XOR<IngredientPreferenceUpdateWithoutGenericIngredientInput, IngredientPreferenceUncheckedUpdateWithoutGenericIngredientInput>
  }

  export type IngredientPreferenceUpdateManyWithWhereWithoutGenericIngredientInput = {
    where: IngredientPreferenceScalarWhereInput
    data: XOR<IngredientPreferenceUpdateManyMutationInput, IngredientPreferenceUncheckedUpdateManyWithoutGenericIngredientInput>
  }

  export type UserCreateWithoutIngredientInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutIngredientInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutIngredientInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIngredientInput, UserUncheckedCreateWithoutIngredientInput>
  }

  export type GenericIngredientCreateWithoutSpecificIngredientInput = {
    id?: string
    name: string
    description?: string | null
    touch?: TouchCreateNestedManyWithoutGenericIngredientInput
    archivedTouch?: ArchivedTouchCreateNestedManyWithoutGenericIngredientInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutGenericIngredientInput
  }

  export type GenericIngredientUncheckedCreateWithoutSpecificIngredientInput = {
    id?: string
    name: string
    description?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutGenericIngredientInput
    archivedTouch?: ArchivedTouchUncheckedCreateNestedManyWithoutGenericIngredientInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutGenericIngredientInput
  }

  export type GenericIngredientCreateOrConnectWithoutSpecificIngredientInput = {
    where: GenericIngredientWhereUniqueInput
    create: XOR<GenericIngredientCreateWithoutSpecificIngredientInput, GenericIngredientUncheckedCreateWithoutSpecificIngredientInput>
  }

  export type TouchCreateWithoutSpecificIngredientInput = {
    id?: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    version?: number | null
    build: BuildCreateNestedOneWithoutTouchInput
    genericIngredient: GenericIngredientCreateNestedOneWithoutTouchInput
  }

  export type TouchUncheckedCreateWithoutSpecificIngredientInput = {
    id?: string
    buildId: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    genericIngredientId: string
    version?: number | null
  }

  export type TouchCreateOrConnectWithoutSpecificIngredientInput = {
    where: TouchWhereUniqueInput
    create: XOR<TouchCreateWithoutSpecificIngredientInput, TouchUncheckedCreateWithoutSpecificIngredientInput>
  }

  export type TouchCreateManySpecificIngredientInputEnvelope = {
    data: TouchCreateManySpecificIngredientInput | TouchCreateManySpecificIngredientInput[]
    skipDuplicates?: boolean
  }

  export type ArchivedTouchCreateWithoutSpecificIngredientInput = {
    id?: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    version?: number | null
    build: BuildCreateNestedOneWithoutArchivedTouchInput
    genericIngredient: GenericIngredientCreateNestedOneWithoutArchivedTouchInput
  }

  export type ArchivedTouchUncheckedCreateWithoutSpecificIngredientInput = {
    id?: string
    buildId: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    genericIngredientId: string
    version?: number | null
  }

  export type ArchivedTouchCreateOrConnectWithoutSpecificIngredientInput = {
    where: ArchivedTouchWhereUniqueInput
    create: XOR<ArchivedTouchCreateWithoutSpecificIngredientInput, ArchivedTouchUncheckedCreateWithoutSpecificIngredientInput>
  }

  export type ArchivedTouchCreateManySpecificIngredientInputEnvelope = {
    data: ArchivedTouchCreateManySpecificIngredientInput | ArchivedTouchCreateManySpecificIngredientInput[]
    skipDuplicates?: boolean
  }

  export type IngredientStorageCreateWithoutIngredientInput = {
    quantity?: number | null
    Storage: StorageCreateNestedOneWithoutIngredientStorageInput
  }

  export type IngredientStorageUncheckedCreateWithoutIngredientInput = {
    storageId: string
    quantity?: number | null
  }

  export type IngredientStorageCreateOrConnectWithoutIngredientInput = {
    where: IngredientStorageWhereUniqueInput
    create: XOR<IngredientStorageCreateWithoutIngredientInput, IngredientStorageUncheckedCreateWithoutIngredientInput>
  }

  export type IngredientStorageCreateManyIngredientInputEnvelope = {
    data: IngredientStorageCreateManyIngredientInput | IngredientStorageCreateManyIngredientInput[]
    skipDuplicates?: boolean
  }

  export type IngredientUserCreateWithoutIngredientInput = {
    permission: string
    user: UserCreateNestedOneWithoutIngredientUserInput
  }

  export type IngredientUserUncheckedCreateWithoutIngredientInput = {
    userId: string
    permission: string
  }

  export type IngredientUserCreateOrConnectWithoutIngredientInput = {
    where: IngredientUserWhereUniqueInput
    create: XOR<IngredientUserCreateWithoutIngredientInput, IngredientUserUncheckedCreateWithoutIngredientInput>
  }

  export type IngredientUserCreateManyIngredientInputEnvelope = {
    data: IngredientUserCreateManyIngredientInput | IngredientUserCreateManyIngredientInput[]
    skipDuplicates?: boolean
  }

  export type IngredientPreferenceCreateWithoutSpecificIngredientInput = {
    genericIngredient: GenericIngredientCreateNestedOneWithoutIngredientPreferenceInput
    user: UserCreateNestedOneWithoutIngredientPreferenceInput
  }

  export type IngredientPreferenceUncheckedCreateWithoutSpecificIngredientInput = {
    genericIngredientId: string
    userId: string
  }

  export type IngredientPreferenceCreateOrConnectWithoutSpecificIngredientInput = {
    where: IngredientPreferenceWhereUniqueInput
    create: XOR<IngredientPreferenceCreateWithoutSpecificIngredientInput, IngredientPreferenceUncheckedCreateWithoutSpecificIngredientInput>
  }

  export type IngredientPreferenceCreateManySpecificIngredientInputEnvelope = {
    data: IngredientPreferenceCreateManySpecificIngredientInput | IngredientPreferenceCreateManySpecificIngredientInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutIngredientInput = {
    update: XOR<UserUpdateWithoutIngredientInput, UserUncheckedUpdateWithoutIngredientInput>
    create: XOR<UserCreateWithoutIngredientInput, UserUncheckedCreateWithoutIngredientInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIngredientInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIngredientInput, UserUncheckedUpdateWithoutIngredientInput>
  }

  export type UserUpdateWithoutIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type GenericIngredientUpsertWithoutSpecificIngredientInput = {
    update: XOR<GenericIngredientUpdateWithoutSpecificIngredientInput, GenericIngredientUncheckedUpdateWithoutSpecificIngredientInput>
    create: XOR<GenericIngredientCreateWithoutSpecificIngredientInput, GenericIngredientUncheckedCreateWithoutSpecificIngredientInput>
    where?: GenericIngredientWhereInput
  }

  export type GenericIngredientUpdateToOneWithWhereWithoutSpecificIngredientInput = {
    where?: GenericIngredientWhereInput
    data: XOR<GenericIngredientUpdateWithoutSpecificIngredientInput, GenericIngredientUncheckedUpdateWithoutSpecificIngredientInput>
  }

  export type GenericIngredientUpdateWithoutSpecificIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUpdateManyWithoutGenericIngredientNestedInput
    archivedTouch?: ArchivedTouchUpdateManyWithoutGenericIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutGenericIngredientNestedInput
  }

  export type GenericIngredientUncheckedUpdateWithoutSpecificIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutGenericIngredientNestedInput
    archivedTouch?: ArchivedTouchUncheckedUpdateManyWithoutGenericIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutGenericIngredientNestedInput
  }

  export type TouchUpsertWithWhereUniqueWithoutSpecificIngredientInput = {
    where: TouchWhereUniqueInput
    update: XOR<TouchUpdateWithoutSpecificIngredientInput, TouchUncheckedUpdateWithoutSpecificIngredientInput>
    create: XOR<TouchCreateWithoutSpecificIngredientInput, TouchUncheckedCreateWithoutSpecificIngredientInput>
  }

  export type TouchUpdateWithWhereUniqueWithoutSpecificIngredientInput = {
    where: TouchWhereUniqueInput
    data: XOR<TouchUpdateWithoutSpecificIngredientInput, TouchUncheckedUpdateWithoutSpecificIngredientInput>
  }

  export type TouchUpdateManyWithWhereWithoutSpecificIngredientInput = {
    where: TouchScalarWhereInput
    data: XOR<TouchUpdateManyMutationInput, TouchUncheckedUpdateManyWithoutSpecificIngredientInput>
  }

  export type ArchivedTouchUpsertWithWhereUniqueWithoutSpecificIngredientInput = {
    where: ArchivedTouchWhereUniqueInput
    update: XOR<ArchivedTouchUpdateWithoutSpecificIngredientInput, ArchivedTouchUncheckedUpdateWithoutSpecificIngredientInput>
    create: XOR<ArchivedTouchCreateWithoutSpecificIngredientInput, ArchivedTouchUncheckedCreateWithoutSpecificIngredientInput>
  }

  export type ArchivedTouchUpdateWithWhereUniqueWithoutSpecificIngredientInput = {
    where: ArchivedTouchWhereUniqueInput
    data: XOR<ArchivedTouchUpdateWithoutSpecificIngredientInput, ArchivedTouchUncheckedUpdateWithoutSpecificIngredientInput>
  }

  export type ArchivedTouchUpdateManyWithWhereWithoutSpecificIngredientInput = {
    where: ArchivedTouchScalarWhereInput
    data: XOR<ArchivedTouchUpdateManyMutationInput, ArchivedTouchUncheckedUpdateManyWithoutSpecificIngredientInput>
  }

  export type IngredientStorageUpsertWithWhereUniqueWithoutIngredientInput = {
    where: IngredientStorageWhereUniqueInput
    update: XOR<IngredientStorageUpdateWithoutIngredientInput, IngredientStorageUncheckedUpdateWithoutIngredientInput>
    create: XOR<IngredientStorageCreateWithoutIngredientInput, IngredientStorageUncheckedCreateWithoutIngredientInput>
  }

  export type IngredientStorageUpdateWithWhereUniqueWithoutIngredientInput = {
    where: IngredientStorageWhereUniqueInput
    data: XOR<IngredientStorageUpdateWithoutIngredientInput, IngredientStorageUncheckedUpdateWithoutIngredientInput>
  }

  export type IngredientStorageUpdateManyWithWhereWithoutIngredientInput = {
    where: IngredientStorageScalarWhereInput
    data: XOR<IngredientStorageUpdateManyMutationInput, IngredientStorageUncheckedUpdateManyWithoutIngredientInput>
  }

  export type IngredientStorageScalarWhereInput = {
    AND?: IngredientStorageScalarWhereInput | IngredientStorageScalarWhereInput[]
    OR?: IngredientStorageScalarWhereInput[]
    NOT?: IngredientStorageScalarWhereInput | IngredientStorageScalarWhereInput[]
    ingredientId?: StringFilter<"IngredientStorage"> | string
    storageId?: StringFilter<"IngredientStorage"> | string
    quantity?: FloatNullableFilter<"IngredientStorage"> | number | null
  }

  export type IngredientUserUpsertWithWhereUniqueWithoutIngredientInput = {
    where: IngredientUserWhereUniqueInput
    update: XOR<IngredientUserUpdateWithoutIngredientInput, IngredientUserUncheckedUpdateWithoutIngredientInput>
    create: XOR<IngredientUserCreateWithoutIngredientInput, IngredientUserUncheckedCreateWithoutIngredientInput>
  }

  export type IngredientUserUpdateWithWhereUniqueWithoutIngredientInput = {
    where: IngredientUserWhereUniqueInput
    data: XOR<IngredientUserUpdateWithoutIngredientInput, IngredientUserUncheckedUpdateWithoutIngredientInput>
  }

  export type IngredientUserUpdateManyWithWhereWithoutIngredientInput = {
    where: IngredientUserScalarWhereInput
    data: XOR<IngredientUserUpdateManyMutationInput, IngredientUserUncheckedUpdateManyWithoutIngredientInput>
  }

  export type IngredientPreferenceUpsertWithWhereUniqueWithoutSpecificIngredientInput = {
    where: IngredientPreferenceWhereUniqueInput
    update: XOR<IngredientPreferenceUpdateWithoutSpecificIngredientInput, IngredientPreferenceUncheckedUpdateWithoutSpecificIngredientInput>
    create: XOR<IngredientPreferenceCreateWithoutSpecificIngredientInput, IngredientPreferenceUncheckedCreateWithoutSpecificIngredientInput>
  }

  export type IngredientPreferenceUpdateWithWhereUniqueWithoutSpecificIngredientInput = {
    where: IngredientPreferenceWhereUniqueInput
    data: XOR<IngredientPreferenceUpdateWithoutSpecificIngredientInput, IngredientPreferenceUncheckedUpdateWithoutSpecificIngredientInput>
  }

  export type IngredientPreferenceUpdateManyWithWhereWithoutSpecificIngredientInput = {
    where: IngredientPreferenceScalarWhereInput
    data: XOR<IngredientPreferenceUpdateManyMutationInput, IngredientPreferenceUncheckedUpdateManyWithoutSpecificIngredientInput>
  }

  export type UserCreateWithoutIngredientUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutIngredientUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutIngredientUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIngredientUserInput, UserUncheckedCreateWithoutIngredientUserInput>
  }

  export type SpecificIngredientCreateWithoutIngredientUserInput = {
    id?: string
    dateCreated?: Date | string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    createdBy?: UserCreateNestedOneWithoutIngredientInput
    genericIngredient: GenericIngredientCreateNestedOneWithoutSpecificIngredientInput
    touch?: TouchCreateNestedManyWithoutSpecificIngredientInput
    archivedTouch?: ArchivedTouchCreateNestedManyWithoutSpecificIngredientInput
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutSpecificIngredientInput
  }

  export type SpecificIngredientUncheckedCreateWithoutIngredientUserInput = {
    id?: string
    dateCreated?: Date | string
    createdById?: string | null
    genericIngredientId: string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutSpecificIngredientInput
    archivedTouch?: ArchivedTouchUncheckedCreateNestedManyWithoutSpecificIngredientInput
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutSpecificIngredientInput
  }

  export type SpecificIngredientCreateOrConnectWithoutIngredientUserInput = {
    where: SpecificIngredientWhereUniqueInput
    create: XOR<SpecificIngredientCreateWithoutIngredientUserInput, SpecificIngredientUncheckedCreateWithoutIngredientUserInput>
  }

  export type UserUpsertWithoutIngredientUserInput = {
    update: XOR<UserUpdateWithoutIngredientUserInput, UserUncheckedUpdateWithoutIngredientUserInput>
    create: XOR<UserCreateWithoutIngredientUserInput, UserUncheckedCreateWithoutIngredientUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIngredientUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIngredientUserInput, UserUncheckedUpdateWithoutIngredientUserInput>
  }

  export type UserUpdateWithoutIngredientUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutIngredientUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type SpecificIngredientUpsertWithoutIngredientUserInput = {
    update: XOR<SpecificIngredientUpdateWithoutIngredientUserInput, SpecificIngredientUncheckedUpdateWithoutIngredientUserInput>
    create: XOR<SpecificIngredientCreateWithoutIngredientUserInput, SpecificIngredientUncheckedCreateWithoutIngredientUserInput>
    where?: SpecificIngredientWhereInput
  }

  export type SpecificIngredientUpdateToOneWithWhereWithoutIngredientUserInput = {
    where?: SpecificIngredientWhereInput
    data: XOR<SpecificIngredientUpdateWithoutIngredientUserInput, SpecificIngredientUncheckedUpdateWithoutIngredientUserInput>
  }

  export type SpecificIngredientUpdateWithoutIngredientUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutIngredientNestedInput
    genericIngredient?: GenericIngredientUpdateOneRequiredWithoutSpecificIngredientNestedInput
    touch?: TouchUpdateManyWithoutSpecificIngredientNestedInput
    archivedTouch?: ArchivedTouchUpdateManyWithoutSpecificIngredientNestedInput
    ingredientStorage?: IngredientStorageUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutSpecificIngredientNestedInput
  }

  export type SpecificIngredientUncheckedUpdateWithoutIngredientUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    genericIngredientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutSpecificIngredientNestedInput
    archivedTouch?: ArchivedTouchUncheckedUpdateManyWithoutSpecificIngredientNestedInput
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutSpecificIngredientNestedInput
  }

  export type GenericIngredientCreateWithoutIngredientPreferenceInput = {
    id?: string
    name: string
    description?: string | null
    touch?: TouchCreateNestedManyWithoutGenericIngredientInput
    archivedTouch?: ArchivedTouchCreateNestedManyWithoutGenericIngredientInput
    specificIngredient?: SpecificIngredientCreateNestedManyWithoutGenericIngredientInput
  }

  export type GenericIngredientUncheckedCreateWithoutIngredientPreferenceInput = {
    id?: string
    name: string
    description?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutGenericIngredientInput
    archivedTouch?: ArchivedTouchUncheckedCreateNestedManyWithoutGenericIngredientInput
    specificIngredient?: SpecificIngredientUncheckedCreateNestedManyWithoutGenericIngredientInput
  }

  export type GenericIngredientCreateOrConnectWithoutIngredientPreferenceInput = {
    where: GenericIngredientWhereUniqueInput
    create: XOR<GenericIngredientCreateWithoutIngredientPreferenceInput, GenericIngredientUncheckedCreateWithoutIngredientPreferenceInput>
  }

  export type SpecificIngredientCreateWithoutIngredientPreferenceInput = {
    id?: string
    dateCreated?: Date | string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    createdBy?: UserCreateNestedOneWithoutIngredientInput
    genericIngredient: GenericIngredientCreateNestedOneWithoutSpecificIngredientInput
    touch?: TouchCreateNestedManyWithoutSpecificIngredientInput
    archivedTouch?: ArchivedTouchCreateNestedManyWithoutSpecificIngredientInput
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutIngredientInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutIngredientInput
  }

  export type SpecificIngredientUncheckedCreateWithoutIngredientPreferenceInput = {
    id?: string
    dateCreated?: Date | string
    createdById?: string | null
    genericIngredientId: string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutSpecificIngredientInput
    archivedTouch?: ArchivedTouchUncheckedCreateNestedManyWithoutSpecificIngredientInput
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutIngredientInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutIngredientInput
  }

  export type SpecificIngredientCreateOrConnectWithoutIngredientPreferenceInput = {
    where: SpecificIngredientWhereUniqueInput
    create: XOR<SpecificIngredientCreateWithoutIngredientPreferenceInput, SpecificIngredientUncheckedCreateWithoutIngredientPreferenceInput>
  }

  export type UserCreateWithoutIngredientPreferenceInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutIngredientPreferenceInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutIngredientPreferenceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIngredientPreferenceInput, UserUncheckedCreateWithoutIngredientPreferenceInput>
  }

  export type GenericIngredientUpsertWithoutIngredientPreferenceInput = {
    update: XOR<GenericIngredientUpdateWithoutIngredientPreferenceInput, GenericIngredientUncheckedUpdateWithoutIngredientPreferenceInput>
    create: XOR<GenericIngredientCreateWithoutIngredientPreferenceInput, GenericIngredientUncheckedCreateWithoutIngredientPreferenceInput>
    where?: GenericIngredientWhereInput
  }

  export type GenericIngredientUpdateToOneWithWhereWithoutIngredientPreferenceInput = {
    where?: GenericIngredientWhereInput
    data: XOR<GenericIngredientUpdateWithoutIngredientPreferenceInput, GenericIngredientUncheckedUpdateWithoutIngredientPreferenceInput>
  }

  export type GenericIngredientUpdateWithoutIngredientPreferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUpdateManyWithoutGenericIngredientNestedInput
    archivedTouch?: ArchivedTouchUpdateManyWithoutGenericIngredientNestedInput
    specificIngredient?: SpecificIngredientUpdateManyWithoutGenericIngredientNestedInput
  }

  export type GenericIngredientUncheckedUpdateWithoutIngredientPreferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutGenericIngredientNestedInput
    archivedTouch?: ArchivedTouchUncheckedUpdateManyWithoutGenericIngredientNestedInput
    specificIngredient?: SpecificIngredientUncheckedUpdateManyWithoutGenericIngredientNestedInput
  }

  export type SpecificIngredientUpsertWithoutIngredientPreferenceInput = {
    update: XOR<SpecificIngredientUpdateWithoutIngredientPreferenceInput, SpecificIngredientUncheckedUpdateWithoutIngredientPreferenceInput>
    create: XOR<SpecificIngredientCreateWithoutIngredientPreferenceInput, SpecificIngredientUncheckedCreateWithoutIngredientPreferenceInput>
    where?: SpecificIngredientWhereInput
  }

  export type SpecificIngredientUpdateToOneWithWhereWithoutIngredientPreferenceInput = {
    where?: SpecificIngredientWhereInput
    data: XOR<SpecificIngredientUpdateWithoutIngredientPreferenceInput, SpecificIngredientUncheckedUpdateWithoutIngredientPreferenceInput>
  }

  export type SpecificIngredientUpdateWithoutIngredientPreferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutIngredientNestedInput
    genericIngredient?: GenericIngredientUpdateOneRequiredWithoutSpecificIngredientNestedInput
    touch?: TouchUpdateManyWithoutSpecificIngredientNestedInput
    archivedTouch?: ArchivedTouchUpdateManyWithoutSpecificIngredientNestedInput
    ingredientStorage?: IngredientStorageUpdateManyWithoutIngredientNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutIngredientNestedInput
  }

  export type SpecificIngredientUncheckedUpdateWithoutIngredientPreferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    genericIngredientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutSpecificIngredientNestedInput
    archivedTouch?: ArchivedTouchUncheckedUpdateManyWithoutSpecificIngredientNestedInput
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutIngredientNestedInput
  }

  export type UserUpsertWithoutIngredientPreferenceInput = {
    update: XOR<UserUpdateWithoutIngredientPreferenceInput, UserUncheckedUpdateWithoutIngredientPreferenceInput>
    create: XOR<UserCreateWithoutIngredientPreferenceInput, UserUncheckedCreateWithoutIngredientPreferenceInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIngredientPreferenceInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIngredientPreferenceInput, UserUncheckedUpdateWithoutIngredientPreferenceInput>
  }

  export type UserUpdateWithoutIngredientPreferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutIngredientPreferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type UserCreateWithoutInventoryInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutInventoryInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutInventoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInventoryInput, UserUncheckedCreateWithoutInventoryInput>
  }

  export type UserCreateWithoutInventoryEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutInventoryEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutInventoryEditedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInventoryEditedByInput, UserUncheckedCreateWithoutInventoryEditedByInput>
  }

  export type InventoryStorageCreateWithoutInventoryInput = {
    storage: StorageCreateNestedOneWithoutInventoryStorageInput
  }

  export type InventoryStorageUncheckedCreateWithoutInventoryInput = {
    storageId: string
  }

  export type InventoryStorageCreateOrConnectWithoutInventoryInput = {
    where: InventoryStorageWhereUniqueInput
    create: XOR<InventoryStorageCreateWithoutInventoryInput, InventoryStorageUncheckedCreateWithoutInventoryInput>
  }

  export type InventoryStorageCreateManyInventoryInputEnvelope = {
    data: InventoryStorageCreateManyInventoryInput | InventoryStorageCreateManyInventoryInput[]
    skipDuplicates?: boolean
  }

  export type InventoryUserCreateWithoutInventoryInput = {
    permission: string
    user: UserCreateNestedOneWithoutInventoryUserInput
  }

  export type InventoryUserUncheckedCreateWithoutInventoryInput = {
    userId: string
    permission: string
  }

  export type InventoryUserCreateOrConnectWithoutInventoryInput = {
    where: InventoryUserWhereUniqueInput
    create: XOR<InventoryUserCreateWithoutInventoryInput, InventoryUserUncheckedCreateWithoutInventoryInput>
  }

  export type InventoryUserCreateManyInventoryInputEnvelope = {
    data: InventoryUserCreateManyInventoryInput | InventoryUserCreateManyInventoryInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutInventoryInput = {
    update: XOR<UserUpdateWithoutInventoryInput, UserUncheckedUpdateWithoutInventoryInput>
    create: XOR<UserCreateWithoutInventoryInput, UserUncheckedCreateWithoutInventoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInventoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInventoryInput, UserUncheckedUpdateWithoutInventoryInput>
  }

  export type UserUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type UserUpsertWithoutInventoryEditedByInput = {
    update: XOR<UserUpdateWithoutInventoryEditedByInput, UserUncheckedUpdateWithoutInventoryEditedByInput>
    create: XOR<UserCreateWithoutInventoryEditedByInput, UserUncheckedCreateWithoutInventoryEditedByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInventoryEditedByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInventoryEditedByInput, UserUncheckedUpdateWithoutInventoryEditedByInput>
  }

  export type UserUpdateWithoutInventoryEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutInventoryEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type InventoryStorageUpsertWithWhereUniqueWithoutInventoryInput = {
    where: InventoryStorageWhereUniqueInput
    update: XOR<InventoryStorageUpdateWithoutInventoryInput, InventoryStorageUncheckedUpdateWithoutInventoryInput>
    create: XOR<InventoryStorageCreateWithoutInventoryInput, InventoryStorageUncheckedCreateWithoutInventoryInput>
  }

  export type InventoryStorageUpdateWithWhereUniqueWithoutInventoryInput = {
    where: InventoryStorageWhereUniqueInput
    data: XOR<InventoryStorageUpdateWithoutInventoryInput, InventoryStorageUncheckedUpdateWithoutInventoryInput>
  }

  export type InventoryStorageUpdateManyWithWhereWithoutInventoryInput = {
    where: InventoryStorageScalarWhereInput
    data: XOR<InventoryStorageUpdateManyMutationInput, InventoryStorageUncheckedUpdateManyWithoutInventoryInput>
  }

  export type InventoryStorageScalarWhereInput = {
    AND?: InventoryStorageScalarWhereInput | InventoryStorageScalarWhereInput[]
    OR?: InventoryStorageScalarWhereInput[]
    NOT?: InventoryStorageScalarWhereInput | InventoryStorageScalarWhereInput[]
    inventoryId?: StringFilter<"InventoryStorage"> | string
    storageId?: StringFilter<"InventoryStorage"> | string
  }

  export type InventoryUserUpsertWithWhereUniqueWithoutInventoryInput = {
    where: InventoryUserWhereUniqueInput
    update: XOR<InventoryUserUpdateWithoutInventoryInput, InventoryUserUncheckedUpdateWithoutInventoryInput>
    create: XOR<InventoryUserCreateWithoutInventoryInput, InventoryUserUncheckedCreateWithoutInventoryInput>
  }

  export type InventoryUserUpdateWithWhereUniqueWithoutInventoryInput = {
    where: InventoryUserWhereUniqueInput
    data: XOR<InventoryUserUpdateWithoutInventoryInput, InventoryUserUncheckedUpdateWithoutInventoryInput>
  }

  export type InventoryUserUpdateManyWithWhereWithoutInventoryInput = {
    where: InventoryUserScalarWhereInput
    data: XOR<InventoryUserUpdateManyMutationInput, InventoryUserUncheckedUpdateManyWithoutInventoryInput>
  }

  export type UserCreateWithoutInventoryUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutInventoryUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutInventoryUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInventoryUserInput, UserUncheckedCreateWithoutInventoryUserInput>
  }

  export type InventoryCreateWithoutInventoryUserInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutInventoryInput
    editedBy?: UserCreateNestedOneWithoutInventoryEditedByInput
    inventoryStorage?: InventoryStorageCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutInventoryUserInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    inventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryCreateOrConnectWithoutInventoryUserInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutInventoryUserInput, InventoryUncheckedCreateWithoutInventoryUserInput>
  }

  export type UserUpsertWithoutInventoryUserInput = {
    update: XOR<UserUpdateWithoutInventoryUserInput, UserUncheckedUpdateWithoutInventoryUserInput>
    create: XOR<UserCreateWithoutInventoryUserInput, UserUncheckedCreateWithoutInventoryUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInventoryUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInventoryUserInput, UserUncheckedUpdateWithoutInventoryUserInput>
  }

  export type UserUpdateWithoutInventoryUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutInventoryUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type InventoryUpsertWithoutInventoryUserInput = {
    update: XOR<InventoryUpdateWithoutInventoryUserInput, InventoryUncheckedUpdateWithoutInventoryUserInput>
    create: XOR<InventoryCreateWithoutInventoryUserInput, InventoryUncheckedCreateWithoutInventoryUserInput>
    where?: InventoryWhereInput
  }

  export type InventoryUpdateToOneWithWhereWithoutInventoryUserInput = {
    where?: InventoryWhereInput
    data: XOR<InventoryUpdateWithoutInventoryUserInput, InventoryUncheckedUpdateWithoutInventoryUserInput>
  }

  export type InventoryUpdateWithoutInventoryUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutInventoryNestedInput
    editedBy?: UserUpdateOneWithoutInventoryEditedByNestedInput
    inventoryStorage?: InventoryStorageUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutInventoryUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    inventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type UserCreateWithoutStorageInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutStorageInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutStorageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStorageInput, UserUncheckedCreateWithoutStorageInput>
  }

  export type UserCreateWithoutStorageEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutStorageEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutStorageEditedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStorageEditedByInput, UserUncheckedCreateWithoutStorageEditedByInput>
  }

  export type InventoryStorageCreateWithoutStorageInput = {
    inventory: InventoryCreateNestedOneWithoutInventoryStorageInput
  }

  export type InventoryStorageUncheckedCreateWithoutStorageInput = {
    inventoryId: string
  }

  export type InventoryStorageCreateOrConnectWithoutStorageInput = {
    where: InventoryStorageWhereUniqueInput
    create: XOR<InventoryStorageCreateWithoutStorageInput, InventoryStorageUncheckedCreateWithoutStorageInput>
  }

  export type InventoryStorageCreateManyStorageInputEnvelope = {
    data: InventoryStorageCreateManyStorageInput | InventoryStorageCreateManyStorageInput[]
    skipDuplicates?: boolean
  }

  export type IngredientStorageCreateWithoutStorageInput = {
    quantity?: number | null
    ingredient: SpecificIngredientCreateNestedOneWithoutIngredientStorageInput
  }

  export type IngredientStorageUncheckedCreateWithoutStorageInput = {
    ingredientId: string
    quantity?: number | null
  }

  export type IngredientStorageCreateOrConnectWithoutStorageInput = {
    where: IngredientStorageWhereUniqueInput
    create: XOR<IngredientStorageCreateWithoutStorageInput, IngredientStorageUncheckedCreateWithoutStorageInput>
  }

  export type IngredientStorageCreateManyStorageInputEnvelope = {
    data: IngredientStorageCreateManyStorageInput | IngredientStorageCreateManyStorageInput[]
    skipDuplicates?: boolean
  }

  export type StorageUserCreateWithoutStorageInput = {
    permission: string
    user: UserCreateNestedOneWithoutStorageUserInput
  }

  export type StorageUserUncheckedCreateWithoutStorageInput = {
    userId: string
    permission: string
  }

  export type StorageUserCreateOrConnectWithoutStorageInput = {
    where: StorageUserWhereUniqueInput
    create: XOR<StorageUserCreateWithoutStorageInput, StorageUserUncheckedCreateWithoutStorageInput>
  }

  export type StorageUserCreateManyStorageInputEnvelope = {
    data: StorageUserCreateManyStorageInput | StorageUserCreateManyStorageInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutStorageInput = {
    update: XOR<UserUpdateWithoutStorageInput, UserUncheckedUpdateWithoutStorageInput>
    create: XOR<UserCreateWithoutStorageInput, UserUncheckedCreateWithoutStorageInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStorageInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStorageInput, UserUncheckedUpdateWithoutStorageInput>
  }

  export type UserUpdateWithoutStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type UserUpsertWithoutStorageEditedByInput = {
    update: XOR<UserUpdateWithoutStorageEditedByInput, UserUncheckedUpdateWithoutStorageEditedByInput>
    create: XOR<UserCreateWithoutStorageEditedByInput, UserUncheckedCreateWithoutStorageEditedByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStorageEditedByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStorageEditedByInput, UserUncheckedUpdateWithoutStorageEditedByInput>
  }

  export type UserUpdateWithoutStorageEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutStorageEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type InventoryStorageUpsertWithWhereUniqueWithoutStorageInput = {
    where: InventoryStorageWhereUniqueInput
    update: XOR<InventoryStorageUpdateWithoutStorageInput, InventoryStorageUncheckedUpdateWithoutStorageInput>
    create: XOR<InventoryStorageCreateWithoutStorageInput, InventoryStorageUncheckedCreateWithoutStorageInput>
  }

  export type InventoryStorageUpdateWithWhereUniqueWithoutStorageInput = {
    where: InventoryStorageWhereUniqueInput
    data: XOR<InventoryStorageUpdateWithoutStorageInput, InventoryStorageUncheckedUpdateWithoutStorageInput>
  }

  export type InventoryStorageUpdateManyWithWhereWithoutStorageInput = {
    where: InventoryStorageScalarWhereInput
    data: XOR<InventoryStorageUpdateManyMutationInput, InventoryStorageUncheckedUpdateManyWithoutStorageInput>
  }

  export type IngredientStorageUpsertWithWhereUniqueWithoutStorageInput = {
    where: IngredientStorageWhereUniqueInput
    update: XOR<IngredientStorageUpdateWithoutStorageInput, IngredientStorageUncheckedUpdateWithoutStorageInput>
    create: XOR<IngredientStorageCreateWithoutStorageInput, IngredientStorageUncheckedCreateWithoutStorageInput>
  }

  export type IngredientStorageUpdateWithWhereUniqueWithoutStorageInput = {
    where: IngredientStorageWhereUniqueInput
    data: XOR<IngredientStorageUpdateWithoutStorageInput, IngredientStorageUncheckedUpdateWithoutStorageInput>
  }

  export type IngredientStorageUpdateManyWithWhereWithoutStorageInput = {
    where: IngredientStorageScalarWhereInput
    data: XOR<IngredientStorageUpdateManyMutationInput, IngredientStorageUncheckedUpdateManyWithoutStorageInput>
  }

  export type StorageUserUpsertWithWhereUniqueWithoutStorageInput = {
    where: StorageUserWhereUniqueInput
    update: XOR<StorageUserUpdateWithoutStorageInput, StorageUserUncheckedUpdateWithoutStorageInput>
    create: XOR<StorageUserCreateWithoutStorageInput, StorageUserUncheckedCreateWithoutStorageInput>
  }

  export type StorageUserUpdateWithWhereUniqueWithoutStorageInput = {
    where: StorageUserWhereUniqueInput
    data: XOR<StorageUserUpdateWithoutStorageInput, StorageUserUncheckedUpdateWithoutStorageInput>
  }

  export type StorageUserUpdateManyWithWhereWithoutStorageInput = {
    where: StorageUserScalarWhereInput
    data: XOR<StorageUserUpdateManyMutationInput, StorageUserUncheckedUpdateManyWithoutStorageInput>
  }

  export type StorageCreateWithoutInventoryStorageInput = {
    id?: string
    name: string
    description?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutStorageInput
    editedBy?: UserCreateNestedOneWithoutStorageEditedByInput
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutStorageInput
    storageUser?: StorageUserCreateNestedManyWithoutStorageInput
  }

  export type StorageUncheckedCreateWithoutInventoryStorageInput = {
    id?: string
    name: string
    description?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutStorageInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutStorageInput
  }

  export type StorageCreateOrConnectWithoutInventoryStorageInput = {
    where: StorageWhereUniqueInput
    create: XOR<StorageCreateWithoutInventoryStorageInput, StorageUncheckedCreateWithoutInventoryStorageInput>
  }

  export type InventoryCreateWithoutInventoryStorageInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutInventoryInput
    editedBy?: UserCreateNestedOneWithoutInventoryEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutInventoryStorageInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryCreateOrConnectWithoutInventoryStorageInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutInventoryStorageInput, InventoryUncheckedCreateWithoutInventoryStorageInput>
  }

  export type StorageUpsertWithoutInventoryStorageInput = {
    update: XOR<StorageUpdateWithoutInventoryStorageInput, StorageUncheckedUpdateWithoutInventoryStorageInput>
    create: XOR<StorageCreateWithoutInventoryStorageInput, StorageUncheckedCreateWithoutInventoryStorageInput>
    where?: StorageWhereInput
  }

  export type StorageUpdateToOneWithWhereWithoutInventoryStorageInput = {
    where?: StorageWhereInput
    data: XOR<StorageUpdateWithoutInventoryStorageInput, StorageUncheckedUpdateWithoutInventoryStorageInput>
  }

  export type StorageUpdateWithoutInventoryStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutStorageNestedInput
    editedBy?: UserUpdateOneWithoutStorageEditedByNestedInput
    ingredientStorage?: IngredientStorageUpdateManyWithoutStorageNestedInput
    storageUser?: StorageUserUpdateManyWithoutStorageNestedInput
  }

  export type StorageUncheckedUpdateWithoutInventoryStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutStorageNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutStorageNestedInput
  }

  export type InventoryUpsertWithoutInventoryStorageInput = {
    update: XOR<InventoryUpdateWithoutInventoryStorageInput, InventoryUncheckedUpdateWithoutInventoryStorageInput>
    create: XOR<InventoryCreateWithoutInventoryStorageInput, InventoryUncheckedCreateWithoutInventoryStorageInput>
    where?: InventoryWhereInput
  }

  export type InventoryUpdateToOneWithWhereWithoutInventoryStorageInput = {
    where?: InventoryWhereInput
    data: XOR<InventoryUpdateWithoutInventoryStorageInput, InventoryUncheckedUpdateWithoutInventoryStorageInput>
  }

  export type InventoryUpdateWithoutInventoryStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutInventoryNestedInput
    editedBy?: UserUpdateOneWithoutInventoryEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutInventoryStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type SpecificIngredientCreateWithoutIngredientStorageInput = {
    id?: string
    dateCreated?: Date | string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    createdBy?: UserCreateNestedOneWithoutIngredientInput
    genericIngredient: GenericIngredientCreateNestedOneWithoutSpecificIngredientInput
    touch?: TouchCreateNestedManyWithoutSpecificIngredientInput
    archivedTouch?: ArchivedTouchCreateNestedManyWithoutSpecificIngredientInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutSpecificIngredientInput
  }

  export type SpecificIngredientUncheckedCreateWithoutIngredientStorageInput = {
    id?: string
    dateCreated?: Date | string
    createdById?: string | null
    genericIngredientId: string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutSpecificIngredientInput
    archivedTouch?: ArchivedTouchUncheckedCreateNestedManyWithoutSpecificIngredientInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutSpecificIngredientInput
  }

  export type SpecificIngredientCreateOrConnectWithoutIngredientStorageInput = {
    where: SpecificIngredientWhereUniqueInput
    create: XOR<SpecificIngredientCreateWithoutIngredientStorageInput, SpecificIngredientUncheckedCreateWithoutIngredientStorageInput>
  }

  export type StorageCreateWithoutIngredientStorageInput = {
    id?: string
    name: string
    description?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutStorageInput
    editedBy?: UserCreateNestedOneWithoutStorageEditedByInput
    inventoryStorage?: InventoryStorageCreateNestedManyWithoutStorageInput
    storageUser?: StorageUserCreateNestedManyWithoutStorageInput
  }

  export type StorageUncheckedCreateWithoutIngredientStorageInput = {
    id?: string
    name: string
    description?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    inventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutStorageInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutStorageInput
  }

  export type StorageCreateOrConnectWithoutIngredientStorageInput = {
    where: StorageWhereUniqueInput
    create: XOR<StorageCreateWithoutIngredientStorageInput, StorageUncheckedCreateWithoutIngredientStorageInput>
  }

  export type SpecificIngredientUpsertWithoutIngredientStorageInput = {
    update: XOR<SpecificIngredientUpdateWithoutIngredientStorageInput, SpecificIngredientUncheckedUpdateWithoutIngredientStorageInput>
    create: XOR<SpecificIngredientCreateWithoutIngredientStorageInput, SpecificIngredientUncheckedCreateWithoutIngredientStorageInput>
    where?: SpecificIngredientWhereInput
  }

  export type SpecificIngredientUpdateToOneWithWhereWithoutIngredientStorageInput = {
    where?: SpecificIngredientWhereInput
    data: XOR<SpecificIngredientUpdateWithoutIngredientStorageInput, SpecificIngredientUncheckedUpdateWithoutIngredientStorageInput>
  }

  export type SpecificIngredientUpdateWithoutIngredientStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutIngredientNestedInput
    genericIngredient?: GenericIngredientUpdateOneRequiredWithoutSpecificIngredientNestedInput
    touch?: TouchUpdateManyWithoutSpecificIngredientNestedInput
    archivedTouch?: ArchivedTouchUpdateManyWithoutSpecificIngredientNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutSpecificIngredientNestedInput
  }

  export type SpecificIngredientUncheckedUpdateWithoutIngredientStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    genericIngredientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutSpecificIngredientNestedInput
    archivedTouch?: ArchivedTouchUncheckedUpdateManyWithoutSpecificIngredientNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutSpecificIngredientNestedInput
  }

  export type StorageUpsertWithoutIngredientStorageInput = {
    update: XOR<StorageUpdateWithoutIngredientStorageInput, StorageUncheckedUpdateWithoutIngredientStorageInput>
    create: XOR<StorageCreateWithoutIngredientStorageInput, StorageUncheckedCreateWithoutIngredientStorageInput>
    where?: StorageWhereInput
  }

  export type StorageUpdateToOneWithWhereWithoutIngredientStorageInput = {
    where?: StorageWhereInput
    data: XOR<StorageUpdateWithoutIngredientStorageInput, StorageUncheckedUpdateWithoutIngredientStorageInput>
  }

  export type StorageUpdateWithoutIngredientStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutStorageNestedInput
    editedBy?: UserUpdateOneWithoutStorageEditedByNestedInput
    inventoryStorage?: InventoryStorageUpdateManyWithoutStorageNestedInput
    storageUser?: StorageUserUpdateManyWithoutStorageNestedInput
  }

  export type StorageUncheckedUpdateWithoutIngredientStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    inventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutStorageNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutStorageNestedInput
  }

  export type UserCreateWithoutStorageUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutStorageUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutStorageUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStorageUserInput, UserUncheckedCreateWithoutStorageUserInput>
  }

  export type StorageCreateWithoutStorageUserInput = {
    id?: string
    name: string
    description?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutStorageInput
    editedBy?: UserCreateNestedOneWithoutStorageEditedByInput
    inventoryStorage?: InventoryStorageCreateNestedManyWithoutStorageInput
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutStorageInput
  }

  export type StorageUncheckedCreateWithoutStorageUserInput = {
    id?: string
    name: string
    description?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    inventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutStorageInput
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutStorageInput
  }

  export type StorageCreateOrConnectWithoutStorageUserInput = {
    where: StorageWhereUniqueInput
    create: XOR<StorageCreateWithoutStorageUserInput, StorageUncheckedCreateWithoutStorageUserInput>
  }

  export type UserUpsertWithoutStorageUserInput = {
    update: XOR<UserUpdateWithoutStorageUserInput, UserUncheckedUpdateWithoutStorageUserInput>
    create: XOR<UserCreateWithoutStorageUserInput, UserUncheckedCreateWithoutStorageUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStorageUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStorageUserInput, UserUncheckedUpdateWithoutStorageUserInput>
  }

  export type UserUpdateWithoutStorageUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutStorageUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type StorageUpsertWithoutStorageUserInput = {
    update: XOR<StorageUpdateWithoutStorageUserInput, StorageUncheckedUpdateWithoutStorageUserInput>
    create: XOR<StorageCreateWithoutStorageUserInput, StorageUncheckedCreateWithoutStorageUserInput>
    where?: StorageWhereInput
  }

  export type StorageUpdateToOneWithWhereWithoutStorageUserInput = {
    where?: StorageWhereInput
    data: XOR<StorageUpdateWithoutStorageUserInput, StorageUncheckedUpdateWithoutStorageUserInput>
  }

  export type StorageUpdateWithoutStorageUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutStorageNestedInput
    editedBy?: UserUpdateOneWithoutStorageEditedByNestedInput
    inventoryStorage?: InventoryStorageUpdateManyWithoutStorageNestedInput
    ingredientStorage?: IngredientStorageUpdateManyWithoutStorageNestedInput
  }

  export type StorageUncheckedUpdateWithoutStorageUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    inventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutStorageNestedInput
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutStorageNestedInput
  }

  export type UserCreateWithoutCrewInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserCreateNestedManyWithoutUserInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutCrewInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutCrewInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCrewInput, UserUncheckedCreateWithoutCrewInput>
  }

  export type UserCreateWithoutCrewEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutCrewEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    CrewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutCrewEditedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCrewEditedByInput, UserUncheckedCreateWithoutCrewEditedByInput>
  }

  export type CrewUserCreateWithoutCrewInput = {
    permission: string
    user: UserCreateNestedOneWithoutCrewUserInput
  }

  export type CrewUserUncheckedCreateWithoutCrewInput = {
    userId: string
    permission: string
  }

  export type CrewUserCreateOrConnectWithoutCrewInput = {
    where: CrewUserWhereUniqueInput
    create: XOR<CrewUserCreateWithoutCrewInput, CrewUserUncheckedCreateWithoutCrewInput>
  }

  export type CrewUserCreateManyCrewInputEnvelope = {
    data: CrewUserCreateManyCrewInput | CrewUserCreateManyCrewInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCrewInput = {
    update: XOR<UserUpdateWithoutCrewInput, UserUncheckedUpdateWithoutCrewInput>
    create: XOR<UserCreateWithoutCrewInput, UserUncheckedCreateWithoutCrewInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCrewInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCrewInput, UserUncheckedUpdateWithoutCrewInput>
  }

  export type UserUpdateWithoutCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type UserUpsertWithoutCrewEditedByInput = {
    update: XOR<UserUpdateWithoutCrewEditedByInput, UserUncheckedUpdateWithoutCrewEditedByInput>
    create: XOR<UserCreateWithoutCrewEditedByInput, UserUncheckedCreateWithoutCrewEditedByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCrewEditedByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCrewEditedByInput, UserUncheckedUpdateWithoutCrewEditedByInput>
  }

  export type UserUpdateWithoutCrewEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutCrewEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    CrewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type CrewUserUpsertWithWhereUniqueWithoutCrewInput = {
    where: CrewUserWhereUniqueInput
    update: XOR<CrewUserUpdateWithoutCrewInput, CrewUserUncheckedUpdateWithoutCrewInput>
    create: XOR<CrewUserCreateWithoutCrewInput, CrewUserUncheckedCreateWithoutCrewInput>
  }

  export type CrewUserUpdateWithWhereUniqueWithoutCrewInput = {
    where: CrewUserWhereUniqueInput
    data: XOR<CrewUserUpdateWithoutCrewInput, CrewUserUncheckedUpdateWithoutCrewInput>
  }

  export type CrewUserUpdateManyWithWhereWithoutCrewInput = {
    where: CrewUserScalarWhereInput
    data: XOR<CrewUserUpdateManyMutationInput, CrewUserUncheckedUpdateManyWithoutCrewInput>
  }

  export type UserCreateWithoutCrewUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutCrewUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutCrewUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCrewUserInput, UserUncheckedCreateWithoutCrewUserInput>
  }

  export type CrewCreateWithoutUserCrewInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCrewInput
    editedBy?: UserCreateNestedOneWithoutCrewEditedByInput
  }

  export type CrewUncheckedCreateWithoutUserCrewInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
  }

  export type CrewCreateOrConnectWithoutUserCrewInput = {
    where: CrewWhereUniqueInput
    create: XOR<CrewCreateWithoutUserCrewInput, CrewUncheckedCreateWithoutUserCrewInput>
  }

  export type UserUpsertWithoutCrewUserInput = {
    update: XOR<UserUpdateWithoutCrewUserInput, UserUncheckedUpdateWithoutCrewUserInput>
    create: XOR<UserCreateWithoutCrewUserInput, UserUncheckedCreateWithoutCrewUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCrewUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCrewUserInput, UserUncheckedUpdateWithoutCrewUserInput>
  }

  export type UserUpdateWithoutCrewUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutCrewUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type CrewUpsertWithoutUserCrewInput = {
    update: XOR<CrewUpdateWithoutUserCrewInput, CrewUncheckedUpdateWithoutUserCrewInput>
    create: XOR<CrewCreateWithoutUserCrewInput, CrewUncheckedCreateWithoutUserCrewInput>
    where?: CrewWhereInput
  }

  export type CrewUpdateToOneWithWhereWithoutUserCrewInput = {
    where?: CrewWhereInput
    data: XOR<CrewUpdateWithoutUserCrewInput, CrewUncheckedUpdateWithoutUserCrewInput>
  }

  export type CrewUpdateWithoutUserCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCrewNestedInput
    editedBy?: UserUpdateOneWithoutCrewEditedByNestedInput
  }

  export type CrewUncheckedUpdateWithoutUserCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookUserCreateManyUserInput = {
    recipeBookId: string
    permission: string
  }

  export type RecipeBookCreateManyCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    editedById?: string | null
  }

  export type RecipeBookCreateManyEditedByInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
  }

  export type RecipeCreateManyCreatedByInput = {
    id?: string
    createdAt?: Date | string
    editedAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    editedById?: string | null
  }

  export type RecipeCreateManyEditedByInput = {
    id?: string
    createdAt?: Date | string
    editedAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    createdById?: string | null
  }

  export type BuildUserCreateManyUserInput = {
    buildId: string
    permission: string
  }

  export type BuildCreateManyCreatedByInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedById?: string | null
    recipeId?: string | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
  }

  export type BuildCreateManyEditedByInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    recipeId?: string | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
  }

  export type CrewUserCreateManyUserInput = {
    crewId: string
    permission: string
  }

  export type CrewCreateManyCreatedByInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedById: string
  }

  export type CrewCreateManyEditedByInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
  }

  export type SpecificIngredientCreateManyCreatedByInput = {
    id?: string
    dateCreated?: Date | string
    genericIngredientId: string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
  }

  export type IngredientPreferenceCreateManyUserInput = {
    genericIngredientId: string
    specificIngredientId: string
  }

  export type IngredientUserCreateManyUserInput = {
    ingredientId: string
    permission: string
  }

  export type StorageUserCreateManyUserInput = {
    storageId: string
    permission: string
  }

  export type StorageCreateManyCreatedByInput = {
    id?: string
    name: string
    description?: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedById: string
  }

  export type StorageCreateManyEditedByInput = {
    id?: string
    name: string
    description?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
  }

  export type InventoryCreateManyCreatedByInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedById: string
  }

  export type InventoryCreateManyEditedByInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
  }

  export type InventoryUserCreateManyUserInput = {
    inventoryId: string
    permission: string
  }

  export type FollowCreateManyFollowedByInput = {
    followingId: string
    relationship: string
  }

  export type FollowCreateManyFollowingInput = {
    followedById: string
    relationship: string
  }

  export type RecipeBookUserUpdateWithoutUserInput = {
    permission?: StringFieldUpdateOperationsInput | string
    recipeBook?: RecipeBookUpdateOneRequiredWithoutRecipeBookUserNestedInput
  }

  export type RecipeBookUserUncheckedUpdateWithoutUserInput = {
    recipeBookId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookUserUncheckedUpdateManyWithoutUserInput = {
    recipeBookId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedBy?: UserUpdateOneWithoutRecipeBookEditedByNestedInput
    recipeBookBuild?: RecipeBookBuildUpdateManyWithoutRecipeBookNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutRecipeBookNestedInput
  }

  export type RecipeBookUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutRecipeBookNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutRecipeBookNestedInput
  }

  export type RecipeBookUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeBookUpdateWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutRecipeBookNestedInput
    recipeBookBuild?: RecipeBookBuildUpdateManyWithoutRecipeBookNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutRecipeBookNestedInput
  }

  export type RecipeBookUncheckedUpdateWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutRecipeBookNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutRecipeBookNestedInput
  }

  export type RecipeBookUncheckedUpdateManyWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    editedBy?: UserUpdateOneWithoutRecipeEditedByNestedInput
    build?: BuildUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    build?: BuildUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeUpdateWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutRecipeNestedInput
    build?: BuildUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    build?: BuildUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateManyWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BuildUserUpdateWithoutUserInput = {
    permission?: StringFieldUpdateOperationsInput | string
    build?: BuildUpdateOneWithoutBuildUserNestedInput
  }

  export type BuildUserUncheckedUpdateWithoutUserInput = {
    buildId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type BuildUserUncheckedUpdateManyWithoutUserInput = {
    buildId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type BuildUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    editedBy?: UserUpdateOneWithoutBuildEditedByNestedInput
    recipe?: RecipeUpdateOneWithoutBuildNestedInput
    touch?: TouchUpdateManyWithoutBuildNestedInput
    archivedTouch?: ArchivedTouchUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeId?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutBuildNestedInput
    archivedTouch?: ArchivedTouchUncheckedUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeId?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BuildUpdateWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutBuildNestedInput
    recipe?: RecipeUpdateOneWithoutBuildNestedInput
    touch?: TouchUpdateManyWithoutBuildNestedInput
    archivedTouch?: ArchivedTouchUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeId?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutBuildNestedInput
    archivedTouch?: ArchivedTouchUncheckedUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateManyWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeId?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CrewUserUpdateWithoutUserInput = {
    permission?: StringFieldUpdateOperationsInput | string
    crew?: CrewUpdateOneRequiredWithoutUserCrewNestedInput
  }

  export type CrewUserUncheckedUpdateWithoutUserInput = {
    crewId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type CrewUserUncheckedUpdateManyWithoutUserInput = {
    crewId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type CrewUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedBy?: UserUpdateOneWithoutCrewEditedByNestedInput
    userCrew?: CrewUserUpdateManyWithoutCrewNestedInput
  }

  export type CrewUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: StringFieldUpdateOperationsInput | string
    userCrew?: CrewUserUncheckedUpdateManyWithoutCrewNestedInput
  }

  export type CrewUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: StringFieldUpdateOperationsInput | string
  }

  export type CrewUpdateWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCrewNestedInput
    userCrew?: CrewUserUpdateManyWithoutCrewNestedInput
  }

  export type CrewUncheckedUpdateWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    userCrew?: CrewUserUncheckedUpdateManyWithoutCrewNestedInput
  }

  export type CrewUncheckedUpdateManyWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type SpecificIngredientUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    genericIngredient?: GenericIngredientUpdateOneRequiredWithoutSpecificIngredientNestedInput
    touch?: TouchUpdateManyWithoutSpecificIngredientNestedInput
    archivedTouch?: ArchivedTouchUpdateManyWithoutSpecificIngredientNestedInput
    ingredientStorage?: IngredientStorageUpdateManyWithoutIngredientNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutSpecificIngredientNestedInput
  }

  export type SpecificIngredientUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    genericIngredientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutSpecificIngredientNestedInput
    archivedTouch?: ArchivedTouchUncheckedUpdateManyWithoutSpecificIngredientNestedInput
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutSpecificIngredientNestedInput
  }

  export type SpecificIngredientUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    genericIngredientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IngredientPreferenceUpdateWithoutUserInput = {
    genericIngredient?: GenericIngredientUpdateOneRequiredWithoutIngredientPreferenceNestedInput
    specificIngredient?: SpecificIngredientUpdateOneRequiredWithoutIngredientPreferenceNestedInput
  }

  export type IngredientPreferenceUncheckedUpdateWithoutUserInput = {
    genericIngredientId?: StringFieldUpdateOperationsInput | string
    specificIngredientId?: StringFieldUpdateOperationsInput | string
  }

  export type IngredientPreferenceUncheckedUpdateManyWithoutUserInput = {
    genericIngredientId?: StringFieldUpdateOperationsInput | string
    specificIngredientId?: StringFieldUpdateOperationsInput | string
  }

  export type IngredientUserUpdateWithoutUserInput = {
    permission?: StringFieldUpdateOperationsInput | string
    ingredient?: SpecificIngredientUpdateOneRequiredWithoutIngredientUserNestedInput
  }

  export type IngredientUserUncheckedUpdateWithoutUserInput = {
    ingredientId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type IngredientUserUncheckedUpdateManyWithoutUserInput = {
    ingredientId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type StorageUserUpdateWithoutUserInput = {
    permission?: StringFieldUpdateOperationsInput | string
    Storage?: StorageUpdateOneRequiredWithoutStorageUserNestedInput
  }

  export type StorageUserUncheckedUpdateWithoutUserInput = {
    storageId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type StorageUserUncheckedUpdateManyWithoutUserInput = {
    storageId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type StorageUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedBy?: UserUpdateOneWithoutStorageEditedByNestedInput
    inventoryStorage?: InventoryStorageUpdateManyWithoutStorageNestedInput
    ingredientStorage?: IngredientStorageUpdateManyWithoutStorageNestedInput
    storageUser?: StorageUserUpdateManyWithoutStorageNestedInput
  }

  export type StorageUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: StringFieldUpdateOperationsInput | string
    inventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutStorageNestedInput
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutStorageNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutStorageNestedInput
  }

  export type StorageUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: StringFieldUpdateOperationsInput | string
  }

  export type StorageUpdateWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutStorageNestedInput
    inventoryStorage?: InventoryStorageUpdateManyWithoutStorageNestedInput
    ingredientStorage?: IngredientStorageUpdateManyWithoutStorageNestedInput
    storageUser?: StorageUserUpdateManyWithoutStorageNestedInput
  }

  export type StorageUncheckedUpdateWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    inventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutStorageNestedInput
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutStorageNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutStorageNestedInput
  }

  export type StorageUncheckedUpdateManyWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedBy?: UserUpdateOneWithoutInventoryEditedByNestedInput
    inventoryStorage?: InventoryStorageUpdateManyWithoutInventoryNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: StringFieldUpdateOperationsInput | string
    inventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutInventoryNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryUpdateWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutInventoryNestedInput
    inventoryStorage?: InventoryStorageUpdateManyWithoutInventoryNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    inventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutInventoryNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateManyWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryUserUpdateWithoutUserInput = {
    permission?: StringFieldUpdateOperationsInput | string
    inventory?: InventoryUpdateOneRequiredWithoutInventoryUserNestedInput
  }

  export type InventoryUserUncheckedUpdateWithoutUserInput = {
    inventoryId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryUserUncheckedUpdateManyWithoutUserInput = {
    inventoryId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type FollowUpdateWithoutFollowedByInput = {
    relationship?: StringFieldUpdateOperationsInput | string
    following?: UserUpdateOneRequiredWithoutFollowingNestedInput
  }

  export type FollowUncheckedUpdateWithoutFollowedByInput = {
    followingId?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
  }

  export type FollowUncheckedUpdateManyWithoutFollowedByInput = {
    followingId?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
  }

  export type FollowUpdateWithoutFollowingInput = {
    relationship?: StringFieldUpdateOperationsInput | string
    followedBy?: UserUpdateOneRequiredWithoutFollowedByNestedInput
  }

  export type FollowUncheckedUpdateWithoutFollowingInput = {
    followedById?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
  }

  export type FollowUncheckedUpdateManyWithoutFollowingInput = {
    followedById?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookBuildCreateManyRecipeBookInput = {
    buildId: string
  }

  export type RecipeBookUserCreateManyRecipeBookInput = {
    userId: string
    permission: string
  }

  export type RecipeBookBuildUpdateWithoutRecipeBookInput = {
    build?: BuildUpdateOneRequiredWithoutRecipeBookBuildNestedInput
  }

  export type RecipeBookBuildUncheckedUpdateWithoutRecipeBookInput = {
    buildId?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookBuildUncheckedUpdateManyWithoutRecipeBookInput = {
    buildId?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookUserUpdateWithoutRecipeBookInput = {
    permission?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutRecipeBookUserNestedInput
  }

  export type RecipeBookUserUncheckedUpdateWithoutRecipeBookInput = {
    userId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookUserUncheckedUpdateManyWithoutRecipeBookInput = {
    userId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type TouchCreateManyBuildInput = {
    id?: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    genericIngredientId: string
    specificIngredientId?: string | null
    version?: number | null
  }

  export type ArchivedTouchCreateManyBuildInput = {
    id?: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    genericIngredientId: string
    specificIngredientId?: string | null
    version?: number | null
  }

  export type RecipeBookBuildCreateManyBuildInput = {
    recipeBookId: string
  }

  export type BuildUserCreateManyBuildInput = {
    userId: string
    permission: string
  }

  export type TouchUpdateWithoutBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    genericIngredient?: GenericIngredientUpdateOneRequiredWithoutTouchNestedInput
    specificIngredient?: SpecificIngredientUpdateOneWithoutTouchNestedInput
  }

  export type TouchUncheckedUpdateWithoutBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    genericIngredientId?: StringFieldUpdateOperationsInput | string
    specificIngredientId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TouchUncheckedUpdateManyWithoutBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    genericIngredientId?: StringFieldUpdateOperationsInput | string
    specificIngredientId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ArchivedTouchUpdateWithoutBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    genericIngredient?: GenericIngredientUpdateOneRequiredWithoutArchivedTouchNestedInput
    specificIngredient?: SpecificIngredientUpdateOneWithoutArchivedTouchNestedInput
  }

  export type ArchivedTouchUncheckedUpdateWithoutBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    genericIngredientId?: StringFieldUpdateOperationsInput | string
    specificIngredientId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ArchivedTouchUncheckedUpdateManyWithoutBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    genericIngredientId?: StringFieldUpdateOperationsInput | string
    specificIngredientId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RecipeBookBuildUpdateWithoutBuildInput = {
    recipeBook?: RecipeBookUpdateOneRequiredWithoutRecipeBookBuildNestedInput
  }

  export type RecipeBookBuildUncheckedUpdateWithoutBuildInput = {
    recipeBookId?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookBuildUncheckedUpdateManyWithoutBuildInput = {
    recipeBookId?: StringFieldUpdateOperationsInput | string
  }

  export type BuildUserUpdateWithoutBuildInput = {
    permission?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneWithoutBuildUserNestedInput
  }

  export type BuildUserUncheckedUpdateWithoutBuildInput = {
    userId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type BuildUserUncheckedUpdateManyWithoutBuildInput = {
    userId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type BuildCreateManyRecipeInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    editedById?: string | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
  }

  export type BuildUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutBuildNestedInput
    editedBy?: UserUpdateOneWithoutBuildEditedByNestedInput
    touch?: TouchUpdateManyWithoutBuildNestedInput
    archivedTouch?: ArchivedTouchUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutBuildNestedInput
    archivedTouch?: ArchivedTouchUncheckedUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateManyWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TouchCreateManyGenericIngredientInput = {
    id?: string
    buildId: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    specificIngredientId?: string | null
    version?: number | null
  }

  export type ArchivedTouchCreateManyGenericIngredientInput = {
    id?: string
    buildId: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    specificIngredientId?: string | null
    version?: number | null
  }

  export type SpecificIngredientCreateManyGenericIngredientInput = {
    id?: string
    dateCreated?: Date | string
    createdById?: string | null
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
  }

  export type IngredientPreferenceCreateManyGenericIngredientInput = {
    specificIngredientId: string
    userId: string
  }

  export type TouchUpdateWithoutGenericIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    build?: BuildUpdateOneRequiredWithoutTouchNestedInput
    specificIngredient?: SpecificIngredientUpdateOneWithoutTouchNestedInput
  }

  export type TouchUncheckedUpdateWithoutGenericIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    specificIngredientId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TouchUncheckedUpdateManyWithoutGenericIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    specificIngredientId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ArchivedTouchUpdateWithoutGenericIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    build?: BuildUpdateOneRequiredWithoutArchivedTouchNestedInput
    specificIngredient?: SpecificIngredientUpdateOneWithoutArchivedTouchNestedInput
  }

  export type ArchivedTouchUncheckedUpdateWithoutGenericIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    specificIngredientId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ArchivedTouchUncheckedUpdateManyWithoutGenericIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    specificIngredientId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpecificIngredientUpdateWithoutGenericIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutIngredientNestedInput
    touch?: TouchUpdateManyWithoutSpecificIngredientNestedInput
    archivedTouch?: ArchivedTouchUpdateManyWithoutSpecificIngredientNestedInput
    ingredientStorage?: IngredientStorageUpdateManyWithoutIngredientNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutSpecificIngredientNestedInput
  }

  export type SpecificIngredientUncheckedUpdateWithoutGenericIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutSpecificIngredientNestedInput
    archivedTouch?: ArchivedTouchUncheckedUpdateManyWithoutSpecificIngredientNestedInput
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutSpecificIngredientNestedInput
  }

  export type SpecificIngredientUncheckedUpdateManyWithoutGenericIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IngredientPreferenceUpdateWithoutGenericIngredientInput = {
    specificIngredient?: SpecificIngredientUpdateOneRequiredWithoutIngredientPreferenceNestedInput
    user?: UserUpdateOneRequiredWithoutIngredientPreferenceNestedInput
  }

  export type IngredientPreferenceUncheckedUpdateWithoutGenericIngredientInput = {
    specificIngredientId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type IngredientPreferenceUncheckedUpdateManyWithoutGenericIngredientInput = {
    specificIngredientId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TouchCreateManySpecificIngredientInput = {
    id?: string
    buildId: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    genericIngredientId: string
    version?: number | null
  }

  export type ArchivedTouchCreateManySpecificIngredientInput = {
    id?: string
    buildId: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    genericIngredientId: string
    version?: number | null
  }

  export type IngredientStorageCreateManyIngredientInput = {
    storageId: string
    quantity?: number | null
  }

  export type IngredientUserCreateManyIngredientInput = {
    userId: string
    permission: string
  }

  export type IngredientPreferenceCreateManySpecificIngredientInput = {
    genericIngredientId: string
    userId: string
  }

  export type TouchUpdateWithoutSpecificIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    build?: BuildUpdateOneRequiredWithoutTouchNestedInput
    genericIngredient?: GenericIngredientUpdateOneRequiredWithoutTouchNestedInput
  }

  export type TouchUncheckedUpdateWithoutSpecificIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    genericIngredientId?: StringFieldUpdateOperationsInput | string
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TouchUncheckedUpdateManyWithoutSpecificIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    genericIngredientId?: StringFieldUpdateOperationsInput | string
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ArchivedTouchUpdateWithoutSpecificIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    build?: BuildUpdateOneRequiredWithoutArchivedTouchNestedInput
    genericIngredient?: GenericIngredientUpdateOneRequiredWithoutArchivedTouchNestedInput
  }

  export type ArchivedTouchUncheckedUpdateWithoutSpecificIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    genericIngredientId?: StringFieldUpdateOperationsInput | string
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ArchivedTouchUncheckedUpdateManyWithoutSpecificIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    genericIngredientId?: StringFieldUpdateOperationsInput | string
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type IngredientStorageUpdateWithoutIngredientInput = {
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    Storage?: StorageUpdateOneRequiredWithoutIngredientStorageNestedInput
  }

  export type IngredientStorageUncheckedUpdateWithoutIngredientInput = {
    storageId?: StringFieldUpdateOperationsInput | string
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type IngredientStorageUncheckedUpdateManyWithoutIngredientInput = {
    storageId?: StringFieldUpdateOperationsInput | string
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type IngredientUserUpdateWithoutIngredientInput = {
    permission?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutIngredientUserNestedInput
  }

  export type IngredientUserUncheckedUpdateWithoutIngredientInput = {
    userId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type IngredientUserUncheckedUpdateManyWithoutIngredientInput = {
    userId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type IngredientPreferenceUpdateWithoutSpecificIngredientInput = {
    genericIngredient?: GenericIngredientUpdateOneRequiredWithoutIngredientPreferenceNestedInput
    user?: UserUpdateOneRequiredWithoutIngredientPreferenceNestedInput
  }

  export type IngredientPreferenceUncheckedUpdateWithoutSpecificIngredientInput = {
    genericIngredientId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type IngredientPreferenceUncheckedUpdateManyWithoutSpecificIngredientInput = {
    genericIngredientId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryStorageCreateManyInventoryInput = {
    storageId: string
  }

  export type InventoryUserCreateManyInventoryInput = {
    userId: string
    permission: string
  }

  export type InventoryStorageUpdateWithoutInventoryInput = {
    storage?: StorageUpdateOneRequiredWithoutInventoryStorageNestedInput
  }

  export type InventoryStorageUncheckedUpdateWithoutInventoryInput = {
    storageId?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryStorageUncheckedUpdateManyWithoutInventoryInput = {
    storageId?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryUserUpdateWithoutInventoryInput = {
    permission?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutInventoryUserNestedInput
  }

  export type InventoryUserUncheckedUpdateWithoutInventoryInput = {
    userId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryUserUncheckedUpdateManyWithoutInventoryInput = {
    userId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryStorageCreateManyStorageInput = {
    inventoryId: string
  }

  export type IngredientStorageCreateManyStorageInput = {
    ingredientId: string
    quantity?: number | null
  }

  export type StorageUserCreateManyStorageInput = {
    userId: string
    permission: string
  }

  export type InventoryStorageUpdateWithoutStorageInput = {
    inventory?: InventoryUpdateOneRequiredWithoutInventoryStorageNestedInput
  }

  export type InventoryStorageUncheckedUpdateWithoutStorageInput = {
    inventoryId?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryStorageUncheckedUpdateManyWithoutStorageInput = {
    inventoryId?: StringFieldUpdateOperationsInput | string
  }

  export type IngredientStorageUpdateWithoutStorageInput = {
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    ingredient?: SpecificIngredientUpdateOneRequiredWithoutIngredientStorageNestedInput
  }

  export type IngredientStorageUncheckedUpdateWithoutStorageInput = {
    ingredientId?: StringFieldUpdateOperationsInput | string
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type IngredientStorageUncheckedUpdateManyWithoutStorageInput = {
    ingredientId?: StringFieldUpdateOperationsInput | string
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type StorageUserUpdateWithoutStorageInput = {
    permission?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutStorageUserNestedInput
  }

  export type StorageUserUncheckedUpdateWithoutStorageInput = {
    userId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type StorageUserUncheckedUpdateManyWithoutStorageInput = {
    userId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type CrewUserCreateManyCrewInput = {
    userId: string
    permission: string
  }

  export type CrewUserUpdateWithoutCrewInput = {
    permission?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutCrewUserNestedInput
  }

  export type CrewUserUncheckedUpdateWithoutCrewInput = {
    userId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type CrewUserUncheckedUpdateManyWithoutCrewInput = {
    userId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecipeBookCountOutputTypeDefaultArgs instead
     */
    export type RecipeBookCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecipeBookCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BuildCountOutputTypeDefaultArgs instead
     */
    export type BuildCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BuildCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecipeCountOutputTypeDefaultArgs instead
     */
    export type RecipeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecipeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GenericIngredientCountOutputTypeDefaultArgs instead
     */
    export type GenericIngredientCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GenericIngredientCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpecificIngredientCountOutputTypeDefaultArgs instead
     */
    export type SpecificIngredientCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpecificIngredientCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventoryCountOutputTypeDefaultArgs instead
     */
    export type InventoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StorageCountOutputTypeDefaultArgs instead
     */
    export type StorageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StorageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CrewCountOutputTypeDefaultArgs instead
     */
    export type CrewCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CrewCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FollowDefaultArgs instead
     */
    export type FollowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FollowDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileDefaultArgs instead
     */
    export type ProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecipeBookDefaultArgs instead
     */
    export type RecipeBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecipeBookDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecipeBookUserDefaultArgs instead
     */
    export type RecipeBookUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecipeBookUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BuildDefaultArgs instead
     */
    export type BuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BuildDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BuildUserDefaultArgs instead
     */
    export type BuildUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BuildUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecipeDefaultArgs instead
     */
    export type RecipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecipeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecipeBookBuildDefaultArgs instead
     */
    export type RecipeBookBuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecipeBookBuildDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TouchDefaultArgs instead
     */
    export type TouchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TouchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ArchivedTouchDefaultArgs instead
     */
    export type ArchivedTouchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ArchivedTouchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GenericIngredientDefaultArgs instead
     */
    export type GenericIngredientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GenericIngredientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpecificIngredientDefaultArgs instead
     */
    export type SpecificIngredientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpecificIngredientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IngredientUserDefaultArgs instead
     */
    export type IngredientUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IngredientUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IngredientPreferenceDefaultArgs instead
     */
    export type IngredientPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IngredientPreferenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventoryDefaultArgs instead
     */
    export type InventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventoryUserDefaultArgs instead
     */
    export type InventoryUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventoryUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StorageDefaultArgs instead
     */
    export type StorageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StorageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventoryStorageDefaultArgs instead
     */
    export type InventoryStorageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventoryStorageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IngredientStorageDefaultArgs instead
     */
    export type IngredientStorageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IngredientStorageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StorageUserDefaultArgs instead
     */
    export type StorageUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StorageUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CrewDefaultArgs instead
     */
    export type CrewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CrewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CrewUserDefaultArgs instead
     */
    export type CrewUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CrewUserDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}