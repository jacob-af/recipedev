
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model User
 * 
 */
export type User = {
  id: string
  userName: string
  firstName: string | null
  lastName: string | null
  dateJoined: Date
  lastEdited: Date
  email: string
  password: string
}

/**
 * Model Profile
 * 
 */
export type Profile = {
  id: number
  userId: string
  photo: string
}

/**
 * Model RecipeBook
 * 
 */
export type RecipeBook = {
  id: number
  name: string
  description: string | null
  createdAt: Date
  editedAt: Date
  createdById: string | null
  editedById: string | null
}

/**
 * Model RecipeBookUser
 * 
 */
export type RecipeBookUser = {
  userId: string
  recipeBookId: number
  permission: string
}

/**
 * Model Build
 * 
 */
export type Build = {
  id: number
  buildName: string
  createdAt: Date
  editedAt: Date
  createdById: string
  editedById: string
  recipeId: number | null
  instructions: string | null
  notes: string | null
  glassware: string | null
  ice: string | null
}

/**
 * Model BuildUser
 * 
 */
export type BuildUser = {
  userId: string
  buildId: number
  permission: string
}

/**
 * Model Recipe
 * 
 */
export type Recipe = {
  id: number
  createdAt: Date
  name: string
  origin: string | null
  history: string | null
  createdById: string
}

/**
 * Model RecipeBookBuild
 * 
 */
export type RecipeBookBuild = {
  buildId: number
  recipeBookId: number
}

/**
 * Model Touch
 * 
 */
export type Touch = {
  id: number
  buildId: number | null
  order: number | null
  amount: number | null
  unit: string | null
  genericIngredientID: number
  specificIngredientID: number | null
}

/**
 * Model GenericIngredient
 * 
 */
export type GenericIngredient = {
  id: number
  name: string
  description: string | null
}

/**
 * Model SpecificIngredient
 * 
 */
export type SpecificIngredient = {
  id: number
  dateCreated: Date
  createdById: string | null
  genericIngredientId: number
  name: string
  description: string
  price: number | null
  amount: number | null
  unit: string | null
  source: string | null
}

/**
 * Model IngredientPreference
 * 
 */
export type IngredientPreference = {
  genericIngredientID: number
  specificIngredientID: number
  userId: string
}

/**
 * Model Inventory
 * 
 */
export type Inventory = {
  id: number
  name: string
  createdAt: Date
  editedAt: Date
  createdById: string
  editedById: string
}

/**
 * Model InventoryUser
 * 
 */
export type InventoryUser = {
  userId: string
  inventoryId: number
  permission: string
}

/**
 * Model Storage
 * 
 */
export type Storage = {
  id: number
  name: string
  createdAt: Date
  editedAt: Date
  createdById: string
  editedById: string
}

/**
 * Model InventoryStorage
 * 
 */
export type InventoryStorage = {
  inventoryId: number
  storageId: number
}

/**
 * Model IngredientStorage
 * 
 */
export type IngredientStorage = {
  ingredientId: number
  storageId: number
  quantity: number | null
}

/**
 * Model StorageUser
 * 
 */
export type StorageUser = {
  userId: string
  storageId: number
  permission: string
}

/**
 * Model Crew
 * 
 */
export type Crew = {
  id: number
  name: string
  description: string
  createdAt: Date
  editedAt: Date
  createdById: string
  editedById: string
}

/**
 * Model UserCrew
 * 
 */
export type UserCrew = {
  userId: string
  crewId: number
  permission: string
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<GlobalReject>;

  /**
   * `prisma.recipeBook`: Exposes CRUD operations for the **RecipeBook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecipeBooks
    * const recipeBooks = await prisma.recipeBook.findMany()
    * ```
    */
  get recipeBook(): Prisma.RecipeBookDelegate<GlobalReject>;

  /**
   * `prisma.recipeBookUser`: Exposes CRUD operations for the **RecipeBookUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecipeBookUsers
    * const recipeBookUsers = await prisma.recipeBookUser.findMany()
    * ```
    */
  get recipeBookUser(): Prisma.RecipeBookUserDelegate<GlobalReject>;

  /**
   * `prisma.build`: Exposes CRUD operations for the **Build** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Builds
    * const builds = await prisma.build.findMany()
    * ```
    */
  get build(): Prisma.BuildDelegate<GlobalReject>;

  /**
   * `prisma.buildUser`: Exposes CRUD operations for the **BuildUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BuildUsers
    * const buildUsers = await prisma.buildUser.findMany()
    * ```
    */
  get buildUser(): Prisma.BuildUserDelegate<GlobalReject>;

  /**
   * `prisma.recipe`: Exposes CRUD operations for the **Recipe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recipes
    * const recipes = await prisma.recipe.findMany()
    * ```
    */
  get recipe(): Prisma.RecipeDelegate<GlobalReject>;

  /**
   * `prisma.recipeBookBuild`: Exposes CRUD operations for the **RecipeBookBuild** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecipeBookBuilds
    * const recipeBookBuilds = await prisma.recipeBookBuild.findMany()
    * ```
    */
  get recipeBookBuild(): Prisma.RecipeBookBuildDelegate<GlobalReject>;

  /**
   * `prisma.touch`: Exposes CRUD operations for the **Touch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Touches
    * const touches = await prisma.touch.findMany()
    * ```
    */
  get touch(): Prisma.TouchDelegate<GlobalReject>;

  /**
   * `prisma.genericIngredient`: Exposes CRUD operations for the **GenericIngredient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GenericIngredients
    * const genericIngredients = await prisma.genericIngredient.findMany()
    * ```
    */
  get genericIngredient(): Prisma.GenericIngredientDelegate<GlobalReject>;

  /**
   * `prisma.specificIngredient`: Exposes CRUD operations for the **SpecificIngredient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpecificIngredients
    * const specificIngredients = await prisma.specificIngredient.findMany()
    * ```
    */
  get specificIngredient(): Prisma.SpecificIngredientDelegate<GlobalReject>;

  /**
   * `prisma.ingredientPreference`: Exposes CRUD operations for the **IngredientPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IngredientPreferences
    * const ingredientPreferences = await prisma.ingredientPreference.findMany()
    * ```
    */
  get ingredientPreference(): Prisma.IngredientPreferenceDelegate<GlobalReject>;

  /**
   * `prisma.inventory`: Exposes CRUD operations for the **Inventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventories
    * const inventories = await prisma.inventory.findMany()
    * ```
    */
  get inventory(): Prisma.InventoryDelegate<GlobalReject>;

  /**
   * `prisma.inventoryUser`: Exposes CRUD operations for the **InventoryUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryUsers
    * const inventoryUsers = await prisma.inventoryUser.findMany()
    * ```
    */
  get inventoryUser(): Prisma.InventoryUserDelegate<GlobalReject>;

  /**
   * `prisma.storage`: Exposes CRUD operations for the **Storage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Storages
    * const storages = await prisma.storage.findMany()
    * ```
    */
  get storage(): Prisma.StorageDelegate<GlobalReject>;

  /**
   * `prisma.inventoryStorage`: Exposes CRUD operations for the **InventoryStorage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryStorages
    * const inventoryStorages = await prisma.inventoryStorage.findMany()
    * ```
    */
  get inventoryStorage(): Prisma.InventoryStorageDelegate<GlobalReject>;

  /**
   * `prisma.ingredientStorage`: Exposes CRUD operations for the **IngredientStorage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IngredientStorages
    * const ingredientStorages = await prisma.ingredientStorage.findMany()
    * ```
    */
  get ingredientStorage(): Prisma.IngredientStorageDelegate<GlobalReject>;

  /**
   * `prisma.storageUser`: Exposes CRUD operations for the **StorageUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StorageUsers
    * const storageUsers = await prisma.storageUser.findMany()
    * ```
    */
  get storageUser(): Prisma.StorageUserDelegate<GlobalReject>;

  /**
   * `prisma.crew`: Exposes CRUD operations for the **Crew** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Crews
    * const crews = await prisma.crew.findMany()
    * ```
    */
  get crew(): Prisma.CrewDelegate<GlobalReject>;

  /**
   * `prisma.userCrew`: Exposes CRUD operations for the **UserCrew** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserCrews
    * const userCrews = await prisma.userCrew.findMany()
    * ```
    */
  get userCrew(): Prisma.UserCrewDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export import Metrics = runtime.Metrics
  export import Metric = runtime.Metric
  export import MetricHistogram = runtime.MetricHistogram
  export import MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
   * Prisma Client JS version: 4.3.1
   * Query Engine version: c875e43600dfe042452e0b868f7a48b817b9640b
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export import FieldRef = runtime.FieldRef

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    User: 'User',
    Profile: 'Profile',
    RecipeBook: 'RecipeBook',
    RecipeBookUser: 'RecipeBookUser',
    Build: 'Build',
    BuildUser: 'BuildUser',
    Recipe: 'Recipe',
    RecipeBookBuild: 'RecipeBookBuild',
    Touch: 'Touch',
    GenericIngredient: 'GenericIngredient',
    SpecificIngredient: 'SpecificIngredient',
    IngredientPreference: 'IngredientPreference',
    Inventory: 'Inventory',
    InventoryUser: 'InventoryUser',
    Storage: 'Storage',
    InventoryStorage: 'InventoryStorage',
    IngredientStorage: 'IngredientStorage',
    StorageUser: 'StorageUser',
    Crew: 'Crew',
    UserCrew: 'UserCrew'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    recipeBookUser: number
    recipeBook: number
    recipeBookEditedById: number
    recipe: number
    buildUser: number
    build: number
    buildEditedBy: number
    userCrew: number
    crew: number
    crewEditedBy: number
    ingredient: number
    ingredientPreference: number
    storageUser: number
    storage: number
    storageEditedBy: number
    inventoryCreatedBy: number
    inventoryEditedBy: number
    inventoryUser: number
  }

  export type UserCountOutputTypeSelect = {
    recipeBookUser?: boolean
    recipeBook?: boolean
    recipeBookEditedById?: boolean
    recipe?: boolean
    buildUser?: boolean
    build?: boolean
    buildEditedBy?: boolean
    userCrew?: boolean
    crew?: boolean
    crewEditedBy?: boolean
    ingredient?: boolean
    ingredientPreference?: boolean
    storageUser?: boolean
    storage?: boolean
    storageEditedBy?: boolean
    inventoryCreatedBy?: boolean
    inventoryEditedBy?: boolean
    inventoryUser?: boolean
  }

  export type UserCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UserCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UserCountOutputType
    : S extends undefined
    ? never
    : S extends UserCountOutputTypeArgs
    ?'include' extends U
    ? UserCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
    : UserCountOutputType
  : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type RecipeBookCountOutputType
   */


  export type RecipeBookCountOutputType = {
    recipeBookBuild: number
    recipeBookUser: number
  }

  export type RecipeBookCountOutputTypeSelect = {
    recipeBookBuild?: boolean
    recipeBookUser?: boolean
  }

  export type RecipeBookCountOutputTypeGetPayload<
    S extends boolean | null | undefined | RecipeBookCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? RecipeBookCountOutputType
    : S extends undefined
    ? never
    : S extends RecipeBookCountOutputTypeArgs
    ?'include' extends U
    ? RecipeBookCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof RecipeBookCountOutputType ? RecipeBookCountOutputType[P] : never
  } 
    : RecipeBookCountOutputType
  : RecipeBookCountOutputType




  // Custom InputTypes

  /**
   * RecipeBookCountOutputType without action
   */
  export type RecipeBookCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RecipeBookCountOutputType
     * 
    **/
    select?: RecipeBookCountOutputTypeSelect | null
  }



  /**
   * Count Type BuildCountOutputType
   */


  export type BuildCountOutputType = {
    touch: number
    RecipeBookBuild: number
    buildUser: number
  }

  export type BuildCountOutputTypeSelect = {
    touch?: boolean
    RecipeBookBuild?: boolean
    buildUser?: boolean
  }

  export type BuildCountOutputTypeGetPayload<
    S extends boolean | null | undefined | BuildCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? BuildCountOutputType
    : S extends undefined
    ? never
    : S extends BuildCountOutputTypeArgs
    ?'include' extends U
    ? BuildCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof BuildCountOutputType ? BuildCountOutputType[P] : never
  } 
    : BuildCountOutputType
  : BuildCountOutputType




  // Custom InputTypes

  /**
   * BuildCountOutputType without action
   */
  export type BuildCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BuildCountOutputType
     * 
    **/
    select?: BuildCountOutputTypeSelect | null
  }



  /**
   * Count Type RecipeCountOutputType
   */


  export type RecipeCountOutputType = {
    build: number
  }

  export type RecipeCountOutputTypeSelect = {
    build?: boolean
  }

  export type RecipeCountOutputTypeGetPayload<
    S extends boolean | null | undefined | RecipeCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? RecipeCountOutputType
    : S extends undefined
    ? never
    : S extends RecipeCountOutputTypeArgs
    ?'include' extends U
    ? RecipeCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof RecipeCountOutputType ? RecipeCountOutputType[P] : never
  } 
    : RecipeCountOutputType
  : RecipeCountOutputType




  // Custom InputTypes

  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RecipeCountOutputType
     * 
    **/
    select?: RecipeCountOutputTypeSelect | null
  }



  /**
   * Count Type GenericIngredientCountOutputType
   */


  export type GenericIngredientCountOutputType = {
    touch: number
    specificIngredient: number
    ingredientPreference: number
  }

  export type GenericIngredientCountOutputTypeSelect = {
    touch?: boolean
    specificIngredient?: boolean
    ingredientPreference?: boolean
  }

  export type GenericIngredientCountOutputTypeGetPayload<
    S extends boolean | null | undefined | GenericIngredientCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? GenericIngredientCountOutputType
    : S extends undefined
    ? never
    : S extends GenericIngredientCountOutputTypeArgs
    ?'include' extends U
    ? GenericIngredientCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof GenericIngredientCountOutputType ? GenericIngredientCountOutputType[P] : never
  } 
    : GenericIngredientCountOutputType
  : GenericIngredientCountOutputType




  // Custom InputTypes

  /**
   * GenericIngredientCountOutputType without action
   */
  export type GenericIngredientCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the GenericIngredientCountOutputType
     * 
    **/
    select?: GenericIngredientCountOutputTypeSelect | null
  }



  /**
   * Count Type SpecificIngredientCountOutputType
   */


  export type SpecificIngredientCountOutputType = {
    touch: number
    ingredientStorage: number
    ingredientPreference: number
  }

  export type SpecificIngredientCountOutputTypeSelect = {
    touch?: boolean
    ingredientStorage?: boolean
    ingredientPreference?: boolean
  }

  export type SpecificIngredientCountOutputTypeGetPayload<
    S extends boolean | null | undefined | SpecificIngredientCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? SpecificIngredientCountOutputType
    : S extends undefined
    ? never
    : S extends SpecificIngredientCountOutputTypeArgs
    ?'include' extends U
    ? SpecificIngredientCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof SpecificIngredientCountOutputType ? SpecificIngredientCountOutputType[P] : never
  } 
    : SpecificIngredientCountOutputType
  : SpecificIngredientCountOutputType




  // Custom InputTypes

  /**
   * SpecificIngredientCountOutputType without action
   */
  export type SpecificIngredientCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SpecificIngredientCountOutputType
     * 
    **/
    select?: SpecificIngredientCountOutputTypeSelect | null
  }



  /**
   * Count Type InventoryCountOutputType
   */


  export type InventoryCountOutputType = {
    inventoryStorage: number
    inventoryUser: number
  }

  export type InventoryCountOutputTypeSelect = {
    inventoryStorage?: boolean
    inventoryUser?: boolean
  }

  export type InventoryCountOutputTypeGetPayload<
    S extends boolean | null | undefined | InventoryCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? InventoryCountOutputType
    : S extends undefined
    ? never
    : S extends InventoryCountOutputTypeArgs
    ?'include' extends U
    ? InventoryCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof InventoryCountOutputType ? InventoryCountOutputType[P] : never
  } 
    : InventoryCountOutputType
  : InventoryCountOutputType




  // Custom InputTypes

  /**
   * InventoryCountOutputType without action
   */
  export type InventoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the InventoryCountOutputType
     * 
    **/
    select?: InventoryCountOutputTypeSelect | null
  }



  /**
   * Count Type StorageCountOutputType
   */


  export type StorageCountOutputType = {
    inventoryStorage: number
    ingredientStorage: number
    storageUser: number
  }

  export type StorageCountOutputTypeSelect = {
    inventoryStorage?: boolean
    ingredientStorage?: boolean
    storageUser?: boolean
  }

  export type StorageCountOutputTypeGetPayload<
    S extends boolean | null | undefined | StorageCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? StorageCountOutputType
    : S extends undefined
    ? never
    : S extends StorageCountOutputTypeArgs
    ?'include' extends U
    ? StorageCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof StorageCountOutputType ? StorageCountOutputType[P] : never
  } 
    : StorageCountOutputType
  : StorageCountOutputType




  // Custom InputTypes

  /**
   * StorageCountOutputType without action
   */
  export type StorageCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the StorageCountOutputType
     * 
    **/
    select?: StorageCountOutputTypeSelect | null
  }



  /**
   * Count Type CrewCountOutputType
   */


  export type CrewCountOutputType = {
    userCrew: number
  }

  export type CrewCountOutputTypeSelect = {
    userCrew?: boolean
  }

  export type CrewCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CrewCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CrewCountOutputType
    : S extends undefined
    ? never
    : S extends CrewCountOutputTypeArgs
    ?'include' extends U
    ? CrewCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CrewCountOutputType ? CrewCountOutputType[P] : never
  } 
    : CrewCountOutputType
  : CrewCountOutputType




  // Custom InputTypes

  /**
   * CrewCountOutputType without action
   */
  export type CrewCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CrewCountOutputType
     * 
    **/
    select?: CrewCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    userName: string | null
    firstName: string | null
    lastName: string | null
    dateJoined: Date | null
    lastEdited: Date | null
    email: string | null
    password: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    userName: string | null
    firstName: string | null
    lastName: string | null
    dateJoined: Date | null
    lastEdited: Date | null
    email: string | null
    password: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    userName: number
    firstName: number
    lastName: number
    dateJoined: number
    lastEdited: number
    email: number
    password: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    userName?: true
    firstName?: true
    lastName?: true
    dateJoined?: true
    lastEdited?: true
    email?: true
    password?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    userName?: true
    firstName?: true
    lastName?: true
    dateJoined?: true
    lastEdited?: true
    email?: true
    password?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    userName?: true
    firstName?: true
    lastName?: true
    dateJoined?: true
    lastEdited?: true
    email?: true
    password?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    userName: string
    firstName: string | null
    lastName: string | null
    dateJoined: Date
    lastEdited: Date
    email: string
    password: string
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    userName?: boolean
    firstName?: boolean
    lastName?: boolean
    dateJoined?: boolean
    lastEdited?: boolean
    email?: boolean
    password?: boolean
    profile?: boolean | ProfileArgs
    recipeBookUser?: boolean | RecipeBookUserFindManyArgs
    recipeBook?: boolean | RecipeBookFindManyArgs
    recipeBookEditedById?: boolean | RecipeBookFindManyArgs
    recipe?: boolean | RecipeFindManyArgs
    buildUser?: boolean | BuildUserFindManyArgs
    build?: boolean | BuildFindManyArgs
    buildEditedBy?: boolean | BuildFindManyArgs
    userCrew?: boolean | UserCrewFindManyArgs
    crew?: boolean | CrewFindManyArgs
    crewEditedBy?: boolean | CrewFindManyArgs
    ingredient?: boolean | SpecificIngredientFindManyArgs
    ingredientPreference?: boolean | IngredientPreferenceFindManyArgs
    storageUser?: boolean | StorageUserFindManyArgs
    storage?: boolean | StorageFindManyArgs
    storageEditedBy?: boolean | StorageFindManyArgs
    inventoryCreatedBy?: boolean | InventoryFindManyArgs
    inventoryEditedBy?: boolean | InventoryFindManyArgs
    inventoryUser?: boolean | InventoryUserFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserInclude = {
    profile?: boolean | ProfileArgs
    recipeBookUser?: boolean | RecipeBookUserFindManyArgs
    recipeBook?: boolean | RecipeBookFindManyArgs
    recipeBookEditedById?: boolean | RecipeBookFindManyArgs
    recipe?: boolean | RecipeFindManyArgs
    buildUser?: boolean | BuildUserFindManyArgs
    build?: boolean | BuildFindManyArgs
    buildEditedBy?: boolean | BuildFindManyArgs
    userCrew?: boolean | UserCrewFindManyArgs
    crew?: boolean | CrewFindManyArgs
    crewEditedBy?: boolean | CrewFindManyArgs
    ingredient?: boolean | SpecificIngredientFindManyArgs
    ingredientPreference?: boolean | IngredientPreferenceFindManyArgs
    storageUser?: boolean | StorageUserFindManyArgs
    storage?: boolean | StorageFindManyArgs
    storageEditedBy?: boolean | StorageFindManyArgs
    inventoryCreatedBy?: boolean | InventoryFindManyArgs
    inventoryEditedBy?: boolean | InventoryFindManyArgs
    inventoryUser?: boolean | InventoryUserFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]:
        P extends 'profile' ? ProfileGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'recipeBookUser' ? Array < RecipeBookUserGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'recipeBook' ? Array < RecipeBookGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'recipeBookEditedById' ? Array < RecipeBookGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'recipe' ? Array < RecipeGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'buildUser' ? Array < BuildUserGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'build' ? Array < BuildGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'buildEditedBy' ? Array < BuildGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'userCrew' ? Array < UserCrewGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'crew' ? Array < CrewGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'crewEditedBy' ? Array < CrewGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'ingredient' ? Array < SpecificIngredientGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'ingredientPreference' ? Array < IngredientPreferenceGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'storageUser' ? Array < StorageUserGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'storage' ? Array < StorageGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'storageEditedBy' ? Array < StorageGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'inventoryCreatedBy' ? Array < InventoryGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'inventoryEditedBy' ? Array < InventoryGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'inventoryUser' ? Array < InventoryUserGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'profile' ? ProfileGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'recipeBookUser' ? Array < RecipeBookUserGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'recipeBook' ? Array < RecipeBookGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'recipeBookEditedById' ? Array < RecipeBookGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'recipe' ? Array < RecipeGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'buildUser' ? Array < BuildUserGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'build' ? Array < BuildGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'buildEditedBy' ? Array < BuildGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'userCrew' ? Array < UserCrewGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'crew' ? Array < CrewGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'crewEditedBy' ? Array < CrewGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'ingredient' ? Array < SpecificIngredientGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'ingredientPreference' ? Array < IngredientPreferenceGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'storageUser' ? Array < StorageUserGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'storage' ? Array < StorageGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'storageEditedBy' ? Array < StorageGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'inventoryCreatedBy' ? Array < InventoryGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'inventoryEditedBy' ? Array < InventoryGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'inventoryUser' ? Array < InventoryUserGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof User ? User[P] : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Find one User that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    profile<T extends ProfileArgs = {}>(args?: Subset<T, ProfileArgs>): CheckSelect<T, Prisma__ProfileClient<Profile | null >, Prisma__ProfileClient<ProfileGetPayload<T> | null >>;

    recipeBookUser<T extends RecipeBookUserFindManyArgs = {}>(args?: Subset<T, RecipeBookUserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RecipeBookUser>>, PrismaPromise<Array<RecipeBookUserGetPayload<T>>>>;

    recipeBook<T extends RecipeBookFindManyArgs = {}>(args?: Subset<T, RecipeBookFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RecipeBook>>, PrismaPromise<Array<RecipeBookGetPayload<T>>>>;

    recipeBookEditedById<T extends RecipeBookFindManyArgs = {}>(args?: Subset<T, RecipeBookFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RecipeBook>>, PrismaPromise<Array<RecipeBookGetPayload<T>>>>;

    recipe<T extends RecipeFindManyArgs = {}>(args?: Subset<T, RecipeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Recipe>>, PrismaPromise<Array<RecipeGetPayload<T>>>>;

    buildUser<T extends BuildUserFindManyArgs = {}>(args?: Subset<T, BuildUserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<BuildUser>>, PrismaPromise<Array<BuildUserGetPayload<T>>>>;

    build<T extends BuildFindManyArgs = {}>(args?: Subset<T, BuildFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Build>>, PrismaPromise<Array<BuildGetPayload<T>>>>;

    buildEditedBy<T extends BuildFindManyArgs = {}>(args?: Subset<T, BuildFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Build>>, PrismaPromise<Array<BuildGetPayload<T>>>>;

    userCrew<T extends UserCrewFindManyArgs = {}>(args?: Subset<T, UserCrewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserCrew>>, PrismaPromise<Array<UserCrewGetPayload<T>>>>;

    crew<T extends CrewFindManyArgs = {}>(args?: Subset<T, CrewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Crew>>, PrismaPromise<Array<CrewGetPayload<T>>>>;

    crewEditedBy<T extends CrewFindManyArgs = {}>(args?: Subset<T, CrewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Crew>>, PrismaPromise<Array<CrewGetPayload<T>>>>;

    ingredient<T extends SpecificIngredientFindManyArgs = {}>(args?: Subset<T, SpecificIngredientFindManyArgs>): CheckSelect<T, PrismaPromise<Array<SpecificIngredient>>, PrismaPromise<Array<SpecificIngredientGetPayload<T>>>>;

    ingredientPreference<T extends IngredientPreferenceFindManyArgs = {}>(args?: Subset<T, IngredientPreferenceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<IngredientPreference>>, PrismaPromise<Array<IngredientPreferenceGetPayload<T>>>>;

    storageUser<T extends StorageUserFindManyArgs = {}>(args?: Subset<T, StorageUserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<StorageUser>>, PrismaPromise<Array<StorageUserGetPayload<T>>>>;

    storage<T extends StorageFindManyArgs = {}>(args?: Subset<T, StorageFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Storage>>, PrismaPromise<Array<StorageGetPayload<T>>>>;

    storageEditedBy<T extends StorageFindManyArgs = {}>(args?: Subset<T, StorageFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Storage>>, PrismaPromise<Array<StorageGetPayload<T>>>>;

    inventoryCreatedBy<T extends InventoryFindManyArgs = {}>(args?: Subset<T, InventoryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Inventory>>, PrismaPromise<Array<InventoryGetPayload<T>>>>;

    inventoryEditedBy<T extends InventoryFindManyArgs = {}>(args?: Subset<T, InventoryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Inventory>>, PrismaPromise<Array<InventoryGetPayload<T>>>>;

    inventoryUser<T extends InventoryUserFindManyArgs = {}>(args?: Subset<T, InventoryUserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<InventoryUser>>, PrismaPromise<Array<InventoryUserGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }

  /**
   * User: findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User: findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     * 
    **/
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     * 
    **/
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User: findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = UserFindUniqueArgsBase
      

  /**
   * User: findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = UserFindFirstArgsBase
      

  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model Profile
   */


  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileAvgAggregateOutputType = {
    id: number | null
  }

  export type ProfileSumAggregateOutputType = {
    id: number | null
  }

  export type ProfileMinAggregateOutputType = {
    id: number | null
    userId: string | null
    photo: string | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    photo: string | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    userId: number
    photo: number
    _all: number
  }


  export type ProfileAvgAggregateInputType = {
    id?: true
  }

  export type ProfileSumAggregateInputType = {
    id?: true
  }

  export type ProfileMinAggregateInputType = {
    id?: true
    userId?: true
    photo?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    photo?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    userId?: true
    photo?: true
    _all?: true
  }

  export type ProfileAggregateArgs = {
    /**
     * Filter which Profile to aggregate.
     * 
    **/
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     * 
    **/
    orderBy?: Enumerable<ProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs = {
    where?: ProfileWhereInput
    orderBy?: Enumerable<ProfileOrderByWithAggregationInput>
    by: Array<ProfileScalarFieldEnum>
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _avg?: ProfileAvgAggregateInputType
    _sum?: ProfileSumAggregateInputType
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }


  export type ProfileGroupByOutputType = {
    id: number
    userId: string
    photo: string
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect = {
    id?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    photo?: boolean
  }

  export type ProfileInclude = {
    user?: boolean | UserArgs
  }

  export type ProfileGetPayload<
    S extends boolean | null | undefined | ProfileArgs,
    U = keyof S
      > = S extends true
        ? Profile
    : S extends undefined
    ? never
    : S extends ProfileArgs | ProfileFindManyArgs
    ?'include' extends U
    ? Profile  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Profile ? Profile[P] : never
  } 
    : Profile
  : Profile


  type ProfileCountArgs = Merge<
    Omit<ProfileFindManyArgs, 'select' | 'include'> & {
      select?: ProfileCountAggregateInputType | true
    }
  >

  export interface ProfileDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProfileFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProfileFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Profile'> extends True ? CheckSelect<T, Prisma__ProfileClient<Profile>, Prisma__ProfileClient<ProfileGetPayload<T>>> : CheckSelect<T, Prisma__ProfileClient<Profile | null >, Prisma__ProfileClient<ProfileGetPayload<T> | null >>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProfileFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProfileFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Profile'> extends True ? CheckSelect<T, Prisma__ProfileClient<Profile>, Prisma__ProfileClient<ProfileGetPayload<T>>> : CheckSelect<T, Prisma__ProfileClient<Profile | null >, Prisma__ProfileClient<ProfileGetPayload<T> | null >>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProfileFindManyArgs>(
      args?: SelectSubset<T, ProfileFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Profile>>, PrismaPromise<Array<ProfileGetPayload<T>>>>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
    **/
    create<T extends ProfileCreateArgs>(
      args: SelectSubset<T, ProfileCreateArgs>
    ): CheckSelect<T, Prisma__ProfileClient<Profile>, Prisma__ProfileClient<ProfileGetPayload<T>>>

    /**
     * Create many Profiles.
     *     @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     *     @example
     *     // Create many Profiles
     *     const profile = await prisma.profile.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProfileCreateManyArgs>(
      args?: SelectSubset<T, ProfileCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
    **/
    delete<T extends ProfileDeleteArgs>(
      args: SelectSubset<T, ProfileDeleteArgs>
    ): CheckSelect<T, Prisma__ProfileClient<Profile>, Prisma__ProfileClient<ProfileGetPayload<T>>>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProfileUpdateArgs>(
      args: SelectSubset<T, ProfileUpdateArgs>
    ): CheckSelect<T, Prisma__ProfileClient<Profile>, Prisma__ProfileClient<ProfileGetPayload<T>>>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProfileDeleteManyArgs>(
      args?: SelectSubset<T, ProfileDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProfileUpdateManyArgs>(
      args: SelectSubset<T, ProfileUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
    **/
    upsert<T extends ProfileUpsertArgs>(
      args: SelectSubset<T, ProfileUpsertArgs>
    ): CheckSelect<T, Prisma__ProfileClient<Profile>, Prisma__ProfileClient<ProfileGetPayload<T>>>

    /**
     * Find one Profile that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProfileFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ProfileClient<Profile>, Prisma__ProfileClient<ProfileGetPayload<T>>>

    /**
     * Find the first Profile that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProfileFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ProfileClient<Profile>, Prisma__ProfileClient<ProfileGetPayload<T>>>

    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProfileClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Profile base type for findUnique actions
   */
  export type ProfileFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * Filter, which Profile to fetch.
     * 
    **/
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile: findUnique
   */
  export interface ProfileFindUniqueArgs extends ProfileFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Profile base type for findFirst actions
   */
  export type ProfileFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * Filter, which Profile to fetch.
     * 
    **/
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     * 
    **/
    orderBy?: Enumerable<ProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     * 
    **/
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     * 
    **/
    distinct?: Enumerable<ProfileScalarFieldEnum>
  }

  /**
   * Profile: findFirst
   */
  export interface ProfileFindFirstArgs extends ProfileFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * Filter, which Profiles to fetch.
     * 
    **/
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     * 
    **/
    orderBy?: Enumerable<ProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     * 
    **/
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProfileScalarFieldEnum>
  }


  /**
   * Profile create
   */
  export type ProfileCreateArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * The data needed to create a Profile.
     * 
    **/
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }


  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs = {
    /**
     * The data used to create many Profiles.
     * 
    **/
    data: Enumerable<ProfileCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Profile update
   */
  export type ProfileUpdateArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * The data needed to update a Profile.
     * 
    **/
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     * 
    **/
    where: ProfileWhereUniqueInput
  }


  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs = {
    /**
     * The data used to update Profiles.
     * 
    **/
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     * 
    **/
    where?: ProfileWhereInput
  }


  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * The filter to search for the Profile to update in case it exists.
     * 
    **/
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     * 
    **/
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }


  /**
   * Profile delete
   */
  export type ProfileDeleteArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * Filter which Profile to delete.
     * 
    **/
    where: ProfileWhereUniqueInput
  }


  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs = {
    /**
     * Filter which Profiles to delete
     * 
    **/
    where?: ProfileWhereInput
  }


  /**
   * Profile: findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs = ProfileFindUniqueArgsBase
      

  /**
   * Profile: findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs = ProfileFindFirstArgsBase
      

  /**
   * Profile without action
   */
  export type ProfileArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
  }



  /**
   * Model RecipeBook
   */


  export type AggregateRecipeBook = {
    _count: RecipeBookCountAggregateOutputType | null
    _avg: RecipeBookAvgAggregateOutputType | null
    _sum: RecipeBookSumAggregateOutputType | null
    _min: RecipeBookMinAggregateOutputType | null
    _max: RecipeBookMaxAggregateOutputType | null
  }

  export type RecipeBookAvgAggregateOutputType = {
    id: number | null
  }

  export type RecipeBookSumAggregateOutputType = {
    id: number | null
  }

  export type RecipeBookMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
  }

  export type RecipeBookMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
  }

  export type RecipeBookCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    editedAt: number
    createdById: number
    editedById: number
    _all: number
  }


  export type RecipeBookAvgAggregateInputType = {
    id?: true
  }

  export type RecipeBookSumAggregateInputType = {
    id?: true
  }

  export type RecipeBookMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
  }

  export type RecipeBookMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
  }

  export type RecipeBookCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
    _all?: true
  }

  export type RecipeBookAggregateArgs = {
    /**
     * Filter which RecipeBook to aggregate.
     * 
    **/
    where?: RecipeBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBooks to fetch.
     * 
    **/
    orderBy?: Enumerable<RecipeBookOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RecipeBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBooks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBooks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecipeBooks
    **/
    _count?: true | RecipeBookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecipeBookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecipeBookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeBookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeBookMaxAggregateInputType
  }

  export type GetRecipeBookAggregateType<T extends RecipeBookAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipeBook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipeBook[P]>
      : GetScalarType<T[P], AggregateRecipeBook[P]>
  }




  export type RecipeBookGroupByArgs = {
    where?: RecipeBookWhereInput
    orderBy?: Enumerable<RecipeBookOrderByWithAggregationInput>
    by: Array<RecipeBookScalarFieldEnum>
    having?: RecipeBookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeBookCountAggregateInputType | true
    _avg?: RecipeBookAvgAggregateInputType
    _sum?: RecipeBookSumAggregateInputType
    _min?: RecipeBookMinAggregateInputType
    _max?: RecipeBookMaxAggregateInputType
  }


  export type RecipeBookGroupByOutputType = {
    id: number
    name: string
    description: string | null
    createdAt: Date
    editedAt: Date
    createdById: string | null
    editedById: string | null
    _count: RecipeBookCountAggregateOutputType | null
    _avg: RecipeBookAvgAggregateOutputType | null
    _sum: RecipeBookSumAggregateOutputType | null
    _min: RecipeBookMinAggregateOutputType | null
    _max: RecipeBookMaxAggregateOutputType | null
  }

  type GetRecipeBookGroupByPayload<T extends RecipeBookGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RecipeBookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeBookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeBookGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeBookGroupByOutputType[P]>
        }
      >
    >


  export type RecipeBookSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    editedAt?: boolean
    createdById?: boolean
    editedById?: boolean
    createdBy?: boolean | UserArgs
    editedBy?: boolean | UserArgs
    recipeBookBuild?: boolean | RecipeBookBuildFindManyArgs
    recipeBookUser?: boolean | RecipeBookUserFindManyArgs
    _count?: boolean | RecipeBookCountOutputTypeArgs
  }

  export type RecipeBookInclude = {
    createdBy?: boolean | UserArgs
    editedBy?: boolean | UserArgs
    recipeBookBuild?: boolean | RecipeBookBuildFindManyArgs
    recipeBookUser?: boolean | RecipeBookUserFindManyArgs
    _count?: boolean | RecipeBookCountOutputTypeArgs
  }

  export type RecipeBookGetPayload<
    S extends boolean | null | undefined | RecipeBookArgs,
    U = keyof S
      > = S extends true
        ? RecipeBook
    : S extends undefined
    ? never
    : S extends RecipeBookArgs | RecipeBookFindManyArgs
    ?'include' extends U
    ? RecipeBook  & {
    [P in TrueKeys<S['include']>]:
        P extends 'createdBy' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'editedBy' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'recipeBookBuild' ? Array < RecipeBookBuildGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'recipeBookUser' ? Array < RecipeBookUserGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? RecipeBookCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'createdBy' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'editedBy' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'recipeBookBuild' ? Array < RecipeBookBuildGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'recipeBookUser' ? Array < RecipeBookUserGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? RecipeBookCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof RecipeBook ? RecipeBook[P] : never
  } 
    : RecipeBook
  : RecipeBook


  type RecipeBookCountArgs = Merge<
    Omit<RecipeBookFindManyArgs, 'select' | 'include'> & {
      select?: RecipeBookCountAggregateInputType | true
    }
  >

  export interface RecipeBookDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one RecipeBook that matches the filter.
     * @param {RecipeBookFindUniqueArgs} args - Arguments to find a RecipeBook
     * @example
     * // Get one RecipeBook
     * const recipeBook = await prisma.recipeBook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RecipeBookFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RecipeBookFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RecipeBook'> extends True ? CheckSelect<T, Prisma__RecipeBookClient<RecipeBook>, Prisma__RecipeBookClient<RecipeBookGetPayload<T>>> : CheckSelect<T, Prisma__RecipeBookClient<RecipeBook | null >, Prisma__RecipeBookClient<RecipeBookGetPayload<T> | null >>

    /**
     * Find the first RecipeBook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookFindFirstArgs} args - Arguments to find a RecipeBook
     * @example
     * // Get one RecipeBook
     * const recipeBook = await prisma.recipeBook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RecipeBookFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RecipeBookFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RecipeBook'> extends True ? CheckSelect<T, Prisma__RecipeBookClient<RecipeBook>, Prisma__RecipeBookClient<RecipeBookGetPayload<T>>> : CheckSelect<T, Prisma__RecipeBookClient<RecipeBook | null >, Prisma__RecipeBookClient<RecipeBookGetPayload<T> | null >>

    /**
     * Find zero or more RecipeBooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecipeBooks
     * const recipeBooks = await prisma.recipeBook.findMany()
     * 
     * // Get first 10 RecipeBooks
     * const recipeBooks = await prisma.recipeBook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeBookWithIdOnly = await prisma.recipeBook.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RecipeBookFindManyArgs>(
      args?: SelectSubset<T, RecipeBookFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RecipeBook>>, PrismaPromise<Array<RecipeBookGetPayload<T>>>>

    /**
     * Create a RecipeBook.
     * @param {RecipeBookCreateArgs} args - Arguments to create a RecipeBook.
     * @example
     * // Create one RecipeBook
     * const RecipeBook = await prisma.recipeBook.create({
     *   data: {
     *     // ... data to create a RecipeBook
     *   }
     * })
     * 
    **/
    create<T extends RecipeBookCreateArgs>(
      args: SelectSubset<T, RecipeBookCreateArgs>
    ): CheckSelect<T, Prisma__RecipeBookClient<RecipeBook>, Prisma__RecipeBookClient<RecipeBookGetPayload<T>>>

    /**
     * Create many RecipeBooks.
     *     @param {RecipeBookCreateManyArgs} args - Arguments to create many RecipeBooks.
     *     @example
     *     // Create many RecipeBooks
     *     const recipeBook = await prisma.recipeBook.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RecipeBookCreateManyArgs>(
      args?: SelectSubset<T, RecipeBookCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RecipeBook.
     * @param {RecipeBookDeleteArgs} args - Arguments to delete one RecipeBook.
     * @example
     * // Delete one RecipeBook
     * const RecipeBook = await prisma.recipeBook.delete({
     *   where: {
     *     // ... filter to delete one RecipeBook
     *   }
     * })
     * 
    **/
    delete<T extends RecipeBookDeleteArgs>(
      args: SelectSubset<T, RecipeBookDeleteArgs>
    ): CheckSelect<T, Prisma__RecipeBookClient<RecipeBook>, Prisma__RecipeBookClient<RecipeBookGetPayload<T>>>

    /**
     * Update one RecipeBook.
     * @param {RecipeBookUpdateArgs} args - Arguments to update one RecipeBook.
     * @example
     * // Update one RecipeBook
     * const recipeBook = await prisma.recipeBook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RecipeBookUpdateArgs>(
      args: SelectSubset<T, RecipeBookUpdateArgs>
    ): CheckSelect<T, Prisma__RecipeBookClient<RecipeBook>, Prisma__RecipeBookClient<RecipeBookGetPayload<T>>>

    /**
     * Delete zero or more RecipeBooks.
     * @param {RecipeBookDeleteManyArgs} args - Arguments to filter RecipeBooks to delete.
     * @example
     * // Delete a few RecipeBooks
     * const { count } = await prisma.recipeBook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RecipeBookDeleteManyArgs>(
      args?: SelectSubset<T, RecipeBookDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecipeBooks
     * const recipeBook = await prisma.recipeBook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RecipeBookUpdateManyArgs>(
      args: SelectSubset<T, RecipeBookUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RecipeBook.
     * @param {RecipeBookUpsertArgs} args - Arguments to update or create a RecipeBook.
     * @example
     * // Update or create a RecipeBook
     * const recipeBook = await prisma.recipeBook.upsert({
     *   create: {
     *     // ... data to create a RecipeBook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecipeBook we want to update
     *   }
     * })
    **/
    upsert<T extends RecipeBookUpsertArgs>(
      args: SelectSubset<T, RecipeBookUpsertArgs>
    ): CheckSelect<T, Prisma__RecipeBookClient<RecipeBook>, Prisma__RecipeBookClient<RecipeBookGetPayload<T>>>

    /**
     * Find one RecipeBook that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {RecipeBookFindUniqueOrThrowArgs} args - Arguments to find a RecipeBook
     * @example
     * // Get one RecipeBook
     * const recipeBook = await prisma.recipeBook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RecipeBookFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RecipeBookFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__RecipeBookClient<RecipeBook>, Prisma__RecipeBookClient<RecipeBookGetPayload<T>>>

    /**
     * Find the first RecipeBook that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookFindFirstOrThrowArgs} args - Arguments to find a RecipeBook
     * @example
     * // Get one RecipeBook
     * const recipeBook = await prisma.recipeBook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RecipeBookFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RecipeBookFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__RecipeBookClient<RecipeBook>, Prisma__RecipeBookClient<RecipeBookGetPayload<T>>>

    /**
     * Count the number of RecipeBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookCountArgs} args - Arguments to filter RecipeBooks to count.
     * @example
     * // Count the number of RecipeBooks
     * const count = await prisma.recipeBook.count({
     *   where: {
     *     // ... the filter for the RecipeBooks we want to count
     *   }
     * })
    **/
    count<T extends RecipeBookCountArgs>(
      args?: Subset<T, RecipeBookCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeBookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecipeBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeBookAggregateArgs>(args: Subset<T, RecipeBookAggregateArgs>): PrismaPromise<GetRecipeBookAggregateType<T>>

    /**
     * Group by RecipeBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeBookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeBookGroupByArgs['orderBy'] }
        : { orderBy?: RecipeBookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeBookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeBookGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RecipeBook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RecipeBookClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    createdBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    editedBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    recipeBookBuild<T extends RecipeBookBuildFindManyArgs = {}>(args?: Subset<T, RecipeBookBuildFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RecipeBookBuild>>, PrismaPromise<Array<RecipeBookBuildGetPayload<T>>>>;

    recipeBookUser<T extends RecipeBookUserFindManyArgs = {}>(args?: Subset<T, RecipeBookUserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RecipeBookUser>>, PrismaPromise<Array<RecipeBookUserGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RecipeBook base type for findUnique actions
   */
  export type RecipeBookFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RecipeBook
     * 
    **/
    select?: RecipeBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookInclude | null
    /**
     * Filter, which RecipeBook to fetch.
     * 
    **/
    where: RecipeBookWhereUniqueInput
  }

  /**
   * RecipeBook: findUnique
   */
  export interface RecipeBookFindUniqueArgs extends RecipeBookFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RecipeBook base type for findFirst actions
   */
  export type RecipeBookFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RecipeBook
     * 
    **/
    select?: RecipeBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookInclude | null
    /**
     * Filter, which RecipeBook to fetch.
     * 
    **/
    where?: RecipeBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBooks to fetch.
     * 
    **/
    orderBy?: Enumerable<RecipeBookOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeBooks.
     * 
    **/
    cursor?: RecipeBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBooks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBooks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeBooks.
     * 
    **/
    distinct?: Enumerable<RecipeBookScalarFieldEnum>
  }

  /**
   * RecipeBook: findFirst
   */
  export interface RecipeBookFindFirstArgs extends RecipeBookFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RecipeBook findMany
   */
  export type RecipeBookFindManyArgs = {
    /**
     * Select specific fields to fetch from the RecipeBook
     * 
    **/
    select?: RecipeBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookInclude | null
    /**
     * Filter, which RecipeBooks to fetch.
     * 
    **/
    where?: RecipeBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBooks to fetch.
     * 
    **/
    orderBy?: Enumerable<RecipeBookOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecipeBooks.
     * 
    **/
    cursor?: RecipeBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBooks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBooks.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RecipeBookScalarFieldEnum>
  }


  /**
   * RecipeBook create
   */
  export type RecipeBookCreateArgs = {
    /**
     * Select specific fields to fetch from the RecipeBook
     * 
    **/
    select?: RecipeBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookInclude | null
    /**
     * The data needed to create a RecipeBook.
     * 
    **/
    data: XOR<RecipeBookCreateInput, RecipeBookUncheckedCreateInput>
  }


  /**
   * RecipeBook createMany
   */
  export type RecipeBookCreateManyArgs = {
    /**
     * The data used to create many RecipeBooks.
     * 
    **/
    data: Enumerable<RecipeBookCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RecipeBook update
   */
  export type RecipeBookUpdateArgs = {
    /**
     * Select specific fields to fetch from the RecipeBook
     * 
    **/
    select?: RecipeBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookInclude | null
    /**
     * The data needed to update a RecipeBook.
     * 
    **/
    data: XOR<RecipeBookUpdateInput, RecipeBookUncheckedUpdateInput>
    /**
     * Choose, which RecipeBook to update.
     * 
    **/
    where: RecipeBookWhereUniqueInput
  }


  /**
   * RecipeBook updateMany
   */
  export type RecipeBookUpdateManyArgs = {
    /**
     * The data used to update RecipeBooks.
     * 
    **/
    data: XOR<RecipeBookUpdateManyMutationInput, RecipeBookUncheckedUpdateManyInput>
    /**
     * Filter which RecipeBooks to update
     * 
    **/
    where?: RecipeBookWhereInput
  }


  /**
   * RecipeBook upsert
   */
  export type RecipeBookUpsertArgs = {
    /**
     * Select specific fields to fetch from the RecipeBook
     * 
    **/
    select?: RecipeBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookInclude | null
    /**
     * The filter to search for the RecipeBook to update in case it exists.
     * 
    **/
    where: RecipeBookWhereUniqueInput
    /**
     * In case the RecipeBook found by the `where` argument doesn't exist, create a new RecipeBook with this data.
     * 
    **/
    create: XOR<RecipeBookCreateInput, RecipeBookUncheckedCreateInput>
    /**
     * In case the RecipeBook was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RecipeBookUpdateInput, RecipeBookUncheckedUpdateInput>
  }


  /**
   * RecipeBook delete
   */
  export type RecipeBookDeleteArgs = {
    /**
     * Select specific fields to fetch from the RecipeBook
     * 
    **/
    select?: RecipeBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookInclude | null
    /**
     * Filter which RecipeBook to delete.
     * 
    **/
    where: RecipeBookWhereUniqueInput
  }


  /**
   * RecipeBook deleteMany
   */
  export type RecipeBookDeleteManyArgs = {
    /**
     * Filter which RecipeBooks to delete
     * 
    **/
    where?: RecipeBookWhereInput
  }


  /**
   * RecipeBook: findUniqueOrThrow
   */
  export type RecipeBookFindUniqueOrThrowArgs = RecipeBookFindUniqueArgsBase
      

  /**
   * RecipeBook: findFirstOrThrow
   */
  export type RecipeBookFindFirstOrThrowArgs = RecipeBookFindFirstArgsBase
      

  /**
   * RecipeBook without action
   */
  export type RecipeBookArgs = {
    /**
     * Select specific fields to fetch from the RecipeBook
     * 
    **/
    select?: RecipeBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookInclude | null
  }



  /**
   * Model RecipeBookUser
   */


  export type AggregateRecipeBookUser = {
    _count: RecipeBookUserCountAggregateOutputType | null
    _avg: RecipeBookUserAvgAggregateOutputType | null
    _sum: RecipeBookUserSumAggregateOutputType | null
    _min: RecipeBookUserMinAggregateOutputType | null
    _max: RecipeBookUserMaxAggregateOutputType | null
  }

  export type RecipeBookUserAvgAggregateOutputType = {
    recipeBookId: number | null
  }

  export type RecipeBookUserSumAggregateOutputType = {
    recipeBookId: number | null
  }

  export type RecipeBookUserMinAggregateOutputType = {
    userId: string | null
    recipeBookId: number | null
    permission: string | null
  }

  export type RecipeBookUserMaxAggregateOutputType = {
    userId: string | null
    recipeBookId: number | null
    permission: string | null
  }

  export type RecipeBookUserCountAggregateOutputType = {
    userId: number
    recipeBookId: number
    permission: number
    _all: number
  }


  export type RecipeBookUserAvgAggregateInputType = {
    recipeBookId?: true
  }

  export type RecipeBookUserSumAggregateInputType = {
    recipeBookId?: true
  }

  export type RecipeBookUserMinAggregateInputType = {
    userId?: true
    recipeBookId?: true
    permission?: true
  }

  export type RecipeBookUserMaxAggregateInputType = {
    userId?: true
    recipeBookId?: true
    permission?: true
  }

  export type RecipeBookUserCountAggregateInputType = {
    userId?: true
    recipeBookId?: true
    permission?: true
    _all?: true
  }

  export type RecipeBookUserAggregateArgs = {
    /**
     * Filter which RecipeBookUser to aggregate.
     * 
    **/
    where?: RecipeBookUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBookUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<RecipeBookUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RecipeBookUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBookUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBookUsers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecipeBookUsers
    **/
    _count?: true | RecipeBookUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecipeBookUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecipeBookUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeBookUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeBookUserMaxAggregateInputType
  }

  export type GetRecipeBookUserAggregateType<T extends RecipeBookUserAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipeBookUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipeBookUser[P]>
      : GetScalarType<T[P], AggregateRecipeBookUser[P]>
  }




  export type RecipeBookUserGroupByArgs = {
    where?: RecipeBookUserWhereInput
    orderBy?: Enumerable<RecipeBookUserOrderByWithAggregationInput>
    by: Array<RecipeBookUserScalarFieldEnum>
    having?: RecipeBookUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeBookUserCountAggregateInputType | true
    _avg?: RecipeBookUserAvgAggregateInputType
    _sum?: RecipeBookUserSumAggregateInputType
    _min?: RecipeBookUserMinAggregateInputType
    _max?: RecipeBookUserMaxAggregateInputType
  }


  export type RecipeBookUserGroupByOutputType = {
    userId: string
    recipeBookId: number
    permission: string
    _count: RecipeBookUserCountAggregateOutputType | null
    _avg: RecipeBookUserAvgAggregateOutputType | null
    _sum: RecipeBookUserSumAggregateOutputType | null
    _min: RecipeBookUserMinAggregateOutputType | null
    _max: RecipeBookUserMaxAggregateOutputType | null
  }

  type GetRecipeBookUserGroupByPayload<T extends RecipeBookUserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RecipeBookUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeBookUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeBookUserGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeBookUserGroupByOutputType[P]>
        }
      >
    >


  export type RecipeBookUserSelect = {
    userId?: boolean
    recipeBookId?: boolean
    recipeBook?: boolean | RecipeBookArgs
    user?: boolean | UserArgs
    permission?: boolean
  }

  export type RecipeBookUserInclude = {
    recipeBook?: boolean | RecipeBookArgs
    user?: boolean | UserArgs
  }

  export type RecipeBookUserGetPayload<
    S extends boolean | null | undefined | RecipeBookUserArgs,
    U = keyof S
      > = S extends true
        ? RecipeBookUser
    : S extends undefined
    ? never
    : S extends RecipeBookUserArgs | RecipeBookUserFindManyArgs
    ?'include' extends U
    ? RecipeBookUser  & {
    [P in TrueKeys<S['include']>]:
        P extends 'recipeBook' ? RecipeBookGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'recipeBook' ? RecipeBookGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof RecipeBookUser ? RecipeBookUser[P] : never
  } 
    : RecipeBookUser
  : RecipeBookUser


  type RecipeBookUserCountArgs = Merge<
    Omit<RecipeBookUserFindManyArgs, 'select' | 'include'> & {
      select?: RecipeBookUserCountAggregateInputType | true
    }
  >

  export interface RecipeBookUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one RecipeBookUser that matches the filter.
     * @param {RecipeBookUserFindUniqueArgs} args - Arguments to find a RecipeBookUser
     * @example
     * // Get one RecipeBookUser
     * const recipeBookUser = await prisma.recipeBookUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RecipeBookUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RecipeBookUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RecipeBookUser'> extends True ? CheckSelect<T, Prisma__RecipeBookUserClient<RecipeBookUser>, Prisma__RecipeBookUserClient<RecipeBookUserGetPayload<T>>> : CheckSelect<T, Prisma__RecipeBookUserClient<RecipeBookUser | null >, Prisma__RecipeBookUserClient<RecipeBookUserGetPayload<T> | null >>

    /**
     * Find the first RecipeBookUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookUserFindFirstArgs} args - Arguments to find a RecipeBookUser
     * @example
     * // Get one RecipeBookUser
     * const recipeBookUser = await prisma.recipeBookUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RecipeBookUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RecipeBookUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RecipeBookUser'> extends True ? CheckSelect<T, Prisma__RecipeBookUserClient<RecipeBookUser>, Prisma__RecipeBookUserClient<RecipeBookUserGetPayload<T>>> : CheckSelect<T, Prisma__RecipeBookUserClient<RecipeBookUser | null >, Prisma__RecipeBookUserClient<RecipeBookUserGetPayload<T> | null >>

    /**
     * Find zero or more RecipeBookUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecipeBookUsers
     * const recipeBookUsers = await prisma.recipeBookUser.findMany()
     * 
     * // Get first 10 RecipeBookUsers
     * const recipeBookUsers = await prisma.recipeBookUser.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const recipeBookUserWithUserIdOnly = await prisma.recipeBookUser.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends RecipeBookUserFindManyArgs>(
      args?: SelectSubset<T, RecipeBookUserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RecipeBookUser>>, PrismaPromise<Array<RecipeBookUserGetPayload<T>>>>

    /**
     * Create a RecipeBookUser.
     * @param {RecipeBookUserCreateArgs} args - Arguments to create a RecipeBookUser.
     * @example
     * // Create one RecipeBookUser
     * const RecipeBookUser = await prisma.recipeBookUser.create({
     *   data: {
     *     // ... data to create a RecipeBookUser
     *   }
     * })
     * 
    **/
    create<T extends RecipeBookUserCreateArgs>(
      args: SelectSubset<T, RecipeBookUserCreateArgs>
    ): CheckSelect<T, Prisma__RecipeBookUserClient<RecipeBookUser>, Prisma__RecipeBookUserClient<RecipeBookUserGetPayload<T>>>

    /**
     * Create many RecipeBookUsers.
     *     @param {RecipeBookUserCreateManyArgs} args - Arguments to create many RecipeBookUsers.
     *     @example
     *     // Create many RecipeBookUsers
     *     const recipeBookUser = await prisma.recipeBookUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RecipeBookUserCreateManyArgs>(
      args?: SelectSubset<T, RecipeBookUserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RecipeBookUser.
     * @param {RecipeBookUserDeleteArgs} args - Arguments to delete one RecipeBookUser.
     * @example
     * // Delete one RecipeBookUser
     * const RecipeBookUser = await prisma.recipeBookUser.delete({
     *   where: {
     *     // ... filter to delete one RecipeBookUser
     *   }
     * })
     * 
    **/
    delete<T extends RecipeBookUserDeleteArgs>(
      args: SelectSubset<T, RecipeBookUserDeleteArgs>
    ): CheckSelect<T, Prisma__RecipeBookUserClient<RecipeBookUser>, Prisma__RecipeBookUserClient<RecipeBookUserGetPayload<T>>>

    /**
     * Update one RecipeBookUser.
     * @param {RecipeBookUserUpdateArgs} args - Arguments to update one RecipeBookUser.
     * @example
     * // Update one RecipeBookUser
     * const recipeBookUser = await prisma.recipeBookUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RecipeBookUserUpdateArgs>(
      args: SelectSubset<T, RecipeBookUserUpdateArgs>
    ): CheckSelect<T, Prisma__RecipeBookUserClient<RecipeBookUser>, Prisma__RecipeBookUserClient<RecipeBookUserGetPayload<T>>>

    /**
     * Delete zero or more RecipeBookUsers.
     * @param {RecipeBookUserDeleteManyArgs} args - Arguments to filter RecipeBookUsers to delete.
     * @example
     * // Delete a few RecipeBookUsers
     * const { count } = await prisma.recipeBookUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RecipeBookUserDeleteManyArgs>(
      args?: SelectSubset<T, RecipeBookUserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeBookUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecipeBookUsers
     * const recipeBookUser = await prisma.recipeBookUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RecipeBookUserUpdateManyArgs>(
      args: SelectSubset<T, RecipeBookUserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RecipeBookUser.
     * @param {RecipeBookUserUpsertArgs} args - Arguments to update or create a RecipeBookUser.
     * @example
     * // Update or create a RecipeBookUser
     * const recipeBookUser = await prisma.recipeBookUser.upsert({
     *   create: {
     *     // ... data to create a RecipeBookUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecipeBookUser we want to update
     *   }
     * })
    **/
    upsert<T extends RecipeBookUserUpsertArgs>(
      args: SelectSubset<T, RecipeBookUserUpsertArgs>
    ): CheckSelect<T, Prisma__RecipeBookUserClient<RecipeBookUser>, Prisma__RecipeBookUserClient<RecipeBookUserGetPayload<T>>>

    /**
     * Find one RecipeBookUser that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {RecipeBookUserFindUniqueOrThrowArgs} args - Arguments to find a RecipeBookUser
     * @example
     * // Get one RecipeBookUser
     * const recipeBookUser = await prisma.recipeBookUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RecipeBookUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RecipeBookUserFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__RecipeBookUserClient<RecipeBookUser>, Prisma__RecipeBookUserClient<RecipeBookUserGetPayload<T>>>

    /**
     * Find the first RecipeBookUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookUserFindFirstOrThrowArgs} args - Arguments to find a RecipeBookUser
     * @example
     * // Get one RecipeBookUser
     * const recipeBookUser = await prisma.recipeBookUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RecipeBookUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RecipeBookUserFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__RecipeBookUserClient<RecipeBookUser>, Prisma__RecipeBookUserClient<RecipeBookUserGetPayload<T>>>

    /**
     * Count the number of RecipeBookUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookUserCountArgs} args - Arguments to filter RecipeBookUsers to count.
     * @example
     * // Count the number of RecipeBookUsers
     * const count = await prisma.recipeBookUser.count({
     *   where: {
     *     // ... the filter for the RecipeBookUsers we want to count
     *   }
     * })
    **/
    count<T extends RecipeBookUserCountArgs>(
      args?: Subset<T, RecipeBookUserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeBookUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecipeBookUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeBookUserAggregateArgs>(args: Subset<T, RecipeBookUserAggregateArgs>): PrismaPromise<GetRecipeBookUserAggregateType<T>>

    /**
     * Group by RecipeBookUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeBookUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeBookUserGroupByArgs['orderBy'] }
        : { orderBy?: RecipeBookUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeBookUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeBookUserGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RecipeBookUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RecipeBookUserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    recipeBook<T extends RecipeBookArgs = {}>(args?: Subset<T, RecipeBookArgs>): CheckSelect<T, Prisma__RecipeBookClient<RecipeBook | null >, Prisma__RecipeBookClient<RecipeBookGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RecipeBookUser base type for findUnique actions
   */
  export type RecipeBookUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     * 
    **/
    select?: RecipeBookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookUserInclude | null
    /**
     * Filter, which RecipeBookUser to fetch.
     * 
    **/
    where: RecipeBookUserWhereUniqueInput
  }

  /**
   * RecipeBookUser: findUnique
   */
  export interface RecipeBookUserFindUniqueArgs extends RecipeBookUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RecipeBookUser base type for findFirst actions
   */
  export type RecipeBookUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     * 
    **/
    select?: RecipeBookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookUserInclude | null
    /**
     * Filter, which RecipeBookUser to fetch.
     * 
    **/
    where?: RecipeBookUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBookUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<RecipeBookUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeBookUsers.
     * 
    **/
    cursor?: RecipeBookUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBookUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBookUsers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeBookUsers.
     * 
    **/
    distinct?: Enumerable<RecipeBookUserScalarFieldEnum>
  }

  /**
   * RecipeBookUser: findFirst
   */
  export interface RecipeBookUserFindFirstArgs extends RecipeBookUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RecipeBookUser findMany
   */
  export type RecipeBookUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     * 
    **/
    select?: RecipeBookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookUserInclude | null
    /**
     * Filter, which RecipeBookUsers to fetch.
     * 
    **/
    where?: RecipeBookUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBookUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<RecipeBookUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecipeBookUsers.
     * 
    **/
    cursor?: RecipeBookUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBookUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBookUsers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RecipeBookUserScalarFieldEnum>
  }


  /**
   * RecipeBookUser create
   */
  export type RecipeBookUserCreateArgs = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     * 
    **/
    select?: RecipeBookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookUserInclude | null
    /**
     * The data needed to create a RecipeBookUser.
     * 
    **/
    data: XOR<RecipeBookUserCreateInput, RecipeBookUserUncheckedCreateInput>
  }


  /**
   * RecipeBookUser createMany
   */
  export type RecipeBookUserCreateManyArgs = {
    /**
     * The data used to create many RecipeBookUsers.
     * 
    **/
    data: Enumerable<RecipeBookUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RecipeBookUser update
   */
  export type RecipeBookUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     * 
    **/
    select?: RecipeBookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookUserInclude | null
    /**
     * The data needed to update a RecipeBookUser.
     * 
    **/
    data: XOR<RecipeBookUserUpdateInput, RecipeBookUserUncheckedUpdateInput>
    /**
     * Choose, which RecipeBookUser to update.
     * 
    **/
    where: RecipeBookUserWhereUniqueInput
  }


  /**
   * RecipeBookUser updateMany
   */
  export type RecipeBookUserUpdateManyArgs = {
    /**
     * The data used to update RecipeBookUsers.
     * 
    **/
    data: XOR<RecipeBookUserUpdateManyMutationInput, RecipeBookUserUncheckedUpdateManyInput>
    /**
     * Filter which RecipeBookUsers to update
     * 
    **/
    where?: RecipeBookUserWhereInput
  }


  /**
   * RecipeBookUser upsert
   */
  export type RecipeBookUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     * 
    **/
    select?: RecipeBookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookUserInclude | null
    /**
     * The filter to search for the RecipeBookUser to update in case it exists.
     * 
    **/
    where: RecipeBookUserWhereUniqueInput
    /**
     * In case the RecipeBookUser found by the `where` argument doesn't exist, create a new RecipeBookUser with this data.
     * 
    **/
    create: XOR<RecipeBookUserCreateInput, RecipeBookUserUncheckedCreateInput>
    /**
     * In case the RecipeBookUser was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RecipeBookUserUpdateInput, RecipeBookUserUncheckedUpdateInput>
  }


  /**
   * RecipeBookUser delete
   */
  export type RecipeBookUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     * 
    **/
    select?: RecipeBookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookUserInclude | null
    /**
     * Filter which RecipeBookUser to delete.
     * 
    **/
    where: RecipeBookUserWhereUniqueInput
  }


  /**
   * RecipeBookUser deleteMany
   */
  export type RecipeBookUserDeleteManyArgs = {
    /**
     * Filter which RecipeBookUsers to delete
     * 
    **/
    where?: RecipeBookUserWhereInput
  }


  /**
   * RecipeBookUser: findUniqueOrThrow
   */
  export type RecipeBookUserFindUniqueOrThrowArgs = RecipeBookUserFindUniqueArgsBase
      

  /**
   * RecipeBookUser: findFirstOrThrow
   */
  export type RecipeBookUserFindFirstOrThrowArgs = RecipeBookUserFindFirstArgsBase
      

  /**
   * RecipeBookUser without action
   */
  export type RecipeBookUserArgs = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     * 
    **/
    select?: RecipeBookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookUserInclude | null
  }



  /**
   * Model Build
   */


  export type AggregateBuild = {
    _count: BuildCountAggregateOutputType | null
    _avg: BuildAvgAggregateOutputType | null
    _sum: BuildSumAggregateOutputType | null
    _min: BuildMinAggregateOutputType | null
    _max: BuildMaxAggregateOutputType | null
  }

  export type BuildAvgAggregateOutputType = {
    id: number | null
    recipeId: number | null
  }

  export type BuildSumAggregateOutputType = {
    id: number | null
    recipeId: number | null
  }

  export type BuildMinAggregateOutputType = {
    id: number | null
    buildName: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
    recipeId: number | null
    instructions: string | null
    notes: string | null
    glassware: string | null
    ice: string | null
  }

  export type BuildMaxAggregateOutputType = {
    id: number | null
    buildName: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
    recipeId: number | null
    instructions: string | null
    notes: string | null
    glassware: string | null
    ice: string | null
  }

  export type BuildCountAggregateOutputType = {
    id: number
    buildName: number
    createdAt: number
    editedAt: number
    createdById: number
    editedById: number
    recipeId: number
    instructions: number
    notes: number
    glassware: number
    ice: number
    _all: number
  }


  export type BuildAvgAggregateInputType = {
    id?: true
    recipeId?: true
  }

  export type BuildSumAggregateInputType = {
    id?: true
    recipeId?: true
  }

  export type BuildMinAggregateInputType = {
    id?: true
    buildName?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
    recipeId?: true
    instructions?: true
    notes?: true
    glassware?: true
    ice?: true
  }

  export type BuildMaxAggregateInputType = {
    id?: true
    buildName?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
    recipeId?: true
    instructions?: true
    notes?: true
    glassware?: true
    ice?: true
  }

  export type BuildCountAggregateInputType = {
    id?: true
    buildName?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
    recipeId?: true
    instructions?: true
    notes?: true
    glassware?: true
    ice?: true
    _all?: true
  }

  export type BuildAggregateArgs = {
    /**
     * Filter which Build to aggregate.
     * 
    **/
    where?: BuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Builds to fetch.
     * 
    **/
    orderBy?: Enumerable<BuildOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: BuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Builds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Builds.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Builds
    **/
    _count?: true | BuildCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BuildAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BuildSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuildMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuildMaxAggregateInputType
  }

  export type GetBuildAggregateType<T extends BuildAggregateArgs> = {
        [P in keyof T & keyof AggregateBuild]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuild[P]>
      : GetScalarType<T[P], AggregateBuild[P]>
  }




  export type BuildGroupByArgs = {
    where?: BuildWhereInput
    orderBy?: Enumerable<BuildOrderByWithAggregationInput>
    by: Array<BuildScalarFieldEnum>
    having?: BuildScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuildCountAggregateInputType | true
    _avg?: BuildAvgAggregateInputType
    _sum?: BuildSumAggregateInputType
    _min?: BuildMinAggregateInputType
    _max?: BuildMaxAggregateInputType
  }


  export type BuildGroupByOutputType = {
    id: number
    buildName: string
    createdAt: Date
    editedAt: Date
    createdById: string
    editedById: string
    recipeId: number | null
    instructions: string | null
    notes: string | null
    glassware: string | null
    ice: string | null
    _count: BuildCountAggregateOutputType | null
    _avg: BuildAvgAggregateOutputType | null
    _sum: BuildSumAggregateOutputType | null
    _min: BuildMinAggregateOutputType | null
    _max: BuildMaxAggregateOutputType | null
  }

  type GetBuildGroupByPayload<T extends BuildGroupByArgs> = PrismaPromise<
    Array<
      PickArray<BuildGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuildGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuildGroupByOutputType[P]>
            : GetScalarType<T[P], BuildGroupByOutputType[P]>
        }
      >
    >


  export type BuildSelect = {
    id?: boolean
    buildName?: boolean
    createdAt?: boolean
    editedAt?: boolean
    createdById?: boolean
    editedById?: boolean
    createdBy?: boolean | UserArgs
    editedBy?: boolean | UserArgs
    recipe?: boolean | RecipeArgs
    recipeId?: boolean
    instructions?: boolean
    notes?: boolean
    glassware?: boolean
    ice?: boolean
    touch?: boolean | TouchFindManyArgs
    RecipeBookBuild?: boolean | RecipeBookBuildFindManyArgs
    buildUser?: boolean | BuildUserFindManyArgs
    _count?: boolean | BuildCountOutputTypeArgs
  }

  export type BuildInclude = {
    createdBy?: boolean | UserArgs
    editedBy?: boolean | UserArgs
    recipe?: boolean | RecipeArgs
    touch?: boolean | TouchFindManyArgs
    RecipeBookBuild?: boolean | RecipeBookBuildFindManyArgs
    buildUser?: boolean | BuildUserFindManyArgs
    _count?: boolean | BuildCountOutputTypeArgs
  }

  export type BuildGetPayload<
    S extends boolean | null | undefined | BuildArgs,
    U = keyof S
      > = S extends true
        ? Build
    : S extends undefined
    ? never
    : S extends BuildArgs | BuildFindManyArgs
    ?'include' extends U
    ? Build  & {
    [P in TrueKeys<S['include']>]:
        P extends 'createdBy' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'editedBy' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'recipe' ? RecipeGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'touch' ? Array < TouchGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'RecipeBookBuild' ? Array < RecipeBookBuildGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'buildUser' ? Array < BuildUserGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? BuildCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'createdBy' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'editedBy' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'recipe' ? RecipeGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'touch' ? Array < TouchGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'RecipeBookBuild' ? Array < RecipeBookBuildGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'buildUser' ? Array < BuildUserGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? BuildCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Build ? Build[P] : never
  } 
    : Build
  : Build


  type BuildCountArgs = Merge<
    Omit<BuildFindManyArgs, 'select' | 'include'> & {
      select?: BuildCountAggregateInputType | true
    }
  >

  export interface BuildDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Build that matches the filter.
     * @param {BuildFindUniqueArgs} args - Arguments to find a Build
     * @example
     * // Get one Build
     * const build = await prisma.build.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BuildFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BuildFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Build'> extends True ? CheckSelect<T, Prisma__BuildClient<Build>, Prisma__BuildClient<BuildGetPayload<T>>> : CheckSelect<T, Prisma__BuildClient<Build | null >, Prisma__BuildClient<BuildGetPayload<T> | null >>

    /**
     * Find the first Build that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildFindFirstArgs} args - Arguments to find a Build
     * @example
     * // Get one Build
     * const build = await prisma.build.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BuildFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BuildFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Build'> extends True ? CheckSelect<T, Prisma__BuildClient<Build>, Prisma__BuildClient<BuildGetPayload<T>>> : CheckSelect<T, Prisma__BuildClient<Build | null >, Prisma__BuildClient<BuildGetPayload<T> | null >>

    /**
     * Find zero or more Builds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Builds
     * const builds = await prisma.build.findMany()
     * 
     * // Get first 10 Builds
     * const builds = await prisma.build.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buildWithIdOnly = await prisma.build.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BuildFindManyArgs>(
      args?: SelectSubset<T, BuildFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Build>>, PrismaPromise<Array<BuildGetPayload<T>>>>

    /**
     * Create a Build.
     * @param {BuildCreateArgs} args - Arguments to create a Build.
     * @example
     * // Create one Build
     * const Build = await prisma.build.create({
     *   data: {
     *     // ... data to create a Build
     *   }
     * })
     * 
    **/
    create<T extends BuildCreateArgs>(
      args: SelectSubset<T, BuildCreateArgs>
    ): CheckSelect<T, Prisma__BuildClient<Build>, Prisma__BuildClient<BuildGetPayload<T>>>

    /**
     * Create many Builds.
     *     @param {BuildCreateManyArgs} args - Arguments to create many Builds.
     *     @example
     *     // Create many Builds
     *     const build = await prisma.build.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BuildCreateManyArgs>(
      args?: SelectSubset<T, BuildCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Build.
     * @param {BuildDeleteArgs} args - Arguments to delete one Build.
     * @example
     * // Delete one Build
     * const Build = await prisma.build.delete({
     *   where: {
     *     // ... filter to delete one Build
     *   }
     * })
     * 
    **/
    delete<T extends BuildDeleteArgs>(
      args: SelectSubset<T, BuildDeleteArgs>
    ): CheckSelect<T, Prisma__BuildClient<Build>, Prisma__BuildClient<BuildGetPayload<T>>>

    /**
     * Update one Build.
     * @param {BuildUpdateArgs} args - Arguments to update one Build.
     * @example
     * // Update one Build
     * const build = await prisma.build.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BuildUpdateArgs>(
      args: SelectSubset<T, BuildUpdateArgs>
    ): CheckSelect<T, Prisma__BuildClient<Build>, Prisma__BuildClient<BuildGetPayload<T>>>

    /**
     * Delete zero or more Builds.
     * @param {BuildDeleteManyArgs} args - Arguments to filter Builds to delete.
     * @example
     * // Delete a few Builds
     * const { count } = await prisma.build.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BuildDeleteManyArgs>(
      args?: SelectSubset<T, BuildDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Builds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Builds
     * const build = await prisma.build.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BuildUpdateManyArgs>(
      args: SelectSubset<T, BuildUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Build.
     * @param {BuildUpsertArgs} args - Arguments to update or create a Build.
     * @example
     * // Update or create a Build
     * const build = await prisma.build.upsert({
     *   create: {
     *     // ... data to create a Build
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Build we want to update
     *   }
     * })
    **/
    upsert<T extends BuildUpsertArgs>(
      args: SelectSubset<T, BuildUpsertArgs>
    ): CheckSelect<T, Prisma__BuildClient<Build>, Prisma__BuildClient<BuildGetPayload<T>>>

    /**
     * Find one Build that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {BuildFindUniqueOrThrowArgs} args - Arguments to find a Build
     * @example
     * // Get one Build
     * const build = await prisma.build.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BuildFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BuildFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__BuildClient<Build>, Prisma__BuildClient<BuildGetPayload<T>>>

    /**
     * Find the first Build that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildFindFirstOrThrowArgs} args - Arguments to find a Build
     * @example
     * // Get one Build
     * const build = await prisma.build.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BuildFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BuildFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__BuildClient<Build>, Prisma__BuildClient<BuildGetPayload<T>>>

    /**
     * Count the number of Builds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildCountArgs} args - Arguments to filter Builds to count.
     * @example
     * // Count the number of Builds
     * const count = await prisma.build.count({
     *   where: {
     *     // ... the filter for the Builds we want to count
     *   }
     * })
    **/
    count<T extends BuildCountArgs>(
      args?: Subset<T, BuildCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuildCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Build.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuildAggregateArgs>(args: Subset<T, BuildAggregateArgs>): PrismaPromise<GetBuildAggregateType<T>>

    /**
     * Group by Build.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuildGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuildGroupByArgs['orderBy'] }
        : { orderBy?: BuildGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuildGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuildGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Build.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BuildClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    createdBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    editedBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    recipe<T extends RecipeArgs = {}>(args?: Subset<T, RecipeArgs>): CheckSelect<T, Prisma__RecipeClient<Recipe | null >, Prisma__RecipeClient<RecipeGetPayload<T> | null >>;

    touch<T extends TouchFindManyArgs = {}>(args?: Subset<T, TouchFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Touch>>, PrismaPromise<Array<TouchGetPayload<T>>>>;

    RecipeBookBuild<T extends RecipeBookBuildFindManyArgs = {}>(args?: Subset<T, RecipeBookBuildFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RecipeBookBuild>>, PrismaPromise<Array<RecipeBookBuildGetPayload<T>>>>;

    buildUser<T extends BuildUserFindManyArgs = {}>(args?: Subset<T, BuildUserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<BuildUser>>, PrismaPromise<Array<BuildUserGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Build base type for findUnique actions
   */
  export type BuildFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Build
     * 
    **/
    select?: BuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BuildInclude | null
    /**
     * Filter, which Build to fetch.
     * 
    **/
    where: BuildWhereUniqueInput
  }

  /**
   * Build: findUnique
   */
  export interface BuildFindUniqueArgs extends BuildFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Build base type for findFirst actions
   */
  export type BuildFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Build
     * 
    **/
    select?: BuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BuildInclude | null
    /**
     * Filter, which Build to fetch.
     * 
    **/
    where?: BuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Builds to fetch.
     * 
    **/
    orderBy?: Enumerable<BuildOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Builds.
     * 
    **/
    cursor?: BuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Builds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Builds.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Builds.
     * 
    **/
    distinct?: Enumerable<BuildScalarFieldEnum>
  }

  /**
   * Build: findFirst
   */
  export interface BuildFindFirstArgs extends BuildFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Build findMany
   */
  export type BuildFindManyArgs = {
    /**
     * Select specific fields to fetch from the Build
     * 
    **/
    select?: BuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BuildInclude | null
    /**
     * Filter, which Builds to fetch.
     * 
    **/
    where?: BuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Builds to fetch.
     * 
    **/
    orderBy?: Enumerable<BuildOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Builds.
     * 
    **/
    cursor?: BuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Builds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Builds.
     * 
    **/
    skip?: number
    distinct?: Enumerable<BuildScalarFieldEnum>
  }


  /**
   * Build create
   */
  export type BuildCreateArgs = {
    /**
     * Select specific fields to fetch from the Build
     * 
    **/
    select?: BuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BuildInclude | null
    /**
     * The data needed to create a Build.
     * 
    **/
    data: XOR<BuildCreateInput, BuildUncheckedCreateInput>
  }


  /**
   * Build createMany
   */
  export type BuildCreateManyArgs = {
    /**
     * The data used to create many Builds.
     * 
    **/
    data: Enumerable<BuildCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Build update
   */
  export type BuildUpdateArgs = {
    /**
     * Select specific fields to fetch from the Build
     * 
    **/
    select?: BuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BuildInclude | null
    /**
     * The data needed to update a Build.
     * 
    **/
    data: XOR<BuildUpdateInput, BuildUncheckedUpdateInput>
    /**
     * Choose, which Build to update.
     * 
    **/
    where: BuildWhereUniqueInput
  }


  /**
   * Build updateMany
   */
  export type BuildUpdateManyArgs = {
    /**
     * The data used to update Builds.
     * 
    **/
    data: XOR<BuildUpdateManyMutationInput, BuildUncheckedUpdateManyInput>
    /**
     * Filter which Builds to update
     * 
    **/
    where?: BuildWhereInput
  }


  /**
   * Build upsert
   */
  export type BuildUpsertArgs = {
    /**
     * Select specific fields to fetch from the Build
     * 
    **/
    select?: BuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BuildInclude | null
    /**
     * The filter to search for the Build to update in case it exists.
     * 
    **/
    where: BuildWhereUniqueInput
    /**
     * In case the Build found by the `where` argument doesn't exist, create a new Build with this data.
     * 
    **/
    create: XOR<BuildCreateInput, BuildUncheckedCreateInput>
    /**
     * In case the Build was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<BuildUpdateInput, BuildUncheckedUpdateInput>
  }


  /**
   * Build delete
   */
  export type BuildDeleteArgs = {
    /**
     * Select specific fields to fetch from the Build
     * 
    **/
    select?: BuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BuildInclude | null
    /**
     * Filter which Build to delete.
     * 
    **/
    where: BuildWhereUniqueInput
  }


  /**
   * Build deleteMany
   */
  export type BuildDeleteManyArgs = {
    /**
     * Filter which Builds to delete
     * 
    **/
    where?: BuildWhereInput
  }


  /**
   * Build: findUniqueOrThrow
   */
  export type BuildFindUniqueOrThrowArgs = BuildFindUniqueArgsBase
      

  /**
   * Build: findFirstOrThrow
   */
  export type BuildFindFirstOrThrowArgs = BuildFindFirstArgsBase
      

  /**
   * Build without action
   */
  export type BuildArgs = {
    /**
     * Select specific fields to fetch from the Build
     * 
    **/
    select?: BuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BuildInclude | null
  }



  /**
   * Model BuildUser
   */


  export type AggregateBuildUser = {
    _count: BuildUserCountAggregateOutputType | null
    _avg: BuildUserAvgAggregateOutputType | null
    _sum: BuildUserSumAggregateOutputType | null
    _min: BuildUserMinAggregateOutputType | null
    _max: BuildUserMaxAggregateOutputType | null
  }

  export type BuildUserAvgAggregateOutputType = {
    buildId: number | null
  }

  export type BuildUserSumAggregateOutputType = {
    buildId: number | null
  }

  export type BuildUserMinAggregateOutputType = {
    userId: string | null
    buildId: number | null
    permission: string | null
  }

  export type BuildUserMaxAggregateOutputType = {
    userId: string | null
    buildId: number | null
    permission: string | null
  }

  export type BuildUserCountAggregateOutputType = {
    userId: number
    buildId: number
    permission: number
    _all: number
  }


  export type BuildUserAvgAggregateInputType = {
    buildId?: true
  }

  export type BuildUserSumAggregateInputType = {
    buildId?: true
  }

  export type BuildUserMinAggregateInputType = {
    userId?: true
    buildId?: true
    permission?: true
  }

  export type BuildUserMaxAggregateInputType = {
    userId?: true
    buildId?: true
    permission?: true
  }

  export type BuildUserCountAggregateInputType = {
    userId?: true
    buildId?: true
    permission?: true
    _all?: true
  }

  export type BuildUserAggregateArgs = {
    /**
     * Filter which BuildUser to aggregate.
     * 
    **/
    where?: BuildUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<BuildUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: BuildUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildUsers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BuildUsers
    **/
    _count?: true | BuildUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BuildUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BuildUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuildUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuildUserMaxAggregateInputType
  }

  export type GetBuildUserAggregateType<T extends BuildUserAggregateArgs> = {
        [P in keyof T & keyof AggregateBuildUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuildUser[P]>
      : GetScalarType<T[P], AggregateBuildUser[P]>
  }




  export type BuildUserGroupByArgs = {
    where?: BuildUserWhereInput
    orderBy?: Enumerable<BuildUserOrderByWithAggregationInput>
    by: Array<BuildUserScalarFieldEnum>
    having?: BuildUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuildUserCountAggregateInputType | true
    _avg?: BuildUserAvgAggregateInputType
    _sum?: BuildUserSumAggregateInputType
    _min?: BuildUserMinAggregateInputType
    _max?: BuildUserMaxAggregateInputType
  }


  export type BuildUserGroupByOutputType = {
    userId: string
    buildId: number
    permission: string
    _count: BuildUserCountAggregateOutputType | null
    _avg: BuildUserAvgAggregateOutputType | null
    _sum: BuildUserSumAggregateOutputType | null
    _min: BuildUserMinAggregateOutputType | null
    _max: BuildUserMaxAggregateOutputType | null
  }

  type GetBuildUserGroupByPayload<T extends BuildUserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<BuildUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuildUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuildUserGroupByOutputType[P]>
            : GetScalarType<T[P], BuildUserGroupByOutputType[P]>
        }
      >
    >


  export type BuildUserSelect = {
    userId?: boolean
    buildId?: boolean
    user?: boolean | UserArgs
    build?: boolean | BuildArgs
    permission?: boolean
  }

  export type BuildUserInclude = {
    user?: boolean | UserArgs
    build?: boolean | BuildArgs
  }

  export type BuildUserGetPayload<
    S extends boolean | null | undefined | BuildUserArgs,
    U = keyof S
      > = S extends true
        ? BuildUser
    : S extends undefined
    ? never
    : S extends BuildUserArgs | BuildUserFindManyArgs
    ?'include' extends U
    ? BuildUser  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'build' ? BuildGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'build' ? BuildGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof BuildUser ? BuildUser[P] : never
  } 
    : BuildUser
  : BuildUser


  type BuildUserCountArgs = Merge<
    Omit<BuildUserFindManyArgs, 'select' | 'include'> & {
      select?: BuildUserCountAggregateInputType | true
    }
  >

  export interface BuildUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one BuildUser that matches the filter.
     * @param {BuildUserFindUniqueArgs} args - Arguments to find a BuildUser
     * @example
     * // Get one BuildUser
     * const buildUser = await prisma.buildUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BuildUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BuildUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BuildUser'> extends True ? CheckSelect<T, Prisma__BuildUserClient<BuildUser>, Prisma__BuildUserClient<BuildUserGetPayload<T>>> : CheckSelect<T, Prisma__BuildUserClient<BuildUser | null >, Prisma__BuildUserClient<BuildUserGetPayload<T> | null >>

    /**
     * Find the first BuildUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildUserFindFirstArgs} args - Arguments to find a BuildUser
     * @example
     * // Get one BuildUser
     * const buildUser = await prisma.buildUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BuildUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BuildUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BuildUser'> extends True ? CheckSelect<T, Prisma__BuildUserClient<BuildUser>, Prisma__BuildUserClient<BuildUserGetPayload<T>>> : CheckSelect<T, Prisma__BuildUserClient<BuildUser | null >, Prisma__BuildUserClient<BuildUserGetPayload<T> | null >>

    /**
     * Find zero or more BuildUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BuildUsers
     * const buildUsers = await prisma.buildUser.findMany()
     * 
     * // Get first 10 BuildUsers
     * const buildUsers = await prisma.buildUser.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const buildUserWithUserIdOnly = await prisma.buildUser.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends BuildUserFindManyArgs>(
      args?: SelectSubset<T, BuildUserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<BuildUser>>, PrismaPromise<Array<BuildUserGetPayload<T>>>>

    /**
     * Create a BuildUser.
     * @param {BuildUserCreateArgs} args - Arguments to create a BuildUser.
     * @example
     * // Create one BuildUser
     * const BuildUser = await prisma.buildUser.create({
     *   data: {
     *     // ... data to create a BuildUser
     *   }
     * })
     * 
    **/
    create<T extends BuildUserCreateArgs>(
      args: SelectSubset<T, BuildUserCreateArgs>
    ): CheckSelect<T, Prisma__BuildUserClient<BuildUser>, Prisma__BuildUserClient<BuildUserGetPayload<T>>>

    /**
     * Create many BuildUsers.
     *     @param {BuildUserCreateManyArgs} args - Arguments to create many BuildUsers.
     *     @example
     *     // Create many BuildUsers
     *     const buildUser = await prisma.buildUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BuildUserCreateManyArgs>(
      args?: SelectSubset<T, BuildUserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a BuildUser.
     * @param {BuildUserDeleteArgs} args - Arguments to delete one BuildUser.
     * @example
     * // Delete one BuildUser
     * const BuildUser = await prisma.buildUser.delete({
     *   where: {
     *     // ... filter to delete one BuildUser
     *   }
     * })
     * 
    **/
    delete<T extends BuildUserDeleteArgs>(
      args: SelectSubset<T, BuildUserDeleteArgs>
    ): CheckSelect<T, Prisma__BuildUserClient<BuildUser>, Prisma__BuildUserClient<BuildUserGetPayload<T>>>

    /**
     * Update one BuildUser.
     * @param {BuildUserUpdateArgs} args - Arguments to update one BuildUser.
     * @example
     * // Update one BuildUser
     * const buildUser = await prisma.buildUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BuildUserUpdateArgs>(
      args: SelectSubset<T, BuildUserUpdateArgs>
    ): CheckSelect<T, Prisma__BuildUserClient<BuildUser>, Prisma__BuildUserClient<BuildUserGetPayload<T>>>

    /**
     * Delete zero or more BuildUsers.
     * @param {BuildUserDeleteManyArgs} args - Arguments to filter BuildUsers to delete.
     * @example
     * // Delete a few BuildUsers
     * const { count } = await prisma.buildUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BuildUserDeleteManyArgs>(
      args?: SelectSubset<T, BuildUserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more BuildUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BuildUsers
     * const buildUser = await prisma.buildUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BuildUserUpdateManyArgs>(
      args: SelectSubset<T, BuildUserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one BuildUser.
     * @param {BuildUserUpsertArgs} args - Arguments to update or create a BuildUser.
     * @example
     * // Update or create a BuildUser
     * const buildUser = await prisma.buildUser.upsert({
     *   create: {
     *     // ... data to create a BuildUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BuildUser we want to update
     *   }
     * })
    **/
    upsert<T extends BuildUserUpsertArgs>(
      args: SelectSubset<T, BuildUserUpsertArgs>
    ): CheckSelect<T, Prisma__BuildUserClient<BuildUser>, Prisma__BuildUserClient<BuildUserGetPayload<T>>>

    /**
     * Find one BuildUser that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {BuildUserFindUniqueOrThrowArgs} args - Arguments to find a BuildUser
     * @example
     * // Get one BuildUser
     * const buildUser = await prisma.buildUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BuildUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BuildUserFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__BuildUserClient<BuildUser>, Prisma__BuildUserClient<BuildUserGetPayload<T>>>

    /**
     * Find the first BuildUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildUserFindFirstOrThrowArgs} args - Arguments to find a BuildUser
     * @example
     * // Get one BuildUser
     * const buildUser = await prisma.buildUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BuildUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BuildUserFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__BuildUserClient<BuildUser>, Prisma__BuildUserClient<BuildUserGetPayload<T>>>

    /**
     * Count the number of BuildUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildUserCountArgs} args - Arguments to filter BuildUsers to count.
     * @example
     * // Count the number of BuildUsers
     * const count = await prisma.buildUser.count({
     *   where: {
     *     // ... the filter for the BuildUsers we want to count
     *   }
     * })
    **/
    count<T extends BuildUserCountArgs>(
      args?: Subset<T, BuildUserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuildUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BuildUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuildUserAggregateArgs>(args: Subset<T, BuildUserAggregateArgs>): PrismaPromise<GetBuildUserAggregateType<T>>

    /**
     * Group by BuildUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuildUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuildUserGroupByArgs['orderBy'] }
        : { orderBy?: BuildUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuildUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuildUserGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BuildUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BuildUserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    build<T extends BuildArgs = {}>(args?: Subset<T, BuildArgs>): CheckSelect<T, Prisma__BuildClient<Build | null >, Prisma__BuildClient<BuildGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BuildUser base type for findUnique actions
   */
  export type BuildUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BuildUser
     * 
    **/
    select?: BuildUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BuildUserInclude | null
    /**
     * Filter, which BuildUser to fetch.
     * 
    **/
    where: BuildUserWhereUniqueInput
  }

  /**
   * BuildUser: findUnique
   */
  export interface BuildUserFindUniqueArgs extends BuildUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BuildUser base type for findFirst actions
   */
  export type BuildUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BuildUser
     * 
    **/
    select?: BuildUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BuildUserInclude | null
    /**
     * Filter, which BuildUser to fetch.
     * 
    **/
    where?: BuildUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<BuildUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuildUsers.
     * 
    **/
    cursor?: BuildUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildUsers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuildUsers.
     * 
    **/
    distinct?: Enumerable<BuildUserScalarFieldEnum>
  }

  /**
   * BuildUser: findFirst
   */
  export interface BuildUserFindFirstArgs extends BuildUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BuildUser findMany
   */
  export type BuildUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the BuildUser
     * 
    **/
    select?: BuildUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BuildUserInclude | null
    /**
     * Filter, which BuildUsers to fetch.
     * 
    **/
    where?: BuildUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<BuildUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BuildUsers.
     * 
    **/
    cursor?: BuildUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildUsers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<BuildUserScalarFieldEnum>
  }


  /**
   * BuildUser create
   */
  export type BuildUserCreateArgs = {
    /**
     * Select specific fields to fetch from the BuildUser
     * 
    **/
    select?: BuildUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BuildUserInclude | null
    /**
     * The data needed to create a BuildUser.
     * 
    **/
    data: XOR<BuildUserCreateInput, BuildUserUncheckedCreateInput>
  }


  /**
   * BuildUser createMany
   */
  export type BuildUserCreateManyArgs = {
    /**
     * The data used to create many BuildUsers.
     * 
    **/
    data: Enumerable<BuildUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BuildUser update
   */
  export type BuildUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the BuildUser
     * 
    **/
    select?: BuildUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BuildUserInclude | null
    /**
     * The data needed to update a BuildUser.
     * 
    **/
    data: XOR<BuildUserUpdateInput, BuildUserUncheckedUpdateInput>
    /**
     * Choose, which BuildUser to update.
     * 
    **/
    where: BuildUserWhereUniqueInput
  }


  /**
   * BuildUser updateMany
   */
  export type BuildUserUpdateManyArgs = {
    /**
     * The data used to update BuildUsers.
     * 
    **/
    data: XOR<BuildUserUpdateManyMutationInput, BuildUserUncheckedUpdateManyInput>
    /**
     * Filter which BuildUsers to update
     * 
    **/
    where?: BuildUserWhereInput
  }


  /**
   * BuildUser upsert
   */
  export type BuildUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the BuildUser
     * 
    **/
    select?: BuildUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BuildUserInclude | null
    /**
     * The filter to search for the BuildUser to update in case it exists.
     * 
    **/
    where: BuildUserWhereUniqueInput
    /**
     * In case the BuildUser found by the `where` argument doesn't exist, create a new BuildUser with this data.
     * 
    **/
    create: XOR<BuildUserCreateInput, BuildUserUncheckedCreateInput>
    /**
     * In case the BuildUser was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<BuildUserUpdateInput, BuildUserUncheckedUpdateInput>
  }


  /**
   * BuildUser delete
   */
  export type BuildUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the BuildUser
     * 
    **/
    select?: BuildUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BuildUserInclude | null
    /**
     * Filter which BuildUser to delete.
     * 
    **/
    where: BuildUserWhereUniqueInput
  }


  /**
   * BuildUser deleteMany
   */
  export type BuildUserDeleteManyArgs = {
    /**
     * Filter which BuildUsers to delete
     * 
    **/
    where?: BuildUserWhereInput
  }


  /**
   * BuildUser: findUniqueOrThrow
   */
  export type BuildUserFindUniqueOrThrowArgs = BuildUserFindUniqueArgsBase
      

  /**
   * BuildUser: findFirstOrThrow
   */
  export type BuildUserFindFirstOrThrowArgs = BuildUserFindFirstArgsBase
      

  /**
   * BuildUser without action
   */
  export type BuildUserArgs = {
    /**
     * Select specific fields to fetch from the BuildUser
     * 
    **/
    select?: BuildUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BuildUserInclude | null
  }



  /**
   * Model Recipe
   */


  export type AggregateRecipe = {
    _count: RecipeCountAggregateOutputType | null
    _avg: RecipeAvgAggregateOutputType | null
    _sum: RecipeSumAggregateOutputType | null
    _min: RecipeMinAggregateOutputType | null
    _max: RecipeMaxAggregateOutputType | null
  }

  export type RecipeAvgAggregateOutputType = {
    id: number | null
  }

  export type RecipeSumAggregateOutputType = {
    id: number | null
  }

  export type RecipeMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    origin: string | null
    history: string | null
    createdById: string | null
  }

  export type RecipeMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    origin: string | null
    history: string | null
    createdById: string | null
  }

  export type RecipeCountAggregateOutputType = {
    id: number
    createdAt: number
    name: number
    origin: number
    history: number
    createdById: number
    _all: number
  }


  export type RecipeAvgAggregateInputType = {
    id?: true
  }

  export type RecipeSumAggregateInputType = {
    id?: true
  }

  export type RecipeMinAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    origin?: true
    history?: true
    createdById?: true
  }

  export type RecipeMaxAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    origin?: true
    history?: true
    createdById?: true
  }

  export type RecipeCountAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    origin?: true
    history?: true
    createdById?: true
    _all?: true
  }

  export type RecipeAggregateArgs = {
    /**
     * Filter which Recipe to aggregate.
     * 
    **/
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     * 
    **/
    orderBy?: Enumerable<RecipeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Recipes
    **/
    _count?: true | RecipeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecipeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecipeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeMaxAggregateInputType
  }

  export type GetRecipeAggregateType<T extends RecipeAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipe[P]>
      : GetScalarType<T[P], AggregateRecipe[P]>
  }




  export type RecipeGroupByArgs = {
    where?: RecipeWhereInput
    orderBy?: Enumerable<RecipeOrderByWithAggregationInput>
    by: Array<RecipeScalarFieldEnum>
    having?: RecipeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeCountAggregateInputType | true
    _avg?: RecipeAvgAggregateInputType
    _sum?: RecipeSumAggregateInputType
    _min?: RecipeMinAggregateInputType
    _max?: RecipeMaxAggregateInputType
  }


  export type RecipeGroupByOutputType = {
    id: number
    createdAt: Date
    name: string
    origin: string | null
    history: string | null
    createdById: string
    _count: RecipeCountAggregateOutputType | null
    _avg: RecipeAvgAggregateOutputType | null
    _sum: RecipeSumAggregateOutputType | null
    _min: RecipeMinAggregateOutputType | null
    _max: RecipeMaxAggregateOutputType | null
  }

  type GetRecipeGroupByPayload<T extends RecipeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RecipeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeGroupByOutputType[P]>
        }
      >
    >


  export type RecipeSelect = {
    id?: boolean
    createdAt?: boolean
    name?: boolean
    origin?: boolean
    history?: boolean
    createdBy?: boolean | UserArgs
    createdById?: boolean
    build?: boolean | BuildFindManyArgs
    _count?: boolean | RecipeCountOutputTypeArgs
  }

  export type RecipeInclude = {
    createdBy?: boolean | UserArgs
    build?: boolean | BuildFindManyArgs
    _count?: boolean | RecipeCountOutputTypeArgs
  }

  export type RecipeGetPayload<
    S extends boolean | null | undefined | RecipeArgs,
    U = keyof S
      > = S extends true
        ? Recipe
    : S extends undefined
    ? never
    : S extends RecipeArgs | RecipeFindManyArgs
    ?'include' extends U
    ? Recipe  & {
    [P in TrueKeys<S['include']>]:
        P extends 'createdBy' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'build' ? Array < BuildGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? RecipeCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'createdBy' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'build' ? Array < BuildGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? RecipeCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Recipe ? Recipe[P] : never
  } 
    : Recipe
  : Recipe


  type RecipeCountArgs = Merge<
    Omit<RecipeFindManyArgs, 'select' | 'include'> & {
      select?: RecipeCountAggregateInputType | true
    }
  >

  export interface RecipeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Recipe that matches the filter.
     * @param {RecipeFindUniqueArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RecipeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RecipeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Recipe'> extends True ? CheckSelect<T, Prisma__RecipeClient<Recipe>, Prisma__RecipeClient<RecipeGetPayload<T>>> : CheckSelect<T, Prisma__RecipeClient<Recipe | null >, Prisma__RecipeClient<RecipeGetPayload<T> | null >>

    /**
     * Find the first Recipe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindFirstArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RecipeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RecipeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Recipe'> extends True ? CheckSelect<T, Prisma__RecipeClient<Recipe>, Prisma__RecipeClient<RecipeGetPayload<T>>> : CheckSelect<T, Prisma__RecipeClient<Recipe | null >, Prisma__RecipeClient<RecipeGetPayload<T> | null >>

    /**
     * Find zero or more Recipes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recipes
     * const recipes = await prisma.recipe.findMany()
     * 
     * // Get first 10 Recipes
     * const recipes = await prisma.recipe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeWithIdOnly = await prisma.recipe.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RecipeFindManyArgs>(
      args?: SelectSubset<T, RecipeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Recipe>>, PrismaPromise<Array<RecipeGetPayload<T>>>>

    /**
     * Create a Recipe.
     * @param {RecipeCreateArgs} args - Arguments to create a Recipe.
     * @example
     * // Create one Recipe
     * const Recipe = await prisma.recipe.create({
     *   data: {
     *     // ... data to create a Recipe
     *   }
     * })
     * 
    **/
    create<T extends RecipeCreateArgs>(
      args: SelectSubset<T, RecipeCreateArgs>
    ): CheckSelect<T, Prisma__RecipeClient<Recipe>, Prisma__RecipeClient<RecipeGetPayload<T>>>

    /**
     * Create many Recipes.
     *     @param {RecipeCreateManyArgs} args - Arguments to create many Recipes.
     *     @example
     *     // Create many Recipes
     *     const recipe = await prisma.recipe.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RecipeCreateManyArgs>(
      args?: SelectSubset<T, RecipeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Recipe.
     * @param {RecipeDeleteArgs} args - Arguments to delete one Recipe.
     * @example
     * // Delete one Recipe
     * const Recipe = await prisma.recipe.delete({
     *   where: {
     *     // ... filter to delete one Recipe
     *   }
     * })
     * 
    **/
    delete<T extends RecipeDeleteArgs>(
      args: SelectSubset<T, RecipeDeleteArgs>
    ): CheckSelect<T, Prisma__RecipeClient<Recipe>, Prisma__RecipeClient<RecipeGetPayload<T>>>

    /**
     * Update one Recipe.
     * @param {RecipeUpdateArgs} args - Arguments to update one Recipe.
     * @example
     * // Update one Recipe
     * const recipe = await prisma.recipe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RecipeUpdateArgs>(
      args: SelectSubset<T, RecipeUpdateArgs>
    ): CheckSelect<T, Prisma__RecipeClient<Recipe>, Prisma__RecipeClient<RecipeGetPayload<T>>>

    /**
     * Delete zero or more Recipes.
     * @param {RecipeDeleteManyArgs} args - Arguments to filter Recipes to delete.
     * @example
     * // Delete a few Recipes
     * const { count } = await prisma.recipe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RecipeDeleteManyArgs>(
      args?: SelectSubset<T, RecipeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recipes
     * const recipe = await prisma.recipe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RecipeUpdateManyArgs>(
      args: SelectSubset<T, RecipeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Recipe.
     * @param {RecipeUpsertArgs} args - Arguments to update or create a Recipe.
     * @example
     * // Update or create a Recipe
     * const recipe = await prisma.recipe.upsert({
     *   create: {
     *     // ... data to create a Recipe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recipe we want to update
     *   }
     * })
    **/
    upsert<T extends RecipeUpsertArgs>(
      args: SelectSubset<T, RecipeUpsertArgs>
    ): CheckSelect<T, Prisma__RecipeClient<Recipe>, Prisma__RecipeClient<RecipeGetPayload<T>>>

    /**
     * Find one Recipe that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {RecipeFindUniqueOrThrowArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RecipeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RecipeFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__RecipeClient<Recipe>, Prisma__RecipeClient<RecipeGetPayload<T>>>

    /**
     * Find the first Recipe that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindFirstOrThrowArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RecipeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RecipeFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__RecipeClient<Recipe>, Prisma__RecipeClient<RecipeGetPayload<T>>>

    /**
     * Count the number of Recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeCountArgs} args - Arguments to filter Recipes to count.
     * @example
     * // Count the number of Recipes
     * const count = await prisma.recipe.count({
     *   where: {
     *     // ... the filter for the Recipes we want to count
     *   }
     * })
    **/
    count<T extends RecipeCountArgs>(
      args?: Subset<T, RecipeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeAggregateArgs>(args: Subset<T, RecipeAggregateArgs>): PrismaPromise<GetRecipeAggregateType<T>>

    /**
     * Group by Recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeGroupByArgs['orderBy'] }
        : { orderBy?: RecipeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Recipe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RecipeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    createdBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    build<T extends BuildFindManyArgs = {}>(args?: Subset<T, BuildFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Build>>, PrismaPromise<Array<BuildGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Recipe base type for findUnique actions
   */
  export type RecipeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Recipe
     * 
    **/
    select?: RecipeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeInclude | null
    /**
     * Filter, which Recipe to fetch.
     * 
    **/
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe: findUnique
   */
  export interface RecipeFindUniqueArgs extends RecipeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Recipe base type for findFirst actions
   */
  export type RecipeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Recipe
     * 
    **/
    select?: RecipeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeInclude | null
    /**
     * Filter, which Recipe to fetch.
     * 
    **/
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     * 
    **/
    orderBy?: Enumerable<RecipeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recipes.
     * 
    **/
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recipes.
     * 
    **/
    distinct?: Enumerable<RecipeScalarFieldEnum>
  }

  /**
   * Recipe: findFirst
   */
  export interface RecipeFindFirstArgs extends RecipeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Recipe findMany
   */
  export type RecipeFindManyArgs = {
    /**
     * Select specific fields to fetch from the Recipe
     * 
    **/
    select?: RecipeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeInclude | null
    /**
     * Filter, which Recipes to fetch.
     * 
    **/
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     * 
    **/
    orderBy?: Enumerable<RecipeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Recipes.
     * 
    **/
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RecipeScalarFieldEnum>
  }


  /**
   * Recipe create
   */
  export type RecipeCreateArgs = {
    /**
     * Select specific fields to fetch from the Recipe
     * 
    **/
    select?: RecipeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeInclude | null
    /**
     * The data needed to create a Recipe.
     * 
    **/
    data: XOR<RecipeCreateInput, RecipeUncheckedCreateInput>
  }


  /**
   * Recipe createMany
   */
  export type RecipeCreateManyArgs = {
    /**
     * The data used to create many Recipes.
     * 
    **/
    data: Enumerable<RecipeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Recipe update
   */
  export type RecipeUpdateArgs = {
    /**
     * Select specific fields to fetch from the Recipe
     * 
    **/
    select?: RecipeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeInclude | null
    /**
     * The data needed to update a Recipe.
     * 
    **/
    data: XOR<RecipeUpdateInput, RecipeUncheckedUpdateInput>
    /**
     * Choose, which Recipe to update.
     * 
    **/
    where: RecipeWhereUniqueInput
  }


  /**
   * Recipe updateMany
   */
  export type RecipeUpdateManyArgs = {
    /**
     * The data used to update Recipes.
     * 
    **/
    data: XOR<RecipeUpdateManyMutationInput, RecipeUncheckedUpdateManyInput>
    /**
     * Filter which Recipes to update
     * 
    **/
    where?: RecipeWhereInput
  }


  /**
   * Recipe upsert
   */
  export type RecipeUpsertArgs = {
    /**
     * Select specific fields to fetch from the Recipe
     * 
    **/
    select?: RecipeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeInclude | null
    /**
     * The filter to search for the Recipe to update in case it exists.
     * 
    **/
    where: RecipeWhereUniqueInput
    /**
     * In case the Recipe found by the `where` argument doesn't exist, create a new Recipe with this data.
     * 
    **/
    create: XOR<RecipeCreateInput, RecipeUncheckedCreateInput>
    /**
     * In case the Recipe was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RecipeUpdateInput, RecipeUncheckedUpdateInput>
  }


  /**
   * Recipe delete
   */
  export type RecipeDeleteArgs = {
    /**
     * Select specific fields to fetch from the Recipe
     * 
    **/
    select?: RecipeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeInclude | null
    /**
     * Filter which Recipe to delete.
     * 
    **/
    where: RecipeWhereUniqueInput
  }


  /**
   * Recipe deleteMany
   */
  export type RecipeDeleteManyArgs = {
    /**
     * Filter which Recipes to delete
     * 
    **/
    where?: RecipeWhereInput
  }


  /**
   * Recipe: findUniqueOrThrow
   */
  export type RecipeFindUniqueOrThrowArgs = RecipeFindUniqueArgsBase
      

  /**
   * Recipe: findFirstOrThrow
   */
  export type RecipeFindFirstOrThrowArgs = RecipeFindFirstArgsBase
      

  /**
   * Recipe without action
   */
  export type RecipeArgs = {
    /**
     * Select specific fields to fetch from the Recipe
     * 
    **/
    select?: RecipeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeInclude | null
  }



  /**
   * Model RecipeBookBuild
   */


  export type AggregateRecipeBookBuild = {
    _count: RecipeBookBuildCountAggregateOutputType | null
    _avg: RecipeBookBuildAvgAggregateOutputType | null
    _sum: RecipeBookBuildSumAggregateOutputType | null
    _min: RecipeBookBuildMinAggregateOutputType | null
    _max: RecipeBookBuildMaxAggregateOutputType | null
  }

  export type RecipeBookBuildAvgAggregateOutputType = {
    buildId: number | null
    recipeBookId: number | null
  }

  export type RecipeBookBuildSumAggregateOutputType = {
    buildId: number | null
    recipeBookId: number | null
  }

  export type RecipeBookBuildMinAggregateOutputType = {
    buildId: number | null
    recipeBookId: number | null
  }

  export type RecipeBookBuildMaxAggregateOutputType = {
    buildId: number | null
    recipeBookId: number | null
  }

  export type RecipeBookBuildCountAggregateOutputType = {
    buildId: number
    recipeBookId: number
    _all: number
  }


  export type RecipeBookBuildAvgAggregateInputType = {
    buildId?: true
    recipeBookId?: true
  }

  export type RecipeBookBuildSumAggregateInputType = {
    buildId?: true
    recipeBookId?: true
  }

  export type RecipeBookBuildMinAggregateInputType = {
    buildId?: true
    recipeBookId?: true
  }

  export type RecipeBookBuildMaxAggregateInputType = {
    buildId?: true
    recipeBookId?: true
  }

  export type RecipeBookBuildCountAggregateInputType = {
    buildId?: true
    recipeBookId?: true
    _all?: true
  }

  export type RecipeBookBuildAggregateArgs = {
    /**
     * Filter which RecipeBookBuild to aggregate.
     * 
    **/
    where?: RecipeBookBuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBookBuilds to fetch.
     * 
    **/
    orderBy?: Enumerable<RecipeBookBuildOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RecipeBookBuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBookBuilds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBookBuilds.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecipeBookBuilds
    **/
    _count?: true | RecipeBookBuildCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecipeBookBuildAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecipeBookBuildSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeBookBuildMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeBookBuildMaxAggregateInputType
  }

  export type GetRecipeBookBuildAggregateType<T extends RecipeBookBuildAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipeBookBuild]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipeBookBuild[P]>
      : GetScalarType<T[P], AggregateRecipeBookBuild[P]>
  }




  export type RecipeBookBuildGroupByArgs = {
    where?: RecipeBookBuildWhereInput
    orderBy?: Enumerable<RecipeBookBuildOrderByWithAggregationInput>
    by: Array<RecipeBookBuildScalarFieldEnum>
    having?: RecipeBookBuildScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeBookBuildCountAggregateInputType | true
    _avg?: RecipeBookBuildAvgAggregateInputType
    _sum?: RecipeBookBuildSumAggregateInputType
    _min?: RecipeBookBuildMinAggregateInputType
    _max?: RecipeBookBuildMaxAggregateInputType
  }


  export type RecipeBookBuildGroupByOutputType = {
    buildId: number
    recipeBookId: number
    _count: RecipeBookBuildCountAggregateOutputType | null
    _avg: RecipeBookBuildAvgAggregateOutputType | null
    _sum: RecipeBookBuildSumAggregateOutputType | null
    _min: RecipeBookBuildMinAggregateOutputType | null
    _max: RecipeBookBuildMaxAggregateOutputType | null
  }

  type GetRecipeBookBuildGroupByPayload<T extends RecipeBookBuildGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RecipeBookBuildGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeBookBuildGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeBookBuildGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeBookBuildGroupByOutputType[P]>
        }
      >
    >


  export type RecipeBookBuildSelect = {
    buildId?: boolean
    recipeBookId?: boolean
    recipeBook?: boolean | RecipeBookArgs
    build?: boolean | BuildArgs
  }

  export type RecipeBookBuildInclude = {
    recipeBook?: boolean | RecipeBookArgs
    build?: boolean | BuildArgs
  }

  export type RecipeBookBuildGetPayload<
    S extends boolean | null | undefined | RecipeBookBuildArgs,
    U = keyof S
      > = S extends true
        ? RecipeBookBuild
    : S extends undefined
    ? never
    : S extends RecipeBookBuildArgs | RecipeBookBuildFindManyArgs
    ?'include' extends U
    ? RecipeBookBuild  & {
    [P in TrueKeys<S['include']>]:
        P extends 'recipeBook' ? RecipeBookGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'build' ? BuildGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'recipeBook' ? RecipeBookGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'build' ? BuildGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof RecipeBookBuild ? RecipeBookBuild[P] : never
  } 
    : RecipeBookBuild
  : RecipeBookBuild


  type RecipeBookBuildCountArgs = Merge<
    Omit<RecipeBookBuildFindManyArgs, 'select' | 'include'> & {
      select?: RecipeBookBuildCountAggregateInputType | true
    }
  >

  export interface RecipeBookBuildDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one RecipeBookBuild that matches the filter.
     * @param {RecipeBookBuildFindUniqueArgs} args - Arguments to find a RecipeBookBuild
     * @example
     * // Get one RecipeBookBuild
     * const recipeBookBuild = await prisma.recipeBookBuild.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RecipeBookBuildFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RecipeBookBuildFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RecipeBookBuild'> extends True ? CheckSelect<T, Prisma__RecipeBookBuildClient<RecipeBookBuild>, Prisma__RecipeBookBuildClient<RecipeBookBuildGetPayload<T>>> : CheckSelect<T, Prisma__RecipeBookBuildClient<RecipeBookBuild | null >, Prisma__RecipeBookBuildClient<RecipeBookBuildGetPayload<T> | null >>

    /**
     * Find the first RecipeBookBuild that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookBuildFindFirstArgs} args - Arguments to find a RecipeBookBuild
     * @example
     * // Get one RecipeBookBuild
     * const recipeBookBuild = await prisma.recipeBookBuild.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RecipeBookBuildFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RecipeBookBuildFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RecipeBookBuild'> extends True ? CheckSelect<T, Prisma__RecipeBookBuildClient<RecipeBookBuild>, Prisma__RecipeBookBuildClient<RecipeBookBuildGetPayload<T>>> : CheckSelect<T, Prisma__RecipeBookBuildClient<RecipeBookBuild | null >, Prisma__RecipeBookBuildClient<RecipeBookBuildGetPayload<T> | null >>

    /**
     * Find zero or more RecipeBookBuilds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookBuildFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecipeBookBuilds
     * const recipeBookBuilds = await prisma.recipeBookBuild.findMany()
     * 
     * // Get first 10 RecipeBookBuilds
     * const recipeBookBuilds = await prisma.recipeBookBuild.findMany({ take: 10 })
     * 
     * // Only select the `buildId`
     * const recipeBookBuildWithBuildIdOnly = await prisma.recipeBookBuild.findMany({ select: { buildId: true } })
     * 
    **/
    findMany<T extends RecipeBookBuildFindManyArgs>(
      args?: SelectSubset<T, RecipeBookBuildFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RecipeBookBuild>>, PrismaPromise<Array<RecipeBookBuildGetPayload<T>>>>

    /**
     * Create a RecipeBookBuild.
     * @param {RecipeBookBuildCreateArgs} args - Arguments to create a RecipeBookBuild.
     * @example
     * // Create one RecipeBookBuild
     * const RecipeBookBuild = await prisma.recipeBookBuild.create({
     *   data: {
     *     // ... data to create a RecipeBookBuild
     *   }
     * })
     * 
    **/
    create<T extends RecipeBookBuildCreateArgs>(
      args: SelectSubset<T, RecipeBookBuildCreateArgs>
    ): CheckSelect<T, Prisma__RecipeBookBuildClient<RecipeBookBuild>, Prisma__RecipeBookBuildClient<RecipeBookBuildGetPayload<T>>>

    /**
     * Create many RecipeBookBuilds.
     *     @param {RecipeBookBuildCreateManyArgs} args - Arguments to create many RecipeBookBuilds.
     *     @example
     *     // Create many RecipeBookBuilds
     *     const recipeBookBuild = await prisma.recipeBookBuild.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RecipeBookBuildCreateManyArgs>(
      args?: SelectSubset<T, RecipeBookBuildCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RecipeBookBuild.
     * @param {RecipeBookBuildDeleteArgs} args - Arguments to delete one RecipeBookBuild.
     * @example
     * // Delete one RecipeBookBuild
     * const RecipeBookBuild = await prisma.recipeBookBuild.delete({
     *   where: {
     *     // ... filter to delete one RecipeBookBuild
     *   }
     * })
     * 
    **/
    delete<T extends RecipeBookBuildDeleteArgs>(
      args: SelectSubset<T, RecipeBookBuildDeleteArgs>
    ): CheckSelect<T, Prisma__RecipeBookBuildClient<RecipeBookBuild>, Prisma__RecipeBookBuildClient<RecipeBookBuildGetPayload<T>>>

    /**
     * Update one RecipeBookBuild.
     * @param {RecipeBookBuildUpdateArgs} args - Arguments to update one RecipeBookBuild.
     * @example
     * // Update one RecipeBookBuild
     * const recipeBookBuild = await prisma.recipeBookBuild.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RecipeBookBuildUpdateArgs>(
      args: SelectSubset<T, RecipeBookBuildUpdateArgs>
    ): CheckSelect<T, Prisma__RecipeBookBuildClient<RecipeBookBuild>, Prisma__RecipeBookBuildClient<RecipeBookBuildGetPayload<T>>>

    /**
     * Delete zero or more RecipeBookBuilds.
     * @param {RecipeBookBuildDeleteManyArgs} args - Arguments to filter RecipeBookBuilds to delete.
     * @example
     * // Delete a few RecipeBookBuilds
     * const { count } = await prisma.recipeBookBuild.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RecipeBookBuildDeleteManyArgs>(
      args?: SelectSubset<T, RecipeBookBuildDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeBookBuilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookBuildUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecipeBookBuilds
     * const recipeBookBuild = await prisma.recipeBookBuild.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RecipeBookBuildUpdateManyArgs>(
      args: SelectSubset<T, RecipeBookBuildUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RecipeBookBuild.
     * @param {RecipeBookBuildUpsertArgs} args - Arguments to update or create a RecipeBookBuild.
     * @example
     * // Update or create a RecipeBookBuild
     * const recipeBookBuild = await prisma.recipeBookBuild.upsert({
     *   create: {
     *     // ... data to create a RecipeBookBuild
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecipeBookBuild we want to update
     *   }
     * })
    **/
    upsert<T extends RecipeBookBuildUpsertArgs>(
      args: SelectSubset<T, RecipeBookBuildUpsertArgs>
    ): CheckSelect<T, Prisma__RecipeBookBuildClient<RecipeBookBuild>, Prisma__RecipeBookBuildClient<RecipeBookBuildGetPayload<T>>>

    /**
     * Find one RecipeBookBuild that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {RecipeBookBuildFindUniqueOrThrowArgs} args - Arguments to find a RecipeBookBuild
     * @example
     * // Get one RecipeBookBuild
     * const recipeBookBuild = await prisma.recipeBookBuild.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RecipeBookBuildFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RecipeBookBuildFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__RecipeBookBuildClient<RecipeBookBuild>, Prisma__RecipeBookBuildClient<RecipeBookBuildGetPayload<T>>>

    /**
     * Find the first RecipeBookBuild that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookBuildFindFirstOrThrowArgs} args - Arguments to find a RecipeBookBuild
     * @example
     * // Get one RecipeBookBuild
     * const recipeBookBuild = await prisma.recipeBookBuild.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RecipeBookBuildFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RecipeBookBuildFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__RecipeBookBuildClient<RecipeBookBuild>, Prisma__RecipeBookBuildClient<RecipeBookBuildGetPayload<T>>>

    /**
     * Count the number of RecipeBookBuilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookBuildCountArgs} args - Arguments to filter RecipeBookBuilds to count.
     * @example
     * // Count the number of RecipeBookBuilds
     * const count = await prisma.recipeBookBuild.count({
     *   where: {
     *     // ... the filter for the RecipeBookBuilds we want to count
     *   }
     * })
    **/
    count<T extends RecipeBookBuildCountArgs>(
      args?: Subset<T, RecipeBookBuildCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeBookBuildCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecipeBookBuild.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookBuildAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeBookBuildAggregateArgs>(args: Subset<T, RecipeBookBuildAggregateArgs>): PrismaPromise<GetRecipeBookBuildAggregateType<T>>

    /**
     * Group by RecipeBookBuild.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookBuildGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeBookBuildGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeBookBuildGroupByArgs['orderBy'] }
        : { orderBy?: RecipeBookBuildGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeBookBuildGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeBookBuildGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RecipeBookBuild.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RecipeBookBuildClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    recipeBook<T extends RecipeBookArgs = {}>(args?: Subset<T, RecipeBookArgs>): CheckSelect<T, Prisma__RecipeBookClient<RecipeBook | null >, Prisma__RecipeBookClient<RecipeBookGetPayload<T> | null >>;

    build<T extends BuildArgs = {}>(args?: Subset<T, BuildArgs>): CheckSelect<T, Prisma__BuildClient<Build | null >, Prisma__BuildClient<BuildGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RecipeBookBuild base type for findUnique actions
   */
  export type RecipeBookBuildFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     * 
    **/
    select?: RecipeBookBuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookBuildInclude | null
    /**
     * Filter, which RecipeBookBuild to fetch.
     * 
    **/
    where: RecipeBookBuildWhereUniqueInput
  }

  /**
   * RecipeBookBuild: findUnique
   */
  export interface RecipeBookBuildFindUniqueArgs extends RecipeBookBuildFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RecipeBookBuild base type for findFirst actions
   */
  export type RecipeBookBuildFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     * 
    **/
    select?: RecipeBookBuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookBuildInclude | null
    /**
     * Filter, which RecipeBookBuild to fetch.
     * 
    **/
    where?: RecipeBookBuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBookBuilds to fetch.
     * 
    **/
    orderBy?: Enumerable<RecipeBookBuildOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeBookBuilds.
     * 
    **/
    cursor?: RecipeBookBuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBookBuilds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBookBuilds.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeBookBuilds.
     * 
    **/
    distinct?: Enumerable<RecipeBookBuildScalarFieldEnum>
  }

  /**
   * RecipeBookBuild: findFirst
   */
  export interface RecipeBookBuildFindFirstArgs extends RecipeBookBuildFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RecipeBookBuild findMany
   */
  export type RecipeBookBuildFindManyArgs = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     * 
    **/
    select?: RecipeBookBuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookBuildInclude | null
    /**
     * Filter, which RecipeBookBuilds to fetch.
     * 
    **/
    where?: RecipeBookBuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBookBuilds to fetch.
     * 
    **/
    orderBy?: Enumerable<RecipeBookBuildOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecipeBookBuilds.
     * 
    **/
    cursor?: RecipeBookBuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBookBuilds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBookBuilds.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RecipeBookBuildScalarFieldEnum>
  }


  /**
   * RecipeBookBuild create
   */
  export type RecipeBookBuildCreateArgs = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     * 
    **/
    select?: RecipeBookBuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookBuildInclude | null
    /**
     * The data needed to create a RecipeBookBuild.
     * 
    **/
    data: XOR<RecipeBookBuildCreateInput, RecipeBookBuildUncheckedCreateInput>
  }


  /**
   * RecipeBookBuild createMany
   */
  export type RecipeBookBuildCreateManyArgs = {
    /**
     * The data used to create many RecipeBookBuilds.
     * 
    **/
    data: Enumerable<RecipeBookBuildCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RecipeBookBuild update
   */
  export type RecipeBookBuildUpdateArgs = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     * 
    **/
    select?: RecipeBookBuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookBuildInclude | null
    /**
     * The data needed to update a RecipeBookBuild.
     * 
    **/
    data: XOR<RecipeBookBuildUpdateInput, RecipeBookBuildUncheckedUpdateInput>
    /**
     * Choose, which RecipeBookBuild to update.
     * 
    **/
    where: RecipeBookBuildWhereUniqueInput
  }


  /**
   * RecipeBookBuild updateMany
   */
  export type RecipeBookBuildUpdateManyArgs = {
    /**
     * The data used to update RecipeBookBuilds.
     * 
    **/
    data: XOR<RecipeBookBuildUpdateManyMutationInput, RecipeBookBuildUncheckedUpdateManyInput>
    /**
     * Filter which RecipeBookBuilds to update
     * 
    **/
    where?: RecipeBookBuildWhereInput
  }


  /**
   * RecipeBookBuild upsert
   */
  export type RecipeBookBuildUpsertArgs = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     * 
    **/
    select?: RecipeBookBuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookBuildInclude | null
    /**
     * The filter to search for the RecipeBookBuild to update in case it exists.
     * 
    **/
    where: RecipeBookBuildWhereUniqueInput
    /**
     * In case the RecipeBookBuild found by the `where` argument doesn't exist, create a new RecipeBookBuild with this data.
     * 
    **/
    create: XOR<RecipeBookBuildCreateInput, RecipeBookBuildUncheckedCreateInput>
    /**
     * In case the RecipeBookBuild was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RecipeBookBuildUpdateInput, RecipeBookBuildUncheckedUpdateInput>
  }


  /**
   * RecipeBookBuild delete
   */
  export type RecipeBookBuildDeleteArgs = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     * 
    **/
    select?: RecipeBookBuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookBuildInclude | null
    /**
     * Filter which RecipeBookBuild to delete.
     * 
    **/
    where: RecipeBookBuildWhereUniqueInput
  }


  /**
   * RecipeBookBuild deleteMany
   */
  export type RecipeBookBuildDeleteManyArgs = {
    /**
     * Filter which RecipeBookBuilds to delete
     * 
    **/
    where?: RecipeBookBuildWhereInput
  }


  /**
   * RecipeBookBuild: findUniqueOrThrow
   */
  export type RecipeBookBuildFindUniqueOrThrowArgs = RecipeBookBuildFindUniqueArgsBase
      

  /**
   * RecipeBookBuild: findFirstOrThrow
   */
  export type RecipeBookBuildFindFirstOrThrowArgs = RecipeBookBuildFindFirstArgsBase
      

  /**
   * RecipeBookBuild without action
   */
  export type RecipeBookBuildArgs = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     * 
    **/
    select?: RecipeBookBuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookBuildInclude | null
  }



  /**
   * Model Touch
   */


  export type AggregateTouch = {
    _count: TouchCountAggregateOutputType | null
    _avg: TouchAvgAggregateOutputType | null
    _sum: TouchSumAggregateOutputType | null
    _min: TouchMinAggregateOutputType | null
    _max: TouchMaxAggregateOutputType | null
  }

  export type TouchAvgAggregateOutputType = {
    id: number | null
    buildId: number | null
    order: number | null
    amount: number | null
    genericIngredientID: number | null
    specificIngredientID: number | null
  }

  export type TouchSumAggregateOutputType = {
    id: number | null
    buildId: number | null
    order: number | null
    amount: number | null
    genericIngredientID: number | null
    specificIngredientID: number | null
  }

  export type TouchMinAggregateOutputType = {
    id: number | null
    buildId: number | null
    order: number | null
    amount: number | null
    unit: string | null
    genericIngredientID: number | null
    specificIngredientID: number | null
  }

  export type TouchMaxAggregateOutputType = {
    id: number | null
    buildId: number | null
    order: number | null
    amount: number | null
    unit: string | null
    genericIngredientID: number | null
    specificIngredientID: number | null
  }

  export type TouchCountAggregateOutputType = {
    id: number
    buildId: number
    order: number
    amount: number
    unit: number
    genericIngredientID: number
    specificIngredientID: number
    _all: number
  }


  export type TouchAvgAggregateInputType = {
    id?: true
    buildId?: true
    order?: true
    amount?: true
    genericIngredientID?: true
    specificIngredientID?: true
  }

  export type TouchSumAggregateInputType = {
    id?: true
    buildId?: true
    order?: true
    amount?: true
    genericIngredientID?: true
    specificIngredientID?: true
  }

  export type TouchMinAggregateInputType = {
    id?: true
    buildId?: true
    order?: true
    amount?: true
    unit?: true
    genericIngredientID?: true
    specificIngredientID?: true
  }

  export type TouchMaxAggregateInputType = {
    id?: true
    buildId?: true
    order?: true
    amount?: true
    unit?: true
    genericIngredientID?: true
    specificIngredientID?: true
  }

  export type TouchCountAggregateInputType = {
    id?: true
    buildId?: true
    order?: true
    amount?: true
    unit?: true
    genericIngredientID?: true
    specificIngredientID?: true
    _all?: true
  }

  export type TouchAggregateArgs = {
    /**
     * Filter which Touch to aggregate.
     * 
    **/
    where?: TouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Touches to fetch.
     * 
    **/
    orderBy?: Enumerable<TouchOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Touches from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Touches.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Touches
    **/
    _count?: true | TouchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TouchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TouchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TouchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TouchMaxAggregateInputType
  }

  export type GetTouchAggregateType<T extends TouchAggregateArgs> = {
        [P in keyof T & keyof AggregateTouch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTouch[P]>
      : GetScalarType<T[P], AggregateTouch[P]>
  }




  export type TouchGroupByArgs = {
    where?: TouchWhereInput
    orderBy?: Enumerable<TouchOrderByWithAggregationInput>
    by: Array<TouchScalarFieldEnum>
    having?: TouchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TouchCountAggregateInputType | true
    _avg?: TouchAvgAggregateInputType
    _sum?: TouchSumAggregateInputType
    _min?: TouchMinAggregateInputType
    _max?: TouchMaxAggregateInputType
  }


  export type TouchGroupByOutputType = {
    id: number
    buildId: number | null
    order: number | null
    amount: number | null
    unit: string | null
    genericIngredientID: number
    specificIngredientID: number | null
    _count: TouchCountAggregateOutputType | null
    _avg: TouchAvgAggregateOutputType | null
    _sum: TouchSumAggregateOutputType | null
    _min: TouchMinAggregateOutputType | null
    _max: TouchMaxAggregateOutputType | null
  }

  type GetTouchGroupByPayload<T extends TouchGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TouchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TouchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TouchGroupByOutputType[P]>
            : GetScalarType<T[P], TouchGroupByOutputType[P]>
        }
      >
    >


  export type TouchSelect = {
    id?: boolean
    build?: boolean | BuildArgs
    buildId?: boolean
    order?: boolean
    amount?: boolean
    unit?: boolean
    genericIngredientID?: boolean
    genericIngredient?: boolean | GenericIngredientArgs
    specificIngredientID?: boolean
    specificIngredient?: boolean | SpecificIngredientArgs
  }

  export type TouchInclude = {
    build?: boolean | BuildArgs
    genericIngredient?: boolean | GenericIngredientArgs
    specificIngredient?: boolean | SpecificIngredientArgs
  }

  export type TouchGetPayload<
    S extends boolean | null | undefined | TouchArgs,
    U = keyof S
      > = S extends true
        ? Touch
    : S extends undefined
    ? never
    : S extends TouchArgs | TouchFindManyArgs
    ?'include' extends U
    ? Touch  & {
    [P in TrueKeys<S['include']>]:
        P extends 'build' ? BuildGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'genericIngredient' ? GenericIngredientGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'specificIngredient' ? SpecificIngredientGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'build' ? BuildGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'genericIngredient' ? GenericIngredientGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'specificIngredient' ? SpecificIngredientGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof Touch ? Touch[P] : never
  } 
    : Touch
  : Touch


  type TouchCountArgs = Merge<
    Omit<TouchFindManyArgs, 'select' | 'include'> & {
      select?: TouchCountAggregateInputType | true
    }
  >

  export interface TouchDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Touch that matches the filter.
     * @param {TouchFindUniqueArgs} args - Arguments to find a Touch
     * @example
     * // Get one Touch
     * const touch = await prisma.touch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TouchFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TouchFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Touch'> extends True ? CheckSelect<T, Prisma__TouchClient<Touch>, Prisma__TouchClient<TouchGetPayload<T>>> : CheckSelect<T, Prisma__TouchClient<Touch | null >, Prisma__TouchClient<TouchGetPayload<T> | null >>

    /**
     * Find the first Touch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchFindFirstArgs} args - Arguments to find a Touch
     * @example
     * // Get one Touch
     * const touch = await prisma.touch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TouchFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TouchFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Touch'> extends True ? CheckSelect<T, Prisma__TouchClient<Touch>, Prisma__TouchClient<TouchGetPayload<T>>> : CheckSelect<T, Prisma__TouchClient<Touch | null >, Prisma__TouchClient<TouchGetPayload<T> | null >>

    /**
     * Find zero or more Touches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Touches
     * const touches = await prisma.touch.findMany()
     * 
     * // Get first 10 Touches
     * const touches = await prisma.touch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const touchWithIdOnly = await prisma.touch.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TouchFindManyArgs>(
      args?: SelectSubset<T, TouchFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Touch>>, PrismaPromise<Array<TouchGetPayload<T>>>>

    /**
     * Create a Touch.
     * @param {TouchCreateArgs} args - Arguments to create a Touch.
     * @example
     * // Create one Touch
     * const Touch = await prisma.touch.create({
     *   data: {
     *     // ... data to create a Touch
     *   }
     * })
     * 
    **/
    create<T extends TouchCreateArgs>(
      args: SelectSubset<T, TouchCreateArgs>
    ): CheckSelect<T, Prisma__TouchClient<Touch>, Prisma__TouchClient<TouchGetPayload<T>>>

    /**
     * Create many Touches.
     *     @param {TouchCreateManyArgs} args - Arguments to create many Touches.
     *     @example
     *     // Create many Touches
     *     const touch = await prisma.touch.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TouchCreateManyArgs>(
      args?: SelectSubset<T, TouchCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Touch.
     * @param {TouchDeleteArgs} args - Arguments to delete one Touch.
     * @example
     * // Delete one Touch
     * const Touch = await prisma.touch.delete({
     *   where: {
     *     // ... filter to delete one Touch
     *   }
     * })
     * 
    **/
    delete<T extends TouchDeleteArgs>(
      args: SelectSubset<T, TouchDeleteArgs>
    ): CheckSelect<T, Prisma__TouchClient<Touch>, Prisma__TouchClient<TouchGetPayload<T>>>

    /**
     * Update one Touch.
     * @param {TouchUpdateArgs} args - Arguments to update one Touch.
     * @example
     * // Update one Touch
     * const touch = await prisma.touch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TouchUpdateArgs>(
      args: SelectSubset<T, TouchUpdateArgs>
    ): CheckSelect<T, Prisma__TouchClient<Touch>, Prisma__TouchClient<TouchGetPayload<T>>>

    /**
     * Delete zero or more Touches.
     * @param {TouchDeleteManyArgs} args - Arguments to filter Touches to delete.
     * @example
     * // Delete a few Touches
     * const { count } = await prisma.touch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TouchDeleteManyArgs>(
      args?: SelectSubset<T, TouchDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Touches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Touches
     * const touch = await prisma.touch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TouchUpdateManyArgs>(
      args: SelectSubset<T, TouchUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Touch.
     * @param {TouchUpsertArgs} args - Arguments to update or create a Touch.
     * @example
     * // Update or create a Touch
     * const touch = await prisma.touch.upsert({
     *   create: {
     *     // ... data to create a Touch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Touch we want to update
     *   }
     * })
    **/
    upsert<T extends TouchUpsertArgs>(
      args: SelectSubset<T, TouchUpsertArgs>
    ): CheckSelect<T, Prisma__TouchClient<Touch>, Prisma__TouchClient<TouchGetPayload<T>>>

    /**
     * Find one Touch that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {TouchFindUniqueOrThrowArgs} args - Arguments to find a Touch
     * @example
     * // Get one Touch
     * const touch = await prisma.touch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TouchFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TouchFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__TouchClient<Touch>, Prisma__TouchClient<TouchGetPayload<T>>>

    /**
     * Find the first Touch that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchFindFirstOrThrowArgs} args - Arguments to find a Touch
     * @example
     * // Get one Touch
     * const touch = await prisma.touch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TouchFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TouchFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__TouchClient<Touch>, Prisma__TouchClient<TouchGetPayload<T>>>

    /**
     * Count the number of Touches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchCountArgs} args - Arguments to filter Touches to count.
     * @example
     * // Count the number of Touches
     * const count = await prisma.touch.count({
     *   where: {
     *     // ... the filter for the Touches we want to count
     *   }
     * })
    **/
    count<T extends TouchCountArgs>(
      args?: Subset<T, TouchCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TouchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Touch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TouchAggregateArgs>(args: Subset<T, TouchAggregateArgs>): PrismaPromise<GetTouchAggregateType<T>>

    /**
     * Group by Touch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TouchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TouchGroupByArgs['orderBy'] }
        : { orderBy?: TouchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TouchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTouchGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Touch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TouchClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    build<T extends BuildArgs = {}>(args?: Subset<T, BuildArgs>): CheckSelect<T, Prisma__BuildClient<Build | null >, Prisma__BuildClient<BuildGetPayload<T> | null >>;

    genericIngredient<T extends GenericIngredientArgs = {}>(args?: Subset<T, GenericIngredientArgs>): CheckSelect<T, Prisma__GenericIngredientClient<GenericIngredient | null >, Prisma__GenericIngredientClient<GenericIngredientGetPayload<T> | null >>;

    specificIngredient<T extends SpecificIngredientArgs = {}>(args?: Subset<T, SpecificIngredientArgs>): CheckSelect<T, Prisma__SpecificIngredientClient<SpecificIngredient | null >, Prisma__SpecificIngredientClient<SpecificIngredientGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Touch base type for findUnique actions
   */
  export type TouchFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Touch
     * 
    **/
    select?: TouchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TouchInclude | null
    /**
     * Filter, which Touch to fetch.
     * 
    **/
    where: TouchWhereUniqueInput
  }

  /**
   * Touch: findUnique
   */
  export interface TouchFindUniqueArgs extends TouchFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Touch base type for findFirst actions
   */
  export type TouchFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Touch
     * 
    **/
    select?: TouchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TouchInclude | null
    /**
     * Filter, which Touch to fetch.
     * 
    **/
    where?: TouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Touches to fetch.
     * 
    **/
    orderBy?: Enumerable<TouchOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Touches.
     * 
    **/
    cursor?: TouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Touches from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Touches.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Touches.
     * 
    **/
    distinct?: Enumerable<TouchScalarFieldEnum>
  }

  /**
   * Touch: findFirst
   */
  export interface TouchFindFirstArgs extends TouchFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Touch findMany
   */
  export type TouchFindManyArgs = {
    /**
     * Select specific fields to fetch from the Touch
     * 
    **/
    select?: TouchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TouchInclude | null
    /**
     * Filter, which Touches to fetch.
     * 
    **/
    where?: TouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Touches to fetch.
     * 
    **/
    orderBy?: Enumerable<TouchOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Touches.
     * 
    **/
    cursor?: TouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Touches from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Touches.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TouchScalarFieldEnum>
  }


  /**
   * Touch create
   */
  export type TouchCreateArgs = {
    /**
     * Select specific fields to fetch from the Touch
     * 
    **/
    select?: TouchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TouchInclude | null
    /**
     * The data needed to create a Touch.
     * 
    **/
    data: XOR<TouchCreateInput, TouchUncheckedCreateInput>
  }


  /**
   * Touch createMany
   */
  export type TouchCreateManyArgs = {
    /**
     * The data used to create many Touches.
     * 
    **/
    data: Enumerable<TouchCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Touch update
   */
  export type TouchUpdateArgs = {
    /**
     * Select specific fields to fetch from the Touch
     * 
    **/
    select?: TouchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TouchInclude | null
    /**
     * The data needed to update a Touch.
     * 
    **/
    data: XOR<TouchUpdateInput, TouchUncheckedUpdateInput>
    /**
     * Choose, which Touch to update.
     * 
    **/
    where: TouchWhereUniqueInput
  }


  /**
   * Touch updateMany
   */
  export type TouchUpdateManyArgs = {
    /**
     * The data used to update Touches.
     * 
    **/
    data: XOR<TouchUpdateManyMutationInput, TouchUncheckedUpdateManyInput>
    /**
     * Filter which Touches to update
     * 
    **/
    where?: TouchWhereInput
  }


  /**
   * Touch upsert
   */
  export type TouchUpsertArgs = {
    /**
     * Select specific fields to fetch from the Touch
     * 
    **/
    select?: TouchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TouchInclude | null
    /**
     * The filter to search for the Touch to update in case it exists.
     * 
    **/
    where: TouchWhereUniqueInput
    /**
     * In case the Touch found by the `where` argument doesn't exist, create a new Touch with this data.
     * 
    **/
    create: XOR<TouchCreateInput, TouchUncheckedCreateInput>
    /**
     * In case the Touch was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TouchUpdateInput, TouchUncheckedUpdateInput>
  }


  /**
   * Touch delete
   */
  export type TouchDeleteArgs = {
    /**
     * Select specific fields to fetch from the Touch
     * 
    **/
    select?: TouchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TouchInclude | null
    /**
     * Filter which Touch to delete.
     * 
    **/
    where: TouchWhereUniqueInput
  }


  /**
   * Touch deleteMany
   */
  export type TouchDeleteManyArgs = {
    /**
     * Filter which Touches to delete
     * 
    **/
    where?: TouchWhereInput
  }


  /**
   * Touch: findUniqueOrThrow
   */
  export type TouchFindUniqueOrThrowArgs = TouchFindUniqueArgsBase
      

  /**
   * Touch: findFirstOrThrow
   */
  export type TouchFindFirstOrThrowArgs = TouchFindFirstArgsBase
      

  /**
   * Touch without action
   */
  export type TouchArgs = {
    /**
     * Select specific fields to fetch from the Touch
     * 
    **/
    select?: TouchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TouchInclude | null
  }



  /**
   * Model GenericIngredient
   */


  export type AggregateGenericIngredient = {
    _count: GenericIngredientCountAggregateOutputType | null
    _avg: GenericIngredientAvgAggregateOutputType | null
    _sum: GenericIngredientSumAggregateOutputType | null
    _min: GenericIngredientMinAggregateOutputType | null
    _max: GenericIngredientMaxAggregateOutputType | null
  }

  export type GenericIngredientAvgAggregateOutputType = {
    id: number | null
  }

  export type GenericIngredientSumAggregateOutputType = {
    id: number | null
  }

  export type GenericIngredientMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type GenericIngredientMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type GenericIngredientCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type GenericIngredientAvgAggregateInputType = {
    id?: true
  }

  export type GenericIngredientSumAggregateInputType = {
    id?: true
  }

  export type GenericIngredientMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type GenericIngredientMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type GenericIngredientCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type GenericIngredientAggregateArgs = {
    /**
     * Filter which GenericIngredient to aggregate.
     * 
    **/
    where?: GenericIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GenericIngredients to fetch.
     * 
    **/
    orderBy?: Enumerable<GenericIngredientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: GenericIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GenericIngredients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GenericIngredients.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GenericIngredients
    **/
    _count?: true | GenericIngredientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GenericIngredientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GenericIngredientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GenericIngredientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GenericIngredientMaxAggregateInputType
  }

  export type GetGenericIngredientAggregateType<T extends GenericIngredientAggregateArgs> = {
        [P in keyof T & keyof AggregateGenericIngredient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGenericIngredient[P]>
      : GetScalarType<T[P], AggregateGenericIngredient[P]>
  }




  export type GenericIngredientGroupByArgs = {
    where?: GenericIngredientWhereInput
    orderBy?: Enumerable<GenericIngredientOrderByWithAggregationInput>
    by: Array<GenericIngredientScalarFieldEnum>
    having?: GenericIngredientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GenericIngredientCountAggregateInputType | true
    _avg?: GenericIngredientAvgAggregateInputType
    _sum?: GenericIngredientSumAggregateInputType
    _min?: GenericIngredientMinAggregateInputType
    _max?: GenericIngredientMaxAggregateInputType
  }


  export type GenericIngredientGroupByOutputType = {
    id: number
    name: string
    description: string | null
    _count: GenericIngredientCountAggregateOutputType | null
    _avg: GenericIngredientAvgAggregateOutputType | null
    _sum: GenericIngredientSumAggregateOutputType | null
    _min: GenericIngredientMinAggregateOutputType | null
    _max: GenericIngredientMaxAggregateOutputType | null
  }

  type GetGenericIngredientGroupByPayload<T extends GenericIngredientGroupByArgs> = PrismaPromise<
    Array<
      PickArray<GenericIngredientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GenericIngredientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GenericIngredientGroupByOutputType[P]>
            : GetScalarType<T[P], GenericIngredientGroupByOutputType[P]>
        }
      >
    >


  export type GenericIngredientSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    touch?: boolean | TouchFindManyArgs
    specificIngredient?: boolean | SpecificIngredientFindManyArgs
    ingredientPreference?: boolean | IngredientPreferenceFindManyArgs
    _count?: boolean | GenericIngredientCountOutputTypeArgs
  }

  export type GenericIngredientInclude = {
    touch?: boolean | TouchFindManyArgs
    specificIngredient?: boolean | SpecificIngredientFindManyArgs
    ingredientPreference?: boolean | IngredientPreferenceFindManyArgs
    _count?: boolean | GenericIngredientCountOutputTypeArgs
  }

  export type GenericIngredientGetPayload<
    S extends boolean | null | undefined | GenericIngredientArgs,
    U = keyof S
      > = S extends true
        ? GenericIngredient
    : S extends undefined
    ? never
    : S extends GenericIngredientArgs | GenericIngredientFindManyArgs
    ?'include' extends U
    ? GenericIngredient  & {
    [P in TrueKeys<S['include']>]:
        P extends 'touch' ? Array < TouchGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'specificIngredient' ? Array < SpecificIngredientGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'ingredientPreference' ? Array < IngredientPreferenceGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? GenericIngredientCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'touch' ? Array < TouchGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'specificIngredient' ? Array < SpecificIngredientGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'ingredientPreference' ? Array < IngredientPreferenceGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? GenericIngredientCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof GenericIngredient ? GenericIngredient[P] : never
  } 
    : GenericIngredient
  : GenericIngredient


  type GenericIngredientCountArgs = Merge<
    Omit<GenericIngredientFindManyArgs, 'select' | 'include'> & {
      select?: GenericIngredientCountAggregateInputType | true
    }
  >

  export interface GenericIngredientDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one GenericIngredient that matches the filter.
     * @param {GenericIngredientFindUniqueArgs} args - Arguments to find a GenericIngredient
     * @example
     * // Get one GenericIngredient
     * const genericIngredient = await prisma.genericIngredient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GenericIngredientFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GenericIngredientFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'GenericIngredient'> extends True ? CheckSelect<T, Prisma__GenericIngredientClient<GenericIngredient>, Prisma__GenericIngredientClient<GenericIngredientGetPayload<T>>> : CheckSelect<T, Prisma__GenericIngredientClient<GenericIngredient | null >, Prisma__GenericIngredientClient<GenericIngredientGetPayload<T> | null >>

    /**
     * Find the first GenericIngredient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenericIngredientFindFirstArgs} args - Arguments to find a GenericIngredient
     * @example
     * // Get one GenericIngredient
     * const genericIngredient = await prisma.genericIngredient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GenericIngredientFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GenericIngredientFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'GenericIngredient'> extends True ? CheckSelect<T, Prisma__GenericIngredientClient<GenericIngredient>, Prisma__GenericIngredientClient<GenericIngredientGetPayload<T>>> : CheckSelect<T, Prisma__GenericIngredientClient<GenericIngredient | null >, Prisma__GenericIngredientClient<GenericIngredientGetPayload<T> | null >>

    /**
     * Find zero or more GenericIngredients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenericIngredientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GenericIngredients
     * const genericIngredients = await prisma.genericIngredient.findMany()
     * 
     * // Get first 10 GenericIngredients
     * const genericIngredients = await prisma.genericIngredient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const genericIngredientWithIdOnly = await prisma.genericIngredient.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GenericIngredientFindManyArgs>(
      args?: SelectSubset<T, GenericIngredientFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<GenericIngredient>>, PrismaPromise<Array<GenericIngredientGetPayload<T>>>>

    /**
     * Create a GenericIngredient.
     * @param {GenericIngredientCreateArgs} args - Arguments to create a GenericIngredient.
     * @example
     * // Create one GenericIngredient
     * const GenericIngredient = await prisma.genericIngredient.create({
     *   data: {
     *     // ... data to create a GenericIngredient
     *   }
     * })
     * 
    **/
    create<T extends GenericIngredientCreateArgs>(
      args: SelectSubset<T, GenericIngredientCreateArgs>
    ): CheckSelect<T, Prisma__GenericIngredientClient<GenericIngredient>, Prisma__GenericIngredientClient<GenericIngredientGetPayload<T>>>

    /**
     * Create many GenericIngredients.
     *     @param {GenericIngredientCreateManyArgs} args - Arguments to create many GenericIngredients.
     *     @example
     *     // Create many GenericIngredients
     *     const genericIngredient = await prisma.genericIngredient.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GenericIngredientCreateManyArgs>(
      args?: SelectSubset<T, GenericIngredientCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a GenericIngredient.
     * @param {GenericIngredientDeleteArgs} args - Arguments to delete one GenericIngredient.
     * @example
     * // Delete one GenericIngredient
     * const GenericIngredient = await prisma.genericIngredient.delete({
     *   where: {
     *     // ... filter to delete one GenericIngredient
     *   }
     * })
     * 
    **/
    delete<T extends GenericIngredientDeleteArgs>(
      args: SelectSubset<T, GenericIngredientDeleteArgs>
    ): CheckSelect<T, Prisma__GenericIngredientClient<GenericIngredient>, Prisma__GenericIngredientClient<GenericIngredientGetPayload<T>>>

    /**
     * Update one GenericIngredient.
     * @param {GenericIngredientUpdateArgs} args - Arguments to update one GenericIngredient.
     * @example
     * // Update one GenericIngredient
     * const genericIngredient = await prisma.genericIngredient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GenericIngredientUpdateArgs>(
      args: SelectSubset<T, GenericIngredientUpdateArgs>
    ): CheckSelect<T, Prisma__GenericIngredientClient<GenericIngredient>, Prisma__GenericIngredientClient<GenericIngredientGetPayload<T>>>

    /**
     * Delete zero or more GenericIngredients.
     * @param {GenericIngredientDeleteManyArgs} args - Arguments to filter GenericIngredients to delete.
     * @example
     * // Delete a few GenericIngredients
     * const { count } = await prisma.genericIngredient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GenericIngredientDeleteManyArgs>(
      args?: SelectSubset<T, GenericIngredientDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more GenericIngredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenericIngredientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GenericIngredients
     * const genericIngredient = await prisma.genericIngredient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GenericIngredientUpdateManyArgs>(
      args: SelectSubset<T, GenericIngredientUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one GenericIngredient.
     * @param {GenericIngredientUpsertArgs} args - Arguments to update or create a GenericIngredient.
     * @example
     * // Update or create a GenericIngredient
     * const genericIngredient = await prisma.genericIngredient.upsert({
     *   create: {
     *     // ... data to create a GenericIngredient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GenericIngredient we want to update
     *   }
     * })
    **/
    upsert<T extends GenericIngredientUpsertArgs>(
      args: SelectSubset<T, GenericIngredientUpsertArgs>
    ): CheckSelect<T, Prisma__GenericIngredientClient<GenericIngredient>, Prisma__GenericIngredientClient<GenericIngredientGetPayload<T>>>

    /**
     * Find one GenericIngredient that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {GenericIngredientFindUniqueOrThrowArgs} args - Arguments to find a GenericIngredient
     * @example
     * // Get one GenericIngredient
     * const genericIngredient = await prisma.genericIngredient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GenericIngredientFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, GenericIngredientFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__GenericIngredientClient<GenericIngredient>, Prisma__GenericIngredientClient<GenericIngredientGetPayload<T>>>

    /**
     * Find the first GenericIngredient that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenericIngredientFindFirstOrThrowArgs} args - Arguments to find a GenericIngredient
     * @example
     * // Get one GenericIngredient
     * const genericIngredient = await prisma.genericIngredient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GenericIngredientFindFirstOrThrowArgs>(
      args?: SelectSubset<T, GenericIngredientFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__GenericIngredientClient<GenericIngredient>, Prisma__GenericIngredientClient<GenericIngredientGetPayload<T>>>

    /**
     * Count the number of GenericIngredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenericIngredientCountArgs} args - Arguments to filter GenericIngredients to count.
     * @example
     * // Count the number of GenericIngredients
     * const count = await prisma.genericIngredient.count({
     *   where: {
     *     // ... the filter for the GenericIngredients we want to count
     *   }
     * })
    **/
    count<T extends GenericIngredientCountArgs>(
      args?: Subset<T, GenericIngredientCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GenericIngredientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GenericIngredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenericIngredientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GenericIngredientAggregateArgs>(args: Subset<T, GenericIngredientAggregateArgs>): PrismaPromise<GetGenericIngredientAggregateType<T>>

    /**
     * Group by GenericIngredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenericIngredientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GenericIngredientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GenericIngredientGroupByArgs['orderBy'] }
        : { orderBy?: GenericIngredientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GenericIngredientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGenericIngredientGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for GenericIngredient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GenericIngredientClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    touch<T extends TouchFindManyArgs = {}>(args?: Subset<T, TouchFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Touch>>, PrismaPromise<Array<TouchGetPayload<T>>>>;

    specificIngredient<T extends SpecificIngredientFindManyArgs = {}>(args?: Subset<T, SpecificIngredientFindManyArgs>): CheckSelect<T, PrismaPromise<Array<SpecificIngredient>>, PrismaPromise<Array<SpecificIngredientGetPayload<T>>>>;

    ingredientPreference<T extends IngredientPreferenceFindManyArgs = {}>(args?: Subset<T, IngredientPreferenceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<IngredientPreference>>, PrismaPromise<Array<IngredientPreferenceGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * GenericIngredient base type for findUnique actions
   */
  export type GenericIngredientFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the GenericIngredient
     * 
    **/
    select?: GenericIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GenericIngredientInclude | null
    /**
     * Filter, which GenericIngredient to fetch.
     * 
    **/
    where: GenericIngredientWhereUniqueInput
  }

  /**
   * GenericIngredient: findUnique
   */
  export interface GenericIngredientFindUniqueArgs extends GenericIngredientFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * GenericIngredient base type for findFirst actions
   */
  export type GenericIngredientFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the GenericIngredient
     * 
    **/
    select?: GenericIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GenericIngredientInclude | null
    /**
     * Filter, which GenericIngredient to fetch.
     * 
    **/
    where?: GenericIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GenericIngredients to fetch.
     * 
    **/
    orderBy?: Enumerable<GenericIngredientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GenericIngredients.
     * 
    **/
    cursor?: GenericIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GenericIngredients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GenericIngredients.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GenericIngredients.
     * 
    **/
    distinct?: Enumerable<GenericIngredientScalarFieldEnum>
  }

  /**
   * GenericIngredient: findFirst
   */
  export interface GenericIngredientFindFirstArgs extends GenericIngredientFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * GenericIngredient findMany
   */
  export type GenericIngredientFindManyArgs = {
    /**
     * Select specific fields to fetch from the GenericIngredient
     * 
    **/
    select?: GenericIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GenericIngredientInclude | null
    /**
     * Filter, which GenericIngredients to fetch.
     * 
    **/
    where?: GenericIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GenericIngredients to fetch.
     * 
    **/
    orderBy?: Enumerable<GenericIngredientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GenericIngredients.
     * 
    **/
    cursor?: GenericIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GenericIngredients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GenericIngredients.
     * 
    **/
    skip?: number
    distinct?: Enumerable<GenericIngredientScalarFieldEnum>
  }


  /**
   * GenericIngredient create
   */
  export type GenericIngredientCreateArgs = {
    /**
     * Select specific fields to fetch from the GenericIngredient
     * 
    **/
    select?: GenericIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GenericIngredientInclude | null
    /**
     * The data needed to create a GenericIngredient.
     * 
    **/
    data: XOR<GenericIngredientCreateInput, GenericIngredientUncheckedCreateInput>
  }


  /**
   * GenericIngredient createMany
   */
  export type GenericIngredientCreateManyArgs = {
    /**
     * The data used to create many GenericIngredients.
     * 
    **/
    data: Enumerable<GenericIngredientCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * GenericIngredient update
   */
  export type GenericIngredientUpdateArgs = {
    /**
     * Select specific fields to fetch from the GenericIngredient
     * 
    **/
    select?: GenericIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GenericIngredientInclude | null
    /**
     * The data needed to update a GenericIngredient.
     * 
    **/
    data: XOR<GenericIngredientUpdateInput, GenericIngredientUncheckedUpdateInput>
    /**
     * Choose, which GenericIngredient to update.
     * 
    **/
    where: GenericIngredientWhereUniqueInput
  }


  /**
   * GenericIngredient updateMany
   */
  export type GenericIngredientUpdateManyArgs = {
    /**
     * The data used to update GenericIngredients.
     * 
    **/
    data: XOR<GenericIngredientUpdateManyMutationInput, GenericIngredientUncheckedUpdateManyInput>
    /**
     * Filter which GenericIngredients to update
     * 
    **/
    where?: GenericIngredientWhereInput
  }


  /**
   * GenericIngredient upsert
   */
  export type GenericIngredientUpsertArgs = {
    /**
     * Select specific fields to fetch from the GenericIngredient
     * 
    **/
    select?: GenericIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GenericIngredientInclude | null
    /**
     * The filter to search for the GenericIngredient to update in case it exists.
     * 
    **/
    where: GenericIngredientWhereUniqueInput
    /**
     * In case the GenericIngredient found by the `where` argument doesn't exist, create a new GenericIngredient with this data.
     * 
    **/
    create: XOR<GenericIngredientCreateInput, GenericIngredientUncheckedCreateInput>
    /**
     * In case the GenericIngredient was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<GenericIngredientUpdateInput, GenericIngredientUncheckedUpdateInput>
  }


  /**
   * GenericIngredient delete
   */
  export type GenericIngredientDeleteArgs = {
    /**
     * Select specific fields to fetch from the GenericIngredient
     * 
    **/
    select?: GenericIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GenericIngredientInclude | null
    /**
     * Filter which GenericIngredient to delete.
     * 
    **/
    where: GenericIngredientWhereUniqueInput
  }


  /**
   * GenericIngredient deleteMany
   */
  export type GenericIngredientDeleteManyArgs = {
    /**
     * Filter which GenericIngredients to delete
     * 
    **/
    where?: GenericIngredientWhereInput
  }


  /**
   * GenericIngredient: findUniqueOrThrow
   */
  export type GenericIngredientFindUniqueOrThrowArgs = GenericIngredientFindUniqueArgsBase
      

  /**
   * GenericIngredient: findFirstOrThrow
   */
  export type GenericIngredientFindFirstOrThrowArgs = GenericIngredientFindFirstArgsBase
      

  /**
   * GenericIngredient without action
   */
  export type GenericIngredientArgs = {
    /**
     * Select specific fields to fetch from the GenericIngredient
     * 
    **/
    select?: GenericIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GenericIngredientInclude | null
  }



  /**
   * Model SpecificIngredient
   */


  export type AggregateSpecificIngredient = {
    _count: SpecificIngredientCountAggregateOutputType | null
    _avg: SpecificIngredientAvgAggregateOutputType | null
    _sum: SpecificIngredientSumAggregateOutputType | null
    _min: SpecificIngredientMinAggregateOutputType | null
    _max: SpecificIngredientMaxAggregateOutputType | null
  }

  export type SpecificIngredientAvgAggregateOutputType = {
    id: number | null
    genericIngredientId: number | null
    price: number | null
    amount: number | null
  }

  export type SpecificIngredientSumAggregateOutputType = {
    id: number | null
    genericIngredientId: number | null
    price: number | null
    amount: number | null
  }

  export type SpecificIngredientMinAggregateOutputType = {
    id: number | null
    dateCreated: Date | null
    createdById: string | null
    genericIngredientId: number | null
    name: string | null
    description: string | null
    price: number | null
    amount: number | null
    unit: string | null
    source: string | null
  }

  export type SpecificIngredientMaxAggregateOutputType = {
    id: number | null
    dateCreated: Date | null
    createdById: string | null
    genericIngredientId: number | null
    name: string | null
    description: string | null
    price: number | null
    amount: number | null
    unit: string | null
    source: string | null
  }

  export type SpecificIngredientCountAggregateOutputType = {
    id: number
    dateCreated: number
    createdById: number
    genericIngredientId: number
    name: number
    description: number
    price: number
    amount: number
    unit: number
    source: number
    _all: number
  }


  export type SpecificIngredientAvgAggregateInputType = {
    id?: true
    genericIngredientId?: true
    price?: true
    amount?: true
  }

  export type SpecificIngredientSumAggregateInputType = {
    id?: true
    genericIngredientId?: true
    price?: true
    amount?: true
  }

  export type SpecificIngredientMinAggregateInputType = {
    id?: true
    dateCreated?: true
    createdById?: true
    genericIngredientId?: true
    name?: true
    description?: true
    price?: true
    amount?: true
    unit?: true
    source?: true
  }

  export type SpecificIngredientMaxAggregateInputType = {
    id?: true
    dateCreated?: true
    createdById?: true
    genericIngredientId?: true
    name?: true
    description?: true
    price?: true
    amount?: true
    unit?: true
    source?: true
  }

  export type SpecificIngredientCountAggregateInputType = {
    id?: true
    dateCreated?: true
    createdById?: true
    genericIngredientId?: true
    name?: true
    description?: true
    price?: true
    amount?: true
    unit?: true
    source?: true
    _all?: true
  }

  export type SpecificIngredientAggregateArgs = {
    /**
     * Filter which SpecificIngredient to aggregate.
     * 
    **/
    where?: SpecificIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecificIngredients to fetch.
     * 
    **/
    orderBy?: Enumerable<SpecificIngredientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SpecificIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecificIngredients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecificIngredients.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpecificIngredients
    **/
    _count?: true | SpecificIngredientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpecificIngredientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpecificIngredientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpecificIngredientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpecificIngredientMaxAggregateInputType
  }

  export type GetSpecificIngredientAggregateType<T extends SpecificIngredientAggregateArgs> = {
        [P in keyof T & keyof AggregateSpecificIngredient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpecificIngredient[P]>
      : GetScalarType<T[P], AggregateSpecificIngredient[P]>
  }




  export type SpecificIngredientGroupByArgs = {
    where?: SpecificIngredientWhereInput
    orderBy?: Enumerable<SpecificIngredientOrderByWithAggregationInput>
    by: Array<SpecificIngredientScalarFieldEnum>
    having?: SpecificIngredientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpecificIngredientCountAggregateInputType | true
    _avg?: SpecificIngredientAvgAggregateInputType
    _sum?: SpecificIngredientSumAggregateInputType
    _min?: SpecificIngredientMinAggregateInputType
    _max?: SpecificIngredientMaxAggregateInputType
  }


  export type SpecificIngredientGroupByOutputType = {
    id: number
    dateCreated: Date
    createdById: string | null
    genericIngredientId: number
    name: string
    description: string
    price: number | null
    amount: number | null
    unit: string | null
    source: string | null
    _count: SpecificIngredientCountAggregateOutputType | null
    _avg: SpecificIngredientAvgAggregateOutputType | null
    _sum: SpecificIngredientSumAggregateOutputType | null
    _min: SpecificIngredientMinAggregateOutputType | null
    _max: SpecificIngredientMaxAggregateOutputType | null
  }

  type GetSpecificIngredientGroupByPayload<T extends SpecificIngredientGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SpecificIngredientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpecificIngredientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpecificIngredientGroupByOutputType[P]>
            : GetScalarType<T[P], SpecificIngredientGroupByOutputType[P]>
        }
      >
    >


  export type SpecificIngredientSelect = {
    id?: boolean
    dateCreated?: boolean
    createdBy?: boolean | UserArgs
    createdById?: boolean
    genericIngredientId?: boolean
    genericIngredient?: boolean | GenericIngredientArgs
    name?: boolean
    description?: boolean
    price?: boolean
    amount?: boolean
    unit?: boolean
    source?: boolean
    touch?: boolean | TouchFindManyArgs
    ingredientStorage?: boolean | IngredientStorageFindManyArgs
    ingredientPreference?: boolean | IngredientPreferenceFindManyArgs
    _count?: boolean | SpecificIngredientCountOutputTypeArgs
  }

  export type SpecificIngredientInclude = {
    createdBy?: boolean | UserArgs
    genericIngredient?: boolean | GenericIngredientArgs
    touch?: boolean | TouchFindManyArgs
    ingredientStorage?: boolean | IngredientStorageFindManyArgs
    ingredientPreference?: boolean | IngredientPreferenceFindManyArgs
    _count?: boolean | SpecificIngredientCountOutputTypeArgs
  }

  export type SpecificIngredientGetPayload<
    S extends boolean | null | undefined | SpecificIngredientArgs,
    U = keyof S
      > = S extends true
        ? SpecificIngredient
    : S extends undefined
    ? never
    : S extends SpecificIngredientArgs | SpecificIngredientFindManyArgs
    ?'include' extends U
    ? SpecificIngredient  & {
    [P in TrueKeys<S['include']>]:
        P extends 'createdBy' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'genericIngredient' ? GenericIngredientGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'touch' ? Array < TouchGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'ingredientStorage' ? Array < IngredientStorageGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'ingredientPreference' ? Array < IngredientPreferenceGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? SpecificIngredientCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'createdBy' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'genericIngredient' ? GenericIngredientGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'touch' ? Array < TouchGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'ingredientStorage' ? Array < IngredientStorageGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'ingredientPreference' ? Array < IngredientPreferenceGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? SpecificIngredientCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof SpecificIngredient ? SpecificIngredient[P] : never
  } 
    : SpecificIngredient
  : SpecificIngredient


  type SpecificIngredientCountArgs = Merge<
    Omit<SpecificIngredientFindManyArgs, 'select' | 'include'> & {
      select?: SpecificIngredientCountAggregateInputType | true
    }
  >

  export interface SpecificIngredientDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one SpecificIngredient that matches the filter.
     * @param {SpecificIngredientFindUniqueArgs} args - Arguments to find a SpecificIngredient
     * @example
     * // Get one SpecificIngredient
     * const specificIngredient = await prisma.specificIngredient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SpecificIngredientFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SpecificIngredientFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SpecificIngredient'> extends True ? CheckSelect<T, Prisma__SpecificIngredientClient<SpecificIngredient>, Prisma__SpecificIngredientClient<SpecificIngredientGetPayload<T>>> : CheckSelect<T, Prisma__SpecificIngredientClient<SpecificIngredient | null >, Prisma__SpecificIngredientClient<SpecificIngredientGetPayload<T> | null >>

    /**
     * Find the first SpecificIngredient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecificIngredientFindFirstArgs} args - Arguments to find a SpecificIngredient
     * @example
     * // Get one SpecificIngredient
     * const specificIngredient = await prisma.specificIngredient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SpecificIngredientFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SpecificIngredientFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SpecificIngredient'> extends True ? CheckSelect<T, Prisma__SpecificIngredientClient<SpecificIngredient>, Prisma__SpecificIngredientClient<SpecificIngredientGetPayload<T>>> : CheckSelect<T, Prisma__SpecificIngredientClient<SpecificIngredient | null >, Prisma__SpecificIngredientClient<SpecificIngredientGetPayload<T> | null >>

    /**
     * Find zero or more SpecificIngredients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecificIngredientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpecificIngredients
     * const specificIngredients = await prisma.specificIngredient.findMany()
     * 
     * // Get first 10 SpecificIngredients
     * const specificIngredients = await prisma.specificIngredient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const specificIngredientWithIdOnly = await prisma.specificIngredient.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SpecificIngredientFindManyArgs>(
      args?: SelectSubset<T, SpecificIngredientFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SpecificIngredient>>, PrismaPromise<Array<SpecificIngredientGetPayload<T>>>>

    /**
     * Create a SpecificIngredient.
     * @param {SpecificIngredientCreateArgs} args - Arguments to create a SpecificIngredient.
     * @example
     * // Create one SpecificIngredient
     * const SpecificIngredient = await prisma.specificIngredient.create({
     *   data: {
     *     // ... data to create a SpecificIngredient
     *   }
     * })
     * 
    **/
    create<T extends SpecificIngredientCreateArgs>(
      args: SelectSubset<T, SpecificIngredientCreateArgs>
    ): CheckSelect<T, Prisma__SpecificIngredientClient<SpecificIngredient>, Prisma__SpecificIngredientClient<SpecificIngredientGetPayload<T>>>

    /**
     * Create many SpecificIngredients.
     *     @param {SpecificIngredientCreateManyArgs} args - Arguments to create many SpecificIngredients.
     *     @example
     *     // Create many SpecificIngredients
     *     const specificIngredient = await prisma.specificIngredient.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SpecificIngredientCreateManyArgs>(
      args?: SelectSubset<T, SpecificIngredientCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SpecificIngredient.
     * @param {SpecificIngredientDeleteArgs} args - Arguments to delete one SpecificIngredient.
     * @example
     * // Delete one SpecificIngredient
     * const SpecificIngredient = await prisma.specificIngredient.delete({
     *   where: {
     *     // ... filter to delete one SpecificIngredient
     *   }
     * })
     * 
    **/
    delete<T extends SpecificIngredientDeleteArgs>(
      args: SelectSubset<T, SpecificIngredientDeleteArgs>
    ): CheckSelect<T, Prisma__SpecificIngredientClient<SpecificIngredient>, Prisma__SpecificIngredientClient<SpecificIngredientGetPayload<T>>>

    /**
     * Update one SpecificIngredient.
     * @param {SpecificIngredientUpdateArgs} args - Arguments to update one SpecificIngredient.
     * @example
     * // Update one SpecificIngredient
     * const specificIngredient = await prisma.specificIngredient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SpecificIngredientUpdateArgs>(
      args: SelectSubset<T, SpecificIngredientUpdateArgs>
    ): CheckSelect<T, Prisma__SpecificIngredientClient<SpecificIngredient>, Prisma__SpecificIngredientClient<SpecificIngredientGetPayload<T>>>

    /**
     * Delete zero or more SpecificIngredients.
     * @param {SpecificIngredientDeleteManyArgs} args - Arguments to filter SpecificIngredients to delete.
     * @example
     * // Delete a few SpecificIngredients
     * const { count } = await prisma.specificIngredient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SpecificIngredientDeleteManyArgs>(
      args?: SelectSubset<T, SpecificIngredientDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpecificIngredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecificIngredientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpecificIngredients
     * const specificIngredient = await prisma.specificIngredient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SpecificIngredientUpdateManyArgs>(
      args: SelectSubset<T, SpecificIngredientUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SpecificIngredient.
     * @param {SpecificIngredientUpsertArgs} args - Arguments to update or create a SpecificIngredient.
     * @example
     * // Update or create a SpecificIngredient
     * const specificIngredient = await prisma.specificIngredient.upsert({
     *   create: {
     *     // ... data to create a SpecificIngredient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpecificIngredient we want to update
     *   }
     * })
    **/
    upsert<T extends SpecificIngredientUpsertArgs>(
      args: SelectSubset<T, SpecificIngredientUpsertArgs>
    ): CheckSelect<T, Prisma__SpecificIngredientClient<SpecificIngredient>, Prisma__SpecificIngredientClient<SpecificIngredientGetPayload<T>>>

    /**
     * Find one SpecificIngredient that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {SpecificIngredientFindUniqueOrThrowArgs} args - Arguments to find a SpecificIngredient
     * @example
     * // Get one SpecificIngredient
     * const specificIngredient = await prisma.specificIngredient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SpecificIngredientFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SpecificIngredientFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__SpecificIngredientClient<SpecificIngredient>, Prisma__SpecificIngredientClient<SpecificIngredientGetPayload<T>>>

    /**
     * Find the first SpecificIngredient that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecificIngredientFindFirstOrThrowArgs} args - Arguments to find a SpecificIngredient
     * @example
     * // Get one SpecificIngredient
     * const specificIngredient = await prisma.specificIngredient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SpecificIngredientFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SpecificIngredientFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__SpecificIngredientClient<SpecificIngredient>, Prisma__SpecificIngredientClient<SpecificIngredientGetPayload<T>>>

    /**
     * Count the number of SpecificIngredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecificIngredientCountArgs} args - Arguments to filter SpecificIngredients to count.
     * @example
     * // Count the number of SpecificIngredients
     * const count = await prisma.specificIngredient.count({
     *   where: {
     *     // ... the filter for the SpecificIngredients we want to count
     *   }
     * })
    **/
    count<T extends SpecificIngredientCountArgs>(
      args?: Subset<T, SpecificIngredientCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpecificIngredientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpecificIngredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecificIngredientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpecificIngredientAggregateArgs>(args: Subset<T, SpecificIngredientAggregateArgs>): PrismaPromise<GetSpecificIngredientAggregateType<T>>

    /**
     * Group by SpecificIngredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecificIngredientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpecificIngredientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpecificIngredientGroupByArgs['orderBy'] }
        : { orderBy?: SpecificIngredientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpecificIngredientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpecificIngredientGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SpecificIngredient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SpecificIngredientClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    createdBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    genericIngredient<T extends GenericIngredientArgs = {}>(args?: Subset<T, GenericIngredientArgs>): CheckSelect<T, Prisma__GenericIngredientClient<GenericIngredient | null >, Prisma__GenericIngredientClient<GenericIngredientGetPayload<T> | null >>;

    touch<T extends TouchFindManyArgs = {}>(args?: Subset<T, TouchFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Touch>>, PrismaPromise<Array<TouchGetPayload<T>>>>;

    ingredientStorage<T extends IngredientStorageFindManyArgs = {}>(args?: Subset<T, IngredientStorageFindManyArgs>): CheckSelect<T, PrismaPromise<Array<IngredientStorage>>, PrismaPromise<Array<IngredientStorageGetPayload<T>>>>;

    ingredientPreference<T extends IngredientPreferenceFindManyArgs = {}>(args?: Subset<T, IngredientPreferenceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<IngredientPreference>>, PrismaPromise<Array<IngredientPreferenceGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SpecificIngredient base type for findUnique actions
   */
  export type SpecificIngredientFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SpecificIngredient
     * 
    **/
    select?: SpecificIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SpecificIngredientInclude | null
    /**
     * Filter, which SpecificIngredient to fetch.
     * 
    **/
    where: SpecificIngredientWhereUniqueInput
  }

  /**
   * SpecificIngredient: findUnique
   */
  export interface SpecificIngredientFindUniqueArgs extends SpecificIngredientFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SpecificIngredient base type for findFirst actions
   */
  export type SpecificIngredientFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SpecificIngredient
     * 
    **/
    select?: SpecificIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SpecificIngredientInclude | null
    /**
     * Filter, which SpecificIngredient to fetch.
     * 
    **/
    where?: SpecificIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecificIngredients to fetch.
     * 
    **/
    orderBy?: Enumerable<SpecificIngredientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpecificIngredients.
     * 
    **/
    cursor?: SpecificIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecificIngredients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecificIngredients.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpecificIngredients.
     * 
    **/
    distinct?: Enumerable<SpecificIngredientScalarFieldEnum>
  }

  /**
   * SpecificIngredient: findFirst
   */
  export interface SpecificIngredientFindFirstArgs extends SpecificIngredientFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SpecificIngredient findMany
   */
  export type SpecificIngredientFindManyArgs = {
    /**
     * Select specific fields to fetch from the SpecificIngredient
     * 
    **/
    select?: SpecificIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SpecificIngredientInclude | null
    /**
     * Filter, which SpecificIngredients to fetch.
     * 
    **/
    where?: SpecificIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecificIngredients to fetch.
     * 
    **/
    orderBy?: Enumerable<SpecificIngredientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpecificIngredients.
     * 
    **/
    cursor?: SpecificIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecificIngredients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecificIngredients.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SpecificIngredientScalarFieldEnum>
  }


  /**
   * SpecificIngredient create
   */
  export type SpecificIngredientCreateArgs = {
    /**
     * Select specific fields to fetch from the SpecificIngredient
     * 
    **/
    select?: SpecificIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SpecificIngredientInclude | null
    /**
     * The data needed to create a SpecificIngredient.
     * 
    **/
    data: XOR<SpecificIngredientCreateInput, SpecificIngredientUncheckedCreateInput>
  }


  /**
   * SpecificIngredient createMany
   */
  export type SpecificIngredientCreateManyArgs = {
    /**
     * The data used to create many SpecificIngredients.
     * 
    **/
    data: Enumerable<SpecificIngredientCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SpecificIngredient update
   */
  export type SpecificIngredientUpdateArgs = {
    /**
     * Select specific fields to fetch from the SpecificIngredient
     * 
    **/
    select?: SpecificIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SpecificIngredientInclude | null
    /**
     * The data needed to update a SpecificIngredient.
     * 
    **/
    data: XOR<SpecificIngredientUpdateInput, SpecificIngredientUncheckedUpdateInput>
    /**
     * Choose, which SpecificIngredient to update.
     * 
    **/
    where: SpecificIngredientWhereUniqueInput
  }


  /**
   * SpecificIngredient updateMany
   */
  export type SpecificIngredientUpdateManyArgs = {
    /**
     * The data used to update SpecificIngredients.
     * 
    **/
    data: XOR<SpecificIngredientUpdateManyMutationInput, SpecificIngredientUncheckedUpdateManyInput>
    /**
     * Filter which SpecificIngredients to update
     * 
    **/
    where?: SpecificIngredientWhereInput
  }


  /**
   * SpecificIngredient upsert
   */
  export type SpecificIngredientUpsertArgs = {
    /**
     * Select specific fields to fetch from the SpecificIngredient
     * 
    **/
    select?: SpecificIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SpecificIngredientInclude | null
    /**
     * The filter to search for the SpecificIngredient to update in case it exists.
     * 
    **/
    where: SpecificIngredientWhereUniqueInput
    /**
     * In case the SpecificIngredient found by the `where` argument doesn't exist, create a new SpecificIngredient with this data.
     * 
    **/
    create: XOR<SpecificIngredientCreateInput, SpecificIngredientUncheckedCreateInput>
    /**
     * In case the SpecificIngredient was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SpecificIngredientUpdateInput, SpecificIngredientUncheckedUpdateInput>
  }


  /**
   * SpecificIngredient delete
   */
  export type SpecificIngredientDeleteArgs = {
    /**
     * Select specific fields to fetch from the SpecificIngredient
     * 
    **/
    select?: SpecificIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SpecificIngredientInclude | null
    /**
     * Filter which SpecificIngredient to delete.
     * 
    **/
    where: SpecificIngredientWhereUniqueInput
  }


  /**
   * SpecificIngredient deleteMany
   */
  export type SpecificIngredientDeleteManyArgs = {
    /**
     * Filter which SpecificIngredients to delete
     * 
    **/
    where?: SpecificIngredientWhereInput
  }


  /**
   * SpecificIngredient: findUniqueOrThrow
   */
  export type SpecificIngredientFindUniqueOrThrowArgs = SpecificIngredientFindUniqueArgsBase
      

  /**
   * SpecificIngredient: findFirstOrThrow
   */
  export type SpecificIngredientFindFirstOrThrowArgs = SpecificIngredientFindFirstArgsBase
      

  /**
   * SpecificIngredient without action
   */
  export type SpecificIngredientArgs = {
    /**
     * Select specific fields to fetch from the SpecificIngredient
     * 
    **/
    select?: SpecificIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SpecificIngredientInclude | null
  }



  /**
   * Model IngredientPreference
   */


  export type AggregateIngredientPreference = {
    _count: IngredientPreferenceCountAggregateOutputType | null
    _avg: IngredientPreferenceAvgAggregateOutputType | null
    _sum: IngredientPreferenceSumAggregateOutputType | null
    _min: IngredientPreferenceMinAggregateOutputType | null
    _max: IngredientPreferenceMaxAggregateOutputType | null
  }

  export type IngredientPreferenceAvgAggregateOutputType = {
    genericIngredientID: number | null
    specificIngredientID: number | null
  }

  export type IngredientPreferenceSumAggregateOutputType = {
    genericIngredientID: number | null
    specificIngredientID: number | null
  }

  export type IngredientPreferenceMinAggregateOutputType = {
    genericIngredientID: number | null
    specificIngredientID: number | null
    userId: string | null
  }

  export type IngredientPreferenceMaxAggregateOutputType = {
    genericIngredientID: number | null
    specificIngredientID: number | null
    userId: string | null
  }

  export type IngredientPreferenceCountAggregateOutputType = {
    genericIngredientID: number
    specificIngredientID: number
    userId: number
    _all: number
  }


  export type IngredientPreferenceAvgAggregateInputType = {
    genericIngredientID?: true
    specificIngredientID?: true
  }

  export type IngredientPreferenceSumAggregateInputType = {
    genericIngredientID?: true
    specificIngredientID?: true
  }

  export type IngredientPreferenceMinAggregateInputType = {
    genericIngredientID?: true
    specificIngredientID?: true
    userId?: true
  }

  export type IngredientPreferenceMaxAggregateInputType = {
    genericIngredientID?: true
    specificIngredientID?: true
    userId?: true
  }

  export type IngredientPreferenceCountAggregateInputType = {
    genericIngredientID?: true
    specificIngredientID?: true
    userId?: true
    _all?: true
  }

  export type IngredientPreferenceAggregateArgs = {
    /**
     * Filter which IngredientPreference to aggregate.
     * 
    **/
    where?: IngredientPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientPreferences to fetch.
     * 
    **/
    orderBy?: Enumerable<IngredientPreferenceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: IngredientPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientPreferences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientPreferences.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IngredientPreferences
    **/
    _count?: true | IngredientPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IngredientPreferenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IngredientPreferenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IngredientPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IngredientPreferenceMaxAggregateInputType
  }

  export type GetIngredientPreferenceAggregateType<T extends IngredientPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateIngredientPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIngredientPreference[P]>
      : GetScalarType<T[P], AggregateIngredientPreference[P]>
  }




  export type IngredientPreferenceGroupByArgs = {
    where?: IngredientPreferenceWhereInput
    orderBy?: Enumerable<IngredientPreferenceOrderByWithAggregationInput>
    by: Array<IngredientPreferenceScalarFieldEnum>
    having?: IngredientPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IngredientPreferenceCountAggregateInputType | true
    _avg?: IngredientPreferenceAvgAggregateInputType
    _sum?: IngredientPreferenceSumAggregateInputType
    _min?: IngredientPreferenceMinAggregateInputType
    _max?: IngredientPreferenceMaxAggregateInputType
  }


  export type IngredientPreferenceGroupByOutputType = {
    genericIngredientID: number
    specificIngredientID: number
    userId: string
    _count: IngredientPreferenceCountAggregateOutputType | null
    _avg: IngredientPreferenceAvgAggregateOutputType | null
    _sum: IngredientPreferenceSumAggregateOutputType | null
    _min: IngredientPreferenceMinAggregateOutputType | null
    _max: IngredientPreferenceMaxAggregateOutputType | null
  }

  type GetIngredientPreferenceGroupByPayload<T extends IngredientPreferenceGroupByArgs> = PrismaPromise<
    Array<
      PickArray<IngredientPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IngredientPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IngredientPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], IngredientPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type IngredientPreferenceSelect = {
    genericIngredientID?: boolean
    genericIngredient?: boolean | GenericIngredientArgs
    specificIngredientID?: boolean
    specificIngredient?: boolean | SpecificIngredientArgs
    userId?: boolean
    user?: boolean | UserArgs
  }

  export type IngredientPreferenceInclude = {
    genericIngredient?: boolean | GenericIngredientArgs
    specificIngredient?: boolean | SpecificIngredientArgs
    user?: boolean | UserArgs
  }

  export type IngredientPreferenceGetPayload<
    S extends boolean | null | undefined | IngredientPreferenceArgs,
    U = keyof S
      > = S extends true
        ? IngredientPreference
    : S extends undefined
    ? never
    : S extends IngredientPreferenceArgs | IngredientPreferenceFindManyArgs
    ?'include' extends U
    ? IngredientPreference  & {
    [P in TrueKeys<S['include']>]:
        P extends 'genericIngredient' ? GenericIngredientGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'specificIngredient' ? SpecificIngredientGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'genericIngredient' ? GenericIngredientGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'specificIngredient' ? SpecificIngredientGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof IngredientPreference ? IngredientPreference[P] : never
  } 
    : IngredientPreference
  : IngredientPreference


  type IngredientPreferenceCountArgs = Merge<
    Omit<IngredientPreferenceFindManyArgs, 'select' | 'include'> & {
      select?: IngredientPreferenceCountAggregateInputType | true
    }
  >

  export interface IngredientPreferenceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one IngredientPreference that matches the filter.
     * @param {IngredientPreferenceFindUniqueArgs} args - Arguments to find a IngredientPreference
     * @example
     * // Get one IngredientPreference
     * const ingredientPreference = await prisma.ingredientPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IngredientPreferenceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, IngredientPreferenceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'IngredientPreference'> extends True ? CheckSelect<T, Prisma__IngredientPreferenceClient<IngredientPreference>, Prisma__IngredientPreferenceClient<IngredientPreferenceGetPayload<T>>> : CheckSelect<T, Prisma__IngredientPreferenceClient<IngredientPreference | null >, Prisma__IngredientPreferenceClient<IngredientPreferenceGetPayload<T> | null >>

    /**
     * Find the first IngredientPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientPreferenceFindFirstArgs} args - Arguments to find a IngredientPreference
     * @example
     * // Get one IngredientPreference
     * const ingredientPreference = await prisma.ingredientPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IngredientPreferenceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, IngredientPreferenceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'IngredientPreference'> extends True ? CheckSelect<T, Prisma__IngredientPreferenceClient<IngredientPreference>, Prisma__IngredientPreferenceClient<IngredientPreferenceGetPayload<T>>> : CheckSelect<T, Prisma__IngredientPreferenceClient<IngredientPreference | null >, Prisma__IngredientPreferenceClient<IngredientPreferenceGetPayload<T> | null >>

    /**
     * Find zero or more IngredientPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientPreferenceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IngredientPreferences
     * const ingredientPreferences = await prisma.ingredientPreference.findMany()
     * 
     * // Get first 10 IngredientPreferences
     * const ingredientPreferences = await prisma.ingredientPreference.findMany({ take: 10 })
     * 
     * // Only select the `genericIngredientID`
     * const ingredientPreferenceWithGenericIngredientIDOnly = await prisma.ingredientPreference.findMany({ select: { genericIngredientID: true } })
     * 
    **/
    findMany<T extends IngredientPreferenceFindManyArgs>(
      args?: SelectSubset<T, IngredientPreferenceFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<IngredientPreference>>, PrismaPromise<Array<IngredientPreferenceGetPayload<T>>>>

    /**
     * Create a IngredientPreference.
     * @param {IngredientPreferenceCreateArgs} args - Arguments to create a IngredientPreference.
     * @example
     * // Create one IngredientPreference
     * const IngredientPreference = await prisma.ingredientPreference.create({
     *   data: {
     *     // ... data to create a IngredientPreference
     *   }
     * })
     * 
    **/
    create<T extends IngredientPreferenceCreateArgs>(
      args: SelectSubset<T, IngredientPreferenceCreateArgs>
    ): CheckSelect<T, Prisma__IngredientPreferenceClient<IngredientPreference>, Prisma__IngredientPreferenceClient<IngredientPreferenceGetPayload<T>>>

    /**
     * Create many IngredientPreferences.
     *     @param {IngredientPreferenceCreateManyArgs} args - Arguments to create many IngredientPreferences.
     *     @example
     *     // Create many IngredientPreferences
     *     const ingredientPreference = await prisma.ingredientPreference.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IngredientPreferenceCreateManyArgs>(
      args?: SelectSubset<T, IngredientPreferenceCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a IngredientPreference.
     * @param {IngredientPreferenceDeleteArgs} args - Arguments to delete one IngredientPreference.
     * @example
     * // Delete one IngredientPreference
     * const IngredientPreference = await prisma.ingredientPreference.delete({
     *   where: {
     *     // ... filter to delete one IngredientPreference
     *   }
     * })
     * 
    **/
    delete<T extends IngredientPreferenceDeleteArgs>(
      args: SelectSubset<T, IngredientPreferenceDeleteArgs>
    ): CheckSelect<T, Prisma__IngredientPreferenceClient<IngredientPreference>, Prisma__IngredientPreferenceClient<IngredientPreferenceGetPayload<T>>>

    /**
     * Update one IngredientPreference.
     * @param {IngredientPreferenceUpdateArgs} args - Arguments to update one IngredientPreference.
     * @example
     * // Update one IngredientPreference
     * const ingredientPreference = await prisma.ingredientPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IngredientPreferenceUpdateArgs>(
      args: SelectSubset<T, IngredientPreferenceUpdateArgs>
    ): CheckSelect<T, Prisma__IngredientPreferenceClient<IngredientPreference>, Prisma__IngredientPreferenceClient<IngredientPreferenceGetPayload<T>>>

    /**
     * Delete zero or more IngredientPreferences.
     * @param {IngredientPreferenceDeleteManyArgs} args - Arguments to filter IngredientPreferences to delete.
     * @example
     * // Delete a few IngredientPreferences
     * const { count } = await prisma.ingredientPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IngredientPreferenceDeleteManyArgs>(
      args?: SelectSubset<T, IngredientPreferenceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more IngredientPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IngredientPreferences
     * const ingredientPreference = await prisma.ingredientPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IngredientPreferenceUpdateManyArgs>(
      args: SelectSubset<T, IngredientPreferenceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one IngredientPreference.
     * @param {IngredientPreferenceUpsertArgs} args - Arguments to update or create a IngredientPreference.
     * @example
     * // Update or create a IngredientPreference
     * const ingredientPreference = await prisma.ingredientPreference.upsert({
     *   create: {
     *     // ... data to create a IngredientPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IngredientPreference we want to update
     *   }
     * })
    **/
    upsert<T extends IngredientPreferenceUpsertArgs>(
      args: SelectSubset<T, IngredientPreferenceUpsertArgs>
    ): CheckSelect<T, Prisma__IngredientPreferenceClient<IngredientPreference>, Prisma__IngredientPreferenceClient<IngredientPreferenceGetPayload<T>>>

    /**
     * Find one IngredientPreference that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {IngredientPreferenceFindUniqueOrThrowArgs} args - Arguments to find a IngredientPreference
     * @example
     * // Get one IngredientPreference
     * const ingredientPreference = await prisma.ingredientPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends IngredientPreferenceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, IngredientPreferenceFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__IngredientPreferenceClient<IngredientPreference>, Prisma__IngredientPreferenceClient<IngredientPreferenceGetPayload<T>>>

    /**
     * Find the first IngredientPreference that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientPreferenceFindFirstOrThrowArgs} args - Arguments to find a IngredientPreference
     * @example
     * // Get one IngredientPreference
     * const ingredientPreference = await prisma.ingredientPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends IngredientPreferenceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, IngredientPreferenceFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__IngredientPreferenceClient<IngredientPreference>, Prisma__IngredientPreferenceClient<IngredientPreferenceGetPayload<T>>>

    /**
     * Count the number of IngredientPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientPreferenceCountArgs} args - Arguments to filter IngredientPreferences to count.
     * @example
     * // Count the number of IngredientPreferences
     * const count = await prisma.ingredientPreference.count({
     *   where: {
     *     // ... the filter for the IngredientPreferences we want to count
     *   }
     * })
    **/
    count<T extends IngredientPreferenceCountArgs>(
      args?: Subset<T, IngredientPreferenceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IngredientPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IngredientPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IngredientPreferenceAggregateArgs>(args: Subset<T, IngredientPreferenceAggregateArgs>): PrismaPromise<GetIngredientPreferenceAggregateType<T>>

    /**
     * Group by IngredientPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IngredientPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IngredientPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: IngredientPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IngredientPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIngredientPreferenceGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for IngredientPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__IngredientPreferenceClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    genericIngredient<T extends GenericIngredientArgs = {}>(args?: Subset<T, GenericIngredientArgs>): CheckSelect<T, Prisma__GenericIngredientClient<GenericIngredient | null >, Prisma__GenericIngredientClient<GenericIngredientGetPayload<T> | null >>;

    specificIngredient<T extends SpecificIngredientArgs = {}>(args?: Subset<T, SpecificIngredientArgs>): CheckSelect<T, Prisma__SpecificIngredientClient<SpecificIngredient | null >, Prisma__SpecificIngredientClient<SpecificIngredientGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * IngredientPreference base type for findUnique actions
   */
  export type IngredientPreferenceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the IngredientPreference
     * 
    **/
    select?: IngredientPreferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IngredientPreferenceInclude | null
    /**
     * Filter, which IngredientPreference to fetch.
     * 
    **/
    where: IngredientPreferenceWhereUniqueInput
  }

  /**
   * IngredientPreference: findUnique
   */
  export interface IngredientPreferenceFindUniqueArgs extends IngredientPreferenceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * IngredientPreference base type for findFirst actions
   */
  export type IngredientPreferenceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the IngredientPreference
     * 
    **/
    select?: IngredientPreferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IngredientPreferenceInclude | null
    /**
     * Filter, which IngredientPreference to fetch.
     * 
    **/
    where?: IngredientPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientPreferences to fetch.
     * 
    **/
    orderBy?: Enumerable<IngredientPreferenceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IngredientPreferences.
     * 
    **/
    cursor?: IngredientPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientPreferences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientPreferences.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IngredientPreferences.
     * 
    **/
    distinct?: Enumerable<IngredientPreferenceScalarFieldEnum>
  }

  /**
   * IngredientPreference: findFirst
   */
  export interface IngredientPreferenceFindFirstArgs extends IngredientPreferenceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * IngredientPreference findMany
   */
  export type IngredientPreferenceFindManyArgs = {
    /**
     * Select specific fields to fetch from the IngredientPreference
     * 
    **/
    select?: IngredientPreferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IngredientPreferenceInclude | null
    /**
     * Filter, which IngredientPreferences to fetch.
     * 
    **/
    where?: IngredientPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientPreferences to fetch.
     * 
    **/
    orderBy?: Enumerable<IngredientPreferenceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IngredientPreferences.
     * 
    **/
    cursor?: IngredientPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientPreferences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientPreferences.
     * 
    **/
    skip?: number
    distinct?: Enumerable<IngredientPreferenceScalarFieldEnum>
  }


  /**
   * IngredientPreference create
   */
  export type IngredientPreferenceCreateArgs = {
    /**
     * Select specific fields to fetch from the IngredientPreference
     * 
    **/
    select?: IngredientPreferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IngredientPreferenceInclude | null
    /**
     * The data needed to create a IngredientPreference.
     * 
    **/
    data: XOR<IngredientPreferenceCreateInput, IngredientPreferenceUncheckedCreateInput>
  }


  /**
   * IngredientPreference createMany
   */
  export type IngredientPreferenceCreateManyArgs = {
    /**
     * The data used to create many IngredientPreferences.
     * 
    **/
    data: Enumerable<IngredientPreferenceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * IngredientPreference update
   */
  export type IngredientPreferenceUpdateArgs = {
    /**
     * Select specific fields to fetch from the IngredientPreference
     * 
    **/
    select?: IngredientPreferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IngredientPreferenceInclude | null
    /**
     * The data needed to update a IngredientPreference.
     * 
    **/
    data: XOR<IngredientPreferenceUpdateInput, IngredientPreferenceUncheckedUpdateInput>
    /**
     * Choose, which IngredientPreference to update.
     * 
    **/
    where: IngredientPreferenceWhereUniqueInput
  }


  /**
   * IngredientPreference updateMany
   */
  export type IngredientPreferenceUpdateManyArgs = {
    /**
     * The data used to update IngredientPreferences.
     * 
    **/
    data: XOR<IngredientPreferenceUpdateManyMutationInput, IngredientPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which IngredientPreferences to update
     * 
    **/
    where?: IngredientPreferenceWhereInput
  }


  /**
   * IngredientPreference upsert
   */
  export type IngredientPreferenceUpsertArgs = {
    /**
     * Select specific fields to fetch from the IngredientPreference
     * 
    **/
    select?: IngredientPreferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IngredientPreferenceInclude | null
    /**
     * The filter to search for the IngredientPreference to update in case it exists.
     * 
    **/
    where: IngredientPreferenceWhereUniqueInput
    /**
     * In case the IngredientPreference found by the `where` argument doesn't exist, create a new IngredientPreference with this data.
     * 
    **/
    create: XOR<IngredientPreferenceCreateInput, IngredientPreferenceUncheckedCreateInput>
    /**
     * In case the IngredientPreference was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<IngredientPreferenceUpdateInput, IngredientPreferenceUncheckedUpdateInput>
  }


  /**
   * IngredientPreference delete
   */
  export type IngredientPreferenceDeleteArgs = {
    /**
     * Select specific fields to fetch from the IngredientPreference
     * 
    **/
    select?: IngredientPreferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IngredientPreferenceInclude | null
    /**
     * Filter which IngredientPreference to delete.
     * 
    **/
    where: IngredientPreferenceWhereUniqueInput
  }


  /**
   * IngredientPreference deleteMany
   */
  export type IngredientPreferenceDeleteManyArgs = {
    /**
     * Filter which IngredientPreferences to delete
     * 
    **/
    where?: IngredientPreferenceWhereInput
  }


  /**
   * IngredientPreference: findUniqueOrThrow
   */
  export type IngredientPreferenceFindUniqueOrThrowArgs = IngredientPreferenceFindUniqueArgsBase
      

  /**
   * IngredientPreference: findFirstOrThrow
   */
  export type IngredientPreferenceFindFirstOrThrowArgs = IngredientPreferenceFindFirstArgsBase
      

  /**
   * IngredientPreference without action
   */
  export type IngredientPreferenceArgs = {
    /**
     * Select specific fields to fetch from the IngredientPreference
     * 
    **/
    select?: IngredientPreferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IngredientPreferenceInclude | null
  }



  /**
   * Model Inventory
   */


  export type AggregateInventory = {
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  export type InventoryAvgAggregateOutputType = {
    id: number | null
  }

  export type InventorySumAggregateOutputType = {
    id: number | null
  }

  export type InventoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
  }

  export type InventoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
  }

  export type InventoryCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    editedAt: number
    createdById: number
    editedById: number
    _all: number
  }


  export type InventoryAvgAggregateInputType = {
    id?: true
  }

  export type InventorySumAggregateInputType = {
    id?: true
  }

  export type InventoryMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
  }

  export type InventoryMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
  }

  export type InventoryCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
    _all?: true
  }

  export type InventoryAggregateArgs = {
    /**
     * Filter which Inventory to aggregate.
     * 
    **/
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     * 
    **/
    orderBy?: Enumerable<InventoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inventories
    **/
    _count?: true | InventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMaxAggregateInputType
  }

  export type GetInventoryAggregateType<T extends InventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventory[P]>
      : GetScalarType<T[P], AggregateInventory[P]>
  }




  export type InventoryGroupByArgs = {
    where?: InventoryWhereInput
    orderBy?: Enumerable<InventoryOrderByWithAggregationInput>
    by: Array<InventoryScalarFieldEnum>
    having?: InventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryCountAggregateInputType | true
    _avg?: InventoryAvgAggregateInputType
    _sum?: InventorySumAggregateInputType
    _min?: InventoryMinAggregateInputType
    _max?: InventoryMaxAggregateInputType
  }


  export type InventoryGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    editedAt: Date
    createdById: string
    editedById: string
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  type GetInventoryGroupByPayload<T extends InventoryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryGroupByOutputType[P]>
        }
      >
    >


  export type InventorySelect = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    editedAt?: boolean
    createdById?: boolean
    editedById?: boolean
    createdBy?: boolean | UserArgs
    editedBy?: boolean | UserArgs
    inventoryStorage?: boolean | InventoryStorageFindManyArgs
    inventoryUser?: boolean | InventoryUserFindManyArgs
    _count?: boolean | InventoryCountOutputTypeArgs
  }

  export type InventoryInclude = {
    createdBy?: boolean | UserArgs
    editedBy?: boolean | UserArgs
    inventoryStorage?: boolean | InventoryStorageFindManyArgs
    inventoryUser?: boolean | InventoryUserFindManyArgs
    _count?: boolean | InventoryCountOutputTypeArgs
  }

  export type InventoryGetPayload<
    S extends boolean | null | undefined | InventoryArgs,
    U = keyof S
      > = S extends true
        ? Inventory
    : S extends undefined
    ? never
    : S extends InventoryArgs | InventoryFindManyArgs
    ?'include' extends U
    ? Inventory  & {
    [P in TrueKeys<S['include']>]:
        P extends 'createdBy' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'editedBy' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'inventoryStorage' ? Array < InventoryStorageGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'inventoryUser' ? Array < InventoryUserGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? InventoryCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'createdBy' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'editedBy' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'inventoryStorage' ? Array < InventoryStorageGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'inventoryUser' ? Array < InventoryUserGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? InventoryCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Inventory ? Inventory[P] : never
  } 
    : Inventory
  : Inventory


  type InventoryCountArgs = Merge<
    Omit<InventoryFindManyArgs, 'select' | 'include'> & {
      select?: InventoryCountAggregateInputType | true
    }
  >

  export interface InventoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Inventory that matches the filter.
     * @param {InventoryFindUniqueArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InventoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InventoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Inventory'> extends True ? CheckSelect<T, Prisma__InventoryClient<Inventory>, Prisma__InventoryClient<InventoryGetPayload<T>>> : CheckSelect<T, Prisma__InventoryClient<Inventory | null >, Prisma__InventoryClient<InventoryGetPayload<T> | null >>

    /**
     * Find the first Inventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InventoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InventoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Inventory'> extends True ? CheckSelect<T, Prisma__InventoryClient<Inventory>, Prisma__InventoryClient<InventoryGetPayload<T>>> : CheckSelect<T, Prisma__InventoryClient<Inventory | null >, Prisma__InventoryClient<InventoryGetPayload<T> | null >>

    /**
     * Find zero or more Inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventories
     * const inventories = await prisma.inventory.findMany()
     * 
     * // Get first 10 Inventories
     * const inventories = await prisma.inventory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryWithIdOnly = await prisma.inventory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InventoryFindManyArgs>(
      args?: SelectSubset<T, InventoryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Inventory>>, PrismaPromise<Array<InventoryGetPayload<T>>>>

    /**
     * Create a Inventory.
     * @param {InventoryCreateArgs} args - Arguments to create a Inventory.
     * @example
     * // Create one Inventory
     * const Inventory = await prisma.inventory.create({
     *   data: {
     *     // ... data to create a Inventory
     *   }
     * })
     * 
    **/
    create<T extends InventoryCreateArgs>(
      args: SelectSubset<T, InventoryCreateArgs>
    ): CheckSelect<T, Prisma__InventoryClient<Inventory>, Prisma__InventoryClient<InventoryGetPayload<T>>>

    /**
     * Create many Inventories.
     *     @param {InventoryCreateManyArgs} args - Arguments to create many Inventories.
     *     @example
     *     // Create many Inventories
     *     const inventory = await prisma.inventory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InventoryCreateManyArgs>(
      args?: SelectSubset<T, InventoryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Inventory.
     * @param {InventoryDeleteArgs} args - Arguments to delete one Inventory.
     * @example
     * // Delete one Inventory
     * const Inventory = await prisma.inventory.delete({
     *   where: {
     *     // ... filter to delete one Inventory
     *   }
     * })
     * 
    **/
    delete<T extends InventoryDeleteArgs>(
      args: SelectSubset<T, InventoryDeleteArgs>
    ): CheckSelect<T, Prisma__InventoryClient<Inventory>, Prisma__InventoryClient<InventoryGetPayload<T>>>

    /**
     * Update one Inventory.
     * @param {InventoryUpdateArgs} args - Arguments to update one Inventory.
     * @example
     * // Update one Inventory
     * const inventory = await prisma.inventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InventoryUpdateArgs>(
      args: SelectSubset<T, InventoryUpdateArgs>
    ): CheckSelect<T, Prisma__InventoryClient<Inventory>, Prisma__InventoryClient<InventoryGetPayload<T>>>

    /**
     * Delete zero or more Inventories.
     * @param {InventoryDeleteManyArgs} args - Arguments to filter Inventories to delete.
     * @example
     * // Delete a few Inventories
     * const { count } = await prisma.inventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InventoryDeleteManyArgs>(
      args?: SelectSubset<T, InventoryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InventoryUpdateManyArgs>(
      args: SelectSubset<T, InventoryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Inventory.
     * @param {InventoryUpsertArgs} args - Arguments to update or create a Inventory.
     * @example
     * // Update or create a Inventory
     * const inventory = await prisma.inventory.upsert({
     *   create: {
     *     // ... data to create a Inventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventory we want to update
     *   }
     * })
    **/
    upsert<T extends InventoryUpsertArgs>(
      args: SelectSubset<T, InventoryUpsertArgs>
    ): CheckSelect<T, Prisma__InventoryClient<Inventory>, Prisma__InventoryClient<InventoryGetPayload<T>>>

    /**
     * Find one Inventory that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {InventoryFindUniqueOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InventoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, InventoryFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__InventoryClient<Inventory>, Prisma__InventoryClient<InventoryGetPayload<T>>>

    /**
     * Find the first Inventory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InventoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, InventoryFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__InventoryClient<Inventory>, Prisma__InventoryClient<InventoryGetPayload<T>>>

    /**
     * Count the number of Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCountArgs} args - Arguments to filter Inventories to count.
     * @example
     * // Count the number of Inventories
     * const count = await prisma.inventory.count({
     *   where: {
     *     // ... the filter for the Inventories we want to count
     *   }
     * })
    **/
    count<T extends InventoryCountArgs>(
      args?: Subset<T, InventoryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryAggregateArgs>(args: Subset<T, InventoryAggregateArgs>): PrismaPromise<GetInventoryAggregateType<T>>

    /**
     * Group by Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryGroupByArgs['orderBy'] }
        : { orderBy?: InventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Inventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InventoryClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    createdBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    editedBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    inventoryStorage<T extends InventoryStorageFindManyArgs = {}>(args?: Subset<T, InventoryStorageFindManyArgs>): CheckSelect<T, PrismaPromise<Array<InventoryStorage>>, PrismaPromise<Array<InventoryStorageGetPayload<T>>>>;

    inventoryUser<T extends InventoryUserFindManyArgs = {}>(args?: Subset<T, InventoryUserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<InventoryUser>>, PrismaPromise<Array<InventoryUserGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Inventory base type for findUnique actions
   */
  export type InventoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Inventory
     * 
    **/
    select?: InventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryInclude | null
    /**
     * Filter, which Inventory to fetch.
     * 
    **/
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory: findUnique
   */
  export interface InventoryFindUniqueArgs extends InventoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Inventory base type for findFirst actions
   */
  export type InventoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Inventory
     * 
    **/
    select?: InventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryInclude | null
    /**
     * Filter, which Inventory to fetch.
     * 
    **/
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     * 
    **/
    orderBy?: Enumerable<InventoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     * 
    **/
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     * 
    **/
    distinct?: Enumerable<InventoryScalarFieldEnum>
  }

  /**
   * Inventory: findFirst
   */
  export interface InventoryFindFirstArgs extends InventoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Inventory findMany
   */
  export type InventoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the Inventory
     * 
    **/
    select?: InventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryInclude | null
    /**
     * Filter, which Inventories to fetch.
     * 
    **/
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     * 
    **/
    orderBy?: Enumerable<InventoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inventories.
     * 
    **/
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InventoryScalarFieldEnum>
  }


  /**
   * Inventory create
   */
  export type InventoryCreateArgs = {
    /**
     * Select specific fields to fetch from the Inventory
     * 
    **/
    select?: InventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryInclude | null
    /**
     * The data needed to create a Inventory.
     * 
    **/
    data: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
  }


  /**
   * Inventory createMany
   */
  export type InventoryCreateManyArgs = {
    /**
     * The data used to create many Inventories.
     * 
    **/
    data: Enumerable<InventoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Inventory update
   */
  export type InventoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the Inventory
     * 
    **/
    select?: InventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryInclude | null
    /**
     * The data needed to update a Inventory.
     * 
    **/
    data: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
    /**
     * Choose, which Inventory to update.
     * 
    **/
    where: InventoryWhereUniqueInput
  }


  /**
   * Inventory updateMany
   */
  export type InventoryUpdateManyArgs = {
    /**
     * The data used to update Inventories.
     * 
    **/
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyInput>
    /**
     * Filter which Inventories to update
     * 
    **/
    where?: InventoryWhereInput
  }


  /**
   * Inventory upsert
   */
  export type InventoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the Inventory
     * 
    **/
    select?: InventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryInclude | null
    /**
     * The filter to search for the Inventory to update in case it exists.
     * 
    **/
    where: InventoryWhereUniqueInput
    /**
     * In case the Inventory found by the `where` argument doesn't exist, create a new Inventory with this data.
     * 
    **/
    create: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
    /**
     * In case the Inventory was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
  }


  /**
   * Inventory delete
   */
  export type InventoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the Inventory
     * 
    **/
    select?: InventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryInclude | null
    /**
     * Filter which Inventory to delete.
     * 
    **/
    where: InventoryWhereUniqueInput
  }


  /**
   * Inventory deleteMany
   */
  export type InventoryDeleteManyArgs = {
    /**
     * Filter which Inventories to delete
     * 
    **/
    where?: InventoryWhereInput
  }


  /**
   * Inventory: findUniqueOrThrow
   */
  export type InventoryFindUniqueOrThrowArgs = InventoryFindUniqueArgsBase
      

  /**
   * Inventory: findFirstOrThrow
   */
  export type InventoryFindFirstOrThrowArgs = InventoryFindFirstArgsBase
      

  /**
   * Inventory without action
   */
  export type InventoryArgs = {
    /**
     * Select specific fields to fetch from the Inventory
     * 
    **/
    select?: InventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryInclude | null
  }



  /**
   * Model InventoryUser
   */


  export type AggregateInventoryUser = {
    _count: InventoryUserCountAggregateOutputType | null
    _avg: InventoryUserAvgAggregateOutputType | null
    _sum: InventoryUserSumAggregateOutputType | null
    _min: InventoryUserMinAggregateOutputType | null
    _max: InventoryUserMaxAggregateOutputType | null
  }

  export type InventoryUserAvgAggregateOutputType = {
    inventoryId: number | null
  }

  export type InventoryUserSumAggregateOutputType = {
    inventoryId: number | null
  }

  export type InventoryUserMinAggregateOutputType = {
    userId: string | null
    inventoryId: number | null
    permission: string | null
  }

  export type InventoryUserMaxAggregateOutputType = {
    userId: string | null
    inventoryId: number | null
    permission: string | null
  }

  export type InventoryUserCountAggregateOutputType = {
    userId: number
    inventoryId: number
    permission: number
    _all: number
  }


  export type InventoryUserAvgAggregateInputType = {
    inventoryId?: true
  }

  export type InventoryUserSumAggregateInputType = {
    inventoryId?: true
  }

  export type InventoryUserMinAggregateInputType = {
    userId?: true
    inventoryId?: true
    permission?: true
  }

  export type InventoryUserMaxAggregateInputType = {
    userId?: true
    inventoryId?: true
    permission?: true
  }

  export type InventoryUserCountAggregateInputType = {
    userId?: true
    inventoryId?: true
    permission?: true
    _all?: true
  }

  export type InventoryUserAggregateArgs = {
    /**
     * Filter which InventoryUser to aggregate.
     * 
    **/
    where?: InventoryUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<InventoryUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: InventoryUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryUsers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryUsers
    **/
    _count?: true | InventoryUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryUserMaxAggregateInputType
  }

  export type GetInventoryUserAggregateType<T extends InventoryUserAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryUser[P]>
      : GetScalarType<T[P], AggregateInventoryUser[P]>
  }




  export type InventoryUserGroupByArgs = {
    where?: InventoryUserWhereInput
    orderBy?: Enumerable<InventoryUserOrderByWithAggregationInput>
    by: Array<InventoryUserScalarFieldEnum>
    having?: InventoryUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryUserCountAggregateInputType | true
    _avg?: InventoryUserAvgAggregateInputType
    _sum?: InventoryUserSumAggregateInputType
    _min?: InventoryUserMinAggregateInputType
    _max?: InventoryUserMaxAggregateInputType
  }


  export type InventoryUserGroupByOutputType = {
    userId: string
    inventoryId: number
    permission: string
    _count: InventoryUserCountAggregateOutputType | null
    _avg: InventoryUserAvgAggregateOutputType | null
    _sum: InventoryUserSumAggregateOutputType | null
    _min: InventoryUserMinAggregateOutputType | null
    _max: InventoryUserMaxAggregateOutputType | null
  }

  type GetInventoryUserGroupByPayload<T extends InventoryUserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InventoryUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryUserGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryUserGroupByOutputType[P]>
        }
      >
    >


  export type InventoryUserSelect = {
    userId?: boolean
    inventoryId?: boolean
    user?: boolean | UserArgs
    inventory?: boolean | InventoryArgs
    permission?: boolean
  }

  export type InventoryUserInclude = {
    user?: boolean | UserArgs
    inventory?: boolean | InventoryArgs
  }

  export type InventoryUserGetPayload<
    S extends boolean | null | undefined | InventoryUserArgs,
    U = keyof S
      > = S extends true
        ? InventoryUser
    : S extends undefined
    ? never
    : S extends InventoryUserArgs | InventoryUserFindManyArgs
    ?'include' extends U
    ? InventoryUser  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'inventory' ? InventoryGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'inventory' ? InventoryGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof InventoryUser ? InventoryUser[P] : never
  } 
    : InventoryUser
  : InventoryUser


  type InventoryUserCountArgs = Merge<
    Omit<InventoryUserFindManyArgs, 'select' | 'include'> & {
      select?: InventoryUserCountAggregateInputType | true
    }
  >

  export interface InventoryUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one InventoryUser that matches the filter.
     * @param {InventoryUserFindUniqueArgs} args - Arguments to find a InventoryUser
     * @example
     * // Get one InventoryUser
     * const inventoryUser = await prisma.inventoryUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InventoryUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InventoryUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'InventoryUser'> extends True ? CheckSelect<T, Prisma__InventoryUserClient<InventoryUser>, Prisma__InventoryUserClient<InventoryUserGetPayload<T>>> : CheckSelect<T, Prisma__InventoryUserClient<InventoryUser | null >, Prisma__InventoryUserClient<InventoryUserGetPayload<T> | null >>

    /**
     * Find the first InventoryUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUserFindFirstArgs} args - Arguments to find a InventoryUser
     * @example
     * // Get one InventoryUser
     * const inventoryUser = await prisma.inventoryUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InventoryUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InventoryUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'InventoryUser'> extends True ? CheckSelect<T, Prisma__InventoryUserClient<InventoryUser>, Prisma__InventoryUserClient<InventoryUserGetPayload<T>>> : CheckSelect<T, Prisma__InventoryUserClient<InventoryUser | null >, Prisma__InventoryUserClient<InventoryUserGetPayload<T> | null >>

    /**
     * Find zero or more InventoryUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryUsers
     * const inventoryUsers = await prisma.inventoryUser.findMany()
     * 
     * // Get first 10 InventoryUsers
     * const inventoryUsers = await prisma.inventoryUser.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const inventoryUserWithUserIdOnly = await prisma.inventoryUser.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends InventoryUserFindManyArgs>(
      args?: SelectSubset<T, InventoryUserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<InventoryUser>>, PrismaPromise<Array<InventoryUserGetPayload<T>>>>

    /**
     * Create a InventoryUser.
     * @param {InventoryUserCreateArgs} args - Arguments to create a InventoryUser.
     * @example
     * // Create one InventoryUser
     * const InventoryUser = await prisma.inventoryUser.create({
     *   data: {
     *     // ... data to create a InventoryUser
     *   }
     * })
     * 
    **/
    create<T extends InventoryUserCreateArgs>(
      args: SelectSubset<T, InventoryUserCreateArgs>
    ): CheckSelect<T, Prisma__InventoryUserClient<InventoryUser>, Prisma__InventoryUserClient<InventoryUserGetPayload<T>>>

    /**
     * Create many InventoryUsers.
     *     @param {InventoryUserCreateManyArgs} args - Arguments to create many InventoryUsers.
     *     @example
     *     // Create many InventoryUsers
     *     const inventoryUser = await prisma.inventoryUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InventoryUserCreateManyArgs>(
      args?: SelectSubset<T, InventoryUserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a InventoryUser.
     * @param {InventoryUserDeleteArgs} args - Arguments to delete one InventoryUser.
     * @example
     * // Delete one InventoryUser
     * const InventoryUser = await prisma.inventoryUser.delete({
     *   where: {
     *     // ... filter to delete one InventoryUser
     *   }
     * })
     * 
    **/
    delete<T extends InventoryUserDeleteArgs>(
      args: SelectSubset<T, InventoryUserDeleteArgs>
    ): CheckSelect<T, Prisma__InventoryUserClient<InventoryUser>, Prisma__InventoryUserClient<InventoryUserGetPayload<T>>>

    /**
     * Update one InventoryUser.
     * @param {InventoryUserUpdateArgs} args - Arguments to update one InventoryUser.
     * @example
     * // Update one InventoryUser
     * const inventoryUser = await prisma.inventoryUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InventoryUserUpdateArgs>(
      args: SelectSubset<T, InventoryUserUpdateArgs>
    ): CheckSelect<T, Prisma__InventoryUserClient<InventoryUser>, Prisma__InventoryUserClient<InventoryUserGetPayload<T>>>

    /**
     * Delete zero or more InventoryUsers.
     * @param {InventoryUserDeleteManyArgs} args - Arguments to filter InventoryUsers to delete.
     * @example
     * // Delete a few InventoryUsers
     * const { count } = await prisma.inventoryUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InventoryUserDeleteManyArgs>(
      args?: SelectSubset<T, InventoryUserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryUsers
     * const inventoryUser = await prisma.inventoryUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InventoryUserUpdateManyArgs>(
      args: SelectSubset<T, InventoryUserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one InventoryUser.
     * @param {InventoryUserUpsertArgs} args - Arguments to update or create a InventoryUser.
     * @example
     * // Update or create a InventoryUser
     * const inventoryUser = await prisma.inventoryUser.upsert({
     *   create: {
     *     // ... data to create a InventoryUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryUser we want to update
     *   }
     * })
    **/
    upsert<T extends InventoryUserUpsertArgs>(
      args: SelectSubset<T, InventoryUserUpsertArgs>
    ): CheckSelect<T, Prisma__InventoryUserClient<InventoryUser>, Prisma__InventoryUserClient<InventoryUserGetPayload<T>>>

    /**
     * Find one InventoryUser that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {InventoryUserFindUniqueOrThrowArgs} args - Arguments to find a InventoryUser
     * @example
     * // Get one InventoryUser
     * const inventoryUser = await prisma.inventoryUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InventoryUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, InventoryUserFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__InventoryUserClient<InventoryUser>, Prisma__InventoryUserClient<InventoryUserGetPayload<T>>>

    /**
     * Find the first InventoryUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUserFindFirstOrThrowArgs} args - Arguments to find a InventoryUser
     * @example
     * // Get one InventoryUser
     * const inventoryUser = await prisma.inventoryUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InventoryUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, InventoryUserFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__InventoryUserClient<InventoryUser>, Prisma__InventoryUserClient<InventoryUserGetPayload<T>>>

    /**
     * Count the number of InventoryUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUserCountArgs} args - Arguments to filter InventoryUsers to count.
     * @example
     * // Count the number of InventoryUsers
     * const count = await prisma.inventoryUser.count({
     *   where: {
     *     // ... the filter for the InventoryUsers we want to count
     *   }
     * })
    **/
    count<T extends InventoryUserCountArgs>(
      args?: Subset<T, InventoryUserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryUserAggregateArgs>(args: Subset<T, InventoryUserAggregateArgs>): PrismaPromise<GetInventoryUserAggregateType<T>>

    /**
     * Group by InventoryUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryUserGroupByArgs['orderBy'] }
        : { orderBy?: InventoryUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryUserGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InventoryUserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    inventory<T extends InventoryArgs = {}>(args?: Subset<T, InventoryArgs>): CheckSelect<T, Prisma__InventoryClient<Inventory | null >, Prisma__InventoryClient<InventoryGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * InventoryUser base type for findUnique actions
   */
  export type InventoryUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the InventoryUser
     * 
    **/
    select?: InventoryUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryUserInclude | null
    /**
     * Filter, which InventoryUser to fetch.
     * 
    **/
    where: InventoryUserWhereUniqueInput
  }

  /**
   * InventoryUser: findUnique
   */
  export interface InventoryUserFindUniqueArgs extends InventoryUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * InventoryUser base type for findFirst actions
   */
  export type InventoryUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the InventoryUser
     * 
    **/
    select?: InventoryUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryUserInclude | null
    /**
     * Filter, which InventoryUser to fetch.
     * 
    **/
    where?: InventoryUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<InventoryUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryUsers.
     * 
    **/
    cursor?: InventoryUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryUsers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryUsers.
     * 
    **/
    distinct?: Enumerable<InventoryUserScalarFieldEnum>
  }

  /**
   * InventoryUser: findFirst
   */
  export interface InventoryUserFindFirstArgs extends InventoryUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * InventoryUser findMany
   */
  export type InventoryUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the InventoryUser
     * 
    **/
    select?: InventoryUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryUserInclude | null
    /**
     * Filter, which InventoryUsers to fetch.
     * 
    **/
    where?: InventoryUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<InventoryUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryUsers.
     * 
    **/
    cursor?: InventoryUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryUsers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InventoryUserScalarFieldEnum>
  }


  /**
   * InventoryUser create
   */
  export type InventoryUserCreateArgs = {
    /**
     * Select specific fields to fetch from the InventoryUser
     * 
    **/
    select?: InventoryUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryUserInclude | null
    /**
     * The data needed to create a InventoryUser.
     * 
    **/
    data: XOR<InventoryUserCreateInput, InventoryUserUncheckedCreateInput>
  }


  /**
   * InventoryUser createMany
   */
  export type InventoryUserCreateManyArgs = {
    /**
     * The data used to create many InventoryUsers.
     * 
    **/
    data: Enumerable<InventoryUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * InventoryUser update
   */
  export type InventoryUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the InventoryUser
     * 
    **/
    select?: InventoryUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryUserInclude | null
    /**
     * The data needed to update a InventoryUser.
     * 
    **/
    data: XOR<InventoryUserUpdateInput, InventoryUserUncheckedUpdateInput>
    /**
     * Choose, which InventoryUser to update.
     * 
    **/
    where: InventoryUserWhereUniqueInput
  }


  /**
   * InventoryUser updateMany
   */
  export type InventoryUserUpdateManyArgs = {
    /**
     * The data used to update InventoryUsers.
     * 
    **/
    data: XOR<InventoryUserUpdateManyMutationInput, InventoryUserUncheckedUpdateManyInput>
    /**
     * Filter which InventoryUsers to update
     * 
    **/
    where?: InventoryUserWhereInput
  }


  /**
   * InventoryUser upsert
   */
  export type InventoryUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the InventoryUser
     * 
    **/
    select?: InventoryUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryUserInclude | null
    /**
     * The filter to search for the InventoryUser to update in case it exists.
     * 
    **/
    where: InventoryUserWhereUniqueInput
    /**
     * In case the InventoryUser found by the `where` argument doesn't exist, create a new InventoryUser with this data.
     * 
    **/
    create: XOR<InventoryUserCreateInput, InventoryUserUncheckedCreateInput>
    /**
     * In case the InventoryUser was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<InventoryUserUpdateInput, InventoryUserUncheckedUpdateInput>
  }


  /**
   * InventoryUser delete
   */
  export type InventoryUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the InventoryUser
     * 
    **/
    select?: InventoryUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryUserInclude | null
    /**
     * Filter which InventoryUser to delete.
     * 
    **/
    where: InventoryUserWhereUniqueInput
  }


  /**
   * InventoryUser deleteMany
   */
  export type InventoryUserDeleteManyArgs = {
    /**
     * Filter which InventoryUsers to delete
     * 
    **/
    where?: InventoryUserWhereInput
  }


  /**
   * InventoryUser: findUniqueOrThrow
   */
  export type InventoryUserFindUniqueOrThrowArgs = InventoryUserFindUniqueArgsBase
      

  /**
   * InventoryUser: findFirstOrThrow
   */
  export type InventoryUserFindFirstOrThrowArgs = InventoryUserFindFirstArgsBase
      

  /**
   * InventoryUser without action
   */
  export type InventoryUserArgs = {
    /**
     * Select specific fields to fetch from the InventoryUser
     * 
    **/
    select?: InventoryUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryUserInclude | null
  }



  /**
   * Model Storage
   */


  export type AggregateStorage = {
    _count: StorageCountAggregateOutputType | null
    _avg: StorageAvgAggregateOutputType | null
    _sum: StorageSumAggregateOutputType | null
    _min: StorageMinAggregateOutputType | null
    _max: StorageMaxAggregateOutputType | null
  }

  export type StorageAvgAggregateOutputType = {
    id: number | null
  }

  export type StorageSumAggregateOutputType = {
    id: number | null
  }

  export type StorageMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
  }

  export type StorageMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
  }

  export type StorageCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    editedAt: number
    createdById: number
    editedById: number
    _all: number
  }


  export type StorageAvgAggregateInputType = {
    id?: true
  }

  export type StorageSumAggregateInputType = {
    id?: true
  }

  export type StorageMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
  }

  export type StorageMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
  }

  export type StorageCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
    _all?: true
  }

  export type StorageAggregateArgs = {
    /**
     * Filter which Storage to aggregate.
     * 
    **/
    where?: StorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Storages to fetch.
     * 
    **/
    orderBy?: Enumerable<StorageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: StorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Storages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Storages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Storages
    **/
    _count?: true | StorageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StorageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StorageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StorageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StorageMaxAggregateInputType
  }

  export type GetStorageAggregateType<T extends StorageAggregateArgs> = {
        [P in keyof T & keyof AggregateStorage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStorage[P]>
      : GetScalarType<T[P], AggregateStorage[P]>
  }




  export type StorageGroupByArgs = {
    where?: StorageWhereInput
    orderBy?: Enumerable<StorageOrderByWithAggregationInput>
    by: Array<StorageScalarFieldEnum>
    having?: StorageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StorageCountAggregateInputType | true
    _avg?: StorageAvgAggregateInputType
    _sum?: StorageSumAggregateInputType
    _min?: StorageMinAggregateInputType
    _max?: StorageMaxAggregateInputType
  }


  export type StorageGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    editedAt: Date
    createdById: string
    editedById: string
    _count: StorageCountAggregateOutputType | null
    _avg: StorageAvgAggregateOutputType | null
    _sum: StorageSumAggregateOutputType | null
    _min: StorageMinAggregateOutputType | null
    _max: StorageMaxAggregateOutputType | null
  }

  type GetStorageGroupByPayload<T extends StorageGroupByArgs> = PrismaPromise<
    Array<
      PickArray<StorageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StorageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StorageGroupByOutputType[P]>
            : GetScalarType<T[P], StorageGroupByOutputType[P]>
        }
      >
    >


  export type StorageSelect = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    editedAt?: boolean
    createdById?: boolean
    editedById?: boolean
    createdBy?: boolean | UserArgs
    editedBy?: boolean | UserArgs
    inventoryStorage?: boolean | InventoryStorageFindManyArgs
    ingredientStorage?: boolean | IngredientStorageFindManyArgs
    storageUser?: boolean | StorageUserFindManyArgs
    _count?: boolean | StorageCountOutputTypeArgs
  }

  export type StorageInclude = {
    createdBy?: boolean | UserArgs
    editedBy?: boolean | UserArgs
    inventoryStorage?: boolean | InventoryStorageFindManyArgs
    ingredientStorage?: boolean | IngredientStorageFindManyArgs
    storageUser?: boolean | StorageUserFindManyArgs
    _count?: boolean | StorageCountOutputTypeArgs
  }

  export type StorageGetPayload<
    S extends boolean | null | undefined | StorageArgs,
    U = keyof S
      > = S extends true
        ? Storage
    : S extends undefined
    ? never
    : S extends StorageArgs | StorageFindManyArgs
    ?'include' extends U
    ? Storage  & {
    [P in TrueKeys<S['include']>]:
        P extends 'createdBy' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'editedBy' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'inventoryStorage' ? Array < InventoryStorageGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'ingredientStorage' ? Array < IngredientStorageGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'storageUser' ? Array < StorageUserGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? StorageCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'createdBy' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'editedBy' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'inventoryStorage' ? Array < InventoryStorageGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'ingredientStorage' ? Array < IngredientStorageGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'storageUser' ? Array < StorageUserGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? StorageCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Storage ? Storage[P] : never
  } 
    : Storage
  : Storage


  type StorageCountArgs = Merge<
    Omit<StorageFindManyArgs, 'select' | 'include'> & {
      select?: StorageCountAggregateInputType | true
    }
  >

  export interface StorageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Storage that matches the filter.
     * @param {StorageFindUniqueArgs} args - Arguments to find a Storage
     * @example
     * // Get one Storage
     * const storage = await prisma.storage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StorageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StorageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Storage'> extends True ? CheckSelect<T, Prisma__StorageClient<Storage>, Prisma__StorageClient<StorageGetPayload<T>>> : CheckSelect<T, Prisma__StorageClient<Storage | null >, Prisma__StorageClient<StorageGetPayload<T> | null >>

    /**
     * Find the first Storage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageFindFirstArgs} args - Arguments to find a Storage
     * @example
     * // Get one Storage
     * const storage = await prisma.storage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StorageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StorageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Storage'> extends True ? CheckSelect<T, Prisma__StorageClient<Storage>, Prisma__StorageClient<StorageGetPayload<T>>> : CheckSelect<T, Prisma__StorageClient<Storage | null >, Prisma__StorageClient<StorageGetPayload<T> | null >>

    /**
     * Find zero or more Storages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Storages
     * const storages = await prisma.storage.findMany()
     * 
     * // Get first 10 Storages
     * const storages = await prisma.storage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storageWithIdOnly = await prisma.storage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StorageFindManyArgs>(
      args?: SelectSubset<T, StorageFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Storage>>, PrismaPromise<Array<StorageGetPayload<T>>>>

    /**
     * Create a Storage.
     * @param {StorageCreateArgs} args - Arguments to create a Storage.
     * @example
     * // Create one Storage
     * const Storage = await prisma.storage.create({
     *   data: {
     *     // ... data to create a Storage
     *   }
     * })
     * 
    **/
    create<T extends StorageCreateArgs>(
      args: SelectSubset<T, StorageCreateArgs>
    ): CheckSelect<T, Prisma__StorageClient<Storage>, Prisma__StorageClient<StorageGetPayload<T>>>

    /**
     * Create many Storages.
     *     @param {StorageCreateManyArgs} args - Arguments to create many Storages.
     *     @example
     *     // Create many Storages
     *     const storage = await prisma.storage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StorageCreateManyArgs>(
      args?: SelectSubset<T, StorageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Storage.
     * @param {StorageDeleteArgs} args - Arguments to delete one Storage.
     * @example
     * // Delete one Storage
     * const Storage = await prisma.storage.delete({
     *   where: {
     *     // ... filter to delete one Storage
     *   }
     * })
     * 
    **/
    delete<T extends StorageDeleteArgs>(
      args: SelectSubset<T, StorageDeleteArgs>
    ): CheckSelect<T, Prisma__StorageClient<Storage>, Prisma__StorageClient<StorageGetPayload<T>>>

    /**
     * Update one Storage.
     * @param {StorageUpdateArgs} args - Arguments to update one Storage.
     * @example
     * // Update one Storage
     * const storage = await prisma.storage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StorageUpdateArgs>(
      args: SelectSubset<T, StorageUpdateArgs>
    ): CheckSelect<T, Prisma__StorageClient<Storage>, Prisma__StorageClient<StorageGetPayload<T>>>

    /**
     * Delete zero or more Storages.
     * @param {StorageDeleteManyArgs} args - Arguments to filter Storages to delete.
     * @example
     * // Delete a few Storages
     * const { count } = await prisma.storage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StorageDeleteManyArgs>(
      args?: SelectSubset<T, StorageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Storages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Storages
     * const storage = await prisma.storage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StorageUpdateManyArgs>(
      args: SelectSubset<T, StorageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Storage.
     * @param {StorageUpsertArgs} args - Arguments to update or create a Storage.
     * @example
     * // Update or create a Storage
     * const storage = await prisma.storage.upsert({
     *   create: {
     *     // ... data to create a Storage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Storage we want to update
     *   }
     * })
    **/
    upsert<T extends StorageUpsertArgs>(
      args: SelectSubset<T, StorageUpsertArgs>
    ): CheckSelect<T, Prisma__StorageClient<Storage>, Prisma__StorageClient<StorageGetPayload<T>>>

    /**
     * Find one Storage that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {StorageFindUniqueOrThrowArgs} args - Arguments to find a Storage
     * @example
     * // Get one Storage
     * const storage = await prisma.storage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StorageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, StorageFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__StorageClient<Storage>, Prisma__StorageClient<StorageGetPayload<T>>>

    /**
     * Find the first Storage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageFindFirstOrThrowArgs} args - Arguments to find a Storage
     * @example
     * // Get one Storage
     * const storage = await prisma.storage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StorageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, StorageFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__StorageClient<Storage>, Prisma__StorageClient<StorageGetPayload<T>>>

    /**
     * Count the number of Storages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageCountArgs} args - Arguments to filter Storages to count.
     * @example
     * // Count the number of Storages
     * const count = await prisma.storage.count({
     *   where: {
     *     // ... the filter for the Storages we want to count
     *   }
     * })
    **/
    count<T extends StorageCountArgs>(
      args?: Subset<T, StorageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StorageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Storage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StorageAggregateArgs>(args: Subset<T, StorageAggregateArgs>): PrismaPromise<GetStorageAggregateType<T>>

    /**
     * Group by Storage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StorageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StorageGroupByArgs['orderBy'] }
        : { orderBy?: StorageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StorageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStorageGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Storage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StorageClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    createdBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    editedBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    inventoryStorage<T extends InventoryStorageFindManyArgs = {}>(args?: Subset<T, InventoryStorageFindManyArgs>): CheckSelect<T, PrismaPromise<Array<InventoryStorage>>, PrismaPromise<Array<InventoryStorageGetPayload<T>>>>;

    ingredientStorage<T extends IngredientStorageFindManyArgs = {}>(args?: Subset<T, IngredientStorageFindManyArgs>): CheckSelect<T, PrismaPromise<Array<IngredientStorage>>, PrismaPromise<Array<IngredientStorageGetPayload<T>>>>;

    storageUser<T extends StorageUserFindManyArgs = {}>(args?: Subset<T, StorageUserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<StorageUser>>, PrismaPromise<Array<StorageUserGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Storage base type for findUnique actions
   */
  export type StorageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Storage
     * 
    **/
    select?: StorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StorageInclude | null
    /**
     * Filter, which Storage to fetch.
     * 
    **/
    where: StorageWhereUniqueInput
  }

  /**
   * Storage: findUnique
   */
  export interface StorageFindUniqueArgs extends StorageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Storage base type for findFirst actions
   */
  export type StorageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Storage
     * 
    **/
    select?: StorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StorageInclude | null
    /**
     * Filter, which Storage to fetch.
     * 
    **/
    where?: StorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Storages to fetch.
     * 
    **/
    orderBy?: Enumerable<StorageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Storages.
     * 
    **/
    cursor?: StorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Storages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Storages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Storages.
     * 
    **/
    distinct?: Enumerable<StorageScalarFieldEnum>
  }

  /**
   * Storage: findFirst
   */
  export interface StorageFindFirstArgs extends StorageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Storage findMany
   */
  export type StorageFindManyArgs = {
    /**
     * Select specific fields to fetch from the Storage
     * 
    **/
    select?: StorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StorageInclude | null
    /**
     * Filter, which Storages to fetch.
     * 
    **/
    where?: StorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Storages to fetch.
     * 
    **/
    orderBy?: Enumerable<StorageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Storages.
     * 
    **/
    cursor?: StorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Storages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Storages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StorageScalarFieldEnum>
  }


  /**
   * Storage create
   */
  export type StorageCreateArgs = {
    /**
     * Select specific fields to fetch from the Storage
     * 
    **/
    select?: StorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StorageInclude | null
    /**
     * The data needed to create a Storage.
     * 
    **/
    data: XOR<StorageCreateInput, StorageUncheckedCreateInput>
  }


  /**
   * Storage createMany
   */
  export type StorageCreateManyArgs = {
    /**
     * The data used to create many Storages.
     * 
    **/
    data: Enumerable<StorageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Storage update
   */
  export type StorageUpdateArgs = {
    /**
     * Select specific fields to fetch from the Storage
     * 
    **/
    select?: StorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StorageInclude | null
    /**
     * The data needed to update a Storage.
     * 
    **/
    data: XOR<StorageUpdateInput, StorageUncheckedUpdateInput>
    /**
     * Choose, which Storage to update.
     * 
    **/
    where: StorageWhereUniqueInput
  }


  /**
   * Storage updateMany
   */
  export type StorageUpdateManyArgs = {
    /**
     * The data used to update Storages.
     * 
    **/
    data: XOR<StorageUpdateManyMutationInput, StorageUncheckedUpdateManyInput>
    /**
     * Filter which Storages to update
     * 
    **/
    where?: StorageWhereInput
  }


  /**
   * Storage upsert
   */
  export type StorageUpsertArgs = {
    /**
     * Select specific fields to fetch from the Storage
     * 
    **/
    select?: StorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StorageInclude | null
    /**
     * The filter to search for the Storage to update in case it exists.
     * 
    **/
    where: StorageWhereUniqueInput
    /**
     * In case the Storage found by the `where` argument doesn't exist, create a new Storage with this data.
     * 
    **/
    create: XOR<StorageCreateInput, StorageUncheckedCreateInput>
    /**
     * In case the Storage was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<StorageUpdateInput, StorageUncheckedUpdateInput>
  }


  /**
   * Storage delete
   */
  export type StorageDeleteArgs = {
    /**
     * Select specific fields to fetch from the Storage
     * 
    **/
    select?: StorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StorageInclude | null
    /**
     * Filter which Storage to delete.
     * 
    **/
    where: StorageWhereUniqueInput
  }


  /**
   * Storage deleteMany
   */
  export type StorageDeleteManyArgs = {
    /**
     * Filter which Storages to delete
     * 
    **/
    where?: StorageWhereInput
  }


  /**
   * Storage: findUniqueOrThrow
   */
  export type StorageFindUniqueOrThrowArgs = StorageFindUniqueArgsBase
      

  /**
   * Storage: findFirstOrThrow
   */
  export type StorageFindFirstOrThrowArgs = StorageFindFirstArgsBase
      

  /**
   * Storage without action
   */
  export type StorageArgs = {
    /**
     * Select specific fields to fetch from the Storage
     * 
    **/
    select?: StorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StorageInclude | null
  }



  /**
   * Model InventoryStorage
   */


  export type AggregateInventoryStorage = {
    _count: InventoryStorageCountAggregateOutputType | null
    _avg: InventoryStorageAvgAggregateOutputType | null
    _sum: InventoryStorageSumAggregateOutputType | null
    _min: InventoryStorageMinAggregateOutputType | null
    _max: InventoryStorageMaxAggregateOutputType | null
  }

  export type InventoryStorageAvgAggregateOutputType = {
    inventoryId: number | null
    storageId: number | null
  }

  export type InventoryStorageSumAggregateOutputType = {
    inventoryId: number | null
    storageId: number | null
  }

  export type InventoryStorageMinAggregateOutputType = {
    inventoryId: number | null
    storageId: number | null
  }

  export type InventoryStorageMaxAggregateOutputType = {
    inventoryId: number | null
    storageId: number | null
  }

  export type InventoryStorageCountAggregateOutputType = {
    inventoryId: number
    storageId: number
    _all: number
  }


  export type InventoryStorageAvgAggregateInputType = {
    inventoryId?: true
    storageId?: true
  }

  export type InventoryStorageSumAggregateInputType = {
    inventoryId?: true
    storageId?: true
  }

  export type InventoryStorageMinAggregateInputType = {
    inventoryId?: true
    storageId?: true
  }

  export type InventoryStorageMaxAggregateInputType = {
    inventoryId?: true
    storageId?: true
  }

  export type InventoryStorageCountAggregateInputType = {
    inventoryId?: true
    storageId?: true
    _all?: true
  }

  export type InventoryStorageAggregateArgs = {
    /**
     * Filter which InventoryStorage to aggregate.
     * 
    **/
    where?: InventoryStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryStorages to fetch.
     * 
    **/
    orderBy?: Enumerable<InventoryStorageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: InventoryStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryStorages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryStorages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryStorages
    **/
    _count?: true | InventoryStorageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryStorageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryStorageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryStorageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryStorageMaxAggregateInputType
  }

  export type GetInventoryStorageAggregateType<T extends InventoryStorageAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryStorage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryStorage[P]>
      : GetScalarType<T[P], AggregateInventoryStorage[P]>
  }




  export type InventoryStorageGroupByArgs = {
    where?: InventoryStorageWhereInput
    orderBy?: Enumerable<InventoryStorageOrderByWithAggregationInput>
    by: Array<InventoryStorageScalarFieldEnum>
    having?: InventoryStorageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryStorageCountAggregateInputType | true
    _avg?: InventoryStorageAvgAggregateInputType
    _sum?: InventoryStorageSumAggregateInputType
    _min?: InventoryStorageMinAggregateInputType
    _max?: InventoryStorageMaxAggregateInputType
  }


  export type InventoryStorageGroupByOutputType = {
    inventoryId: number
    storageId: number
    _count: InventoryStorageCountAggregateOutputType | null
    _avg: InventoryStorageAvgAggregateOutputType | null
    _sum: InventoryStorageSumAggregateOutputType | null
    _min: InventoryStorageMinAggregateOutputType | null
    _max: InventoryStorageMaxAggregateOutputType | null
  }

  type GetInventoryStorageGroupByPayload<T extends InventoryStorageGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InventoryStorageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryStorageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryStorageGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryStorageGroupByOutputType[P]>
        }
      >
    >


  export type InventoryStorageSelect = {
    inventoryId?: boolean
    storageId?: boolean
    storage?: boolean | StorageArgs
    inventory?: boolean | InventoryArgs
  }

  export type InventoryStorageInclude = {
    storage?: boolean | StorageArgs
    inventory?: boolean | InventoryArgs
  }

  export type InventoryStorageGetPayload<
    S extends boolean | null | undefined | InventoryStorageArgs,
    U = keyof S
      > = S extends true
        ? InventoryStorage
    : S extends undefined
    ? never
    : S extends InventoryStorageArgs | InventoryStorageFindManyArgs
    ?'include' extends U
    ? InventoryStorage  & {
    [P in TrueKeys<S['include']>]:
        P extends 'storage' ? StorageGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'inventory' ? InventoryGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'storage' ? StorageGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'inventory' ? InventoryGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof InventoryStorage ? InventoryStorage[P] : never
  } 
    : InventoryStorage
  : InventoryStorage


  type InventoryStorageCountArgs = Merge<
    Omit<InventoryStorageFindManyArgs, 'select' | 'include'> & {
      select?: InventoryStorageCountAggregateInputType | true
    }
  >

  export interface InventoryStorageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one InventoryStorage that matches the filter.
     * @param {InventoryStorageFindUniqueArgs} args - Arguments to find a InventoryStorage
     * @example
     * // Get one InventoryStorage
     * const inventoryStorage = await prisma.inventoryStorage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InventoryStorageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InventoryStorageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'InventoryStorage'> extends True ? CheckSelect<T, Prisma__InventoryStorageClient<InventoryStorage>, Prisma__InventoryStorageClient<InventoryStorageGetPayload<T>>> : CheckSelect<T, Prisma__InventoryStorageClient<InventoryStorage | null >, Prisma__InventoryStorageClient<InventoryStorageGetPayload<T> | null >>

    /**
     * Find the first InventoryStorage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryStorageFindFirstArgs} args - Arguments to find a InventoryStorage
     * @example
     * // Get one InventoryStorage
     * const inventoryStorage = await prisma.inventoryStorage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InventoryStorageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InventoryStorageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'InventoryStorage'> extends True ? CheckSelect<T, Prisma__InventoryStorageClient<InventoryStorage>, Prisma__InventoryStorageClient<InventoryStorageGetPayload<T>>> : CheckSelect<T, Prisma__InventoryStorageClient<InventoryStorage | null >, Prisma__InventoryStorageClient<InventoryStorageGetPayload<T> | null >>

    /**
     * Find zero or more InventoryStorages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryStorageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryStorages
     * const inventoryStorages = await prisma.inventoryStorage.findMany()
     * 
     * // Get first 10 InventoryStorages
     * const inventoryStorages = await prisma.inventoryStorage.findMany({ take: 10 })
     * 
     * // Only select the `inventoryId`
     * const inventoryStorageWithInventoryIdOnly = await prisma.inventoryStorage.findMany({ select: { inventoryId: true } })
     * 
    **/
    findMany<T extends InventoryStorageFindManyArgs>(
      args?: SelectSubset<T, InventoryStorageFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<InventoryStorage>>, PrismaPromise<Array<InventoryStorageGetPayload<T>>>>

    /**
     * Create a InventoryStorage.
     * @param {InventoryStorageCreateArgs} args - Arguments to create a InventoryStorage.
     * @example
     * // Create one InventoryStorage
     * const InventoryStorage = await prisma.inventoryStorage.create({
     *   data: {
     *     // ... data to create a InventoryStorage
     *   }
     * })
     * 
    **/
    create<T extends InventoryStorageCreateArgs>(
      args: SelectSubset<T, InventoryStorageCreateArgs>
    ): CheckSelect<T, Prisma__InventoryStorageClient<InventoryStorage>, Prisma__InventoryStorageClient<InventoryStorageGetPayload<T>>>

    /**
     * Create many InventoryStorages.
     *     @param {InventoryStorageCreateManyArgs} args - Arguments to create many InventoryStorages.
     *     @example
     *     // Create many InventoryStorages
     *     const inventoryStorage = await prisma.inventoryStorage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InventoryStorageCreateManyArgs>(
      args?: SelectSubset<T, InventoryStorageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a InventoryStorage.
     * @param {InventoryStorageDeleteArgs} args - Arguments to delete one InventoryStorage.
     * @example
     * // Delete one InventoryStorage
     * const InventoryStorage = await prisma.inventoryStorage.delete({
     *   where: {
     *     // ... filter to delete one InventoryStorage
     *   }
     * })
     * 
    **/
    delete<T extends InventoryStorageDeleteArgs>(
      args: SelectSubset<T, InventoryStorageDeleteArgs>
    ): CheckSelect<T, Prisma__InventoryStorageClient<InventoryStorage>, Prisma__InventoryStorageClient<InventoryStorageGetPayload<T>>>

    /**
     * Update one InventoryStorage.
     * @param {InventoryStorageUpdateArgs} args - Arguments to update one InventoryStorage.
     * @example
     * // Update one InventoryStorage
     * const inventoryStorage = await prisma.inventoryStorage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InventoryStorageUpdateArgs>(
      args: SelectSubset<T, InventoryStorageUpdateArgs>
    ): CheckSelect<T, Prisma__InventoryStorageClient<InventoryStorage>, Prisma__InventoryStorageClient<InventoryStorageGetPayload<T>>>

    /**
     * Delete zero or more InventoryStorages.
     * @param {InventoryStorageDeleteManyArgs} args - Arguments to filter InventoryStorages to delete.
     * @example
     * // Delete a few InventoryStorages
     * const { count } = await prisma.inventoryStorage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InventoryStorageDeleteManyArgs>(
      args?: SelectSubset<T, InventoryStorageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryStorages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryStorageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryStorages
     * const inventoryStorage = await prisma.inventoryStorage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InventoryStorageUpdateManyArgs>(
      args: SelectSubset<T, InventoryStorageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one InventoryStorage.
     * @param {InventoryStorageUpsertArgs} args - Arguments to update or create a InventoryStorage.
     * @example
     * // Update or create a InventoryStorage
     * const inventoryStorage = await prisma.inventoryStorage.upsert({
     *   create: {
     *     // ... data to create a InventoryStorage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryStorage we want to update
     *   }
     * })
    **/
    upsert<T extends InventoryStorageUpsertArgs>(
      args: SelectSubset<T, InventoryStorageUpsertArgs>
    ): CheckSelect<T, Prisma__InventoryStorageClient<InventoryStorage>, Prisma__InventoryStorageClient<InventoryStorageGetPayload<T>>>

    /**
     * Find one InventoryStorage that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {InventoryStorageFindUniqueOrThrowArgs} args - Arguments to find a InventoryStorage
     * @example
     * // Get one InventoryStorage
     * const inventoryStorage = await prisma.inventoryStorage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InventoryStorageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, InventoryStorageFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__InventoryStorageClient<InventoryStorage>, Prisma__InventoryStorageClient<InventoryStorageGetPayload<T>>>

    /**
     * Find the first InventoryStorage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryStorageFindFirstOrThrowArgs} args - Arguments to find a InventoryStorage
     * @example
     * // Get one InventoryStorage
     * const inventoryStorage = await prisma.inventoryStorage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InventoryStorageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, InventoryStorageFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__InventoryStorageClient<InventoryStorage>, Prisma__InventoryStorageClient<InventoryStorageGetPayload<T>>>

    /**
     * Count the number of InventoryStorages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryStorageCountArgs} args - Arguments to filter InventoryStorages to count.
     * @example
     * // Count the number of InventoryStorages
     * const count = await prisma.inventoryStorage.count({
     *   where: {
     *     // ... the filter for the InventoryStorages we want to count
     *   }
     * })
    **/
    count<T extends InventoryStorageCountArgs>(
      args?: Subset<T, InventoryStorageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryStorageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryStorage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryStorageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryStorageAggregateArgs>(args: Subset<T, InventoryStorageAggregateArgs>): PrismaPromise<GetInventoryStorageAggregateType<T>>

    /**
     * Group by InventoryStorage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryStorageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryStorageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryStorageGroupByArgs['orderBy'] }
        : { orderBy?: InventoryStorageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryStorageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryStorageGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryStorage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InventoryStorageClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    storage<T extends StorageArgs = {}>(args?: Subset<T, StorageArgs>): CheckSelect<T, Prisma__StorageClient<Storage | null >, Prisma__StorageClient<StorageGetPayload<T> | null >>;

    inventory<T extends InventoryArgs = {}>(args?: Subset<T, InventoryArgs>): CheckSelect<T, Prisma__InventoryClient<Inventory | null >, Prisma__InventoryClient<InventoryGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * InventoryStorage base type for findUnique actions
   */
  export type InventoryStorageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     * 
    **/
    select?: InventoryStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryStorageInclude | null
    /**
     * Filter, which InventoryStorage to fetch.
     * 
    **/
    where: InventoryStorageWhereUniqueInput
  }

  /**
   * InventoryStorage: findUnique
   */
  export interface InventoryStorageFindUniqueArgs extends InventoryStorageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * InventoryStorage base type for findFirst actions
   */
  export type InventoryStorageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     * 
    **/
    select?: InventoryStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryStorageInclude | null
    /**
     * Filter, which InventoryStorage to fetch.
     * 
    **/
    where?: InventoryStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryStorages to fetch.
     * 
    **/
    orderBy?: Enumerable<InventoryStorageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryStorages.
     * 
    **/
    cursor?: InventoryStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryStorages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryStorages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryStorages.
     * 
    **/
    distinct?: Enumerable<InventoryStorageScalarFieldEnum>
  }

  /**
   * InventoryStorage: findFirst
   */
  export interface InventoryStorageFindFirstArgs extends InventoryStorageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * InventoryStorage findMany
   */
  export type InventoryStorageFindManyArgs = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     * 
    **/
    select?: InventoryStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryStorageInclude | null
    /**
     * Filter, which InventoryStorages to fetch.
     * 
    **/
    where?: InventoryStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryStorages to fetch.
     * 
    **/
    orderBy?: Enumerable<InventoryStorageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryStorages.
     * 
    **/
    cursor?: InventoryStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryStorages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryStorages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InventoryStorageScalarFieldEnum>
  }


  /**
   * InventoryStorage create
   */
  export type InventoryStorageCreateArgs = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     * 
    **/
    select?: InventoryStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryStorageInclude | null
    /**
     * The data needed to create a InventoryStorage.
     * 
    **/
    data: XOR<InventoryStorageCreateInput, InventoryStorageUncheckedCreateInput>
  }


  /**
   * InventoryStorage createMany
   */
  export type InventoryStorageCreateManyArgs = {
    /**
     * The data used to create many InventoryStorages.
     * 
    **/
    data: Enumerable<InventoryStorageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * InventoryStorage update
   */
  export type InventoryStorageUpdateArgs = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     * 
    **/
    select?: InventoryStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryStorageInclude | null
    /**
     * The data needed to update a InventoryStorage.
     * 
    **/
    data: XOR<InventoryStorageUpdateInput, InventoryStorageUncheckedUpdateInput>
    /**
     * Choose, which InventoryStorage to update.
     * 
    **/
    where: InventoryStorageWhereUniqueInput
  }


  /**
   * InventoryStorage updateMany
   */
  export type InventoryStorageUpdateManyArgs = {
    /**
     * The data used to update InventoryStorages.
     * 
    **/
    data: XOR<InventoryStorageUpdateManyMutationInput, InventoryStorageUncheckedUpdateManyInput>
    /**
     * Filter which InventoryStorages to update
     * 
    **/
    where?: InventoryStorageWhereInput
  }


  /**
   * InventoryStorage upsert
   */
  export type InventoryStorageUpsertArgs = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     * 
    **/
    select?: InventoryStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryStorageInclude | null
    /**
     * The filter to search for the InventoryStorage to update in case it exists.
     * 
    **/
    where: InventoryStorageWhereUniqueInput
    /**
     * In case the InventoryStorage found by the `where` argument doesn't exist, create a new InventoryStorage with this data.
     * 
    **/
    create: XOR<InventoryStorageCreateInput, InventoryStorageUncheckedCreateInput>
    /**
     * In case the InventoryStorage was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<InventoryStorageUpdateInput, InventoryStorageUncheckedUpdateInput>
  }


  /**
   * InventoryStorage delete
   */
  export type InventoryStorageDeleteArgs = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     * 
    **/
    select?: InventoryStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryStorageInclude | null
    /**
     * Filter which InventoryStorage to delete.
     * 
    **/
    where: InventoryStorageWhereUniqueInput
  }


  /**
   * InventoryStorage deleteMany
   */
  export type InventoryStorageDeleteManyArgs = {
    /**
     * Filter which InventoryStorages to delete
     * 
    **/
    where?: InventoryStorageWhereInput
  }


  /**
   * InventoryStorage: findUniqueOrThrow
   */
  export type InventoryStorageFindUniqueOrThrowArgs = InventoryStorageFindUniqueArgsBase
      

  /**
   * InventoryStorage: findFirstOrThrow
   */
  export type InventoryStorageFindFirstOrThrowArgs = InventoryStorageFindFirstArgsBase
      

  /**
   * InventoryStorage without action
   */
  export type InventoryStorageArgs = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     * 
    **/
    select?: InventoryStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryStorageInclude | null
  }



  /**
   * Model IngredientStorage
   */


  export type AggregateIngredientStorage = {
    _count: IngredientStorageCountAggregateOutputType | null
    _avg: IngredientStorageAvgAggregateOutputType | null
    _sum: IngredientStorageSumAggregateOutputType | null
    _min: IngredientStorageMinAggregateOutputType | null
    _max: IngredientStorageMaxAggregateOutputType | null
  }

  export type IngredientStorageAvgAggregateOutputType = {
    ingredientId: number | null
    storageId: number | null
    quantity: number | null
  }

  export type IngredientStorageSumAggregateOutputType = {
    ingredientId: number | null
    storageId: number | null
    quantity: number | null
  }

  export type IngredientStorageMinAggregateOutputType = {
    ingredientId: number | null
    storageId: number | null
    quantity: number | null
  }

  export type IngredientStorageMaxAggregateOutputType = {
    ingredientId: number | null
    storageId: number | null
    quantity: number | null
  }

  export type IngredientStorageCountAggregateOutputType = {
    ingredientId: number
    storageId: number
    quantity: number
    _all: number
  }


  export type IngredientStorageAvgAggregateInputType = {
    ingredientId?: true
    storageId?: true
    quantity?: true
  }

  export type IngredientStorageSumAggregateInputType = {
    ingredientId?: true
    storageId?: true
    quantity?: true
  }

  export type IngredientStorageMinAggregateInputType = {
    ingredientId?: true
    storageId?: true
    quantity?: true
  }

  export type IngredientStorageMaxAggregateInputType = {
    ingredientId?: true
    storageId?: true
    quantity?: true
  }

  export type IngredientStorageCountAggregateInputType = {
    ingredientId?: true
    storageId?: true
    quantity?: true
    _all?: true
  }

  export type IngredientStorageAggregateArgs = {
    /**
     * Filter which IngredientStorage to aggregate.
     * 
    **/
    where?: IngredientStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientStorages to fetch.
     * 
    **/
    orderBy?: Enumerable<IngredientStorageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: IngredientStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientStorages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientStorages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IngredientStorages
    **/
    _count?: true | IngredientStorageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IngredientStorageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IngredientStorageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IngredientStorageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IngredientStorageMaxAggregateInputType
  }

  export type GetIngredientStorageAggregateType<T extends IngredientStorageAggregateArgs> = {
        [P in keyof T & keyof AggregateIngredientStorage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIngredientStorage[P]>
      : GetScalarType<T[P], AggregateIngredientStorage[P]>
  }




  export type IngredientStorageGroupByArgs = {
    where?: IngredientStorageWhereInput
    orderBy?: Enumerable<IngredientStorageOrderByWithAggregationInput>
    by: Array<IngredientStorageScalarFieldEnum>
    having?: IngredientStorageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IngredientStorageCountAggregateInputType | true
    _avg?: IngredientStorageAvgAggregateInputType
    _sum?: IngredientStorageSumAggregateInputType
    _min?: IngredientStorageMinAggregateInputType
    _max?: IngredientStorageMaxAggregateInputType
  }


  export type IngredientStorageGroupByOutputType = {
    ingredientId: number
    storageId: number
    quantity: number | null
    _count: IngredientStorageCountAggregateOutputType | null
    _avg: IngredientStorageAvgAggregateOutputType | null
    _sum: IngredientStorageSumAggregateOutputType | null
    _min: IngredientStorageMinAggregateOutputType | null
    _max: IngredientStorageMaxAggregateOutputType | null
  }

  type GetIngredientStorageGroupByPayload<T extends IngredientStorageGroupByArgs> = PrismaPromise<
    Array<
      PickArray<IngredientStorageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IngredientStorageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IngredientStorageGroupByOutputType[P]>
            : GetScalarType<T[P], IngredientStorageGroupByOutputType[P]>
        }
      >
    >


  export type IngredientStorageSelect = {
    ingredientId?: boolean
    ingredient?: boolean | SpecificIngredientArgs
    storageId?: boolean
    Storage?: boolean | StorageArgs
    quantity?: boolean
  }

  export type IngredientStorageInclude = {
    ingredient?: boolean | SpecificIngredientArgs
    Storage?: boolean | StorageArgs
  }

  export type IngredientStorageGetPayload<
    S extends boolean | null | undefined | IngredientStorageArgs,
    U = keyof S
      > = S extends true
        ? IngredientStorage
    : S extends undefined
    ? never
    : S extends IngredientStorageArgs | IngredientStorageFindManyArgs
    ?'include' extends U
    ? IngredientStorage  & {
    [P in TrueKeys<S['include']>]:
        P extends 'ingredient' ? SpecificIngredientGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'Storage' ? StorageGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'ingredient' ? SpecificIngredientGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'Storage' ? StorageGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof IngredientStorage ? IngredientStorage[P] : never
  } 
    : IngredientStorage
  : IngredientStorage


  type IngredientStorageCountArgs = Merge<
    Omit<IngredientStorageFindManyArgs, 'select' | 'include'> & {
      select?: IngredientStorageCountAggregateInputType | true
    }
  >

  export interface IngredientStorageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one IngredientStorage that matches the filter.
     * @param {IngredientStorageFindUniqueArgs} args - Arguments to find a IngredientStorage
     * @example
     * // Get one IngredientStorage
     * const ingredientStorage = await prisma.ingredientStorage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IngredientStorageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, IngredientStorageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'IngredientStorage'> extends True ? CheckSelect<T, Prisma__IngredientStorageClient<IngredientStorage>, Prisma__IngredientStorageClient<IngredientStorageGetPayload<T>>> : CheckSelect<T, Prisma__IngredientStorageClient<IngredientStorage | null >, Prisma__IngredientStorageClient<IngredientStorageGetPayload<T> | null >>

    /**
     * Find the first IngredientStorage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientStorageFindFirstArgs} args - Arguments to find a IngredientStorage
     * @example
     * // Get one IngredientStorage
     * const ingredientStorage = await prisma.ingredientStorage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IngredientStorageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, IngredientStorageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'IngredientStorage'> extends True ? CheckSelect<T, Prisma__IngredientStorageClient<IngredientStorage>, Prisma__IngredientStorageClient<IngredientStorageGetPayload<T>>> : CheckSelect<T, Prisma__IngredientStorageClient<IngredientStorage | null >, Prisma__IngredientStorageClient<IngredientStorageGetPayload<T> | null >>

    /**
     * Find zero or more IngredientStorages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientStorageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IngredientStorages
     * const ingredientStorages = await prisma.ingredientStorage.findMany()
     * 
     * // Get first 10 IngredientStorages
     * const ingredientStorages = await prisma.ingredientStorage.findMany({ take: 10 })
     * 
     * // Only select the `ingredientId`
     * const ingredientStorageWithIngredientIdOnly = await prisma.ingredientStorage.findMany({ select: { ingredientId: true } })
     * 
    **/
    findMany<T extends IngredientStorageFindManyArgs>(
      args?: SelectSubset<T, IngredientStorageFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<IngredientStorage>>, PrismaPromise<Array<IngredientStorageGetPayload<T>>>>

    /**
     * Create a IngredientStorage.
     * @param {IngredientStorageCreateArgs} args - Arguments to create a IngredientStorage.
     * @example
     * // Create one IngredientStorage
     * const IngredientStorage = await prisma.ingredientStorage.create({
     *   data: {
     *     // ... data to create a IngredientStorage
     *   }
     * })
     * 
    **/
    create<T extends IngredientStorageCreateArgs>(
      args: SelectSubset<T, IngredientStorageCreateArgs>
    ): CheckSelect<T, Prisma__IngredientStorageClient<IngredientStorage>, Prisma__IngredientStorageClient<IngredientStorageGetPayload<T>>>

    /**
     * Create many IngredientStorages.
     *     @param {IngredientStorageCreateManyArgs} args - Arguments to create many IngredientStorages.
     *     @example
     *     // Create many IngredientStorages
     *     const ingredientStorage = await prisma.ingredientStorage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IngredientStorageCreateManyArgs>(
      args?: SelectSubset<T, IngredientStorageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a IngredientStorage.
     * @param {IngredientStorageDeleteArgs} args - Arguments to delete one IngredientStorage.
     * @example
     * // Delete one IngredientStorage
     * const IngredientStorage = await prisma.ingredientStorage.delete({
     *   where: {
     *     // ... filter to delete one IngredientStorage
     *   }
     * })
     * 
    **/
    delete<T extends IngredientStorageDeleteArgs>(
      args: SelectSubset<T, IngredientStorageDeleteArgs>
    ): CheckSelect<T, Prisma__IngredientStorageClient<IngredientStorage>, Prisma__IngredientStorageClient<IngredientStorageGetPayload<T>>>

    /**
     * Update one IngredientStorage.
     * @param {IngredientStorageUpdateArgs} args - Arguments to update one IngredientStorage.
     * @example
     * // Update one IngredientStorage
     * const ingredientStorage = await prisma.ingredientStorage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IngredientStorageUpdateArgs>(
      args: SelectSubset<T, IngredientStorageUpdateArgs>
    ): CheckSelect<T, Prisma__IngredientStorageClient<IngredientStorage>, Prisma__IngredientStorageClient<IngredientStorageGetPayload<T>>>

    /**
     * Delete zero or more IngredientStorages.
     * @param {IngredientStorageDeleteManyArgs} args - Arguments to filter IngredientStorages to delete.
     * @example
     * // Delete a few IngredientStorages
     * const { count } = await prisma.ingredientStorage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IngredientStorageDeleteManyArgs>(
      args?: SelectSubset<T, IngredientStorageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more IngredientStorages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientStorageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IngredientStorages
     * const ingredientStorage = await prisma.ingredientStorage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IngredientStorageUpdateManyArgs>(
      args: SelectSubset<T, IngredientStorageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one IngredientStorage.
     * @param {IngredientStorageUpsertArgs} args - Arguments to update or create a IngredientStorage.
     * @example
     * // Update or create a IngredientStorage
     * const ingredientStorage = await prisma.ingredientStorage.upsert({
     *   create: {
     *     // ... data to create a IngredientStorage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IngredientStorage we want to update
     *   }
     * })
    **/
    upsert<T extends IngredientStorageUpsertArgs>(
      args: SelectSubset<T, IngredientStorageUpsertArgs>
    ): CheckSelect<T, Prisma__IngredientStorageClient<IngredientStorage>, Prisma__IngredientStorageClient<IngredientStorageGetPayload<T>>>

    /**
     * Find one IngredientStorage that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {IngredientStorageFindUniqueOrThrowArgs} args - Arguments to find a IngredientStorage
     * @example
     * // Get one IngredientStorage
     * const ingredientStorage = await prisma.ingredientStorage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends IngredientStorageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, IngredientStorageFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__IngredientStorageClient<IngredientStorage>, Prisma__IngredientStorageClient<IngredientStorageGetPayload<T>>>

    /**
     * Find the first IngredientStorage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientStorageFindFirstOrThrowArgs} args - Arguments to find a IngredientStorage
     * @example
     * // Get one IngredientStorage
     * const ingredientStorage = await prisma.ingredientStorage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends IngredientStorageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, IngredientStorageFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__IngredientStorageClient<IngredientStorage>, Prisma__IngredientStorageClient<IngredientStorageGetPayload<T>>>

    /**
     * Count the number of IngredientStorages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientStorageCountArgs} args - Arguments to filter IngredientStorages to count.
     * @example
     * // Count the number of IngredientStorages
     * const count = await prisma.ingredientStorage.count({
     *   where: {
     *     // ... the filter for the IngredientStorages we want to count
     *   }
     * })
    **/
    count<T extends IngredientStorageCountArgs>(
      args?: Subset<T, IngredientStorageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IngredientStorageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IngredientStorage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientStorageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IngredientStorageAggregateArgs>(args: Subset<T, IngredientStorageAggregateArgs>): PrismaPromise<GetIngredientStorageAggregateType<T>>

    /**
     * Group by IngredientStorage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientStorageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IngredientStorageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IngredientStorageGroupByArgs['orderBy'] }
        : { orderBy?: IngredientStorageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IngredientStorageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIngredientStorageGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for IngredientStorage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__IngredientStorageClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    ingredient<T extends SpecificIngredientArgs = {}>(args?: Subset<T, SpecificIngredientArgs>): CheckSelect<T, Prisma__SpecificIngredientClient<SpecificIngredient | null >, Prisma__SpecificIngredientClient<SpecificIngredientGetPayload<T> | null >>;

    Storage<T extends StorageArgs = {}>(args?: Subset<T, StorageArgs>): CheckSelect<T, Prisma__StorageClient<Storage | null >, Prisma__StorageClient<StorageGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * IngredientStorage base type for findUnique actions
   */
  export type IngredientStorageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the IngredientStorage
     * 
    **/
    select?: IngredientStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IngredientStorageInclude | null
    /**
     * Filter, which IngredientStorage to fetch.
     * 
    **/
    where: IngredientStorageWhereUniqueInput
  }

  /**
   * IngredientStorage: findUnique
   */
  export interface IngredientStorageFindUniqueArgs extends IngredientStorageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * IngredientStorage base type for findFirst actions
   */
  export type IngredientStorageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the IngredientStorage
     * 
    **/
    select?: IngredientStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IngredientStorageInclude | null
    /**
     * Filter, which IngredientStorage to fetch.
     * 
    **/
    where?: IngredientStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientStorages to fetch.
     * 
    **/
    orderBy?: Enumerable<IngredientStorageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IngredientStorages.
     * 
    **/
    cursor?: IngredientStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientStorages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientStorages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IngredientStorages.
     * 
    **/
    distinct?: Enumerable<IngredientStorageScalarFieldEnum>
  }

  /**
   * IngredientStorage: findFirst
   */
  export interface IngredientStorageFindFirstArgs extends IngredientStorageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * IngredientStorage findMany
   */
  export type IngredientStorageFindManyArgs = {
    /**
     * Select specific fields to fetch from the IngredientStorage
     * 
    **/
    select?: IngredientStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IngredientStorageInclude | null
    /**
     * Filter, which IngredientStorages to fetch.
     * 
    **/
    where?: IngredientStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientStorages to fetch.
     * 
    **/
    orderBy?: Enumerable<IngredientStorageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IngredientStorages.
     * 
    **/
    cursor?: IngredientStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientStorages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientStorages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<IngredientStorageScalarFieldEnum>
  }


  /**
   * IngredientStorage create
   */
  export type IngredientStorageCreateArgs = {
    /**
     * Select specific fields to fetch from the IngredientStorage
     * 
    **/
    select?: IngredientStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IngredientStorageInclude | null
    /**
     * The data needed to create a IngredientStorage.
     * 
    **/
    data: XOR<IngredientStorageCreateInput, IngredientStorageUncheckedCreateInput>
  }


  /**
   * IngredientStorage createMany
   */
  export type IngredientStorageCreateManyArgs = {
    /**
     * The data used to create many IngredientStorages.
     * 
    **/
    data: Enumerable<IngredientStorageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * IngredientStorage update
   */
  export type IngredientStorageUpdateArgs = {
    /**
     * Select specific fields to fetch from the IngredientStorage
     * 
    **/
    select?: IngredientStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IngredientStorageInclude | null
    /**
     * The data needed to update a IngredientStorage.
     * 
    **/
    data: XOR<IngredientStorageUpdateInput, IngredientStorageUncheckedUpdateInput>
    /**
     * Choose, which IngredientStorage to update.
     * 
    **/
    where: IngredientStorageWhereUniqueInput
  }


  /**
   * IngredientStorage updateMany
   */
  export type IngredientStorageUpdateManyArgs = {
    /**
     * The data used to update IngredientStorages.
     * 
    **/
    data: XOR<IngredientStorageUpdateManyMutationInput, IngredientStorageUncheckedUpdateManyInput>
    /**
     * Filter which IngredientStorages to update
     * 
    **/
    where?: IngredientStorageWhereInput
  }


  /**
   * IngredientStorage upsert
   */
  export type IngredientStorageUpsertArgs = {
    /**
     * Select specific fields to fetch from the IngredientStorage
     * 
    **/
    select?: IngredientStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IngredientStorageInclude | null
    /**
     * The filter to search for the IngredientStorage to update in case it exists.
     * 
    **/
    where: IngredientStorageWhereUniqueInput
    /**
     * In case the IngredientStorage found by the `where` argument doesn't exist, create a new IngredientStorage with this data.
     * 
    **/
    create: XOR<IngredientStorageCreateInput, IngredientStorageUncheckedCreateInput>
    /**
     * In case the IngredientStorage was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<IngredientStorageUpdateInput, IngredientStorageUncheckedUpdateInput>
  }


  /**
   * IngredientStorage delete
   */
  export type IngredientStorageDeleteArgs = {
    /**
     * Select specific fields to fetch from the IngredientStorage
     * 
    **/
    select?: IngredientStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IngredientStorageInclude | null
    /**
     * Filter which IngredientStorage to delete.
     * 
    **/
    where: IngredientStorageWhereUniqueInput
  }


  /**
   * IngredientStorage deleteMany
   */
  export type IngredientStorageDeleteManyArgs = {
    /**
     * Filter which IngredientStorages to delete
     * 
    **/
    where?: IngredientStorageWhereInput
  }


  /**
   * IngredientStorage: findUniqueOrThrow
   */
  export type IngredientStorageFindUniqueOrThrowArgs = IngredientStorageFindUniqueArgsBase
      

  /**
   * IngredientStorage: findFirstOrThrow
   */
  export type IngredientStorageFindFirstOrThrowArgs = IngredientStorageFindFirstArgsBase
      

  /**
   * IngredientStorage without action
   */
  export type IngredientStorageArgs = {
    /**
     * Select specific fields to fetch from the IngredientStorage
     * 
    **/
    select?: IngredientStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IngredientStorageInclude | null
  }



  /**
   * Model StorageUser
   */


  export type AggregateStorageUser = {
    _count: StorageUserCountAggregateOutputType | null
    _avg: StorageUserAvgAggregateOutputType | null
    _sum: StorageUserSumAggregateOutputType | null
    _min: StorageUserMinAggregateOutputType | null
    _max: StorageUserMaxAggregateOutputType | null
  }

  export type StorageUserAvgAggregateOutputType = {
    storageId: number | null
  }

  export type StorageUserSumAggregateOutputType = {
    storageId: number | null
  }

  export type StorageUserMinAggregateOutputType = {
    userId: string | null
    storageId: number | null
    permission: string | null
  }

  export type StorageUserMaxAggregateOutputType = {
    userId: string | null
    storageId: number | null
    permission: string | null
  }

  export type StorageUserCountAggregateOutputType = {
    userId: number
    storageId: number
    permission: number
    _all: number
  }


  export type StorageUserAvgAggregateInputType = {
    storageId?: true
  }

  export type StorageUserSumAggregateInputType = {
    storageId?: true
  }

  export type StorageUserMinAggregateInputType = {
    userId?: true
    storageId?: true
    permission?: true
  }

  export type StorageUserMaxAggregateInputType = {
    userId?: true
    storageId?: true
    permission?: true
  }

  export type StorageUserCountAggregateInputType = {
    userId?: true
    storageId?: true
    permission?: true
    _all?: true
  }

  export type StorageUserAggregateArgs = {
    /**
     * Filter which StorageUser to aggregate.
     * 
    **/
    where?: StorageUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<StorageUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: StorageUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageUsers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StorageUsers
    **/
    _count?: true | StorageUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StorageUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StorageUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StorageUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StorageUserMaxAggregateInputType
  }

  export type GetStorageUserAggregateType<T extends StorageUserAggregateArgs> = {
        [P in keyof T & keyof AggregateStorageUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStorageUser[P]>
      : GetScalarType<T[P], AggregateStorageUser[P]>
  }




  export type StorageUserGroupByArgs = {
    where?: StorageUserWhereInput
    orderBy?: Enumerable<StorageUserOrderByWithAggregationInput>
    by: Array<StorageUserScalarFieldEnum>
    having?: StorageUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StorageUserCountAggregateInputType | true
    _avg?: StorageUserAvgAggregateInputType
    _sum?: StorageUserSumAggregateInputType
    _min?: StorageUserMinAggregateInputType
    _max?: StorageUserMaxAggregateInputType
  }


  export type StorageUserGroupByOutputType = {
    userId: string
    storageId: number
    permission: string
    _count: StorageUserCountAggregateOutputType | null
    _avg: StorageUserAvgAggregateOutputType | null
    _sum: StorageUserSumAggregateOutputType | null
    _min: StorageUserMinAggregateOutputType | null
    _max: StorageUserMaxAggregateOutputType | null
  }

  type GetStorageUserGroupByPayload<T extends StorageUserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<StorageUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StorageUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StorageUserGroupByOutputType[P]>
            : GetScalarType<T[P], StorageUserGroupByOutputType[P]>
        }
      >
    >


  export type StorageUserSelect = {
    userId?: boolean
    user?: boolean | UserArgs
    storageId?: boolean
    Storage?: boolean | StorageArgs
    permission?: boolean
  }

  export type StorageUserInclude = {
    user?: boolean | UserArgs
    Storage?: boolean | StorageArgs
  }

  export type StorageUserGetPayload<
    S extends boolean | null | undefined | StorageUserArgs,
    U = keyof S
      > = S extends true
        ? StorageUser
    : S extends undefined
    ? never
    : S extends StorageUserArgs | StorageUserFindManyArgs
    ?'include' extends U
    ? StorageUser  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'Storage' ? StorageGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'Storage' ? StorageGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof StorageUser ? StorageUser[P] : never
  } 
    : StorageUser
  : StorageUser


  type StorageUserCountArgs = Merge<
    Omit<StorageUserFindManyArgs, 'select' | 'include'> & {
      select?: StorageUserCountAggregateInputType | true
    }
  >

  export interface StorageUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one StorageUser that matches the filter.
     * @param {StorageUserFindUniqueArgs} args - Arguments to find a StorageUser
     * @example
     * // Get one StorageUser
     * const storageUser = await prisma.storageUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StorageUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StorageUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'StorageUser'> extends True ? CheckSelect<T, Prisma__StorageUserClient<StorageUser>, Prisma__StorageUserClient<StorageUserGetPayload<T>>> : CheckSelect<T, Prisma__StorageUserClient<StorageUser | null >, Prisma__StorageUserClient<StorageUserGetPayload<T> | null >>

    /**
     * Find the first StorageUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageUserFindFirstArgs} args - Arguments to find a StorageUser
     * @example
     * // Get one StorageUser
     * const storageUser = await prisma.storageUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StorageUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StorageUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'StorageUser'> extends True ? CheckSelect<T, Prisma__StorageUserClient<StorageUser>, Prisma__StorageUserClient<StorageUserGetPayload<T>>> : CheckSelect<T, Prisma__StorageUserClient<StorageUser | null >, Prisma__StorageUserClient<StorageUserGetPayload<T> | null >>

    /**
     * Find zero or more StorageUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StorageUsers
     * const storageUsers = await prisma.storageUser.findMany()
     * 
     * // Get first 10 StorageUsers
     * const storageUsers = await prisma.storageUser.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const storageUserWithUserIdOnly = await prisma.storageUser.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends StorageUserFindManyArgs>(
      args?: SelectSubset<T, StorageUserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<StorageUser>>, PrismaPromise<Array<StorageUserGetPayload<T>>>>

    /**
     * Create a StorageUser.
     * @param {StorageUserCreateArgs} args - Arguments to create a StorageUser.
     * @example
     * // Create one StorageUser
     * const StorageUser = await prisma.storageUser.create({
     *   data: {
     *     // ... data to create a StorageUser
     *   }
     * })
     * 
    **/
    create<T extends StorageUserCreateArgs>(
      args: SelectSubset<T, StorageUserCreateArgs>
    ): CheckSelect<T, Prisma__StorageUserClient<StorageUser>, Prisma__StorageUserClient<StorageUserGetPayload<T>>>

    /**
     * Create many StorageUsers.
     *     @param {StorageUserCreateManyArgs} args - Arguments to create many StorageUsers.
     *     @example
     *     // Create many StorageUsers
     *     const storageUser = await prisma.storageUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StorageUserCreateManyArgs>(
      args?: SelectSubset<T, StorageUserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a StorageUser.
     * @param {StorageUserDeleteArgs} args - Arguments to delete one StorageUser.
     * @example
     * // Delete one StorageUser
     * const StorageUser = await prisma.storageUser.delete({
     *   where: {
     *     // ... filter to delete one StorageUser
     *   }
     * })
     * 
    **/
    delete<T extends StorageUserDeleteArgs>(
      args: SelectSubset<T, StorageUserDeleteArgs>
    ): CheckSelect<T, Prisma__StorageUserClient<StorageUser>, Prisma__StorageUserClient<StorageUserGetPayload<T>>>

    /**
     * Update one StorageUser.
     * @param {StorageUserUpdateArgs} args - Arguments to update one StorageUser.
     * @example
     * // Update one StorageUser
     * const storageUser = await prisma.storageUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StorageUserUpdateArgs>(
      args: SelectSubset<T, StorageUserUpdateArgs>
    ): CheckSelect<T, Prisma__StorageUserClient<StorageUser>, Prisma__StorageUserClient<StorageUserGetPayload<T>>>

    /**
     * Delete zero or more StorageUsers.
     * @param {StorageUserDeleteManyArgs} args - Arguments to filter StorageUsers to delete.
     * @example
     * // Delete a few StorageUsers
     * const { count } = await prisma.storageUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StorageUserDeleteManyArgs>(
      args?: SelectSubset<T, StorageUserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more StorageUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StorageUsers
     * const storageUser = await prisma.storageUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StorageUserUpdateManyArgs>(
      args: SelectSubset<T, StorageUserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one StorageUser.
     * @param {StorageUserUpsertArgs} args - Arguments to update or create a StorageUser.
     * @example
     * // Update or create a StorageUser
     * const storageUser = await prisma.storageUser.upsert({
     *   create: {
     *     // ... data to create a StorageUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StorageUser we want to update
     *   }
     * })
    **/
    upsert<T extends StorageUserUpsertArgs>(
      args: SelectSubset<T, StorageUserUpsertArgs>
    ): CheckSelect<T, Prisma__StorageUserClient<StorageUser>, Prisma__StorageUserClient<StorageUserGetPayload<T>>>

    /**
     * Find one StorageUser that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {StorageUserFindUniqueOrThrowArgs} args - Arguments to find a StorageUser
     * @example
     * // Get one StorageUser
     * const storageUser = await prisma.storageUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StorageUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, StorageUserFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__StorageUserClient<StorageUser>, Prisma__StorageUserClient<StorageUserGetPayload<T>>>

    /**
     * Find the first StorageUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageUserFindFirstOrThrowArgs} args - Arguments to find a StorageUser
     * @example
     * // Get one StorageUser
     * const storageUser = await prisma.storageUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StorageUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, StorageUserFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__StorageUserClient<StorageUser>, Prisma__StorageUserClient<StorageUserGetPayload<T>>>

    /**
     * Count the number of StorageUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageUserCountArgs} args - Arguments to filter StorageUsers to count.
     * @example
     * // Count the number of StorageUsers
     * const count = await prisma.storageUser.count({
     *   where: {
     *     // ... the filter for the StorageUsers we want to count
     *   }
     * })
    **/
    count<T extends StorageUserCountArgs>(
      args?: Subset<T, StorageUserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StorageUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StorageUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StorageUserAggregateArgs>(args: Subset<T, StorageUserAggregateArgs>): PrismaPromise<GetStorageUserAggregateType<T>>

    /**
     * Group by StorageUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StorageUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StorageUserGroupByArgs['orderBy'] }
        : { orderBy?: StorageUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StorageUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStorageUserGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for StorageUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StorageUserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    Storage<T extends StorageArgs = {}>(args?: Subset<T, StorageArgs>): CheckSelect<T, Prisma__StorageClient<Storage | null >, Prisma__StorageClient<StorageGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * StorageUser base type for findUnique actions
   */
  export type StorageUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the StorageUser
     * 
    **/
    select?: StorageUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StorageUserInclude | null
    /**
     * Filter, which StorageUser to fetch.
     * 
    **/
    where: StorageUserWhereUniqueInput
  }

  /**
   * StorageUser: findUnique
   */
  export interface StorageUserFindUniqueArgs extends StorageUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * StorageUser base type for findFirst actions
   */
  export type StorageUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the StorageUser
     * 
    **/
    select?: StorageUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StorageUserInclude | null
    /**
     * Filter, which StorageUser to fetch.
     * 
    **/
    where?: StorageUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<StorageUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StorageUsers.
     * 
    **/
    cursor?: StorageUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageUsers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StorageUsers.
     * 
    **/
    distinct?: Enumerable<StorageUserScalarFieldEnum>
  }

  /**
   * StorageUser: findFirst
   */
  export interface StorageUserFindFirstArgs extends StorageUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * StorageUser findMany
   */
  export type StorageUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the StorageUser
     * 
    **/
    select?: StorageUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StorageUserInclude | null
    /**
     * Filter, which StorageUsers to fetch.
     * 
    **/
    where?: StorageUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<StorageUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StorageUsers.
     * 
    **/
    cursor?: StorageUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageUsers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StorageUserScalarFieldEnum>
  }


  /**
   * StorageUser create
   */
  export type StorageUserCreateArgs = {
    /**
     * Select specific fields to fetch from the StorageUser
     * 
    **/
    select?: StorageUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StorageUserInclude | null
    /**
     * The data needed to create a StorageUser.
     * 
    **/
    data: XOR<StorageUserCreateInput, StorageUserUncheckedCreateInput>
  }


  /**
   * StorageUser createMany
   */
  export type StorageUserCreateManyArgs = {
    /**
     * The data used to create many StorageUsers.
     * 
    **/
    data: Enumerable<StorageUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * StorageUser update
   */
  export type StorageUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the StorageUser
     * 
    **/
    select?: StorageUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StorageUserInclude | null
    /**
     * The data needed to update a StorageUser.
     * 
    **/
    data: XOR<StorageUserUpdateInput, StorageUserUncheckedUpdateInput>
    /**
     * Choose, which StorageUser to update.
     * 
    **/
    where: StorageUserWhereUniqueInput
  }


  /**
   * StorageUser updateMany
   */
  export type StorageUserUpdateManyArgs = {
    /**
     * The data used to update StorageUsers.
     * 
    **/
    data: XOR<StorageUserUpdateManyMutationInput, StorageUserUncheckedUpdateManyInput>
    /**
     * Filter which StorageUsers to update
     * 
    **/
    where?: StorageUserWhereInput
  }


  /**
   * StorageUser upsert
   */
  export type StorageUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the StorageUser
     * 
    **/
    select?: StorageUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StorageUserInclude | null
    /**
     * The filter to search for the StorageUser to update in case it exists.
     * 
    **/
    where: StorageUserWhereUniqueInput
    /**
     * In case the StorageUser found by the `where` argument doesn't exist, create a new StorageUser with this data.
     * 
    **/
    create: XOR<StorageUserCreateInput, StorageUserUncheckedCreateInput>
    /**
     * In case the StorageUser was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<StorageUserUpdateInput, StorageUserUncheckedUpdateInput>
  }


  /**
   * StorageUser delete
   */
  export type StorageUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the StorageUser
     * 
    **/
    select?: StorageUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StorageUserInclude | null
    /**
     * Filter which StorageUser to delete.
     * 
    **/
    where: StorageUserWhereUniqueInput
  }


  /**
   * StorageUser deleteMany
   */
  export type StorageUserDeleteManyArgs = {
    /**
     * Filter which StorageUsers to delete
     * 
    **/
    where?: StorageUserWhereInput
  }


  /**
   * StorageUser: findUniqueOrThrow
   */
  export type StorageUserFindUniqueOrThrowArgs = StorageUserFindUniqueArgsBase
      

  /**
   * StorageUser: findFirstOrThrow
   */
  export type StorageUserFindFirstOrThrowArgs = StorageUserFindFirstArgsBase
      

  /**
   * StorageUser without action
   */
  export type StorageUserArgs = {
    /**
     * Select specific fields to fetch from the StorageUser
     * 
    **/
    select?: StorageUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StorageUserInclude | null
  }



  /**
   * Model Crew
   */


  export type AggregateCrew = {
    _count: CrewCountAggregateOutputType | null
    _avg: CrewAvgAggregateOutputType | null
    _sum: CrewSumAggregateOutputType | null
    _min: CrewMinAggregateOutputType | null
    _max: CrewMaxAggregateOutputType | null
  }

  export type CrewAvgAggregateOutputType = {
    id: number | null
  }

  export type CrewSumAggregateOutputType = {
    id: number | null
  }

  export type CrewMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
  }

  export type CrewMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
  }

  export type CrewCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    editedAt: number
    createdById: number
    editedById: number
    _all: number
  }


  export type CrewAvgAggregateInputType = {
    id?: true
  }

  export type CrewSumAggregateInputType = {
    id?: true
  }

  export type CrewMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
  }

  export type CrewMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
  }

  export type CrewCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
    _all?: true
  }

  export type CrewAggregateArgs = {
    /**
     * Filter which Crew to aggregate.
     * 
    **/
    where?: CrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crews to fetch.
     * 
    **/
    orderBy?: Enumerable<CrewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crews.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Crews
    **/
    _count?: true | CrewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CrewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CrewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrewMaxAggregateInputType
  }

  export type GetCrewAggregateType<T extends CrewAggregateArgs> = {
        [P in keyof T & keyof AggregateCrew]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrew[P]>
      : GetScalarType<T[P], AggregateCrew[P]>
  }




  export type CrewGroupByArgs = {
    where?: CrewWhereInput
    orderBy?: Enumerable<CrewOrderByWithAggregationInput>
    by: Array<CrewScalarFieldEnum>
    having?: CrewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrewCountAggregateInputType | true
    _avg?: CrewAvgAggregateInputType
    _sum?: CrewSumAggregateInputType
    _min?: CrewMinAggregateInputType
    _max?: CrewMaxAggregateInputType
  }


  export type CrewGroupByOutputType = {
    id: number
    name: string
    description: string
    createdAt: Date
    editedAt: Date
    createdById: string
    editedById: string
    _count: CrewCountAggregateOutputType | null
    _avg: CrewAvgAggregateOutputType | null
    _sum: CrewSumAggregateOutputType | null
    _min: CrewMinAggregateOutputType | null
    _max: CrewMaxAggregateOutputType | null
  }

  type GetCrewGroupByPayload<T extends CrewGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CrewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrewGroupByOutputType[P]>
            : GetScalarType<T[P], CrewGroupByOutputType[P]>
        }
      >
    >


  export type CrewSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    editedAt?: boolean
    createdById?: boolean
    editedById?: boolean
    createdBy?: boolean | UserArgs
    editedBy?: boolean | UserArgs
    userCrew?: boolean | UserCrewFindManyArgs
    _count?: boolean | CrewCountOutputTypeArgs
  }

  export type CrewInclude = {
    createdBy?: boolean | UserArgs
    editedBy?: boolean | UserArgs
    userCrew?: boolean | UserCrewFindManyArgs
    _count?: boolean | CrewCountOutputTypeArgs
  }

  export type CrewGetPayload<
    S extends boolean | null | undefined | CrewArgs,
    U = keyof S
      > = S extends true
        ? Crew
    : S extends undefined
    ? never
    : S extends CrewArgs | CrewFindManyArgs
    ?'include' extends U
    ? Crew  & {
    [P in TrueKeys<S['include']>]:
        P extends 'createdBy' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'editedBy' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'userCrew' ? Array < UserCrewGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? CrewCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'createdBy' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'editedBy' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'userCrew' ? Array < UserCrewGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? CrewCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Crew ? Crew[P] : never
  } 
    : Crew
  : Crew


  type CrewCountArgs = Merge<
    Omit<CrewFindManyArgs, 'select' | 'include'> & {
      select?: CrewCountAggregateInputType | true
    }
  >

  export interface CrewDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Crew that matches the filter.
     * @param {CrewFindUniqueArgs} args - Arguments to find a Crew
     * @example
     * // Get one Crew
     * const crew = await prisma.crew.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CrewFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CrewFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Crew'> extends True ? CheckSelect<T, Prisma__CrewClient<Crew>, Prisma__CrewClient<CrewGetPayload<T>>> : CheckSelect<T, Prisma__CrewClient<Crew | null >, Prisma__CrewClient<CrewGetPayload<T> | null >>

    /**
     * Find the first Crew that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewFindFirstArgs} args - Arguments to find a Crew
     * @example
     * // Get one Crew
     * const crew = await prisma.crew.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CrewFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CrewFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Crew'> extends True ? CheckSelect<T, Prisma__CrewClient<Crew>, Prisma__CrewClient<CrewGetPayload<T>>> : CheckSelect<T, Prisma__CrewClient<Crew | null >, Prisma__CrewClient<CrewGetPayload<T> | null >>

    /**
     * Find zero or more Crews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Crews
     * const crews = await prisma.crew.findMany()
     * 
     * // Get first 10 Crews
     * const crews = await prisma.crew.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const crewWithIdOnly = await prisma.crew.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CrewFindManyArgs>(
      args?: SelectSubset<T, CrewFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Crew>>, PrismaPromise<Array<CrewGetPayload<T>>>>

    /**
     * Create a Crew.
     * @param {CrewCreateArgs} args - Arguments to create a Crew.
     * @example
     * // Create one Crew
     * const Crew = await prisma.crew.create({
     *   data: {
     *     // ... data to create a Crew
     *   }
     * })
     * 
    **/
    create<T extends CrewCreateArgs>(
      args: SelectSubset<T, CrewCreateArgs>
    ): CheckSelect<T, Prisma__CrewClient<Crew>, Prisma__CrewClient<CrewGetPayload<T>>>

    /**
     * Create many Crews.
     *     @param {CrewCreateManyArgs} args - Arguments to create many Crews.
     *     @example
     *     // Create many Crews
     *     const crew = await prisma.crew.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CrewCreateManyArgs>(
      args?: SelectSubset<T, CrewCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Crew.
     * @param {CrewDeleteArgs} args - Arguments to delete one Crew.
     * @example
     * // Delete one Crew
     * const Crew = await prisma.crew.delete({
     *   where: {
     *     // ... filter to delete one Crew
     *   }
     * })
     * 
    **/
    delete<T extends CrewDeleteArgs>(
      args: SelectSubset<T, CrewDeleteArgs>
    ): CheckSelect<T, Prisma__CrewClient<Crew>, Prisma__CrewClient<CrewGetPayload<T>>>

    /**
     * Update one Crew.
     * @param {CrewUpdateArgs} args - Arguments to update one Crew.
     * @example
     * // Update one Crew
     * const crew = await prisma.crew.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CrewUpdateArgs>(
      args: SelectSubset<T, CrewUpdateArgs>
    ): CheckSelect<T, Prisma__CrewClient<Crew>, Prisma__CrewClient<CrewGetPayload<T>>>

    /**
     * Delete zero or more Crews.
     * @param {CrewDeleteManyArgs} args - Arguments to filter Crews to delete.
     * @example
     * // Delete a few Crews
     * const { count } = await prisma.crew.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CrewDeleteManyArgs>(
      args?: SelectSubset<T, CrewDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Crews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Crews
     * const crew = await prisma.crew.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CrewUpdateManyArgs>(
      args: SelectSubset<T, CrewUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Crew.
     * @param {CrewUpsertArgs} args - Arguments to update or create a Crew.
     * @example
     * // Update or create a Crew
     * const crew = await prisma.crew.upsert({
     *   create: {
     *     // ... data to create a Crew
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Crew we want to update
     *   }
     * })
    **/
    upsert<T extends CrewUpsertArgs>(
      args: SelectSubset<T, CrewUpsertArgs>
    ): CheckSelect<T, Prisma__CrewClient<Crew>, Prisma__CrewClient<CrewGetPayload<T>>>

    /**
     * Find one Crew that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CrewFindUniqueOrThrowArgs} args - Arguments to find a Crew
     * @example
     * // Get one Crew
     * const crew = await prisma.crew.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CrewFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CrewFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__CrewClient<Crew>, Prisma__CrewClient<CrewGetPayload<T>>>

    /**
     * Find the first Crew that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewFindFirstOrThrowArgs} args - Arguments to find a Crew
     * @example
     * // Get one Crew
     * const crew = await prisma.crew.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CrewFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CrewFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__CrewClient<Crew>, Prisma__CrewClient<CrewGetPayload<T>>>

    /**
     * Count the number of Crews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewCountArgs} args - Arguments to filter Crews to count.
     * @example
     * // Count the number of Crews
     * const count = await prisma.crew.count({
     *   where: {
     *     // ... the filter for the Crews we want to count
     *   }
     * })
    **/
    count<T extends CrewCountArgs>(
      args?: Subset<T, CrewCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Crew.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrewAggregateArgs>(args: Subset<T, CrewAggregateArgs>): PrismaPromise<GetCrewAggregateType<T>>

    /**
     * Group by Crew.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrewGroupByArgs['orderBy'] }
        : { orderBy?: CrewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrewGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Crew.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CrewClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    createdBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    editedBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    userCrew<T extends UserCrewFindManyArgs = {}>(args?: Subset<T, UserCrewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserCrew>>, PrismaPromise<Array<UserCrewGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Crew base type for findUnique actions
   */
  export type CrewFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Crew
     * 
    **/
    select?: CrewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CrewInclude | null
    /**
     * Filter, which Crew to fetch.
     * 
    **/
    where: CrewWhereUniqueInput
  }

  /**
   * Crew: findUnique
   */
  export interface CrewFindUniqueArgs extends CrewFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Crew base type for findFirst actions
   */
  export type CrewFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Crew
     * 
    **/
    select?: CrewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CrewInclude | null
    /**
     * Filter, which Crew to fetch.
     * 
    **/
    where?: CrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crews to fetch.
     * 
    **/
    orderBy?: Enumerable<CrewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Crews.
     * 
    **/
    cursor?: CrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crews.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Crews.
     * 
    **/
    distinct?: Enumerable<CrewScalarFieldEnum>
  }

  /**
   * Crew: findFirst
   */
  export interface CrewFindFirstArgs extends CrewFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Crew findMany
   */
  export type CrewFindManyArgs = {
    /**
     * Select specific fields to fetch from the Crew
     * 
    **/
    select?: CrewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CrewInclude | null
    /**
     * Filter, which Crews to fetch.
     * 
    **/
    where?: CrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crews to fetch.
     * 
    **/
    orderBy?: Enumerable<CrewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Crews.
     * 
    **/
    cursor?: CrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crews.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CrewScalarFieldEnum>
  }


  /**
   * Crew create
   */
  export type CrewCreateArgs = {
    /**
     * Select specific fields to fetch from the Crew
     * 
    **/
    select?: CrewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CrewInclude | null
    /**
     * The data needed to create a Crew.
     * 
    **/
    data: XOR<CrewCreateInput, CrewUncheckedCreateInput>
  }


  /**
   * Crew createMany
   */
  export type CrewCreateManyArgs = {
    /**
     * The data used to create many Crews.
     * 
    **/
    data: Enumerable<CrewCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Crew update
   */
  export type CrewUpdateArgs = {
    /**
     * Select specific fields to fetch from the Crew
     * 
    **/
    select?: CrewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CrewInclude | null
    /**
     * The data needed to update a Crew.
     * 
    **/
    data: XOR<CrewUpdateInput, CrewUncheckedUpdateInput>
    /**
     * Choose, which Crew to update.
     * 
    **/
    where: CrewWhereUniqueInput
  }


  /**
   * Crew updateMany
   */
  export type CrewUpdateManyArgs = {
    /**
     * The data used to update Crews.
     * 
    **/
    data: XOR<CrewUpdateManyMutationInput, CrewUncheckedUpdateManyInput>
    /**
     * Filter which Crews to update
     * 
    **/
    where?: CrewWhereInput
  }


  /**
   * Crew upsert
   */
  export type CrewUpsertArgs = {
    /**
     * Select specific fields to fetch from the Crew
     * 
    **/
    select?: CrewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CrewInclude | null
    /**
     * The filter to search for the Crew to update in case it exists.
     * 
    **/
    where: CrewWhereUniqueInput
    /**
     * In case the Crew found by the `where` argument doesn't exist, create a new Crew with this data.
     * 
    **/
    create: XOR<CrewCreateInput, CrewUncheckedCreateInput>
    /**
     * In case the Crew was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CrewUpdateInput, CrewUncheckedUpdateInput>
  }


  /**
   * Crew delete
   */
  export type CrewDeleteArgs = {
    /**
     * Select specific fields to fetch from the Crew
     * 
    **/
    select?: CrewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CrewInclude | null
    /**
     * Filter which Crew to delete.
     * 
    **/
    where: CrewWhereUniqueInput
  }


  /**
   * Crew deleteMany
   */
  export type CrewDeleteManyArgs = {
    /**
     * Filter which Crews to delete
     * 
    **/
    where?: CrewWhereInput
  }


  /**
   * Crew: findUniqueOrThrow
   */
  export type CrewFindUniqueOrThrowArgs = CrewFindUniqueArgsBase
      

  /**
   * Crew: findFirstOrThrow
   */
  export type CrewFindFirstOrThrowArgs = CrewFindFirstArgsBase
      

  /**
   * Crew without action
   */
  export type CrewArgs = {
    /**
     * Select specific fields to fetch from the Crew
     * 
    **/
    select?: CrewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CrewInclude | null
  }



  /**
   * Model UserCrew
   */


  export type AggregateUserCrew = {
    _count: UserCrewCountAggregateOutputType | null
    _avg: UserCrewAvgAggregateOutputType | null
    _sum: UserCrewSumAggregateOutputType | null
    _min: UserCrewMinAggregateOutputType | null
    _max: UserCrewMaxAggregateOutputType | null
  }

  export type UserCrewAvgAggregateOutputType = {
    crewId: number | null
  }

  export type UserCrewSumAggregateOutputType = {
    crewId: number | null
  }

  export type UserCrewMinAggregateOutputType = {
    userId: string | null
    crewId: number | null
    permission: string | null
  }

  export type UserCrewMaxAggregateOutputType = {
    userId: string | null
    crewId: number | null
    permission: string | null
  }

  export type UserCrewCountAggregateOutputType = {
    userId: number
    crewId: number
    permission: number
    _all: number
  }


  export type UserCrewAvgAggregateInputType = {
    crewId?: true
  }

  export type UserCrewSumAggregateInputType = {
    crewId?: true
  }

  export type UserCrewMinAggregateInputType = {
    userId?: true
    crewId?: true
    permission?: true
  }

  export type UserCrewMaxAggregateInputType = {
    userId?: true
    crewId?: true
    permission?: true
  }

  export type UserCrewCountAggregateInputType = {
    userId?: true
    crewId?: true
    permission?: true
    _all?: true
  }

  export type UserCrewAggregateArgs = {
    /**
     * Filter which UserCrew to aggregate.
     * 
    **/
    where?: UserCrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCrews to fetch.
     * 
    **/
    orderBy?: Enumerable<UserCrewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserCrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCrews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCrews.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserCrews
    **/
    _count?: true | UserCrewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserCrewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserCrewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserCrewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserCrewMaxAggregateInputType
  }

  export type GetUserCrewAggregateType<T extends UserCrewAggregateArgs> = {
        [P in keyof T & keyof AggregateUserCrew]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserCrew[P]>
      : GetScalarType<T[P], AggregateUserCrew[P]>
  }




  export type UserCrewGroupByArgs = {
    where?: UserCrewWhereInput
    orderBy?: Enumerable<UserCrewOrderByWithAggregationInput>
    by: Array<UserCrewScalarFieldEnum>
    having?: UserCrewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCrewCountAggregateInputType | true
    _avg?: UserCrewAvgAggregateInputType
    _sum?: UserCrewSumAggregateInputType
    _min?: UserCrewMinAggregateInputType
    _max?: UserCrewMaxAggregateInputType
  }


  export type UserCrewGroupByOutputType = {
    userId: string
    crewId: number
    permission: string
    _count: UserCrewCountAggregateOutputType | null
    _avg: UserCrewAvgAggregateOutputType | null
    _sum: UserCrewSumAggregateOutputType | null
    _min: UserCrewMinAggregateOutputType | null
    _max: UserCrewMaxAggregateOutputType | null
  }

  type GetUserCrewGroupByPayload<T extends UserCrewGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserCrewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserCrewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserCrewGroupByOutputType[P]>
            : GetScalarType<T[P], UserCrewGroupByOutputType[P]>
        }
      >
    >


  export type UserCrewSelect = {
    userId?: boolean
    crewId?: boolean
    user?: boolean | UserArgs
    crew?: boolean | CrewArgs
    permission?: boolean
  }

  export type UserCrewInclude = {
    user?: boolean | UserArgs
    crew?: boolean | CrewArgs
  }

  export type UserCrewGetPayload<
    S extends boolean | null | undefined | UserCrewArgs,
    U = keyof S
      > = S extends true
        ? UserCrew
    : S extends undefined
    ? never
    : S extends UserCrewArgs | UserCrewFindManyArgs
    ?'include' extends U
    ? UserCrew  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'crew' ? CrewGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'crew' ? CrewGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof UserCrew ? UserCrew[P] : never
  } 
    : UserCrew
  : UserCrew


  type UserCrewCountArgs = Merge<
    Omit<UserCrewFindManyArgs, 'select' | 'include'> & {
      select?: UserCrewCountAggregateInputType | true
    }
  >

  export interface UserCrewDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one UserCrew that matches the filter.
     * @param {UserCrewFindUniqueArgs} args - Arguments to find a UserCrew
     * @example
     * // Get one UserCrew
     * const userCrew = await prisma.userCrew.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserCrewFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserCrewFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserCrew'> extends True ? CheckSelect<T, Prisma__UserCrewClient<UserCrew>, Prisma__UserCrewClient<UserCrewGetPayload<T>>> : CheckSelect<T, Prisma__UserCrewClient<UserCrew | null >, Prisma__UserCrewClient<UserCrewGetPayload<T> | null >>

    /**
     * Find the first UserCrew that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCrewFindFirstArgs} args - Arguments to find a UserCrew
     * @example
     * // Get one UserCrew
     * const userCrew = await prisma.userCrew.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserCrewFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserCrewFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserCrew'> extends True ? CheckSelect<T, Prisma__UserCrewClient<UserCrew>, Prisma__UserCrewClient<UserCrewGetPayload<T>>> : CheckSelect<T, Prisma__UserCrewClient<UserCrew | null >, Prisma__UserCrewClient<UserCrewGetPayload<T> | null >>

    /**
     * Find zero or more UserCrews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCrewFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserCrews
     * const userCrews = await prisma.userCrew.findMany()
     * 
     * // Get first 10 UserCrews
     * const userCrews = await prisma.userCrew.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userCrewWithUserIdOnly = await prisma.userCrew.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends UserCrewFindManyArgs>(
      args?: SelectSubset<T, UserCrewFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserCrew>>, PrismaPromise<Array<UserCrewGetPayload<T>>>>

    /**
     * Create a UserCrew.
     * @param {UserCrewCreateArgs} args - Arguments to create a UserCrew.
     * @example
     * // Create one UserCrew
     * const UserCrew = await prisma.userCrew.create({
     *   data: {
     *     // ... data to create a UserCrew
     *   }
     * })
     * 
    **/
    create<T extends UserCrewCreateArgs>(
      args: SelectSubset<T, UserCrewCreateArgs>
    ): CheckSelect<T, Prisma__UserCrewClient<UserCrew>, Prisma__UserCrewClient<UserCrewGetPayload<T>>>

    /**
     * Create many UserCrews.
     *     @param {UserCrewCreateManyArgs} args - Arguments to create many UserCrews.
     *     @example
     *     // Create many UserCrews
     *     const userCrew = await prisma.userCrew.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCrewCreateManyArgs>(
      args?: SelectSubset<T, UserCrewCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserCrew.
     * @param {UserCrewDeleteArgs} args - Arguments to delete one UserCrew.
     * @example
     * // Delete one UserCrew
     * const UserCrew = await prisma.userCrew.delete({
     *   where: {
     *     // ... filter to delete one UserCrew
     *   }
     * })
     * 
    **/
    delete<T extends UserCrewDeleteArgs>(
      args: SelectSubset<T, UserCrewDeleteArgs>
    ): CheckSelect<T, Prisma__UserCrewClient<UserCrew>, Prisma__UserCrewClient<UserCrewGetPayload<T>>>

    /**
     * Update one UserCrew.
     * @param {UserCrewUpdateArgs} args - Arguments to update one UserCrew.
     * @example
     * // Update one UserCrew
     * const userCrew = await prisma.userCrew.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserCrewUpdateArgs>(
      args: SelectSubset<T, UserCrewUpdateArgs>
    ): CheckSelect<T, Prisma__UserCrewClient<UserCrew>, Prisma__UserCrewClient<UserCrewGetPayload<T>>>

    /**
     * Delete zero or more UserCrews.
     * @param {UserCrewDeleteManyArgs} args - Arguments to filter UserCrews to delete.
     * @example
     * // Delete a few UserCrews
     * const { count } = await prisma.userCrew.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserCrewDeleteManyArgs>(
      args?: SelectSubset<T, UserCrewDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCrews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCrewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserCrews
     * const userCrew = await prisma.userCrew.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserCrewUpdateManyArgs>(
      args: SelectSubset<T, UserCrewUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserCrew.
     * @param {UserCrewUpsertArgs} args - Arguments to update or create a UserCrew.
     * @example
     * // Update or create a UserCrew
     * const userCrew = await prisma.userCrew.upsert({
     *   create: {
     *     // ... data to create a UserCrew
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserCrew we want to update
     *   }
     * })
    **/
    upsert<T extends UserCrewUpsertArgs>(
      args: SelectSubset<T, UserCrewUpsertArgs>
    ): CheckSelect<T, Prisma__UserCrewClient<UserCrew>, Prisma__UserCrewClient<UserCrewGetPayload<T>>>

    /**
     * Find one UserCrew that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {UserCrewFindUniqueOrThrowArgs} args - Arguments to find a UserCrew
     * @example
     * // Get one UserCrew
     * const userCrew = await prisma.userCrew.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserCrewFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserCrewFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__UserCrewClient<UserCrew>, Prisma__UserCrewClient<UserCrewGetPayload<T>>>

    /**
     * Find the first UserCrew that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCrewFindFirstOrThrowArgs} args - Arguments to find a UserCrew
     * @example
     * // Get one UserCrew
     * const userCrew = await prisma.userCrew.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserCrewFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserCrewFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__UserCrewClient<UserCrew>, Prisma__UserCrewClient<UserCrewGetPayload<T>>>

    /**
     * Count the number of UserCrews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCrewCountArgs} args - Arguments to filter UserCrews to count.
     * @example
     * // Count the number of UserCrews
     * const count = await prisma.userCrew.count({
     *   where: {
     *     // ... the filter for the UserCrews we want to count
     *   }
     * })
    **/
    count<T extends UserCrewCountArgs>(
      args?: Subset<T, UserCrewCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCrewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserCrew.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCrewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserCrewAggregateArgs>(args: Subset<T, UserCrewAggregateArgs>): PrismaPromise<GetUserCrewAggregateType<T>>

    /**
     * Group by UserCrew.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCrewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserCrewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserCrewGroupByArgs['orderBy'] }
        : { orderBy?: UserCrewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserCrewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserCrewGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserCrew.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserCrewClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    crew<T extends CrewArgs = {}>(args?: Subset<T, CrewArgs>): CheckSelect<T, Prisma__CrewClient<Crew | null >, Prisma__CrewClient<CrewGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserCrew base type for findUnique actions
   */
  export type UserCrewFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserCrew
     * 
    **/
    select?: UserCrewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserCrewInclude | null
    /**
     * Filter, which UserCrew to fetch.
     * 
    **/
    where: UserCrewWhereUniqueInput
  }

  /**
   * UserCrew: findUnique
   */
  export interface UserCrewFindUniqueArgs extends UserCrewFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserCrew base type for findFirst actions
   */
  export type UserCrewFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserCrew
     * 
    **/
    select?: UserCrewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserCrewInclude | null
    /**
     * Filter, which UserCrew to fetch.
     * 
    **/
    where?: UserCrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCrews to fetch.
     * 
    **/
    orderBy?: Enumerable<UserCrewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCrews.
     * 
    **/
    cursor?: UserCrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCrews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCrews.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCrews.
     * 
    **/
    distinct?: Enumerable<UserCrewScalarFieldEnum>
  }

  /**
   * UserCrew: findFirst
   */
  export interface UserCrewFindFirstArgs extends UserCrewFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserCrew findMany
   */
  export type UserCrewFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserCrew
     * 
    **/
    select?: UserCrewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserCrewInclude | null
    /**
     * Filter, which UserCrews to fetch.
     * 
    **/
    where?: UserCrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCrews to fetch.
     * 
    **/
    orderBy?: Enumerable<UserCrewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserCrews.
     * 
    **/
    cursor?: UserCrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCrews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCrews.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserCrewScalarFieldEnum>
  }


  /**
   * UserCrew create
   */
  export type UserCrewCreateArgs = {
    /**
     * Select specific fields to fetch from the UserCrew
     * 
    **/
    select?: UserCrewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserCrewInclude | null
    /**
     * The data needed to create a UserCrew.
     * 
    **/
    data: XOR<UserCrewCreateInput, UserCrewUncheckedCreateInput>
  }


  /**
   * UserCrew createMany
   */
  export type UserCrewCreateManyArgs = {
    /**
     * The data used to create many UserCrews.
     * 
    **/
    data: Enumerable<UserCrewCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserCrew update
   */
  export type UserCrewUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserCrew
     * 
    **/
    select?: UserCrewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserCrewInclude | null
    /**
     * The data needed to update a UserCrew.
     * 
    **/
    data: XOR<UserCrewUpdateInput, UserCrewUncheckedUpdateInput>
    /**
     * Choose, which UserCrew to update.
     * 
    **/
    where: UserCrewWhereUniqueInput
  }


  /**
   * UserCrew updateMany
   */
  export type UserCrewUpdateManyArgs = {
    /**
     * The data used to update UserCrews.
     * 
    **/
    data: XOR<UserCrewUpdateManyMutationInput, UserCrewUncheckedUpdateManyInput>
    /**
     * Filter which UserCrews to update
     * 
    **/
    where?: UserCrewWhereInput
  }


  /**
   * UserCrew upsert
   */
  export type UserCrewUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserCrew
     * 
    **/
    select?: UserCrewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserCrewInclude | null
    /**
     * The filter to search for the UserCrew to update in case it exists.
     * 
    **/
    where: UserCrewWhereUniqueInput
    /**
     * In case the UserCrew found by the `where` argument doesn't exist, create a new UserCrew with this data.
     * 
    **/
    create: XOR<UserCrewCreateInput, UserCrewUncheckedCreateInput>
    /**
     * In case the UserCrew was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserCrewUpdateInput, UserCrewUncheckedUpdateInput>
  }


  /**
   * UserCrew delete
   */
  export type UserCrewDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserCrew
     * 
    **/
    select?: UserCrewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserCrewInclude | null
    /**
     * Filter which UserCrew to delete.
     * 
    **/
    where: UserCrewWhereUniqueInput
  }


  /**
   * UserCrew deleteMany
   */
  export type UserCrewDeleteManyArgs = {
    /**
     * Filter which UserCrews to delete
     * 
    **/
    where?: UserCrewWhereInput
  }


  /**
   * UserCrew: findUniqueOrThrow
   */
  export type UserCrewFindUniqueOrThrowArgs = UserCrewFindUniqueArgsBase
      

  /**
   * UserCrew: findFirstOrThrow
   */
  export type UserCrewFindFirstOrThrowArgs = UserCrewFindFirstArgsBase
      

  /**
   * UserCrew without action
   */
  export type UserCrewArgs = {
    /**
     * Select specific fields to fetch from the UserCrew
     * 
    **/
    select?: UserCrewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserCrewInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const BuildScalarFieldEnum: {
    id: 'id',
    buildName: 'buildName',
    createdAt: 'createdAt',
    editedAt: 'editedAt',
    createdById: 'createdById',
    editedById: 'editedById',
    recipeId: 'recipeId',
    instructions: 'instructions',
    notes: 'notes',
    glassware: 'glassware',
    ice: 'ice'
  };

  export type BuildScalarFieldEnum = (typeof BuildScalarFieldEnum)[keyof typeof BuildScalarFieldEnum]


  export const BuildUserScalarFieldEnum: {
    userId: 'userId',
    buildId: 'buildId',
    permission: 'permission'
  };

  export type BuildUserScalarFieldEnum = (typeof BuildUserScalarFieldEnum)[keyof typeof BuildUserScalarFieldEnum]


  export const CrewScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    editedAt: 'editedAt',
    createdById: 'createdById',
    editedById: 'editedById'
  };

  export type CrewScalarFieldEnum = (typeof CrewScalarFieldEnum)[keyof typeof CrewScalarFieldEnum]


  export const GenericIngredientScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type GenericIngredientScalarFieldEnum = (typeof GenericIngredientScalarFieldEnum)[keyof typeof GenericIngredientScalarFieldEnum]


  export const IngredientPreferenceScalarFieldEnum: {
    genericIngredientID: 'genericIngredientID',
    specificIngredientID: 'specificIngredientID',
    userId: 'userId'
  };

  export type IngredientPreferenceScalarFieldEnum = (typeof IngredientPreferenceScalarFieldEnum)[keyof typeof IngredientPreferenceScalarFieldEnum]


  export const IngredientStorageScalarFieldEnum: {
    ingredientId: 'ingredientId',
    storageId: 'storageId',
    quantity: 'quantity'
  };

  export type IngredientStorageScalarFieldEnum = (typeof IngredientStorageScalarFieldEnum)[keyof typeof IngredientStorageScalarFieldEnum]


  export const InventoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    editedAt: 'editedAt',
    createdById: 'createdById',
    editedById: 'editedById'
  };

  export type InventoryScalarFieldEnum = (typeof InventoryScalarFieldEnum)[keyof typeof InventoryScalarFieldEnum]


  export const InventoryStorageScalarFieldEnum: {
    inventoryId: 'inventoryId',
    storageId: 'storageId'
  };

  export type InventoryStorageScalarFieldEnum = (typeof InventoryStorageScalarFieldEnum)[keyof typeof InventoryStorageScalarFieldEnum]


  export const InventoryUserScalarFieldEnum: {
    userId: 'userId',
    inventoryId: 'inventoryId',
    permission: 'permission'
  };

  export type InventoryUserScalarFieldEnum = (typeof InventoryUserScalarFieldEnum)[keyof typeof InventoryUserScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    photo: 'photo'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const RecipeBookBuildScalarFieldEnum: {
    buildId: 'buildId',
    recipeBookId: 'recipeBookId'
  };

  export type RecipeBookBuildScalarFieldEnum = (typeof RecipeBookBuildScalarFieldEnum)[keyof typeof RecipeBookBuildScalarFieldEnum]


  export const RecipeBookScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    editedAt: 'editedAt',
    createdById: 'createdById',
    editedById: 'editedById'
  };

  export type RecipeBookScalarFieldEnum = (typeof RecipeBookScalarFieldEnum)[keyof typeof RecipeBookScalarFieldEnum]


  export const RecipeBookUserScalarFieldEnum: {
    userId: 'userId',
    recipeBookId: 'recipeBookId',
    permission: 'permission'
  };

  export type RecipeBookUserScalarFieldEnum = (typeof RecipeBookUserScalarFieldEnum)[keyof typeof RecipeBookUserScalarFieldEnum]


  export const RecipeScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    name: 'name',
    origin: 'origin',
    history: 'history',
    createdById: 'createdById'
  };

  export type RecipeScalarFieldEnum = (typeof RecipeScalarFieldEnum)[keyof typeof RecipeScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const SpecificIngredientScalarFieldEnum: {
    id: 'id',
    dateCreated: 'dateCreated',
    createdById: 'createdById',
    genericIngredientId: 'genericIngredientId',
    name: 'name',
    description: 'description',
    price: 'price',
    amount: 'amount',
    unit: 'unit',
    source: 'source'
  };

  export type SpecificIngredientScalarFieldEnum = (typeof SpecificIngredientScalarFieldEnum)[keyof typeof SpecificIngredientScalarFieldEnum]


  export const StorageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    editedAt: 'editedAt',
    createdById: 'createdById',
    editedById: 'editedById'
  };

  export type StorageScalarFieldEnum = (typeof StorageScalarFieldEnum)[keyof typeof StorageScalarFieldEnum]


  export const StorageUserScalarFieldEnum: {
    userId: 'userId',
    storageId: 'storageId',
    permission: 'permission'
  };

  export type StorageUserScalarFieldEnum = (typeof StorageUserScalarFieldEnum)[keyof typeof StorageUserScalarFieldEnum]


  export const TouchScalarFieldEnum: {
    id: 'id',
    buildId: 'buildId',
    order: 'order',
    amount: 'amount',
    unit: 'unit',
    genericIngredientID: 'genericIngredientID',
    specificIngredientID: 'specificIngredientID'
  };

  export type TouchScalarFieldEnum = (typeof TouchScalarFieldEnum)[keyof typeof TouchScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserCrewScalarFieldEnum: {
    userId: 'userId',
    crewId: 'crewId',
    permission: 'permission'
  };

  export type UserCrewScalarFieldEnum = (typeof UserCrewScalarFieldEnum)[keyof typeof UserCrewScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    userName: 'userName',
    firstName: 'firstName',
    lastName: 'lastName',
    dateJoined: 'dateJoined',
    lastEdited: 'lastEdited',
    email: 'email',
    password: 'password'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    userName?: StringFilter | string
    firstName?: StringNullableFilter | string | null
    lastName?: StringNullableFilter | string | null
    dateJoined?: DateTimeFilter | Date | string
    lastEdited?: DateTimeFilter | Date | string
    email?: StringFilter | string
    password?: StringFilter | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput> | null
    recipeBookUser?: RecipeBookUserListRelationFilter
    recipeBook?: RecipeBookListRelationFilter
    recipeBookEditedById?: RecipeBookListRelationFilter
    recipe?: RecipeListRelationFilter
    buildUser?: BuildUserListRelationFilter
    build?: BuildListRelationFilter
    buildEditedBy?: BuildListRelationFilter
    userCrew?: UserCrewListRelationFilter
    crew?: CrewListRelationFilter
    crewEditedBy?: CrewListRelationFilter
    ingredient?: SpecificIngredientListRelationFilter
    ingredientPreference?: IngredientPreferenceListRelationFilter
    storageUser?: StorageUserListRelationFilter
    storage?: StorageListRelationFilter
    storageEditedBy?: StorageListRelationFilter
    inventoryCreatedBy?: InventoryListRelationFilter
    inventoryEditedBy?: InventoryListRelationFilter
    inventoryUser?: InventoryUserListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    userName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateJoined?: SortOrder
    lastEdited?: SortOrder
    email?: SortOrder
    password?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    recipeBookUser?: RecipeBookUserOrderByRelationAggregateInput
    recipeBook?: RecipeBookOrderByRelationAggregateInput
    recipeBookEditedById?: RecipeBookOrderByRelationAggregateInput
    recipe?: RecipeOrderByRelationAggregateInput
    buildUser?: BuildUserOrderByRelationAggregateInput
    build?: BuildOrderByRelationAggregateInput
    buildEditedBy?: BuildOrderByRelationAggregateInput
    userCrew?: UserCrewOrderByRelationAggregateInput
    crew?: CrewOrderByRelationAggregateInput
    crewEditedBy?: CrewOrderByRelationAggregateInput
    ingredient?: SpecificIngredientOrderByRelationAggregateInput
    ingredientPreference?: IngredientPreferenceOrderByRelationAggregateInput
    storageUser?: StorageUserOrderByRelationAggregateInput
    storage?: StorageOrderByRelationAggregateInput
    storageEditedBy?: StorageOrderByRelationAggregateInput
    inventoryCreatedBy?: InventoryOrderByRelationAggregateInput
    inventoryEditedBy?: InventoryOrderByRelationAggregateInput
    inventoryUser?: InventoryUserOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    userName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateJoined?: SortOrder
    lastEdited?: SortOrder
    email?: SortOrder
    password?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userName?: StringWithAggregatesFilter | string
    firstName?: StringNullableWithAggregatesFilter | string | null
    lastName?: StringNullableWithAggregatesFilter | string | null
    dateJoined?: DateTimeWithAggregatesFilter | Date | string
    lastEdited?: DateTimeWithAggregatesFilter | Date | string
    email?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
  }

  export type ProfileWhereInput = {
    AND?: Enumerable<ProfileWhereInput>
    OR?: Enumerable<ProfileWhereInput>
    NOT?: Enumerable<ProfileWhereInput>
    id?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: StringFilter | string
    photo?: StringFilter | string
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    user?: UserOrderByWithRelationInput
    userId?: SortOrder
    photo?: SortOrder
  }

  export type ProfileWhereUniqueInput = {
    id?: number
    userId?: string
  }

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    photo?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _avg?: ProfileAvgOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
    _sum?: ProfileSumOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProfileScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProfileScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProfileScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: StringWithAggregatesFilter | string
    photo?: StringWithAggregatesFilter | string
  }

  export type RecipeBookWhereInput = {
    AND?: Enumerable<RecipeBookWhereInput>
    OR?: Enumerable<RecipeBookWhereInput>
    NOT?: Enumerable<RecipeBookWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    editedAt?: DateTimeFilter | Date | string
    createdById?: StringNullableFilter | string | null
    editedById?: StringNullableFilter | string | null
    createdBy?: XOR<UserRelationFilter, UserWhereInput> | null
    editedBy?: XOR<UserRelationFilter, UserWhereInput> | null
    recipeBookBuild?: RecipeBookBuildListRelationFilter
    recipeBookUser?: RecipeBookUserListRelationFilter
  }

  export type RecipeBookOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    editedBy?: UserOrderByWithRelationInput
    recipeBookBuild?: RecipeBookBuildOrderByRelationAggregateInput
    recipeBookUser?: RecipeBookUserOrderByRelationAggregateInput
  }

  export type RecipeBookWhereUniqueInput = {
    id?: number
  }

  export type RecipeBookOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    _count?: RecipeBookCountOrderByAggregateInput
    _avg?: RecipeBookAvgOrderByAggregateInput
    _max?: RecipeBookMaxOrderByAggregateInput
    _min?: RecipeBookMinOrderByAggregateInput
    _sum?: RecipeBookSumOrderByAggregateInput
  }

  export type RecipeBookScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RecipeBookScalarWhereWithAggregatesInput>
    OR?: Enumerable<RecipeBookScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RecipeBookScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    editedAt?: DateTimeWithAggregatesFilter | Date | string
    createdById?: StringNullableWithAggregatesFilter | string | null
    editedById?: StringNullableWithAggregatesFilter | string | null
  }

  export type RecipeBookUserWhereInput = {
    AND?: Enumerable<RecipeBookUserWhereInput>
    OR?: Enumerable<RecipeBookUserWhereInput>
    NOT?: Enumerable<RecipeBookUserWhereInput>
    userId?: StringFilter | string
    recipeBookId?: IntFilter | number
    recipeBook?: XOR<RecipeBookRelationFilter, RecipeBookWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    permission?: StringFilter | string
  }

  export type RecipeBookUserOrderByWithRelationInput = {
    userId?: SortOrder
    recipeBookId?: SortOrder
    recipeBook?: RecipeBookOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    permission?: SortOrder
  }

  export type RecipeBookUserWhereUniqueInput = {
    userId_recipeBookId?: RecipeBookUserUserIdRecipeBookIdCompoundUniqueInput
  }

  export type RecipeBookUserOrderByWithAggregationInput = {
    userId?: SortOrder
    recipeBookId?: SortOrder
    permission?: SortOrder
    _count?: RecipeBookUserCountOrderByAggregateInput
    _avg?: RecipeBookUserAvgOrderByAggregateInput
    _max?: RecipeBookUserMaxOrderByAggregateInput
    _min?: RecipeBookUserMinOrderByAggregateInput
    _sum?: RecipeBookUserSumOrderByAggregateInput
  }

  export type RecipeBookUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RecipeBookUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<RecipeBookUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RecipeBookUserScalarWhereWithAggregatesInput>
    userId?: StringWithAggregatesFilter | string
    recipeBookId?: IntWithAggregatesFilter | number
    permission?: StringWithAggregatesFilter | string
  }

  export type BuildWhereInput = {
    AND?: Enumerable<BuildWhereInput>
    OR?: Enumerable<BuildWhereInput>
    NOT?: Enumerable<BuildWhereInput>
    id?: IntFilter | number
    buildName?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    editedAt?: DateTimeFilter | Date | string
    createdById?: StringFilter | string
    editedById?: StringFilter | string
    createdBy?: XOR<UserRelationFilter, UserWhereInput> | null
    editedBy?: XOR<UserRelationFilter, UserWhereInput> | null
    recipe?: XOR<RecipeRelationFilter, RecipeWhereInput> | null
    recipeId?: IntNullableFilter | number | null
    instructions?: StringNullableFilter | string | null
    notes?: StringNullableFilter | string | null
    glassware?: StringNullableFilter | string | null
    ice?: StringNullableFilter | string | null
    touch?: TouchListRelationFilter
    RecipeBookBuild?: RecipeBookBuildListRelationFilter
    buildUser?: BuildUserListRelationFilter
  }

  export type BuildOrderByWithRelationInput = {
    id?: SortOrder
    buildName?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    editedBy?: UserOrderByWithRelationInput
    recipe?: RecipeOrderByWithRelationInput
    recipeId?: SortOrder
    instructions?: SortOrder
    notes?: SortOrder
    glassware?: SortOrder
    ice?: SortOrder
    touch?: TouchOrderByRelationAggregateInput
    RecipeBookBuild?: RecipeBookBuildOrderByRelationAggregateInput
    buildUser?: BuildUserOrderByRelationAggregateInput
  }

  export type BuildWhereUniqueInput = {
    id?: number
  }

  export type BuildOrderByWithAggregationInput = {
    id?: SortOrder
    buildName?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    recipeId?: SortOrder
    instructions?: SortOrder
    notes?: SortOrder
    glassware?: SortOrder
    ice?: SortOrder
    _count?: BuildCountOrderByAggregateInput
    _avg?: BuildAvgOrderByAggregateInput
    _max?: BuildMaxOrderByAggregateInput
    _min?: BuildMinOrderByAggregateInput
    _sum?: BuildSumOrderByAggregateInput
  }

  export type BuildScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BuildScalarWhereWithAggregatesInput>
    OR?: Enumerable<BuildScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BuildScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    buildName?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    editedAt?: DateTimeWithAggregatesFilter | Date | string
    createdById?: StringWithAggregatesFilter | string
    editedById?: StringWithAggregatesFilter | string
    recipeId?: IntNullableWithAggregatesFilter | number | null
    instructions?: StringNullableWithAggregatesFilter | string | null
    notes?: StringNullableWithAggregatesFilter | string | null
    glassware?: StringNullableWithAggregatesFilter | string | null
    ice?: StringNullableWithAggregatesFilter | string | null
  }

  export type BuildUserWhereInput = {
    AND?: Enumerable<BuildUserWhereInput>
    OR?: Enumerable<BuildUserWhereInput>
    NOT?: Enumerable<BuildUserWhereInput>
    userId?: StringFilter | string
    buildId?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    build?: XOR<BuildRelationFilter, BuildWhereInput>
    permission?: StringFilter | string
  }

  export type BuildUserOrderByWithRelationInput = {
    userId?: SortOrder
    buildId?: SortOrder
    user?: UserOrderByWithRelationInput
    build?: BuildOrderByWithRelationInput
    permission?: SortOrder
  }

  export type BuildUserWhereUniqueInput = {
    userId_buildId?: BuildUserUserIdBuildIdCompoundUniqueInput
  }

  export type BuildUserOrderByWithAggregationInput = {
    userId?: SortOrder
    buildId?: SortOrder
    permission?: SortOrder
    _count?: BuildUserCountOrderByAggregateInput
    _avg?: BuildUserAvgOrderByAggregateInput
    _max?: BuildUserMaxOrderByAggregateInput
    _min?: BuildUserMinOrderByAggregateInput
    _sum?: BuildUserSumOrderByAggregateInput
  }

  export type BuildUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BuildUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<BuildUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BuildUserScalarWhereWithAggregatesInput>
    userId?: StringWithAggregatesFilter | string
    buildId?: IntWithAggregatesFilter | number
    permission?: StringWithAggregatesFilter | string
  }

  export type RecipeWhereInput = {
    AND?: Enumerable<RecipeWhereInput>
    OR?: Enumerable<RecipeWhereInput>
    NOT?: Enumerable<RecipeWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    name?: StringFilter | string
    origin?: StringNullableFilter | string | null
    history?: StringNullableFilter | string | null
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    createdById?: StringFilter | string
    build?: BuildListRelationFilter
  }

  export type RecipeOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    origin?: SortOrder
    history?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    createdById?: SortOrder
    build?: BuildOrderByRelationAggregateInput
  }

  export type RecipeWhereUniqueInput = {
    id?: number
  }

  export type RecipeOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    origin?: SortOrder
    history?: SortOrder
    createdById?: SortOrder
    _count?: RecipeCountOrderByAggregateInput
    _avg?: RecipeAvgOrderByAggregateInput
    _max?: RecipeMaxOrderByAggregateInput
    _min?: RecipeMinOrderByAggregateInput
    _sum?: RecipeSumOrderByAggregateInput
  }

  export type RecipeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RecipeScalarWhereWithAggregatesInput>
    OR?: Enumerable<RecipeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RecipeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    name?: StringWithAggregatesFilter | string
    origin?: StringNullableWithAggregatesFilter | string | null
    history?: StringNullableWithAggregatesFilter | string | null
    createdById?: StringWithAggregatesFilter | string
  }

  export type RecipeBookBuildWhereInput = {
    AND?: Enumerable<RecipeBookBuildWhereInput>
    OR?: Enumerable<RecipeBookBuildWhereInput>
    NOT?: Enumerable<RecipeBookBuildWhereInput>
    buildId?: IntFilter | number
    recipeBookId?: IntFilter | number
    recipeBook?: XOR<RecipeBookRelationFilter, RecipeBookWhereInput>
    build?: XOR<BuildRelationFilter, BuildWhereInput>
  }

  export type RecipeBookBuildOrderByWithRelationInput = {
    buildId?: SortOrder
    recipeBookId?: SortOrder
    recipeBook?: RecipeBookOrderByWithRelationInput
    build?: BuildOrderByWithRelationInput
  }

  export type RecipeBookBuildWhereUniqueInput = {
    buildId_recipeBookId?: RecipeBookBuildBuildIdRecipeBookIdCompoundUniqueInput
  }

  export type RecipeBookBuildOrderByWithAggregationInput = {
    buildId?: SortOrder
    recipeBookId?: SortOrder
    _count?: RecipeBookBuildCountOrderByAggregateInput
    _avg?: RecipeBookBuildAvgOrderByAggregateInput
    _max?: RecipeBookBuildMaxOrderByAggregateInput
    _min?: RecipeBookBuildMinOrderByAggregateInput
    _sum?: RecipeBookBuildSumOrderByAggregateInput
  }

  export type RecipeBookBuildScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RecipeBookBuildScalarWhereWithAggregatesInput>
    OR?: Enumerable<RecipeBookBuildScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RecipeBookBuildScalarWhereWithAggregatesInput>
    buildId?: IntWithAggregatesFilter | number
    recipeBookId?: IntWithAggregatesFilter | number
  }

  export type TouchWhereInput = {
    AND?: Enumerable<TouchWhereInput>
    OR?: Enumerable<TouchWhereInput>
    NOT?: Enumerable<TouchWhereInput>
    id?: IntFilter | number
    build?: XOR<BuildRelationFilter, BuildWhereInput> | null
    buildId?: IntNullableFilter | number | null
    order?: IntNullableFilter | number | null
    amount?: FloatNullableFilter | number | null
    unit?: StringNullableFilter | string | null
    genericIngredientID?: IntFilter | number
    genericIngredient?: XOR<GenericIngredientRelationFilter, GenericIngredientWhereInput>
    specificIngredientID?: IntNullableFilter | number | null
    specificIngredient?: XOR<SpecificIngredientRelationFilter, SpecificIngredientWhereInput> | null
  }

  export type TouchOrderByWithRelationInput = {
    id?: SortOrder
    build?: BuildOrderByWithRelationInput
    buildId?: SortOrder
    order?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    genericIngredientID?: SortOrder
    genericIngredient?: GenericIngredientOrderByWithRelationInput
    specificIngredientID?: SortOrder
    specificIngredient?: SpecificIngredientOrderByWithRelationInput
  }

  export type TouchWhereUniqueInput = {
    id?: number
  }

  export type TouchOrderByWithAggregationInput = {
    id?: SortOrder
    buildId?: SortOrder
    order?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    genericIngredientID?: SortOrder
    specificIngredientID?: SortOrder
    _count?: TouchCountOrderByAggregateInput
    _avg?: TouchAvgOrderByAggregateInput
    _max?: TouchMaxOrderByAggregateInput
    _min?: TouchMinOrderByAggregateInput
    _sum?: TouchSumOrderByAggregateInput
  }

  export type TouchScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TouchScalarWhereWithAggregatesInput>
    OR?: Enumerable<TouchScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TouchScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    buildId?: IntNullableWithAggregatesFilter | number | null
    order?: IntNullableWithAggregatesFilter | number | null
    amount?: FloatNullableWithAggregatesFilter | number | null
    unit?: StringNullableWithAggregatesFilter | string | null
    genericIngredientID?: IntWithAggregatesFilter | number
    specificIngredientID?: IntNullableWithAggregatesFilter | number | null
  }

  export type GenericIngredientWhereInput = {
    AND?: Enumerable<GenericIngredientWhereInput>
    OR?: Enumerable<GenericIngredientWhereInput>
    NOT?: Enumerable<GenericIngredientWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    touch?: TouchListRelationFilter
    specificIngredient?: SpecificIngredientListRelationFilter
    ingredientPreference?: IngredientPreferenceListRelationFilter
  }

  export type GenericIngredientOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    touch?: TouchOrderByRelationAggregateInput
    specificIngredient?: SpecificIngredientOrderByRelationAggregateInput
    ingredientPreference?: IngredientPreferenceOrderByRelationAggregateInput
  }

  export type GenericIngredientWhereUniqueInput = {
    id?: number
  }

  export type GenericIngredientOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    _count?: GenericIngredientCountOrderByAggregateInput
    _avg?: GenericIngredientAvgOrderByAggregateInput
    _max?: GenericIngredientMaxOrderByAggregateInput
    _min?: GenericIngredientMinOrderByAggregateInput
    _sum?: GenericIngredientSumOrderByAggregateInput
  }

  export type GenericIngredientScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GenericIngredientScalarWhereWithAggregatesInput>
    OR?: Enumerable<GenericIngredientScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GenericIngredientScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
  }

  export type SpecificIngredientWhereInput = {
    AND?: Enumerable<SpecificIngredientWhereInput>
    OR?: Enumerable<SpecificIngredientWhereInput>
    NOT?: Enumerable<SpecificIngredientWhereInput>
    id?: IntFilter | number
    dateCreated?: DateTimeFilter | Date | string
    createdBy?: XOR<UserRelationFilter, UserWhereInput> | null
    createdById?: StringNullableFilter | string | null
    genericIngredientId?: IntFilter | number
    genericIngredient?: XOR<GenericIngredientRelationFilter, GenericIngredientWhereInput>
    name?: StringFilter | string
    description?: StringFilter | string
    price?: FloatNullableFilter | number | null
    amount?: FloatNullableFilter | number | null
    unit?: StringNullableFilter | string | null
    source?: StringNullableFilter | string | null
    touch?: TouchListRelationFilter
    ingredientStorage?: IngredientStorageListRelationFilter
    ingredientPreference?: IngredientPreferenceListRelationFilter
  }

  export type SpecificIngredientOrderByWithRelationInput = {
    id?: SortOrder
    dateCreated?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    createdById?: SortOrder
    genericIngredientId?: SortOrder
    genericIngredient?: GenericIngredientOrderByWithRelationInput
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    source?: SortOrder
    touch?: TouchOrderByRelationAggregateInput
    ingredientStorage?: IngredientStorageOrderByRelationAggregateInput
    ingredientPreference?: IngredientPreferenceOrderByRelationAggregateInput
  }

  export type SpecificIngredientWhereUniqueInput = {
    id?: number
  }

  export type SpecificIngredientOrderByWithAggregationInput = {
    id?: SortOrder
    dateCreated?: SortOrder
    createdById?: SortOrder
    genericIngredientId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    source?: SortOrder
    _count?: SpecificIngredientCountOrderByAggregateInput
    _avg?: SpecificIngredientAvgOrderByAggregateInput
    _max?: SpecificIngredientMaxOrderByAggregateInput
    _min?: SpecificIngredientMinOrderByAggregateInput
    _sum?: SpecificIngredientSumOrderByAggregateInput
  }

  export type SpecificIngredientScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SpecificIngredientScalarWhereWithAggregatesInput>
    OR?: Enumerable<SpecificIngredientScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SpecificIngredientScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    dateCreated?: DateTimeWithAggregatesFilter | Date | string
    createdById?: StringNullableWithAggregatesFilter | string | null
    genericIngredientId?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    price?: FloatNullableWithAggregatesFilter | number | null
    amount?: FloatNullableWithAggregatesFilter | number | null
    unit?: StringNullableWithAggregatesFilter | string | null
    source?: StringNullableWithAggregatesFilter | string | null
  }

  export type IngredientPreferenceWhereInput = {
    AND?: Enumerable<IngredientPreferenceWhereInput>
    OR?: Enumerable<IngredientPreferenceWhereInput>
    NOT?: Enumerable<IngredientPreferenceWhereInput>
    genericIngredientID?: IntFilter | number
    genericIngredient?: XOR<GenericIngredientRelationFilter, GenericIngredientWhereInput>
    specificIngredientID?: IntFilter | number
    specificIngredient?: XOR<SpecificIngredientRelationFilter, SpecificIngredientWhereInput>
    userId?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type IngredientPreferenceOrderByWithRelationInput = {
    genericIngredientID?: SortOrder
    genericIngredient?: GenericIngredientOrderByWithRelationInput
    specificIngredientID?: SortOrder
    specificIngredient?: SpecificIngredientOrderByWithRelationInput
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type IngredientPreferenceWhereUniqueInput = {
    genericIngredientID_specificIngredientID?: IngredientPreferenceGenericIngredientIDSpecificIngredientIDCompoundUniqueInput
  }

  export type IngredientPreferenceOrderByWithAggregationInput = {
    genericIngredientID?: SortOrder
    specificIngredientID?: SortOrder
    userId?: SortOrder
    _count?: IngredientPreferenceCountOrderByAggregateInput
    _avg?: IngredientPreferenceAvgOrderByAggregateInput
    _max?: IngredientPreferenceMaxOrderByAggregateInput
    _min?: IngredientPreferenceMinOrderByAggregateInput
    _sum?: IngredientPreferenceSumOrderByAggregateInput
  }

  export type IngredientPreferenceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<IngredientPreferenceScalarWhereWithAggregatesInput>
    OR?: Enumerable<IngredientPreferenceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<IngredientPreferenceScalarWhereWithAggregatesInput>
    genericIngredientID?: IntWithAggregatesFilter | number
    specificIngredientID?: IntWithAggregatesFilter | number
    userId?: StringWithAggregatesFilter | string
  }

  export type InventoryWhereInput = {
    AND?: Enumerable<InventoryWhereInput>
    OR?: Enumerable<InventoryWhereInput>
    NOT?: Enumerable<InventoryWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    editedAt?: DateTimeFilter | Date | string
    createdById?: StringFilter | string
    editedById?: StringFilter | string
    createdBy?: XOR<UserRelationFilter, UserWhereInput> | null
    editedBy?: XOR<UserRelationFilter, UserWhereInput> | null
    inventoryStorage?: InventoryStorageListRelationFilter
    inventoryUser?: InventoryUserListRelationFilter
  }

  export type InventoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    editedBy?: UserOrderByWithRelationInput
    inventoryStorage?: InventoryStorageOrderByRelationAggregateInput
    inventoryUser?: InventoryUserOrderByRelationAggregateInput
  }

  export type InventoryWhereUniqueInput = {
    id?: number
  }

  export type InventoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    _count?: InventoryCountOrderByAggregateInput
    _avg?: InventoryAvgOrderByAggregateInput
    _max?: InventoryMaxOrderByAggregateInput
    _min?: InventoryMinOrderByAggregateInput
    _sum?: InventorySumOrderByAggregateInput
  }

  export type InventoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InventoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<InventoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InventoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    editedAt?: DateTimeWithAggregatesFilter | Date | string
    createdById?: StringWithAggregatesFilter | string
    editedById?: StringWithAggregatesFilter | string
  }

  export type InventoryUserWhereInput = {
    AND?: Enumerable<InventoryUserWhereInput>
    OR?: Enumerable<InventoryUserWhereInput>
    NOT?: Enumerable<InventoryUserWhereInput>
    userId?: StringFilter | string
    inventoryId?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    inventory?: XOR<InventoryRelationFilter, InventoryWhereInput>
    permission?: StringFilter | string
  }

  export type InventoryUserOrderByWithRelationInput = {
    userId?: SortOrder
    inventoryId?: SortOrder
    user?: UserOrderByWithRelationInput
    inventory?: InventoryOrderByWithRelationInput
    permission?: SortOrder
  }

  export type InventoryUserWhereUniqueInput = {
    userId_inventoryId?: InventoryUserUserIdInventoryIdCompoundUniqueInput
  }

  export type InventoryUserOrderByWithAggregationInput = {
    userId?: SortOrder
    inventoryId?: SortOrder
    permission?: SortOrder
    _count?: InventoryUserCountOrderByAggregateInput
    _avg?: InventoryUserAvgOrderByAggregateInput
    _max?: InventoryUserMaxOrderByAggregateInput
    _min?: InventoryUserMinOrderByAggregateInput
    _sum?: InventoryUserSumOrderByAggregateInput
  }

  export type InventoryUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InventoryUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<InventoryUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InventoryUserScalarWhereWithAggregatesInput>
    userId?: StringWithAggregatesFilter | string
    inventoryId?: IntWithAggregatesFilter | number
    permission?: StringWithAggregatesFilter | string
  }

  export type StorageWhereInput = {
    AND?: Enumerable<StorageWhereInput>
    OR?: Enumerable<StorageWhereInput>
    NOT?: Enumerable<StorageWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    editedAt?: DateTimeFilter | Date | string
    createdById?: StringFilter | string
    editedById?: StringFilter | string
    createdBy?: XOR<UserRelationFilter, UserWhereInput> | null
    editedBy?: XOR<UserRelationFilter, UserWhereInput> | null
    inventoryStorage?: InventoryStorageListRelationFilter
    ingredientStorage?: IngredientStorageListRelationFilter
    storageUser?: StorageUserListRelationFilter
  }

  export type StorageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    editedBy?: UserOrderByWithRelationInput
    inventoryStorage?: InventoryStorageOrderByRelationAggregateInput
    ingredientStorage?: IngredientStorageOrderByRelationAggregateInput
    storageUser?: StorageUserOrderByRelationAggregateInput
  }

  export type StorageWhereUniqueInput = {
    id?: number
  }

  export type StorageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    _count?: StorageCountOrderByAggregateInput
    _avg?: StorageAvgOrderByAggregateInput
    _max?: StorageMaxOrderByAggregateInput
    _min?: StorageMinOrderByAggregateInput
    _sum?: StorageSumOrderByAggregateInput
  }

  export type StorageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StorageScalarWhereWithAggregatesInput>
    OR?: Enumerable<StorageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StorageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    editedAt?: DateTimeWithAggregatesFilter | Date | string
    createdById?: StringWithAggregatesFilter | string
    editedById?: StringWithAggregatesFilter | string
  }

  export type InventoryStorageWhereInput = {
    AND?: Enumerable<InventoryStorageWhereInput>
    OR?: Enumerable<InventoryStorageWhereInput>
    NOT?: Enumerable<InventoryStorageWhereInput>
    inventoryId?: IntFilter | number
    storageId?: IntFilter | number
    storage?: XOR<StorageRelationFilter, StorageWhereInput>
    inventory?: XOR<InventoryRelationFilter, InventoryWhereInput>
  }

  export type InventoryStorageOrderByWithRelationInput = {
    inventoryId?: SortOrder
    storageId?: SortOrder
    storage?: StorageOrderByWithRelationInput
    inventory?: InventoryOrderByWithRelationInput
  }

  export type InventoryStorageWhereUniqueInput = {
    inventoryId_storageId?: InventoryStorageInventoryIdStorageIdCompoundUniqueInput
  }

  export type InventoryStorageOrderByWithAggregationInput = {
    inventoryId?: SortOrder
    storageId?: SortOrder
    _count?: InventoryStorageCountOrderByAggregateInput
    _avg?: InventoryStorageAvgOrderByAggregateInput
    _max?: InventoryStorageMaxOrderByAggregateInput
    _min?: InventoryStorageMinOrderByAggregateInput
    _sum?: InventoryStorageSumOrderByAggregateInput
  }

  export type InventoryStorageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InventoryStorageScalarWhereWithAggregatesInput>
    OR?: Enumerable<InventoryStorageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InventoryStorageScalarWhereWithAggregatesInput>
    inventoryId?: IntWithAggregatesFilter | number
    storageId?: IntWithAggregatesFilter | number
  }

  export type IngredientStorageWhereInput = {
    AND?: Enumerable<IngredientStorageWhereInput>
    OR?: Enumerable<IngredientStorageWhereInput>
    NOT?: Enumerable<IngredientStorageWhereInput>
    ingredientId?: IntFilter | number
    ingredient?: XOR<SpecificIngredientRelationFilter, SpecificIngredientWhereInput>
    storageId?: IntFilter | number
    Storage?: XOR<StorageRelationFilter, StorageWhereInput>
    quantity?: FloatNullableFilter | number | null
  }

  export type IngredientStorageOrderByWithRelationInput = {
    ingredientId?: SortOrder
    ingredient?: SpecificIngredientOrderByWithRelationInput
    storageId?: SortOrder
    Storage?: StorageOrderByWithRelationInput
    quantity?: SortOrder
  }

  export type IngredientStorageWhereUniqueInput = {
    ingredientId_storageId?: IngredientStorageIngredientIdStorageIdCompoundUniqueInput
  }

  export type IngredientStorageOrderByWithAggregationInput = {
    ingredientId?: SortOrder
    storageId?: SortOrder
    quantity?: SortOrder
    _count?: IngredientStorageCountOrderByAggregateInput
    _avg?: IngredientStorageAvgOrderByAggregateInput
    _max?: IngredientStorageMaxOrderByAggregateInput
    _min?: IngredientStorageMinOrderByAggregateInput
    _sum?: IngredientStorageSumOrderByAggregateInput
  }

  export type IngredientStorageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<IngredientStorageScalarWhereWithAggregatesInput>
    OR?: Enumerable<IngredientStorageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<IngredientStorageScalarWhereWithAggregatesInput>
    ingredientId?: IntWithAggregatesFilter | number
    storageId?: IntWithAggregatesFilter | number
    quantity?: FloatNullableWithAggregatesFilter | number | null
  }

  export type StorageUserWhereInput = {
    AND?: Enumerable<StorageUserWhereInput>
    OR?: Enumerable<StorageUserWhereInput>
    NOT?: Enumerable<StorageUserWhereInput>
    userId?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    storageId?: IntFilter | number
    Storage?: XOR<StorageRelationFilter, StorageWhereInput>
    permission?: StringFilter | string
  }

  export type StorageUserOrderByWithRelationInput = {
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    storageId?: SortOrder
    Storage?: StorageOrderByWithRelationInput
    permission?: SortOrder
  }

  export type StorageUserWhereUniqueInput = {
    userId_storageId?: StorageUserUserIdStorageIdCompoundUniqueInput
  }

  export type StorageUserOrderByWithAggregationInput = {
    userId?: SortOrder
    storageId?: SortOrder
    permission?: SortOrder
    _count?: StorageUserCountOrderByAggregateInput
    _avg?: StorageUserAvgOrderByAggregateInput
    _max?: StorageUserMaxOrderByAggregateInput
    _min?: StorageUserMinOrderByAggregateInput
    _sum?: StorageUserSumOrderByAggregateInput
  }

  export type StorageUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StorageUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<StorageUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StorageUserScalarWhereWithAggregatesInput>
    userId?: StringWithAggregatesFilter | string
    storageId?: IntWithAggregatesFilter | number
    permission?: StringWithAggregatesFilter | string
  }

  export type CrewWhereInput = {
    AND?: Enumerable<CrewWhereInput>
    OR?: Enumerable<CrewWhereInput>
    NOT?: Enumerable<CrewWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    editedAt?: DateTimeFilter | Date | string
    createdById?: StringFilter | string
    editedById?: StringFilter | string
    createdBy?: XOR<UserRelationFilter, UserWhereInput> | null
    editedBy?: XOR<UserRelationFilter, UserWhereInput> | null
    userCrew?: UserCrewListRelationFilter
  }

  export type CrewOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    editedBy?: UserOrderByWithRelationInput
    userCrew?: UserCrewOrderByRelationAggregateInput
  }

  export type CrewWhereUniqueInput = {
    id?: number
  }

  export type CrewOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    _count?: CrewCountOrderByAggregateInput
    _avg?: CrewAvgOrderByAggregateInput
    _max?: CrewMaxOrderByAggregateInput
    _min?: CrewMinOrderByAggregateInput
    _sum?: CrewSumOrderByAggregateInput
  }

  export type CrewScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CrewScalarWhereWithAggregatesInput>
    OR?: Enumerable<CrewScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CrewScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    editedAt?: DateTimeWithAggregatesFilter | Date | string
    createdById?: StringWithAggregatesFilter | string
    editedById?: StringWithAggregatesFilter | string
  }

  export type UserCrewWhereInput = {
    AND?: Enumerable<UserCrewWhereInput>
    OR?: Enumerable<UserCrewWhereInput>
    NOT?: Enumerable<UserCrewWhereInput>
    userId?: StringFilter | string
    crewId?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    crew?: XOR<CrewRelationFilter, CrewWhereInput>
    permission?: StringFilter | string
  }

  export type UserCrewOrderByWithRelationInput = {
    userId?: SortOrder
    crewId?: SortOrder
    user?: UserOrderByWithRelationInput
    crew?: CrewOrderByWithRelationInput
    permission?: SortOrder
  }

  export type UserCrewWhereUniqueInput = {
    userId_crewId?: UserCrewUserIdCrewIdCompoundUniqueInput
  }

  export type UserCrewOrderByWithAggregationInput = {
    userId?: SortOrder
    crewId?: SortOrder
    permission?: SortOrder
    _count?: UserCrewCountOrderByAggregateInput
    _avg?: UserCrewAvgOrderByAggregateInput
    _max?: UserCrewMaxOrderByAggregateInput
    _min?: UserCrewMinOrderByAggregateInput
    _sum?: UserCrewSumOrderByAggregateInput
  }

  export type UserCrewScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserCrewScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserCrewScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserCrewScalarWhereWithAggregatesInput>
    userId?: StringWithAggregatesFilter | string
    crewId?: IntWithAggregatesFilter | number
    permission?: StringWithAggregatesFilter | string
  }

  export type UserCreateInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileCreateInput = {
    user: UserCreateNestedOneWithoutProfileInput
    photo: string
  }

  export type ProfileUncheckedCreateInput = {
    id?: number
    userId: string
    photo: string
  }

  export type ProfileUpdateInput = {
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    photo?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileCreateManyInput = {
    id?: number
    userId: string
    photo: string
  }

  export type ProfileUpdateManyMutationInput = {
    photo?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookCreateInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutRecipeBookInput
    editedBy?: UserCreateNestedOneWithoutRecipeBookEditedByIdInput
    recipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutRecipeBookInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    editedById?: string | null
    recipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutRecipeBookInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutRecipeBookNestedInput
    editedBy?: UserUpdateOneWithoutRecipeBookEditedByIdNestedInput
    recipeBookBuild?: RecipeBookBuildUpdateManyWithoutRecipeBookNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutRecipeBookNestedInput
  }

  export type RecipeBookUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutRecipeBookNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutRecipeBookNestedInput
  }

  export type RecipeBookCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    editedById?: string | null
  }

  export type RecipeBookUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipeBookUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeBookUserCreateInput = {
    recipeBook: RecipeBookCreateNestedOneWithoutRecipeBookUserInput
    user: UserCreateNestedOneWithoutRecipeBookUserInput
    permission: string
  }

  export type RecipeBookUserUncheckedCreateInput = {
    userId: string
    recipeBookId: number
    permission: string
  }

  export type RecipeBookUserUpdateInput = {
    recipeBook?: RecipeBookUpdateOneRequiredWithoutRecipeBookUserNestedInput
    user?: UserUpdateOneRequiredWithoutRecipeBookUserNestedInput
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookUserUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    recipeBookId?: IntFieldUpdateOperationsInput | number
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookUserCreateManyInput = {
    userId: string
    recipeBookId: number
    permission: string
  }

  export type RecipeBookUserUpdateManyMutationInput = {
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookUserUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    recipeBookId?: IntFieldUpdateOperationsInput | number
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type BuildCreateInput = {
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutBuildInput
    editedBy?: UserCreateNestedOneWithoutBuildEditedByInput
    recipe?: RecipeCreateNestedOneWithoutBuildInput
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    touch?: TouchCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserCreateNestedManyWithoutBuildInput
  }

  export type BuildUncheckedCreateInput = {
    id?: number
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    recipeId?: number | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutBuildInput
  }

  export type BuildUpdateInput = {
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutBuildNestedInput
    editedBy?: UserUpdateOneWithoutBuildEditedByNestedInput
    recipe?: RecipeUpdateOneWithoutBuildNestedInput
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutBuildNestedInput
  }

  export type BuildCreateManyInput = {
    id?: number
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    recipeId?: number | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
  }

  export type BuildUpdateManyMutationInput = {
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BuildUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BuildUserCreateInput = {
    user: UserCreateNestedOneWithoutBuildUserInput
    build: BuildCreateNestedOneWithoutBuildUserInput
    permission: string
  }

  export type BuildUserUncheckedCreateInput = {
    userId: string
    buildId: number
    permission: string
  }

  export type BuildUserUpdateInput = {
    user?: UserUpdateOneRequiredWithoutBuildUserNestedInput
    build?: BuildUpdateOneRequiredWithoutBuildUserNestedInput
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type BuildUserUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    buildId?: IntFieldUpdateOperationsInput | number
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type BuildUserCreateManyInput = {
    userId: string
    buildId: number
    permission: string
  }

  export type BuildUserUpdateManyMutationInput = {
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type BuildUserUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    buildId?: IntFieldUpdateOperationsInput | number
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeCreateInput = {
    createdAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    createdBy: UserCreateNestedOneWithoutRecipeInput
    build?: BuildCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    createdById: string
    build?: BuildUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneRequiredWithoutRecipeNestedInput
    build?: BuildUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    build?: BuildUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeCreateManyInput = {
    id?: number
    createdAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    createdById: string
  }

  export type RecipeUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookBuildCreateInput = {
    recipeBook: RecipeBookCreateNestedOneWithoutRecipeBookBuildInput
    build: BuildCreateNestedOneWithoutRecipeBookBuildInput
  }

  export type RecipeBookBuildUncheckedCreateInput = {
    buildId: number
    recipeBookId: number
  }

  export type RecipeBookBuildUpdateInput = {
    recipeBook?: RecipeBookUpdateOneRequiredWithoutRecipeBookBuildNestedInput
    build?: BuildUpdateOneRequiredWithoutRecipeBookBuildNestedInput
  }

  export type RecipeBookBuildUncheckedUpdateInput = {
    buildId?: IntFieldUpdateOperationsInput | number
    recipeBookId?: IntFieldUpdateOperationsInput | number
  }

  export type RecipeBookBuildCreateManyInput = {
    buildId: number
    recipeBookId: number
  }

  export type RecipeBookBuildUpdateManyMutationInput = {

  }

  export type RecipeBookBuildUncheckedUpdateManyInput = {
    buildId?: IntFieldUpdateOperationsInput | number
    recipeBookId?: IntFieldUpdateOperationsInput | number
  }

  export type TouchCreateInput = {
    build?: BuildCreateNestedOneWithoutTouchInput
    order?: number | null
    amount?: number | null
    unit?: string | null
    genericIngredient: GenericIngredientCreateNestedOneWithoutTouchInput
    specificIngredient?: SpecificIngredientCreateNestedOneWithoutTouchInput
  }

  export type TouchUncheckedCreateInput = {
    id?: number
    buildId?: number | null
    order?: number | null
    amount?: number | null
    unit?: string | null
    genericIngredientID: number
    specificIngredientID?: number | null
  }

  export type TouchUpdateInput = {
    build?: BuildUpdateOneWithoutTouchNestedInput
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    genericIngredient?: GenericIngredientUpdateOneRequiredWithoutTouchNestedInput
    specificIngredient?: SpecificIngredientUpdateOneWithoutTouchNestedInput
  }

  export type TouchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildId?: NullableIntFieldUpdateOperationsInput | number | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    genericIngredientID?: IntFieldUpdateOperationsInput | number
    specificIngredientID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TouchCreateManyInput = {
    id?: number
    buildId?: number | null
    order?: number | null
    amount?: number | null
    unit?: string | null
    genericIngredientID: number
    specificIngredientID?: number | null
  }

  export type TouchUpdateManyMutationInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TouchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildId?: NullableIntFieldUpdateOperationsInput | number | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    genericIngredientID?: IntFieldUpdateOperationsInput | number
    specificIngredientID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GenericIngredientCreateInput = {
    name: string
    description?: string | null
    touch?: TouchCreateNestedManyWithoutGenericIngredientInput
    specificIngredient?: SpecificIngredientCreateNestedManyWithoutGenericIngredientInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutGenericIngredientInput
  }

  export type GenericIngredientUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutGenericIngredientInput
    specificIngredient?: SpecificIngredientUncheckedCreateNestedManyWithoutGenericIngredientInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutGenericIngredientInput
  }

  export type GenericIngredientUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUpdateManyWithoutGenericIngredientNestedInput
    specificIngredient?: SpecificIngredientUpdateManyWithoutGenericIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutGenericIngredientNestedInput
  }

  export type GenericIngredientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutGenericIngredientNestedInput
    specificIngredient?: SpecificIngredientUncheckedUpdateManyWithoutGenericIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutGenericIngredientNestedInput
  }

  export type GenericIngredientCreateManyInput = {
    id?: number
    name: string
    description?: string | null
  }

  export type GenericIngredientUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GenericIngredientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpecificIngredientCreateInput = {
    dateCreated?: Date | string
    createdBy?: UserCreateNestedOneWithoutIngredientInput
    genericIngredient: GenericIngredientCreateNestedOneWithoutSpecificIngredientInput
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    touch?: TouchCreateNestedManyWithoutSpecificIngredientInput
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutSpecificIngredientInput
  }

  export type SpecificIngredientUncheckedCreateInput = {
    id?: number
    dateCreated?: Date | string
    createdById?: string | null
    genericIngredientId: number
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutSpecificIngredientInput
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutSpecificIngredientInput
  }

  export type SpecificIngredientUpdateInput = {
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutIngredientNestedInput
    genericIngredient?: GenericIngredientUpdateOneRequiredWithoutSpecificIngredientNestedInput
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUpdateManyWithoutSpecificIngredientNestedInput
    ingredientStorage?: IngredientStorageUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutSpecificIngredientNestedInput
  }

  export type SpecificIngredientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    genericIngredientId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutSpecificIngredientNestedInput
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutSpecificIngredientNestedInput
  }

  export type SpecificIngredientCreateManyInput = {
    id?: number
    dateCreated?: Date | string
    createdById?: string | null
    genericIngredientId: number
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
  }

  export type SpecificIngredientUpdateManyMutationInput = {
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpecificIngredientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    genericIngredientId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IngredientPreferenceCreateInput = {
    genericIngredient: GenericIngredientCreateNestedOneWithoutIngredientPreferenceInput
    specificIngredient: SpecificIngredientCreateNestedOneWithoutIngredientPreferenceInput
    user: UserCreateNestedOneWithoutIngredientPreferenceInput
  }

  export type IngredientPreferenceUncheckedCreateInput = {
    genericIngredientID: number
    specificIngredientID: number
    userId: string
  }

  export type IngredientPreferenceUpdateInput = {
    genericIngredient?: GenericIngredientUpdateOneRequiredWithoutIngredientPreferenceNestedInput
    specificIngredient?: SpecificIngredientUpdateOneRequiredWithoutIngredientPreferenceNestedInput
    user?: UserUpdateOneRequiredWithoutIngredientPreferenceNestedInput
  }

  export type IngredientPreferenceUncheckedUpdateInput = {
    genericIngredientID?: IntFieldUpdateOperationsInput | number
    specificIngredientID?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type IngredientPreferenceCreateManyInput = {
    genericIngredientID: number
    specificIngredientID: number
    userId: string
  }

  export type IngredientPreferenceUpdateManyMutationInput = {

  }

  export type IngredientPreferenceUncheckedUpdateManyInput = {
    genericIngredientID?: IntFieldUpdateOperationsInput | number
    specificIngredientID?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryCreateInput = {
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutInventoryCreatedByInput
    editedBy?: UserCreateNestedOneWithoutInventoryEditedByInput
    inventoryStorage?: InventoryStorageCreateNestedManyWithoutInventoryInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    inventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutInventoryInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutInventoryCreatedByNestedInput
    editedBy?: UserUpdateOneWithoutInventoryEditedByNestedInput
    inventoryStorage?: InventoryStorageUpdateManyWithoutInventoryNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    inventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutInventoryNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
  }

  export type InventoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryUserCreateInput = {
    user: UserCreateNestedOneWithoutInventoryUserInput
    inventory: InventoryCreateNestedOneWithoutInventoryUserInput
    permission: string
  }

  export type InventoryUserUncheckedCreateInput = {
    userId: string
    inventoryId: number
    permission: string
  }

  export type InventoryUserUpdateInput = {
    user?: UserUpdateOneRequiredWithoutInventoryUserNestedInput
    inventory?: InventoryUpdateOneRequiredWithoutInventoryUserNestedInput
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryUserUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    inventoryId?: IntFieldUpdateOperationsInput | number
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryUserCreateManyInput = {
    userId: string
    inventoryId: number
    permission: string
  }

  export type InventoryUserUpdateManyMutationInput = {
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryUserUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    inventoryId?: IntFieldUpdateOperationsInput | number
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type StorageCreateInput = {
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutStorageInput
    editedBy?: UserCreateNestedOneWithoutStorageEditedByInput
    inventoryStorage?: InventoryStorageCreateNestedManyWithoutStorageInput
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutStorageInput
    storageUser?: StorageUserCreateNestedManyWithoutStorageInput
  }

  export type StorageUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    inventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutStorageInput
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutStorageInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutStorageInput
  }

  export type StorageUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutStorageNestedInput
    editedBy?: UserUpdateOneWithoutStorageEditedByNestedInput
    inventoryStorage?: InventoryStorageUpdateManyWithoutStorageNestedInput
    ingredientStorage?: IngredientStorageUpdateManyWithoutStorageNestedInput
    storageUser?: StorageUserUpdateManyWithoutStorageNestedInput
  }

  export type StorageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    inventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutStorageNestedInput
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutStorageNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutStorageNestedInput
  }

  export type StorageCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
  }

  export type StorageUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryStorageCreateInput = {
    storage: StorageCreateNestedOneWithoutInventoryStorageInput
    inventory: InventoryCreateNestedOneWithoutInventoryStorageInput
  }

  export type InventoryStorageUncheckedCreateInput = {
    inventoryId: number
    storageId: number
  }

  export type InventoryStorageUpdateInput = {
    storage?: StorageUpdateOneRequiredWithoutInventoryStorageNestedInput
    inventory?: InventoryUpdateOneRequiredWithoutInventoryStorageNestedInput
  }

  export type InventoryStorageUncheckedUpdateInput = {
    inventoryId?: IntFieldUpdateOperationsInput | number
    storageId?: IntFieldUpdateOperationsInput | number
  }

  export type InventoryStorageCreateManyInput = {
    inventoryId: number
    storageId: number
  }

  export type InventoryStorageUpdateManyMutationInput = {

  }

  export type InventoryStorageUncheckedUpdateManyInput = {
    inventoryId?: IntFieldUpdateOperationsInput | number
    storageId?: IntFieldUpdateOperationsInput | number
  }

  export type IngredientStorageCreateInput = {
    ingredient: SpecificIngredientCreateNestedOneWithoutIngredientStorageInput
    Storage: StorageCreateNestedOneWithoutIngredientStorageInput
    quantity?: number | null
  }

  export type IngredientStorageUncheckedCreateInput = {
    ingredientId: number
    storageId: number
    quantity?: number | null
  }

  export type IngredientStorageUpdateInput = {
    ingredient?: SpecificIngredientUpdateOneRequiredWithoutIngredientStorageNestedInput
    Storage?: StorageUpdateOneRequiredWithoutIngredientStorageNestedInput
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type IngredientStorageUncheckedUpdateInput = {
    ingredientId?: IntFieldUpdateOperationsInput | number
    storageId?: IntFieldUpdateOperationsInput | number
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type IngredientStorageCreateManyInput = {
    ingredientId: number
    storageId: number
    quantity?: number | null
  }

  export type IngredientStorageUpdateManyMutationInput = {
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type IngredientStorageUncheckedUpdateManyInput = {
    ingredientId?: IntFieldUpdateOperationsInput | number
    storageId?: IntFieldUpdateOperationsInput | number
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type StorageUserCreateInput = {
    user: UserCreateNestedOneWithoutStorageUserInput
    Storage: StorageCreateNestedOneWithoutStorageUserInput
    permission: string
  }

  export type StorageUserUncheckedCreateInput = {
    userId: string
    storageId: number
    permission: string
  }

  export type StorageUserUpdateInput = {
    user?: UserUpdateOneRequiredWithoutStorageUserNestedInput
    Storage?: StorageUpdateOneRequiredWithoutStorageUserNestedInput
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type StorageUserUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    storageId?: IntFieldUpdateOperationsInput | number
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type StorageUserCreateManyInput = {
    userId: string
    storageId: number
    permission: string
  }

  export type StorageUserUpdateManyMutationInput = {
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type StorageUserUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    storageId?: IntFieldUpdateOperationsInput | number
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type CrewCreateInput = {
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCrewInput
    editedBy?: UserCreateNestedOneWithoutCrewEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutCrewInput
  }

  export type CrewUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutCrewInput
  }

  export type CrewUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCrewNestedInput
    editedBy?: UserUpdateOneWithoutCrewEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutCrewNestedInput
  }

  export type CrewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    userCrew?: UserCrewUncheckedUpdateManyWithoutCrewNestedInput
  }

  export type CrewCreateManyInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
  }

  export type CrewUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
  }

  export type UserCrewCreateInput = {
    user: UserCreateNestedOneWithoutUserCrewInput
    crew: CrewCreateNestedOneWithoutUserCrewInput
    permission: string
  }

  export type UserCrewUncheckedCreateInput = {
    userId: string
    crewId: number
    permission: string
  }

  export type UserCrewUpdateInput = {
    user?: UserUpdateOneRequiredWithoutUserCrewNestedInput
    crew?: CrewUpdateOneRequiredWithoutUserCrewNestedInput
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type UserCrewUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    crewId?: IntFieldUpdateOperationsInput | number
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type UserCrewCreateManyInput = {
    userId: string
    crewId: number
    permission: string
  }

  export type UserCrewUpdateManyMutationInput = {
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type UserCrewUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    crewId?: IntFieldUpdateOperationsInput | number
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type ProfileRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type RecipeBookUserListRelationFilter = {
    every?: RecipeBookUserWhereInput
    some?: RecipeBookUserWhereInput
    none?: RecipeBookUserWhereInput
  }

  export type RecipeBookListRelationFilter = {
    every?: RecipeBookWhereInput
    some?: RecipeBookWhereInput
    none?: RecipeBookWhereInput
  }

  export type RecipeListRelationFilter = {
    every?: RecipeWhereInput
    some?: RecipeWhereInput
    none?: RecipeWhereInput
  }

  export type BuildUserListRelationFilter = {
    every?: BuildUserWhereInput
    some?: BuildUserWhereInput
    none?: BuildUserWhereInput
  }

  export type BuildListRelationFilter = {
    every?: BuildWhereInput
    some?: BuildWhereInput
    none?: BuildWhereInput
  }

  export type UserCrewListRelationFilter = {
    every?: UserCrewWhereInput
    some?: UserCrewWhereInput
    none?: UserCrewWhereInput
  }

  export type CrewListRelationFilter = {
    every?: CrewWhereInput
    some?: CrewWhereInput
    none?: CrewWhereInput
  }

  export type SpecificIngredientListRelationFilter = {
    every?: SpecificIngredientWhereInput
    some?: SpecificIngredientWhereInput
    none?: SpecificIngredientWhereInput
  }

  export type IngredientPreferenceListRelationFilter = {
    every?: IngredientPreferenceWhereInput
    some?: IngredientPreferenceWhereInput
    none?: IngredientPreferenceWhereInput
  }

  export type StorageUserListRelationFilter = {
    every?: StorageUserWhereInput
    some?: StorageUserWhereInput
    none?: StorageUserWhereInput
  }

  export type StorageListRelationFilter = {
    every?: StorageWhereInput
    some?: StorageWhereInput
    none?: StorageWhereInput
  }

  export type InventoryListRelationFilter = {
    every?: InventoryWhereInput
    some?: InventoryWhereInput
    none?: InventoryWhereInput
  }

  export type InventoryUserListRelationFilter = {
    every?: InventoryUserWhereInput
    some?: InventoryUserWhereInput
    none?: InventoryUserWhereInput
  }

  export type RecipeBookUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipeBookOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BuildUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BuildOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCrewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CrewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpecificIngredientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IngredientPreferenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StorageUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StorageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    userName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateJoined?: SortOrder
    lastEdited?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    userName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateJoined?: SortOrder
    lastEdited?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    userName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateJoined?: SortOrder
    lastEdited?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    photo?: SortOrder
  }

  export type ProfileAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    photo?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    photo?: SortOrder
  }

  export type ProfileSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type RecipeBookBuildListRelationFilter = {
    every?: RecipeBookBuildWhereInput
    some?: RecipeBookBuildWhereInput
    none?: RecipeBookBuildWhereInput
  }

  export type RecipeBookBuildOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipeBookCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type RecipeBookAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RecipeBookMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type RecipeBookMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type RecipeBookSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RecipeBookRelationFilter = {
    is?: RecipeBookWhereInput
    isNot?: RecipeBookWhereInput
  }

  export type RecipeBookUserUserIdRecipeBookIdCompoundUniqueInput = {
    userId: string
    recipeBookId: number
  }

  export type RecipeBookUserCountOrderByAggregateInput = {
    userId?: SortOrder
    recipeBookId?: SortOrder
    permission?: SortOrder
  }

  export type RecipeBookUserAvgOrderByAggregateInput = {
    recipeBookId?: SortOrder
  }

  export type RecipeBookUserMaxOrderByAggregateInput = {
    userId?: SortOrder
    recipeBookId?: SortOrder
    permission?: SortOrder
  }

  export type RecipeBookUserMinOrderByAggregateInput = {
    userId?: SortOrder
    recipeBookId?: SortOrder
    permission?: SortOrder
  }

  export type RecipeBookUserSumOrderByAggregateInput = {
    recipeBookId?: SortOrder
  }

  export type RecipeRelationFilter = {
    is?: RecipeWhereInput | null
    isNot?: RecipeWhereInput | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type TouchListRelationFilter = {
    every?: TouchWhereInput
    some?: TouchWhereInput
    none?: TouchWhereInput
  }

  export type TouchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BuildCountOrderByAggregateInput = {
    id?: SortOrder
    buildName?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    recipeId?: SortOrder
    instructions?: SortOrder
    notes?: SortOrder
    glassware?: SortOrder
    ice?: SortOrder
  }

  export type BuildAvgOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
  }

  export type BuildMaxOrderByAggregateInput = {
    id?: SortOrder
    buildName?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    recipeId?: SortOrder
    instructions?: SortOrder
    notes?: SortOrder
    glassware?: SortOrder
    ice?: SortOrder
  }

  export type BuildMinOrderByAggregateInput = {
    id?: SortOrder
    buildName?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    recipeId?: SortOrder
    instructions?: SortOrder
    notes?: SortOrder
    glassware?: SortOrder
    ice?: SortOrder
  }

  export type BuildSumOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type BuildRelationFilter = {
    is?: BuildWhereInput | null
    isNot?: BuildWhereInput | null
  }

  export type BuildUserUserIdBuildIdCompoundUniqueInput = {
    userId: string
    buildId: number
  }

  export type BuildUserCountOrderByAggregateInput = {
    userId?: SortOrder
    buildId?: SortOrder
    permission?: SortOrder
  }

  export type BuildUserAvgOrderByAggregateInput = {
    buildId?: SortOrder
  }

  export type BuildUserMaxOrderByAggregateInput = {
    userId?: SortOrder
    buildId?: SortOrder
    permission?: SortOrder
  }

  export type BuildUserMinOrderByAggregateInput = {
    userId?: SortOrder
    buildId?: SortOrder
    permission?: SortOrder
  }

  export type BuildUserSumOrderByAggregateInput = {
    buildId?: SortOrder
  }

  export type RecipeCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    origin?: SortOrder
    history?: SortOrder
    createdById?: SortOrder
  }

  export type RecipeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RecipeMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    origin?: SortOrder
    history?: SortOrder
    createdById?: SortOrder
  }

  export type RecipeMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    origin?: SortOrder
    history?: SortOrder
    createdById?: SortOrder
  }

  export type RecipeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RecipeBookBuildBuildIdRecipeBookIdCompoundUniqueInput = {
    buildId: number
    recipeBookId: number
  }

  export type RecipeBookBuildCountOrderByAggregateInput = {
    buildId?: SortOrder
    recipeBookId?: SortOrder
  }

  export type RecipeBookBuildAvgOrderByAggregateInput = {
    buildId?: SortOrder
    recipeBookId?: SortOrder
  }

  export type RecipeBookBuildMaxOrderByAggregateInput = {
    buildId?: SortOrder
    recipeBookId?: SortOrder
  }

  export type RecipeBookBuildMinOrderByAggregateInput = {
    buildId?: SortOrder
    recipeBookId?: SortOrder
  }

  export type RecipeBookBuildSumOrderByAggregateInput = {
    buildId?: SortOrder
    recipeBookId?: SortOrder
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type GenericIngredientRelationFilter = {
    is?: GenericIngredientWhereInput
    isNot?: GenericIngredientWhereInput
  }

  export type SpecificIngredientRelationFilter = {
    is?: SpecificIngredientWhereInput
    isNot?: SpecificIngredientWhereInput
  }

  export type TouchCountOrderByAggregateInput = {
    id?: SortOrder
    buildId?: SortOrder
    order?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    genericIngredientID?: SortOrder
    specificIngredientID?: SortOrder
  }

  export type TouchAvgOrderByAggregateInput = {
    id?: SortOrder
    buildId?: SortOrder
    order?: SortOrder
    amount?: SortOrder
    genericIngredientID?: SortOrder
    specificIngredientID?: SortOrder
  }

  export type TouchMaxOrderByAggregateInput = {
    id?: SortOrder
    buildId?: SortOrder
    order?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    genericIngredientID?: SortOrder
    specificIngredientID?: SortOrder
  }

  export type TouchMinOrderByAggregateInput = {
    id?: SortOrder
    buildId?: SortOrder
    order?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    genericIngredientID?: SortOrder
    specificIngredientID?: SortOrder
  }

  export type TouchSumOrderByAggregateInput = {
    id?: SortOrder
    buildId?: SortOrder
    order?: SortOrder
    amount?: SortOrder
    genericIngredientID?: SortOrder
    specificIngredientID?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type GenericIngredientCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type GenericIngredientAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GenericIngredientMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type GenericIngredientMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type GenericIngredientSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IngredientStorageListRelationFilter = {
    every?: IngredientStorageWhereInput
    some?: IngredientStorageWhereInput
    none?: IngredientStorageWhereInput
  }

  export type IngredientStorageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpecificIngredientCountOrderByAggregateInput = {
    id?: SortOrder
    dateCreated?: SortOrder
    createdById?: SortOrder
    genericIngredientId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    source?: SortOrder
  }

  export type SpecificIngredientAvgOrderByAggregateInput = {
    id?: SortOrder
    genericIngredientId?: SortOrder
    price?: SortOrder
    amount?: SortOrder
  }

  export type SpecificIngredientMaxOrderByAggregateInput = {
    id?: SortOrder
    dateCreated?: SortOrder
    createdById?: SortOrder
    genericIngredientId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    source?: SortOrder
  }

  export type SpecificIngredientMinOrderByAggregateInput = {
    id?: SortOrder
    dateCreated?: SortOrder
    createdById?: SortOrder
    genericIngredientId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    source?: SortOrder
  }

  export type SpecificIngredientSumOrderByAggregateInput = {
    id?: SortOrder
    genericIngredientId?: SortOrder
    price?: SortOrder
    amount?: SortOrder
  }

  export type IngredientPreferenceGenericIngredientIDSpecificIngredientIDCompoundUniqueInput = {
    genericIngredientID: number
    specificIngredientID: number
  }

  export type IngredientPreferenceCountOrderByAggregateInput = {
    genericIngredientID?: SortOrder
    specificIngredientID?: SortOrder
    userId?: SortOrder
  }

  export type IngredientPreferenceAvgOrderByAggregateInput = {
    genericIngredientID?: SortOrder
    specificIngredientID?: SortOrder
  }

  export type IngredientPreferenceMaxOrderByAggregateInput = {
    genericIngredientID?: SortOrder
    specificIngredientID?: SortOrder
    userId?: SortOrder
  }

  export type IngredientPreferenceMinOrderByAggregateInput = {
    genericIngredientID?: SortOrder
    specificIngredientID?: SortOrder
    userId?: SortOrder
  }

  export type IngredientPreferenceSumOrderByAggregateInput = {
    genericIngredientID?: SortOrder
    specificIngredientID?: SortOrder
  }

  export type InventoryStorageListRelationFilter = {
    every?: InventoryStorageWhereInput
    some?: InventoryStorageWhereInput
    none?: InventoryStorageWhereInput
  }

  export type InventoryStorageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type InventoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type InventoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type InventoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type InventorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type InventoryRelationFilter = {
    is?: InventoryWhereInput
    isNot?: InventoryWhereInput
  }

  export type InventoryUserUserIdInventoryIdCompoundUniqueInput = {
    userId: string
    inventoryId: number
  }

  export type InventoryUserCountOrderByAggregateInput = {
    userId?: SortOrder
    inventoryId?: SortOrder
    permission?: SortOrder
  }

  export type InventoryUserAvgOrderByAggregateInput = {
    inventoryId?: SortOrder
  }

  export type InventoryUserMaxOrderByAggregateInput = {
    userId?: SortOrder
    inventoryId?: SortOrder
    permission?: SortOrder
  }

  export type InventoryUserMinOrderByAggregateInput = {
    userId?: SortOrder
    inventoryId?: SortOrder
    permission?: SortOrder
  }

  export type InventoryUserSumOrderByAggregateInput = {
    inventoryId?: SortOrder
  }

  export type StorageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type StorageAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StorageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type StorageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type StorageSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StorageRelationFilter = {
    is?: StorageWhereInput
    isNot?: StorageWhereInput
  }

  export type InventoryStorageInventoryIdStorageIdCompoundUniqueInput = {
    inventoryId: number
    storageId: number
  }

  export type InventoryStorageCountOrderByAggregateInput = {
    inventoryId?: SortOrder
    storageId?: SortOrder
  }

  export type InventoryStorageAvgOrderByAggregateInput = {
    inventoryId?: SortOrder
    storageId?: SortOrder
  }

  export type InventoryStorageMaxOrderByAggregateInput = {
    inventoryId?: SortOrder
    storageId?: SortOrder
  }

  export type InventoryStorageMinOrderByAggregateInput = {
    inventoryId?: SortOrder
    storageId?: SortOrder
  }

  export type InventoryStorageSumOrderByAggregateInput = {
    inventoryId?: SortOrder
    storageId?: SortOrder
  }

  export type IngredientStorageIngredientIdStorageIdCompoundUniqueInput = {
    ingredientId: number
    storageId: number
  }

  export type IngredientStorageCountOrderByAggregateInput = {
    ingredientId?: SortOrder
    storageId?: SortOrder
    quantity?: SortOrder
  }

  export type IngredientStorageAvgOrderByAggregateInput = {
    ingredientId?: SortOrder
    storageId?: SortOrder
    quantity?: SortOrder
  }

  export type IngredientStorageMaxOrderByAggregateInput = {
    ingredientId?: SortOrder
    storageId?: SortOrder
    quantity?: SortOrder
  }

  export type IngredientStorageMinOrderByAggregateInput = {
    ingredientId?: SortOrder
    storageId?: SortOrder
    quantity?: SortOrder
  }

  export type IngredientStorageSumOrderByAggregateInput = {
    ingredientId?: SortOrder
    storageId?: SortOrder
    quantity?: SortOrder
  }

  export type StorageUserUserIdStorageIdCompoundUniqueInput = {
    userId: string
    storageId: number
  }

  export type StorageUserCountOrderByAggregateInput = {
    userId?: SortOrder
    storageId?: SortOrder
    permission?: SortOrder
  }

  export type StorageUserAvgOrderByAggregateInput = {
    storageId?: SortOrder
  }

  export type StorageUserMaxOrderByAggregateInput = {
    userId?: SortOrder
    storageId?: SortOrder
    permission?: SortOrder
  }

  export type StorageUserMinOrderByAggregateInput = {
    userId?: SortOrder
    storageId?: SortOrder
    permission?: SortOrder
  }

  export type StorageUserSumOrderByAggregateInput = {
    storageId?: SortOrder
  }

  export type CrewCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type CrewAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CrewMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type CrewMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type CrewSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CrewRelationFilter = {
    is?: CrewWhereInput
    isNot?: CrewWhereInput
  }

  export type UserCrewUserIdCrewIdCompoundUniqueInput = {
    userId: string
    crewId: number
  }

  export type UserCrewCountOrderByAggregateInput = {
    userId?: SortOrder
    crewId?: SortOrder
    permission?: SortOrder
  }

  export type UserCrewAvgOrderByAggregateInput = {
    crewId?: SortOrder
  }

  export type UserCrewMaxOrderByAggregateInput = {
    userId?: SortOrder
    crewId?: SortOrder
    permission?: SortOrder
  }

  export type UserCrewMinOrderByAggregateInput = {
    userId?: SortOrder
    crewId?: SortOrder
    permission?: SortOrder
  }

  export type UserCrewSumOrderByAggregateInput = {
    crewId?: SortOrder
  }

  export type ProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type RecipeBookUserCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<RecipeBookUserCreateWithoutUserInput>, Enumerable<RecipeBookUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RecipeBookUserCreateOrConnectWithoutUserInput>
    createMany?: RecipeBookUserCreateManyUserInputEnvelope
    connect?: Enumerable<RecipeBookUserWhereUniqueInput>
  }

  export type RecipeBookCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<RecipeBookCreateWithoutCreatedByInput>, Enumerable<RecipeBookUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<RecipeBookCreateOrConnectWithoutCreatedByInput>
    createMany?: RecipeBookCreateManyCreatedByInputEnvelope
    connect?: Enumerable<RecipeBookWhereUniqueInput>
  }

  export type RecipeBookCreateNestedManyWithoutEditedByInput = {
    create?: XOR<Enumerable<RecipeBookCreateWithoutEditedByInput>, Enumerable<RecipeBookUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<RecipeBookCreateOrConnectWithoutEditedByInput>
    createMany?: RecipeBookCreateManyEditedByInputEnvelope
    connect?: Enumerable<RecipeBookWhereUniqueInput>
  }

  export type RecipeCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<RecipeCreateWithoutCreatedByInput>, Enumerable<RecipeUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<RecipeCreateOrConnectWithoutCreatedByInput>
    createMany?: RecipeCreateManyCreatedByInputEnvelope
    connect?: Enumerable<RecipeWhereUniqueInput>
  }

  export type BuildUserCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<BuildUserCreateWithoutUserInput>, Enumerable<BuildUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BuildUserCreateOrConnectWithoutUserInput>
    createMany?: BuildUserCreateManyUserInputEnvelope
    connect?: Enumerable<BuildUserWhereUniqueInput>
  }

  export type BuildCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<BuildCreateWithoutCreatedByInput>, Enumerable<BuildUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutCreatedByInput>
    createMany?: BuildCreateManyCreatedByInputEnvelope
    connect?: Enumerable<BuildWhereUniqueInput>
  }

  export type BuildCreateNestedManyWithoutEditedByInput = {
    create?: XOR<Enumerable<BuildCreateWithoutEditedByInput>, Enumerable<BuildUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutEditedByInput>
    createMany?: BuildCreateManyEditedByInputEnvelope
    connect?: Enumerable<BuildWhereUniqueInput>
  }

  export type UserCrewCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserCrewCreateWithoutUserInput>, Enumerable<UserCrewUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserCrewCreateOrConnectWithoutUserInput>
    createMany?: UserCrewCreateManyUserInputEnvelope
    connect?: Enumerable<UserCrewWhereUniqueInput>
  }

  export type CrewCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<CrewCreateWithoutCreatedByInput>, Enumerable<CrewUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<CrewCreateOrConnectWithoutCreatedByInput>
    createMany?: CrewCreateManyCreatedByInputEnvelope
    connect?: Enumerable<CrewWhereUniqueInput>
  }

  export type CrewCreateNestedManyWithoutEditedByInput = {
    create?: XOR<Enumerable<CrewCreateWithoutEditedByInput>, Enumerable<CrewUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<CrewCreateOrConnectWithoutEditedByInput>
    createMany?: CrewCreateManyEditedByInputEnvelope
    connect?: Enumerable<CrewWhereUniqueInput>
  }

  export type SpecificIngredientCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<SpecificIngredientCreateWithoutCreatedByInput>, Enumerable<SpecificIngredientUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<SpecificIngredientCreateOrConnectWithoutCreatedByInput>
    createMany?: SpecificIngredientCreateManyCreatedByInputEnvelope
    connect?: Enumerable<SpecificIngredientWhereUniqueInput>
  }

  export type IngredientPreferenceCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<IngredientPreferenceCreateWithoutUserInput>, Enumerable<IngredientPreferenceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<IngredientPreferenceCreateOrConnectWithoutUserInput>
    createMany?: IngredientPreferenceCreateManyUserInputEnvelope
    connect?: Enumerable<IngredientPreferenceWhereUniqueInput>
  }

  export type StorageUserCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<StorageUserCreateWithoutUserInput>, Enumerable<StorageUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<StorageUserCreateOrConnectWithoutUserInput>
    createMany?: StorageUserCreateManyUserInputEnvelope
    connect?: Enumerable<StorageUserWhereUniqueInput>
  }

  export type StorageCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<StorageCreateWithoutCreatedByInput>, Enumerable<StorageUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<StorageCreateOrConnectWithoutCreatedByInput>
    createMany?: StorageCreateManyCreatedByInputEnvelope
    connect?: Enumerable<StorageWhereUniqueInput>
  }

  export type StorageCreateNestedManyWithoutEditedByInput = {
    create?: XOR<Enumerable<StorageCreateWithoutEditedByInput>, Enumerable<StorageUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<StorageCreateOrConnectWithoutEditedByInput>
    createMany?: StorageCreateManyEditedByInputEnvelope
    connect?: Enumerable<StorageWhereUniqueInput>
  }

  export type InventoryCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<InventoryCreateWithoutCreatedByInput>, Enumerable<InventoryUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<InventoryCreateOrConnectWithoutCreatedByInput>
    createMany?: InventoryCreateManyCreatedByInputEnvelope
    connect?: Enumerable<InventoryWhereUniqueInput>
  }

  export type InventoryCreateNestedManyWithoutEditedByInput = {
    create?: XOR<Enumerable<InventoryCreateWithoutEditedByInput>, Enumerable<InventoryUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<InventoryCreateOrConnectWithoutEditedByInput>
    createMany?: InventoryCreateManyEditedByInputEnvelope
    connect?: Enumerable<InventoryWhereUniqueInput>
  }

  export type InventoryUserCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<InventoryUserCreateWithoutUserInput>, Enumerable<InventoryUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<InventoryUserCreateOrConnectWithoutUserInput>
    createMany?: InventoryUserCreateManyUserInputEnvelope
    connect?: Enumerable<InventoryUserWhereUniqueInput>
  }

  export type ProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type RecipeBookUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<RecipeBookUserCreateWithoutUserInput>, Enumerable<RecipeBookUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RecipeBookUserCreateOrConnectWithoutUserInput>
    createMany?: RecipeBookUserCreateManyUserInputEnvelope
    connect?: Enumerable<RecipeBookUserWhereUniqueInput>
  }

  export type RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<RecipeBookCreateWithoutCreatedByInput>, Enumerable<RecipeBookUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<RecipeBookCreateOrConnectWithoutCreatedByInput>
    createMany?: RecipeBookCreateManyCreatedByInputEnvelope
    connect?: Enumerable<RecipeBookWhereUniqueInput>
  }

  export type RecipeBookUncheckedCreateNestedManyWithoutEditedByInput = {
    create?: XOR<Enumerable<RecipeBookCreateWithoutEditedByInput>, Enumerable<RecipeBookUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<RecipeBookCreateOrConnectWithoutEditedByInput>
    createMany?: RecipeBookCreateManyEditedByInputEnvelope
    connect?: Enumerable<RecipeBookWhereUniqueInput>
  }

  export type RecipeUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<RecipeCreateWithoutCreatedByInput>, Enumerable<RecipeUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<RecipeCreateOrConnectWithoutCreatedByInput>
    createMany?: RecipeCreateManyCreatedByInputEnvelope
    connect?: Enumerable<RecipeWhereUniqueInput>
  }

  export type BuildUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<BuildUserCreateWithoutUserInput>, Enumerable<BuildUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BuildUserCreateOrConnectWithoutUserInput>
    createMany?: BuildUserCreateManyUserInputEnvelope
    connect?: Enumerable<BuildUserWhereUniqueInput>
  }

  export type BuildUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<BuildCreateWithoutCreatedByInput>, Enumerable<BuildUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutCreatedByInput>
    createMany?: BuildCreateManyCreatedByInputEnvelope
    connect?: Enumerable<BuildWhereUniqueInput>
  }

  export type BuildUncheckedCreateNestedManyWithoutEditedByInput = {
    create?: XOR<Enumerable<BuildCreateWithoutEditedByInput>, Enumerable<BuildUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutEditedByInput>
    createMany?: BuildCreateManyEditedByInputEnvelope
    connect?: Enumerable<BuildWhereUniqueInput>
  }

  export type UserCrewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserCrewCreateWithoutUserInput>, Enumerable<UserCrewUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserCrewCreateOrConnectWithoutUserInput>
    createMany?: UserCrewCreateManyUserInputEnvelope
    connect?: Enumerable<UserCrewWhereUniqueInput>
  }

  export type CrewUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<CrewCreateWithoutCreatedByInput>, Enumerable<CrewUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<CrewCreateOrConnectWithoutCreatedByInput>
    createMany?: CrewCreateManyCreatedByInputEnvelope
    connect?: Enumerable<CrewWhereUniqueInput>
  }

  export type CrewUncheckedCreateNestedManyWithoutEditedByInput = {
    create?: XOR<Enumerable<CrewCreateWithoutEditedByInput>, Enumerable<CrewUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<CrewCreateOrConnectWithoutEditedByInput>
    createMany?: CrewCreateManyEditedByInputEnvelope
    connect?: Enumerable<CrewWhereUniqueInput>
  }

  export type SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<SpecificIngredientCreateWithoutCreatedByInput>, Enumerable<SpecificIngredientUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<SpecificIngredientCreateOrConnectWithoutCreatedByInput>
    createMany?: SpecificIngredientCreateManyCreatedByInputEnvelope
    connect?: Enumerable<SpecificIngredientWhereUniqueInput>
  }

  export type IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<IngredientPreferenceCreateWithoutUserInput>, Enumerable<IngredientPreferenceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<IngredientPreferenceCreateOrConnectWithoutUserInput>
    createMany?: IngredientPreferenceCreateManyUserInputEnvelope
    connect?: Enumerable<IngredientPreferenceWhereUniqueInput>
  }

  export type StorageUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<StorageUserCreateWithoutUserInput>, Enumerable<StorageUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<StorageUserCreateOrConnectWithoutUserInput>
    createMany?: StorageUserCreateManyUserInputEnvelope
    connect?: Enumerable<StorageUserWhereUniqueInput>
  }

  export type StorageUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<StorageCreateWithoutCreatedByInput>, Enumerable<StorageUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<StorageCreateOrConnectWithoutCreatedByInput>
    createMany?: StorageCreateManyCreatedByInputEnvelope
    connect?: Enumerable<StorageWhereUniqueInput>
  }

  export type StorageUncheckedCreateNestedManyWithoutEditedByInput = {
    create?: XOR<Enumerable<StorageCreateWithoutEditedByInput>, Enumerable<StorageUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<StorageCreateOrConnectWithoutEditedByInput>
    createMany?: StorageCreateManyEditedByInputEnvelope
    connect?: Enumerable<StorageWhereUniqueInput>
  }

  export type InventoryUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<InventoryCreateWithoutCreatedByInput>, Enumerable<InventoryUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<InventoryCreateOrConnectWithoutCreatedByInput>
    createMany?: InventoryCreateManyCreatedByInputEnvelope
    connect?: Enumerable<InventoryWhereUniqueInput>
  }

  export type InventoryUncheckedCreateNestedManyWithoutEditedByInput = {
    create?: XOR<Enumerable<InventoryCreateWithoutEditedByInput>, Enumerable<InventoryUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<InventoryCreateOrConnectWithoutEditedByInput>
    createMany?: InventoryCreateManyEditedByInputEnvelope
    connect?: Enumerable<InventoryWhereUniqueInput>
  }

  export type InventoryUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<InventoryUserCreateWithoutUserInput>, Enumerable<InventoryUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<InventoryUserCreateOrConnectWithoutUserInput>
    createMany?: InventoryUserCreateManyUserInputEnvelope
    connect?: Enumerable<InventoryUserWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type RecipeBookUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<RecipeBookUserCreateWithoutUserInput>, Enumerable<RecipeBookUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RecipeBookUserCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<RecipeBookUserUpsertWithWhereUniqueWithoutUserInput>
    createMany?: RecipeBookUserCreateManyUserInputEnvelope
    set?: Enumerable<RecipeBookUserWhereUniqueInput>
    disconnect?: Enumerable<RecipeBookUserWhereUniqueInput>
    delete?: Enumerable<RecipeBookUserWhereUniqueInput>
    connect?: Enumerable<RecipeBookUserWhereUniqueInput>
    update?: Enumerable<RecipeBookUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<RecipeBookUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<RecipeBookUserScalarWhereInput>
  }

  export type RecipeBookUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<RecipeBookCreateWithoutCreatedByInput>, Enumerable<RecipeBookUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<RecipeBookCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<RecipeBookUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: RecipeBookCreateManyCreatedByInputEnvelope
    set?: Enumerable<RecipeBookWhereUniqueInput>
    disconnect?: Enumerable<RecipeBookWhereUniqueInput>
    delete?: Enumerable<RecipeBookWhereUniqueInput>
    connect?: Enumerable<RecipeBookWhereUniqueInput>
    update?: Enumerable<RecipeBookUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<RecipeBookUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<RecipeBookScalarWhereInput>
  }

  export type RecipeBookUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<Enumerable<RecipeBookCreateWithoutEditedByInput>, Enumerable<RecipeBookUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<RecipeBookCreateOrConnectWithoutEditedByInput>
    upsert?: Enumerable<RecipeBookUpsertWithWhereUniqueWithoutEditedByInput>
    createMany?: RecipeBookCreateManyEditedByInputEnvelope
    set?: Enumerable<RecipeBookWhereUniqueInput>
    disconnect?: Enumerable<RecipeBookWhereUniqueInput>
    delete?: Enumerable<RecipeBookWhereUniqueInput>
    connect?: Enumerable<RecipeBookWhereUniqueInput>
    update?: Enumerable<RecipeBookUpdateWithWhereUniqueWithoutEditedByInput>
    updateMany?: Enumerable<RecipeBookUpdateManyWithWhereWithoutEditedByInput>
    deleteMany?: Enumerable<RecipeBookScalarWhereInput>
  }

  export type RecipeUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<RecipeCreateWithoutCreatedByInput>, Enumerable<RecipeUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<RecipeCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<RecipeUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: RecipeCreateManyCreatedByInputEnvelope
    set?: Enumerable<RecipeWhereUniqueInput>
    disconnect?: Enumerable<RecipeWhereUniqueInput>
    delete?: Enumerable<RecipeWhereUniqueInput>
    connect?: Enumerable<RecipeWhereUniqueInput>
    update?: Enumerable<RecipeUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<RecipeUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<RecipeScalarWhereInput>
  }

  export type BuildUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<BuildUserCreateWithoutUserInput>, Enumerable<BuildUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BuildUserCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<BuildUserUpsertWithWhereUniqueWithoutUserInput>
    createMany?: BuildUserCreateManyUserInputEnvelope
    set?: Enumerable<BuildUserWhereUniqueInput>
    disconnect?: Enumerable<BuildUserWhereUniqueInput>
    delete?: Enumerable<BuildUserWhereUniqueInput>
    connect?: Enumerable<BuildUserWhereUniqueInput>
    update?: Enumerable<BuildUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<BuildUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<BuildUserScalarWhereInput>
  }

  export type BuildUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<BuildCreateWithoutCreatedByInput>, Enumerable<BuildUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<BuildUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: BuildCreateManyCreatedByInputEnvelope
    set?: Enumerable<BuildWhereUniqueInput>
    disconnect?: Enumerable<BuildWhereUniqueInput>
    delete?: Enumerable<BuildWhereUniqueInput>
    connect?: Enumerable<BuildWhereUniqueInput>
    update?: Enumerable<BuildUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<BuildUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<BuildScalarWhereInput>
  }

  export type BuildUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<Enumerable<BuildCreateWithoutEditedByInput>, Enumerable<BuildUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutEditedByInput>
    upsert?: Enumerable<BuildUpsertWithWhereUniqueWithoutEditedByInput>
    createMany?: BuildCreateManyEditedByInputEnvelope
    set?: Enumerable<BuildWhereUniqueInput>
    disconnect?: Enumerable<BuildWhereUniqueInput>
    delete?: Enumerable<BuildWhereUniqueInput>
    connect?: Enumerable<BuildWhereUniqueInput>
    update?: Enumerable<BuildUpdateWithWhereUniqueWithoutEditedByInput>
    updateMany?: Enumerable<BuildUpdateManyWithWhereWithoutEditedByInput>
    deleteMany?: Enumerable<BuildScalarWhereInput>
  }

  export type UserCrewUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserCrewCreateWithoutUserInput>, Enumerable<UserCrewUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserCrewCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserCrewUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserCrewCreateManyUserInputEnvelope
    set?: Enumerable<UserCrewWhereUniqueInput>
    disconnect?: Enumerable<UserCrewWhereUniqueInput>
    delete?: Enumerable<UserCrewWhereUniqueInput>
    connect?: Enumerable<UserCrewWhereUniqueInput>
    update?: Enumerable<UserCrewUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserCrewUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserCrewScalarWhereInput>
  }

  export type CrewUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<CrewCreateWithoutCreatedByInput>, Enumerable<CrewUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<CrewCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<CrewUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: CrewCreateManyCreatedByInputEnvelope
    set?: Enumerable<CrewWhereUniqueInput>
    disconnect?: Enumerable<CrewWhereUniqueInput>
    delete?: Enumerable<CrewWhereUniqueInput>
    connect?: Enumerable<CrewWhereUniqueInput>
    update?: Enumerable<CrewUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<CrewUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<CrewScalarWhereInput>
  }

  export type CrewUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<Enumerable<CrewCreateWithoutEditedByInput>, Enumerable<CrewUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<CrewCreateOrConnectWithoutEditedByInput>
    upsert?: Enumerable<CrewUpsertWithWhereUniqueWithoutEditedByInput>
    createMany?: CrewCreateManyEditedByInputEnvelope
    set?: Enumerable<CrewWhereUniqueInput>
    disconnect?: Enumerable<CrewWhereUniqueInput>
    delete?: Enumerable<CrewWhereUniqueInput>
    connect?: Enumerable<CrewWhereUniqueInput>
    update?: Enumerable<CrewUpdateWithWhereUniqueWithoutEditedByInput>
    updateMany?: Enumerable<CrewUpdateManyWithWhereWithoutEditedByInput>
    deleteMany?: Enumerable<CrewScalarWhereInput>
  }

  export type SpecificIngredientUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<SpecificIngredientCreateWithoutCreatedByInput>, Enumerable<SpecificIngredientUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<SpecificIngredientCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<SpecificIngredientUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: SpecificIngredientCreateManyCreatedByInputEnvelope
    set?: Enumerable<SpecificIngredientWhereUniqueInput>
    disconnect?: Enumerable<SpecificIngredientWhereUniqueInput>
    delete?: Enumerable<SpecificIngredientWhereUniqueInput>
    connect?: Enumerable<SpecificIngredientWhereUniqueInput>
    update?: Enumerable<SpecificIngredientUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<SpecificIngredientUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<SpecificIngredientScalarWhereInput>
  }

  export type IngredientPreferenceUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<IngredientPreferenceCreateWithoutUserInput>, Enumerable<IngredientPreferenceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<IngredientPreferenceCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<IngredientPreferenceUpsertWithWhereUniqueWithoutUserInput>
    createMany?: IngredientPreferenceCreateManyUserInputEnvelope
    set?: Enumerable<IngredientPreferenceWhereUniqueInput>
    disconnect?: Enumerable<IngredientPreferenceWhereUniqueInput>
    delete?: Enumerable<IngredientPreferenceWhereUniqueInput>
    connect?: Enumerable<IngredientPreferenceWhereUniqueInput>
    update?: Enumerable<IngredientPreferenceUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<IngredientPreferenceUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<IngredientPreferenceScalarWhereInput>
  }

  export type StorageUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<StorageUserCreateWithoutUserInput>, Enumerable<StorageUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<StorageUserCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<StorageUserUpsertWithWhereUniqueWithoutUserInput>
    createMany?: StorageUserCreateManyUserInputEnvelope
    set?: Enumerable<StorageUserWhereUniqueInput>
    disconnect?: Enumerable<StorageUserWhereUniqueInput>
    delete?: Enumerable<StorageUserWhereUniqueInput>
    connect?: Enumerable<StorageUserWhereUniqueInput>
    update?: Enumerable<StorageUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<StorageUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<StorageUserScalarWhereInput>
  }

  export type StorageUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<StorageCreateWithoutCreatedByInput>, Enumerable<StorageUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<StorageCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<StorageUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: StorageCreateManyCreatedByInputEnvelope
    set?: Enumerable<StorageWhereUniqueInput>
    disconnect?: Enumerable<StorageWhereUniqueInput>
    delete?: Enumerable<StorageWhereUniqueInput>
    connect?: Enumerable<StorageWhereUniqueInput>
    update?: Enumerable<StorageUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<StorageUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<StorageScalarWhereInput>
  }

  export type StorageUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<Enumerable<StorageCreateWithoutEditedByInput>, Enumerable<StorageUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<StorageCreateOrConnectWithoutEditedByInput>
    upsert?: Enumerable<StorageUpsertWithWhereUniqueWithoutEditedByInput>
    createMany?: StorageCreateManyEditedByInputEnvelope
    set?: Enumerable<StorageWhereUniqueInput>
    disconnect?: Enumerable<StorageWhereUniqueInput>
    delete?: Enumerable<StorageWhereUniqueInput>
    connect?: Enumerable<StorageWhereUniqueInput>
    update?: Enumerable<StorageUpdateWithWhereUniqueWithoutEditedByInput>
    updateMany?: Enumerable<StorageUpdateManyWithWhereWithoutEditedByInput>
    deleteMany?: Enumerable<StorageScalarWhereInput>
  }

  export type InventoryUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<InventoryCreateWithoutCreatedByInput>, Enumerable<InventoryUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<InventoryCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<InventoryUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: InventoryCreateManyCreatedByInputEnvelope
    set?: Enumerable<InventoryWhereUniqueInput>
    disconnect?: Enumerable<InventoryWhereUniqueInput>
    delete?: Enumerable<InventoryWhereUniqueInput>
    connect?: Enumerable<InventoryWhereUniqueInput>
    update?: Enumerable<InventoryUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<InventoryUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<InventoryScalarWhereInput>
  }

  export type InventoryUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<Enumerable<InventoryCreateWithoutEditedByInput>, Enumerable<InventoryUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<InventoryCreateOrConnectWithoutEditedByInput>
    upsert?: Enumerable<InventoryUpsertWithWhereUniqueWithoutEditedByInput>
    createMany?: InventoryCreateManyEditedByInputEnvelope
    set?: Enumerable<InventoryWhereUniqueInput>
    disconnect?: Enumerable<InventoryWhereUniqueInput>
    delete?: Enumerable<InventoryWhereUniqueInput>
    connect?: Enumerable<InventoryWhereUniqueInput>
    update?: Enumerable<InventoryUpdateWithWhereUniqueWithoutEditedByInput>
    updateMany?: Enumerable<InventoryUpdateManyWithWhereWithoutEditedByInput>
    deleteMany?: Enumerable<InventoryScalarWhereInput>
  }

  export type InventoryUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<InventoryUserCreateWithoutUserInput>, Enumerable<InventoryUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<InventoryUserCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<InventoryUserUpsertWithWhereUniqueWithoutUserInput>
    createMany?: InventoryUserCreateManyUserInputEnvelope
    set?: Enumerable<InventoryUserWhereUniqueInput>
    disconnect?: Enumerable<InventoryUserWhereUniqueInput>
    delete?: Enumerable<InventoryUserWhereUniqueInput>
    connect?: Enumerable<InventoryUserWhereUniqueInput>
    update?: Enumerable<InventoryUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<InventoryUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<InventoryUserScalarWhereInput>
  }

  export type ProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<RecipeBookUserCreateWithoutUserInput>, Enumerable<RecipeBookUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RecipeBookUserCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<RecipeBookUserUpsertWithWhereUniqueWithoutUserInput>
    createMany?: RecipeBookUserCreateManyUserInputEnvelope
    set?: Enumerable<RecipeBookUserWhereUniqueInput>
    disconnect?: Enumerable<RecipeBookUserWhereUniqueInput>
    delete?: Enumerable<RecipeBookUserWhereUniqueInput>
    connect?: Enumerable<RecipeBookUserWhereUniqueInput>
    update?: Enumerable<RecipeBookUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<RecipeBookUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<RecipeBookUserScalarWhereInput>
  }

  export type RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<RecipeBookCreateWithoutCreatedByInput>, Enumerable<RecipeBookUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<RecipeBookCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<RecipeBookUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: RecipeBookCreateManyCreatedByInputEnvelope
    set?: Enumerable<RecipeBookWhereUniqueInput>
    disconnect?: Enumerable<RecipeBookWhereUniqueInput>
    delete?: Enumerable<RecipeBookWhereUniqueInput>
    connect?: Enumerable<RecipeBookWhereUniqueInput>
    update?: Enumerable<RecipeBookUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<RecipeBookUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<RecipeBookScalarWhereInput>
  }

  export type RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<Enumerable<RecipeBookCreateWithoutEditedByInput>, Enumerable<RecipeBookUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<RecipeBookCreateOrConnectWithoutEditedByInput>
    upsert?: Enumerable<RecipeBookUpsertWithWhereUniqueWithoutEditedByInput>
    createMany?: RecipeBookCreateManyEditedByInputEnvelope
    set?: Enumerable<RecipeBookWhereUniqueInput>
    disconnect?: Enumerable<RecipeBookWhereUniqueInput>
    delete?: Enumerable<RecipeBookWhereUniqueInput>
    connect?: Enumerable<RecipeBookWhereUniqueInput>
    update?: Enumerable<RecipeBookUpdateWithWhereUniqueWithoutEditedByInput>
    updateMany?: Enumerable<RecipeBookUpdateManyWithWhereWithoutEditedByInput>
    deleteMany?: Enumerable<RecipeBookScalarWhereInput>
  }

  export type RecipeUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<RecipeCreateWithoutCreatedByInput>, Enumerable<RecipeUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<RecipeCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<RecipeUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: RecipeCreateManyCreatedByInputEnvelope
    set?: Enumerable<RecipeWhereUniqueInput>
    disconnect?: Enumerable<RecipeWhereUniqueInput>
    delete?: Enumerable<RecipeWhereUniqueInput>
    connect?: Enumerable<RecipeWhereUniqueInput>
    update?: Enumerable<RecipeUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<RecipeUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<RecipeScalarWhereInput>
  }

  export type BuildUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<BuildUserCreateWithoutUserInput>, Enumerable<BuildUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BuildUserCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<BuildUserUpsertWithWhereUniqueWithoutUserInput>
    createMany?: BuildUserCreateManyUserInputEnvelope
    set?: Enumerable<BuildUserWhereUniqueInput>
    disconnect?: Enumerable<BuildUserWhereUniqueInput>
    delete?: Enumerable<BuildUserWhereUniqueInput>
    connect?: Enumerable<BuildUserWhereUniqueInput>
    update?: Enumerable<BuildUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<BuildUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<BuildUserScalarWhereInput>
  }

  export type BuildUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<BuildCreateWithoutCreatedByInput>, Enumerable<BuildUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<BuildUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: BuildCreateManyCreatedByInputEnvelope
    set?: Enumerable<BuildWhereUniqueInput>
    disconnect?: Enumerable<BuildWhereUniqueInput>
    delete?: Enumerable<BuildWhereUniqueInput>
    connect?: Enumerable<BuildWhereUniqueInput>
    update?: Enumerable<BuildUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<BuildUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<BuildScalarWhereInput>
  }

  export type BuildUncheckedUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<Enumerable<BuildCreateWithoutEditedByInput>, Enumerable<BuildUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutEditedByInput>
    upsert?: Enumerable<BuildUpsertWithWhereUniqueWithoutEditedByInput>
    createMany?: BuildCreateManyEditedByInputEnvelope
    set?: Enumerable<BuildWhereUniqueInput>
    disconnect?: Enumerable<BuildWhereUniqueInput>
    delete?: Enumerable<BuildWhereUniqueInput>
    connect?: Enumerable<BuildWhereUniqueInput>
    update?: Enumerable<BuildUpdateWithWhereUniqueWithoutEditedByInput>
    updateMany?: Enumerable<BuildUpdateManyWithWhereWithoutEditedByInput>
    deleteMany?: Enumerable<BuildScalarWhereInput>
  }

  export type UserCrewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserCrewCreateWithoutUserInput>, Enumerable<UserCrewUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserCrewCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserCrewUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserCrewCreateManyUserInputEnvelope
    set?: Enumerable<UserCrewWhereUniqueInput>
    disconnect?: Enumerable<UserCrewWhereUniqueInput>
    delete?: Enumerable<UserCrewWhereUniqueInput>
    connect?: Enumerable<UserCrewWhereUniqueInput>
    update?: Enumerable<UserCrewUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserCrewUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserCrewScalarWhereInput>
  }

  export type CrewUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<CrewCreateWithoutCreatedByInput>, Enumerable<CrewUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<CrewCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<CrewUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: CrewCreateManyCreatedByInputEnvelope
    set?: Enumerable<CrewWhereUniqueInput>
    disconnect?: Enumerable<CrewWhereUniqueInput>
    delete?: Enumerable<CrewWhereUniqueInput>
    connect?: Enumerable<CrewWhereUniqueInput>
    update?: Enumerable<CrewUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<CrewUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<CrewScalarWhereInput>
  }

  export type CrewUncheckedUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<Enumerable<CrewCreateWithoutEditedByInput>, Enumerable<CrewUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<CrewCreateOrConnectWithoutEditedByInput>
    upsert?: Enumerable<CrewUpsertWithWhereUniqueWithoutEditedByInput>
    createMany?: CrewCreateManyEditedByInputEnvelope
    set?: Enumerable<CrewWhereUniqueInput>
    disconnect?: Enumerable<CrewWhereUniqueInput>
    delete?: Enumerable<CrewWhereUniqueInput>
    connect?: Enumerable<CrewWhereUniqueInput>
    update?: Enumerable<CrewUpdateWithWhereUniqueWithoutEditedByInput>
    updateMany?: Enumerable<CrewUpdateManyWithWhereWithoutEditedByInput>
    deleteMany?: Enumerable<CrewScalarWhereInput>
  }

  export type SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<SpecificIngredientCreateWithoutCreatedByInput>, Enumerable<SpecificIngredientUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<SpecificIngredientCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<SpecificIngredientUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: SpecificIngredientCreateManyCreatedByInputEnvelope
    set?: Enumerable<SpecificIngredientWhereUniqueInput>
    disconnect?: Enumerable<SpecificIngredientWhereUniqueInput>
    delete?: Enumerable<SpecificIngredientWhereUniqueInput>
    connect?: Enumerable<SpecificIngredientWhereUniqueInput>
    update?: Enumerable<SpecificIngredientUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<SpecificIngredientUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<SpecificIngredientScalarWhereInput>
  }

  export type IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<IngredientPreferenceCreateWithoutUserInput>, Enumerable<IngredientPreferenceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<IngredientPreferenceCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<IngredientPreferenceUpsertWithWhereUniqueWithoutUserInput>
    createMany?: IngredientPreferenceCreateManyUserInputEnvelope
    set?: Enumerable<IngredientPreferenceWhereUniqueInput>
    disconnect?: Enumerable<IngredientPreferenceWhereUniqueInput>
    delete?: Enumerable<IngredientPreferenceWhereUniqueInput>
    connect?: Enumerable<IngredientPreferenceWhereUniqueInput>
    update?: Enumerable<IngredientPreferenceUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<IngredientPreferenceUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<IngredientPreferenceScalarWhereInput>
  }

  export type StorageUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<StorageUserCreateWithoutUserInput>, Enumerable<StorageUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<StorageUserCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<StorageUserUpsertWithWhereUniqueWithoutUserInput>
    createMany?: StorageUserCreateManyUserInputEnvelope
    set?: Enumerable<StorageUserWhereUniqueInput>
    disconnect?: Enumerable<StorageUserWhereUniqueInput>
    delete?: Enumerable<StorageUserWhereUniqueInput>
    connect?: Enumerable<StorageUserWhereUniqueInput>
    update?: Enumerable<StorageUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<StorageUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<StorageUserScalarWhereInput>
  }

  export type StorageUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<StorageCreateWithoutCreatedByInput>, Enumerable<StorageUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<StorageCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<StorageUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: StorageCreateManyCreatedByInputEnvelope
    set?: Enumerable<StorageWhereUniqueInput>
    disconnect?: Enumerable<StorageWhereUniqueInput>
    delete?: Enumerable<StorageWhereUniqueInput>
    connect?: Enumerable<StorageWhereUniqueInput>
    update?: Enumerable<StorageUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<StorageUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<StorageScalarWhereInput>
  }

  export type StorageUncheckedUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<Enumerable<StorageCreateWithoutEditedByInput>, Enumerable<StorageUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<StorageCreateOrConnectWithoutEditedByInput>
    upsert?: Enumerable<StorageUpsertWithWhereUniqueWithoutEditedByInput>
    createMany?: StorageCreateManyEditedByInputEnvelope
    set?: Enumerable<StorageWhereUniqueInput>
    disconnect?: Enumerable<StorageWhereUniqueInput>
    delete?: Enumerable<StorageWhereUniqueInput>
    connect?: Enumerable<StorageWhereUniqueInput>
    update?: Enumerable<StorageUpdateWithWhereUniqueWithoutEditedByInput>
    updateMany?: Enumerable<StorageUpdateManyWithWhereWithoutEditedByInput>
    deleteMany?: Enumerable<StorageScalarWhereInput>
  }

  export type InventoryUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<InventoryCreateWithoutCreatedByInput>, Enumerable<InventoryUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<InventoryCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<InventoryUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: InventoryCreateManyCreatedByInputEnvelope
    set?: Enumerable<InventoryWhereUniqueInput>
    disconnect?: Enumerable<InventoryWhereUniqueInput>
    delete?: Enumerable<InventoryWhereUniqueInput>
    connect?: Enumerable<InventoryWhereUniqueInput>
    update?: Enumerable<InventoryUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<InventoryUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<InventoryScalarWhereInput>
  }

  export type InventoryUncheckedUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<Enumerable<InventoryCreateWithoutEditedByInput>, Enumerable<InventoryUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<InventoryCreateOrConnectWithoutEditedByInput>
    upsert?: Enumerable<InventoryUpsertWithWhereUniqueWithoutEditedByInput>
    createMany?: InventoryCreateManyEditedByInputEnvelope
    set?: Enumerable<InventoryWhereUniqueInput>
    disconnect?: Enumerable<InventoryWhereUniqueInput>
    delete?: Enumerable<InventoryWhereUniqueInput>
    connect?: Enumerable<InventoryWhereUniqueInput>
    update?: Enumerable<InventoryUpdateWithWhereUniqueWithoutEditedByInput>
    updateMany?: Enumerable<InventoryUpdateManyWithWhereWithoutEditedByInput>
    deleteMany?: Enumerable<InventoryScalarWhereInput>
  }

  export type InventoryUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<InventoryUserCreateWithoutUserInput>, Enumerable<InventoryUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<InventoryUserCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<InventoryUserUpsertWithWhereUniqueWithoutUserInput>
    createMany?: InventoryUserCreateManyUserInputEnvelope
    set?: Enumerable<InventoryUserWhereUniqueInput>
    disconnect?: Enumerable<InventoryUserWhereUniqueInput>
    delete?: Enumerable<InventoryUserWhereUniqueInput>
    connect?: Enumerable<InventoryUserWhereUniqueInput>
    update?: Enumerable<InventoryUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<InventoryUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<InventoryUserScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserCreateNestedOneWithoutRecipeBookInput = {
    create?: XOR<UserCreateWithoutRecipeBookInput, UserUncheckedCreateWithoutRecipeBookInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeBookInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRecipeBookEditedByIdInput = {
    create?: XOR<UserCreateWithoutRecipeBookEditedByIdInput, UserUncheckedCreateWithoutRecipeBookEditedByIdInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeBookEditedByIdInput
    connect?: UserWhereUniqueInput
  }

  export type RecipeBookBuildCreateNestedManyWithoutRecipeBookInput = {
    create?: XOR<Enumerable<RecipeBookBuildCreateWithoutRecipeBookInput>, Enumerable<RecipeBookBuildUncheckedCreateWithoutRecipeBookInput>>
    connectOrCreate?: Enumerable<RecipeBookBuildCreateOrConnectWithoutRecipeBookInput>
    createMany?: RecipeBookBuildCreateManyRecipeBookInputEnvelope
    connect?: Enumerable<RecipeBookBuildWhereUniqueInput>
  }

  export type RecipeBookUserCreateNestedManyWithoutRecipeBookInput = {
    create?: XOR<Enumerable<RecipeBookUserCreateWithoutRecipeBookInput>, Enumerable<RecipeBookUserUncheckedCreateWithoutRecipeBookInput>>
    connectOrCreate?: Enumerable<RecipeBookUserCreateOrConnectWithoutRecipeBookInput>
    createMany?: RecipeBookUserCreateManyRecipeBookInputEnvelope
    connect?: Enumerable<RecipeBookUserWhereUniqueInput>
  }

  export type RecipeBookBuildUncheckedCreateNestedManyWithoutRecipeBookInput = {
    create?: XOR<Enumerable<RecipeBookBuildCreateWithoutRecipeBookInput>, Enumerable<RecipeBookBuildUncheckedCreateWithoutRecipeBookInput>>
    connectOrCreate?: Enumerable<RecipeBookBuildCreateOrConnectWithoutRecipeBookInput>
    createMany?: RecipeBookBuildCreateManyRecipeBookInputEnvelope
    connect?: Enumerable<RecipeBookBuildWhereUniqueInput>
  }

  export type RecipeBookUserUncheckedCreateNestedManyWithoutRecipeBookInput = {
    create?: XOR<Enumerable<RecipeBookUserCreateWithoutRecipeBookInput>, Enumerable<RecipeBookUserUncheckedCreateWithoutRecipeBookInput>>
    connectOrCreate?: Enumerable<RecipeBookUserCreateOrConnectWithoutRecipeBookInput>
    createMany?: RecipeBookUserCreateManyRecipeBookInputEnvelope
    connect?: Enumerable<RecipeBookUserWhereUniqueInput>
  }

  export type UserUpdateOneWithoutRecipeBookNestedInput = {
    create?: XOR<UserCreateWithoutRecipeBookInput, UserUncheckedCreateWithoutRecipeBookInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeBookInput
    upsert?: UserUpsertWithoutRecipeBookInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutRecipeBookInput, UserUncheckedUpdateWithoutRecipeBookInput>
  }

  export type UserUpdateOneWithoutRecipeBookEditedByIdNestedInput = {
    create?: XOR<UserCreateWithoutRecipeBookEditedByIdInput, UserUncheckedCreateWithoutRecipeBookEditedByIdInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeBookEditedByIdInput
    upsert?: UserUpsertWithoutRecipeBookEditedByIdInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutRecipeBookEditedByIdInput, UserUncheckedUpdateWithoutRecipeBookEditedByIdInput>
  }

  export type RecipeBookBuildUpdateManyWithoutRecipeBookNestedInput = {
    create?: XOR<Enumerable<RecipeBookBuildCreateWithoutRecipeBookInput>, Enumerable<RecipeBookBuildUncheckedCreateWithoutRecipeBookInput>>
    connectOrCreate?: Enumerable<RecipeBookBuildCreateOrConnectWithoutRecipeBookInput>
    upsert?: Enumerable<RecipeBookBuildUpsertWithWhereUniqueWithoutRecipeBookInput>
    createMany?: RecipeBookBuildCreateManyRecipeBookInputEnvelope
    set?: Enumerable<RecipeBookBuildWhereUniqueInput>
    disconnect?: Enumerable<RecipeBookBuildWhereUniqueInput>
    delete?: Enumerable<RecipeBookBuildWhereUniqueInput>
    connect?: Enumerable<RecipeBookBuildWhereUniqueInput>
    update?: Enumerable<RecipeBookBuildUpdateWithWhereUniqueWithoutRecipeBookInput>
    updateMany?: Enumerable<RecipeBookBuildUpdateManyWithWhereWithoutRecipeBookInput>
    deleteMany?: Enumerable<RecipeBookBuildScalarWhereInput>
  }

  export type RecipeBookUserUpdateManyWithoutRecipeBookNestedInput = {
    create?: XOR<Enumerable<RecipeBookUserCreateWithoutRecipeBookInput>, Enumerable<RecipeBookUserUncheckedCreateWithoutRecipeBookInput>>
    connectOrCreate?: Enumerable<RecipeBookUserCreateOrConnectWithoutRecipeBookInput>
    upsert?: Enumerable<RecipeBookUserUpsertWithWhereUniqueWithoutRecipeBookInput>
    createMany?: RecipeBookUserCreateManyRecipeBookInputEnvelope
    set?: Enumerable<RecipeBookUserWhereUniqueInput>
    disconnect?: Enumerable<RecipeBookUserWhereUniqueInput>
    delete?: Enumerable<RecipeBookUserWhereUniqueInput>
    connect?: Enumerable<RecipeBookUserWhereUniqueInput>
    update?: Enumerable<RecipeBookUserUpdateWithWhereUniqueWithoutRecipeBookInput>
    updateMany?: Enumerable<RecipeBookUserUpdateManyWithWhereWithoutRecipeBookInput>
    deleteMany?: Enumerable<RecipeBookUserScalarWhereInput>
  }

  export type RecipeBookBuildUncheckedUpdateManyWithoutRecipeBookNestedInput = {
    create?: XOR<Enumerable<RecipeBookBuildCreateWithoutRecipeBookInput>, Enumerable<RecipeBookBuildUncheckedCreateWithoutRecipeBookInput>>
    connectOrCreate?: Enumerable<RecipeBookBuildCreateOrConnectWithoutRecipeBookInput>
    upsert?: Enumerable<RecipeBookBuildUpsertWithWhereUniqueWithoutRecipeBookInput>
    createMany?: RecipeBookBuildCreateManyRecipeBookInputEnvelope
    set?: Enumerable<RecipeBookBuildWhereUniqueInput>
    disconnect?: Enumerable<RecipeBookBuildWhereUniqueInput>
    delete?: Enumerable<RecipeBookBuildWhereUniqueInput>
    connect?: Enumerable<RecipeBookBuildWhereUniqueInput>
    update?: Enumerable<RecipeBookBuildUpdateWithWhereUniqueWithoutRecipeBookInput>
    updateMany?: Enumerable<RecipeBookBuildUpdateManyWithWhereWithoutRecipeBookInput>
    deleteMany?: Enumerable<RecipeBookBuildScalarWhereInput>
  }

  export type RecipeBookUserUncheckedUpdateManyWithoutRecipeBookNestedInput = {
    create?: XOR<Enumerable<RecipeBookUserCreateWithoutRecipeBookInput>, Enumerable<RecipeBookUserUncheckedCreateWithoutRecipeBookInput>>
    connectOrCreate?: Enumerable<RecipeBookUserCreateOrConnectWithoutRecipeBookInput>
    upsert?: Enumerable<RecipeBookUserUpsertWithWhereUniqueWithoutRecipeBookInput>
    createMany?: RecipeBookUserCreateManyRecipeBookInputEnvelope
    set?: Enumerable<RecipeBookUserWhereUniqueInput>
    disconnect?: Enumerable<RecipeBookUserWhereUniqueInput>
    delete?: Enumerable<RecipeBookUserWhereUniqueInput>
    connect?: Enumerable<RecipeBookUserWhereUniqueInput>
    update?: Enumerable<RecipeBookUserUpdateWithWhereUniqueWithoutRecipeBookInput>
    updateMany?: Enumerable<RecipeBookUserUpdateManyWithWhereWithoutRecipeBookInput>
    deleteMany?: Enumerable<RecipeBookUserScalarWhereInput>
  }

  export type RecipeBookCreateNestedOneWithoutRecipeBookUserInput = {
    create?: XOR<RecipeBookCreateWithoutRecipeBookUserInput, RecipeBookUncheckedCreateWithoutRecipeBookUserInput>
    connectOrCreate?: RecipeBookCreateOrConnectWithoutRecipeBookUserInput
    connect?: RecipeBookWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRecipeBookUserInput = {
    create?: XOR<UserCreateWithoutRecipeBookUserInput, UserUncheckedCreateWithoutRecipeBookUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeBookUserInput
    connect?: UserWhereUniqueInput
  }

  export type RecipeBookUpdateOneRequiredWithoutRecipeBookUserNestedInput = {
    create?: XOR<RecipeBookCreateWithoutRecipeBookUserInput, RecipeBookUncheckedCreateWithoutRecipeBookUserInput>
    connectOrCreate?: RecipeBookCreateOrConnectWithoutRecipeBookUserInput
    upsert?: RecipeBookUpsertWithoutRecipeBookUserInput
    connect?: RecipeBookWhereUniqueInput
    update?: XOR<RecipeBookUpdateWithoutRecipeBookUserInput, RecipeBookUncheckedUpdateWithoutRecipeBookUserInput>
  }

  export type UserUpdateOneRequiredWithoutRecipeBookUserNestedInput = {
    create?: XOR<UserCreateWithoutRecipeBookUserInput, UserUncheckedCreateWithoutRecipeBookUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeBookUserInput
    upsert?: UserUpsertWithoutRecipeBookUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutRecipeBookUserInput, UserUncheckedUpdateWithoutRecipeBookUserInput>
  }

  export type UserCreateNestedOneWithoutBuildInput = {
    create?: XOR<UserCreateWithoutBuildInput, UserUncheckedCreateWithoutBuildInput>
    connectOrCreate?: UserCreateOrConnectWithoutBuildInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBuildEditedByInput = {
    create?: XOR<UserCreateWithoutBuildEditedByInput, UserUncheckedCreateWithoutBuildEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutBuildEditedByInput
    connect?: UserWhereUniqueInput
  }

  export type RecipeCreateNestedOneWithoutBuildInput = {
    create?: XOR<RecipeCreateWithoutBuildInput, RecipeUncheckedCreateWithoutBuildInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutBuildInput
    connect?: RecipeWhereUniqueInput
  }

  export type TouchCreateNestedManyWithoutBuildInput = {
    create?: XOR<Enumerable<TouchCreateWithoutBuildInput>, Enumerable<TouchUncheckedCreateWithoutBuildInput>>
    connectOrCreate?: Enumerable<TouchCreateOrConnectWithoutBuildInput>
    createMany?: TouchCreateManyBuildInputEnvelope
    connect?: Enumerable<TouchWhereUniqueInput>
  }

  export type RecipeBookBuildCreateNestedManyWithoutBuildInput = {
    create?: XOR<Enumerable<RecipeBookBuildCreateWithoutBuildInput>, Enumerable<RecipeBookBuildUncheckedCreateWithoutBuildInput>>
    connectOrCreate?: Enumerable<RecipeBookBuildCreateOrConnectWithoutBuildInput>
    createMany?: RecipeBookBuildCreateManyBuildInputEnvelope
    connect?: Enumerable<RecipeBookBuildWhereUniqueInput>
  }

  export type BuildUserCreateNestedManyWithoutBuildInput = {
    create?: XOR<Enumerable<BuildUserCreateWithoutBuildInput>, Enumerable<BuildUserUncheckedCreateWithoutBuildInput>>
    connectOrCreate?: Enumerable<BuildUserCreateOrConnectWithoutBuildInput>
    createMany?: BuildUserCreateManyBuildInputEnvelope
    connect?: Enumerable<BuildUserWhereUniqueInput>
  }

  export type TouchUncheckedCreateNestedManyWithoutBuildInput = {
    create?: XOR<Enumerable<TouchCreateWithoutBuildInput>, Enumerable<TouchUncheckedCreateWithoutBuildInput>>
    connectOrCreate?: Enumerable<TouchCreateOrConnectWithoutBuildInput>
    createMany?: TouchCreateManyBuildInputEnvelope
    connect?: Enumerable<TouchWhereUniqueInput>
  }

  export type RecipeBookBuildUncheckedCreateNestedManyWithoutBuildInput = {
    create?: XOR<Enumerable<RecipeBookBuildCreateWithoutBuildInput>, Enumerable<RecipeBookBuildUncheckedCreateWithoutBuildInput>>
    connectOrCreate?: Enumerable<RecipeBookBuildCreateOrConnectWithoutBuildInput>
    createMany?: RecipeBookBuildCreateManyBuildInputEnvelope
    connect?: Enumerable<RecipeBookBuildWhereUniqueInput>
  }

  export type BuildUserUncheckedCreateNestedManyWithoutBuildInput = {
    create?: XOR<Enumerable<BuildUserCreateWithoutBuildInput>, Enumerable<BuildUserUncheckedCreateWithoutBuildInput>>
    connectOrCreate?: Enumerable<BuildUserCreateOrConnectWithoutBuildInput>
    createMany?: BuildUserCreateManyBuildInputEnvelope
    connect?: Enumerable<BuildUserWhereUniqueInput>
  }

  export type UserUpdateOneWithoutBuildNestedInput = {
    create?: XOR<UserCreateWithoutBuildInput, UserUncheckedCreateWithoutBuildInput>
    connectOrCreate?: UserCreateOrConnectWithoutBuildInput
    upsert?: UserUpsertWithoutBuildInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutBuildInput, UserUncheckedUpdateWithoutBuildInput>
  }

  export type UserUpdateOneWithoutBuildEditedByNestedInput = {
    create?: XOR<UserCreateWithoutBuildEditedByInput, UserUncheckedCreateWithoutBuildEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutBuildEditedByInput
    upsert?: UserUpsertWithoutBuildEditedByInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutBuildEditedByInput, UserUncheckedUpdateWithoutBuildEditedByInput>
  }

  export type RecipeUpdateOneWithoutBuildNestedInput = {
    create?: XOR<RecipeCreateWithoutBuildInput, RecipeUncheckedCreateWithoutBuildInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutBuildInput
    upsert?: RecipeUpsertWithoutBuildInput
    disconnect?: boolean
    delete?: boolean
    connect?: RecipeWhereUniqueInput
    update?: XOR<RecipeUpdateWithoutBuildInput, RecipeUncheckedUpdateWithoutBuildInput>
  }

  export type TouchUpdateManyWithoutBuildNestedInput = {
    create?: XOR<Enumerable<TouchCreateWithoutBuildInput>, Enumerable<TouchUncheckedCreateWithoutBuildInput>>
    connectOrCreate?: Enumerable<TouchCreateOrConnectWithoutBuildInput>
    upsert?: Enumerable<TouchUpsertWithWhereUniqueWithoutBuildInput>
    createMany?: TouchCreateManyBuildInputEnvelope
    set?: Enumerable<TouchWhereUniqueInput>
    disconnect?: Enumerable<TouchWhereUniqueInput>
    delete?: Enumerable<TouchWhereUniqueInput>
    connect?: Enumerable<TouchWhereUniqueInput>
    update?: Enumerable<TouchUpdateWithWhereUniqueWithoutBuildInput>
    updateMany?: Enumerable<TouchUpdateManyWithWhereWithoutBuildInput>
    deleteMany?: Enumerable<TouchScalarWhereInput>
  }

  export type RecipeBookBuildUpdateManyWithoutBuildNestedInput = {
    create?: XOR<Enumerable<RecipeBookBuildCreateWithoutBuildInput>, Enumerable<RecipeBookBuildUncheckedCreateWithoutBuildInput>>
    connectOrCreate?: Enumerable<RecipeBookBuildCreateOrConnectWithoutBuildInput>
    upsert?: Enumerable<RecipeBookBuildUpsertWithWhereUniqueWithoutBuildInput>
    createMany?: RecipeBookBuildCreateManyBuildInputEnvelope
    set?: Enumerable<RecipeBookBuildWhereUniqueInput>
    disconnect?: Enumerable<RecipeBookBuildWhereUniqueInput>
    delete?: Enumerable<RecipeBookBuildWhereUniqueInput>
    connect?: Enumerable<RecipeBookBuildWhereUniqueInput>
    update?: Enumerable<RecipeBookBuildUpdateWithWhereUniqueWithoutBuildInput>
    updateMany?: Enumerable<RecipeBookBuildUpdateManyWithWhereWithoutBuildInput>
    deleteMany?: Enumerable<RecipeBookBuildScalarWhereInput>
  }

  export type BuildUserUpdateManyWithoutBuildNestedInput = {
    create?: XOR<Enumerable<BuildUserCreateWithoutBuildInput>, Enumerable<BuildUserUncheckedCreateWithoutBuildInput>>
    connectOrCreate?: Enumerable<BuildUserCreateOrConnectWithoutBuildInput>
    upsert?: Enumerable<BuildUserUpsertWithWhereUniqueWithoutBuildInput>
    createMany?: BuildUserCreateManyBuildInputEnvelope
    set?: Enumerable<BuildUserWhereUniqueInput>
    disconnect?: Enumerable<BuildUserWhereUniqueInput>
    delete?: Enumerable<BuildUserWhereUniqueInput>
    connect?: Enumerable<BuildUserWhereUniqueInput>
    update?: Enumerable<BuildUserUpdateWithWhereUniqueWithoutBuildInput>
    updateMany?: Enumerable<BuildUserUpdateManyWithWhereWithoutBuildInput>
    deleteMany?: Enumerable<BuildUserScalarWhereInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TouchUncheckedUpdateManyWithoutBuildNestedInput = {
    create?: XOR<Enumerable<TouchCreateWithoutBuildInput>, Enumerable<TouchUncheckedCreateWithoutBuildInput>>
    connectOrCreate?: Enumerable<TouchCreateOrConnectWithoutBuildInput>
    upsert?: Enumerable<TouchUpsertWithWhereUniqueWithoutBuildInput>
    createMany?: TouchCreateManyBuildInputEnvelope
    set?: Enumerable<TouchWhereUniqueInput>
    disconnect?: Enumerable<TouchWhereUniqueInput>
    delete?: Enumerable<TouchWhereUniqueInput>
    connect?: Enumerable<TouchWhereUniqueInput>
    update?: Enumerable<TouchUpdateWithWhereUniqueWithoutBuildInput>
    updateMany?: Enumerable<TouchUpdateManyWithWhereWithoutBuildInput>
    deleteMany?: Enumerable<TouchScalarWhereInput>
  }

  export type RecipeBookBuildUncheckedUpdateManyWithoutBuildNestedInput = {
    create?: XOR<Enumerable<RecipeBookBuildCreateWithoutBuildInput>, Enumerable<RecipeBookBuildUncheckedCreateWithoutBuildInput>>
    connectOrCreate?: Enumerable<RecipeBookBuildCreateOrConnectWithoutBuildInput>
    upsert?: Enumerable<RecipeBookBuildUpsertWithWhereUniqueWithoutBuildInput>
    createMany?: RecipeBookBuildCreateManyBuildInputEnvelope
    set?: Enumerable<RecipeBookBuildWhereUniqueInput>
    disconnect?: Enumerable<RecipeBookBuildWhereUniqueInput>
    delete?: Enumerable<RecipeBookBuildWhereUniqueInput>
    connect?: Enumerable<RecipeBookBuildWhereUniqueInput>
    update?: Enumerable<RecipeBookBuildUpdateWithWhereUniqueWithoutBuildInput>
    updateMany?: Enumerable<RecipeBookBuildUpdateManyWithWhereWithoutBuildInput>
    deleteMany?: Enumerable<RecipeBookBuildScalarWhereInput>
  }

  export type BuildUserUncheckedUpdateManyWithoutBuildNestedInput = {
    create?: XOR<Enumerable<BuildUserCreateWithoutBuildInput>, Enumerable<BuildUserUncheckedCreateWithoutBuildInput>>
    connectOrCreate?: Enumerable<BuildUserCreateOrConnectWithoutBuildInput>
    upsert?: Enumerable<BuildUserUpsertWithWhereUniqueWithoutBuildInput>
    createMany?: BuildUserCreateManyBuildInputEnvelope
    set?: Enumerable<BuildUserWhereUniqueInput>
    disconnect?: Enumerable<BuildUserWhereUniqueInput>
    delete?: Enumerable<BuildUserWhereUniqueInput>
    connect?: Enumerable<BuildUserWhereUniqueInput>
    update?: Enumerable<BuildUserUpdateWithWhereUniqueWithoutBuildInput>
    updateMany?: Enumerable<BuildUserUpdateManyWithWhereWithoutBuildInput>
    deleteMany?: Enumerable<BuildUserScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutBuildUserInput = {
    create?: XOR<UserCreateWithoutBuildUserInput, UserUncheckedCreateWithoutBuildUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutBuildUserInput
    connect?: UserWhereUniqueInput
  }

  export type BuildCreateNestedOneWithoutBuildUserInput = {
    create?: XOR<BuildCreateWithoutBuildUserInput, BuildUncheckedCreateWithoutBuildUserInput>
    connectOrCreate?: BuildCreateOrConnectWithoutBuildUserInput
    connect?: BuildWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBuildUserNestedInput = {
    create?: XOR<UserCreateWithoutBuildUserInput, UserUncheckedCreateWithoutBuildUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutBuildUserInput
    upsert?: UserUpsertWithoutBuildUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutBuildUserInput, UserUncheckedUpdateWithoutBuildUserInput>
  }

  export type BuildUpdateOneRequiredWithoutBuildUserNestedInput = {
    create?: XOR<BuildCreateWithoutBuildUserInput, BuildUncheckedCreateWithoutBuildUserInput>
    connectOrCreate?: BuildCreateOrConnectWithoutBuildUserInput
    upsert?: BuildUpsertWithoutBuildUserInput
    connect?: BuildWhereUniqueInput
    update?: XOR<BuildUpdateWithoutBuildUserInput, BuildUncheckedUpdateWithoutBuildUserInput>
  }

  export type UserCreateNestedOneWithoutRecipeInput = {
    create?: XOR<UserCreateWithoutRecipeInput, UserUncheckedCreateWithoutRecipeInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeInput
    connect?: UserWhereUniqueInput
  }

  export type BuildCreateNestedManyWithoutRecipeInput = {
    create?: XOR<Enumerable<BuildCreateWithoutRecipeInput>, Enumerable<BuildUncheckedCreateWithoutRecipeInput>>
    connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutRecipeInput>
    createMany?: BuildCreateManyRecipeInputEnvelope
    connect?: Enumerable<BuildWhereUniqueInput>
  }

  export type BuildUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<Enumerable<BuildCreateWithoutRecipeInput>, Enumerable<BuildUncheckedCreateWithoutRecipeInput>>
    connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutRecipeInput>
    createMany?: BuildCreateManyRecipeInputEnvelope
    connect?: Enumerable<BuildWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutRecipeNestedInput = {
    create?: XOR<UserCreateWithoutRecipeInput, UserUncheckedCreateWithoutRecipeInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeInput
    upsert?: UserUpsertWithoutRecipeInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutRecipeInput, UserUncheckedUpdateWithoutRecipeInput>
  }

  export type BuildUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<Enumerable<BuildCreateWithoutRecipeInput>, Enumerable<BuildUncheckedCreateWithoutRecipeInput>>
    connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutRecipeInput>
    upsert?: Enumerable<BuildUpsertWithWhereUniqueWithoutRecipeInput>
    createMany?: BuildCreateManyRecipeInputEnvelope
    set?: Enumerable<BuildWhereUniqueInput>
    disconnect?: Enumerable<BuildWhereUniqueInput>
    delete?: Enumerable<BuildWhereUniqueInput>
    connect?: Enumerable<BuildWhereUniqueInput>
    update?: Enumerable<BuildUpdateWithWhereUniqueWithoutRecipeInput>
    updateMany?: Enumerable<BuildUpdateManyWithWhereWithoutRecipeInput>
    deleteMany?: Enumerable<BuildScalarWhereInput>
  }

  export type BuildUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<Enumerable<BuildCreateWithoutRecipeInput>, Enumerable<BuildUncheckedCreateWithoutRecipeInput>>
    connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutRecipeInput>
    upsert?: Enumerable<BuildUpsertWithWhereUniqueWithoutRecipeInput>
    createMany?: BuildCreateManyRecipeInputEnvelope
    set?: Enumerable<BuildWhereUniqueInput>
    disconnect?: Enumerable<BuildWhereUniqueInput>
    delete?: Enumerable<BuildWhereUniqueInput>
    connect?: Enumerable<BuildWhereUniqueInput>
    update?: Enumerable<BuildUpdateWithWhereUniqueWithoutRecipeInput>
    updateMany?: Enumerable<BuildUpdateManyWithWhereWithoutRecipeInput>
    deleteMany?: Enumerable<BuildScalarWhereInput>
  }

  export type RecipeBookCreateNestedOneWithoutRecipeBookBuildInput = {
    create?: XOR<RecipeBookCreateWithoutRecipeBookBuildInput, RecipeBookUncheckedCreateWithoutRecipeBookBuildInput>
    connectOrCreate?: RecipeBookCreateOrConnectWithoutRecipeBookBuildInput
    connect?: RecipeBookWhereUniqueInput
  }

  export type BuildCreateNestedOneWithoutRecipeBookBuildInput = {
    create?: XOR<BuildCreateWithoutRecipeBookBuildInput, BuildUncheckedCreateWithoutRecipeBookBuildInput>
    connectOrCreate?: BuildCreateOrConnectWithoutRecipeBookBuildInput
    connect?: BuildWhereUniqueInput
  }

  export type RecipeBookUpdateOneRequiredWithoutRecipeBookBuildNestedInput = {
    create?: XOR<RecipeBookCreateWithoutRecipeBookBuildInput, RecipeBookUncheckedCreateWithoutRecipeBookBuildInput>
    connectOrCreate?: RecipeBookCreateOrConnectWithoutRecipeBookBuildInput
    upsert?: RecipeBookUpsertWithoutRecipeBookBuildInput
    connect?: RecipeBookWhereUniqueInput
    update?: XOR<RecipeBookUpdateWithoutRecipeBookBuildInput, RecipeBookUncheckedUpdateWithoutRecipeBookBuildInput>
  }

  export type BuildUpdateOneRequiredWithoutRecipeBookBuildNestedInput = {
    create?: XOR<BuildCreateWithoutRecipeBookBuildInput, BuildUncheckedCreateWithoutRecipeBookBuildInput>
    connectOrCreate?: BuildCreateOrConnectWithoutRecipeBookBuildInput
    upsert?: BuildUpsertWithoutRecipeBookBuildInput
    connect?: BuildWhereUniqueInput
    update?: XOR<BuildUpdateWithoutRecipeBookBuildInput, BuildUncheckedUpdateWithoutRecipeBookBuildInput>
  }

  export type BuildCreateNestedOneWithoutTouchInput = {
    create?: XOR<BuildCreateWithoutTouchInput, BuildUncheckedCreateWithoutTouchInput>
    connectOrCreate?: BuildCreateOrConnectWithoutTouchInput
    connect?: BuildWhereUniqueInput
  }

  export type GenericIngredientCreateNestedOneWithoutTouchInput = {
    create?: XOR<GenericIngredientCreateWithoutTouchInput, GenericIngredientUncheckedCreateWithoutTouchInput>
    connectOrCreate?: GenericIngredientCreateOrConnectWithoutTouchInput
    connect?: GenericIngredientWhereUniqueInput
  }

  export type SpecificIngredientCreateNestedOneWithoutTouchInput = {
    create?: XOR<SpecificIngredientCreateWithoutTouchInput, SpecificIngredientUncheckedCreateWithoutTouchInput>
    connectOrCreate?: SpecificIngredientCreateOrConnectWithoutTouchInput
    connect?: SpecificIngredientWhereUniqueInput
  }

  export type BuildUpdateOneWithoutTouchNestedInput = {
    create?: XOR<BuildCreateWithoutTouchInput, BuildUncheckedCreateWithoutTouchInput>
    connectOrCreate?: BuildCreateOrConnectWithoutTouchInput
    upsert?: BuildUpsertWithoutTouchInput
    disconnect?: boolean
    delete?: boolean
    connect?: BuildWhereUniqueInput
    update?: XOR<BuildUpdateWithoutTouchInput, BuildUncheckedUpdateWithoutTouchInput>
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type GenericIngredientUpdateOneRequiredWithoutTouchNestedInput = {
    create?: XOR<GenericIngredientCreateWithoutTouchInput, GenericIngredientUncheckedCreateWithoutTouchInput>
    connectOrCreate?: GenericIngredientCreateOrConnectWithoutTouchInput
    upsert?: GenericIngredientUpsertWithoutTouchInput
    connect?: GenericIngredientWhereUniqueInput
    update?: XOR<GenericIngredientUpdateWithoutTouchInput, GenericIngredientUncheckedUpdateWithoutTouchInput>
  }

  export type SpecificIngredientUpdateOneWithoutTouchNestedInput = {
    create?: XOR<SpecificIngredientCreateWithoutTouchInput, SpecificIngredientUncheckedCreateWithoutTouchInput>
    connectOrCreate?: SpecificIngredientCreateOrConnectWithoutTouchInput
    upsert?: SpecificIngredientUpsertWithoutTouchInput
    disconnect?: boolean
    delete?: boolean
    connect?: SpecificIngredientWhereUniqueInput
    update?: XOR<SpecificIngredientUpdateWithoutTouchInput, SpecificIngredientUncheckedUpdateWithoutTouchInput>
  }

  export type TouchCreateNestedManyWithoutGenericIngredientInput = {
    create?: XOR<Enumerable<TouchCreateWithoutGenericIngredientInput>, Enumerable<TouchUncheckedCreateWithoutGenericIngredientInput>>
    connectOrCreate?: Enumerable<TouchCreateOrConnectWithoutGenericIngredientInput>
    createMany?: TouchCreateManyGenericIngredientInputEnvelope
    connect?: Enumerable<TouchWhereUniqueInput>
  }

  export type SpecificIngredientCreateNestedManyWithoutGenericIngredientInput = {
    create?: XOR<Enumerable<SpecificIngredientCreateWithoutGenericIngredientInput>, Enumerable<SpecificIngredientUncheckedCreateWithoutGenericIngredientInput>>
    connectOrCreate?: Enumerable<SpecificIngredientCreateOrConnectWithoutGenericIngredientInput>
    createMany?: SpecificIngredientCreateManyGenericIngredientInputEnvelope
    connect?: Enumerable<SpecificIngredientWhereUniqueInput>
  }

  export type IngredientPreferenceCreateNestedManyWithoutGenericIngredientInput = {
    create?: XOR<Enumerable<IngredientPreferenceCreateWithoutGenericIngredientInput>, Enumerable<IngredientPreferenceUncheckedCreateWithoutGenericIngredientInput>>
    connectOrCreate?: Enumerable<IngredientPreferenceCreateOrConnectWithoutGenericIngredientInput>
    createMany?: IngredientPreferenceCreateManyGenericIngredientInputEnvelope
    connect?: Enumerable<IngredientPreferenceWhereUniqueInput>
  }

  export type TouchUncheckedCreateNestedManyWithoutGenericIngredientInput = {
    create?: XOR<Enumerable<TouchCreateWithoutGenericIngredientInput>, Enumerable<TouchUncheckedCreateWithoutGenericIngredientInput>>
    connectOrCreate?: Enumerable<TouchCreateOrConnectWithoutGenericIngredientInput>
    createMany?: TouchCreateManyGenericIngredientInputEnvelope
    connect?: Enumerable<TouchWhereUniqueInput>
  }

  export type SpecificIngredientUncheckedCreateNestedManyWithoutGenericIngredientInput = {
    create?: XOR<Enumerable<SpecificIngredientCreateWithoutGenericIngredientInput>, Enumerable<SpecificIngredientUncheckedCreateWithoutGenericIngredientInput>>
    connectOrCreate?: Enumerable<SpecificIngredientCreateOrConnectWithoutGenericIngredientInput>
    createMany?: SpecificIngredientCreateManyGenericIngredientInputEnvelope
    connect?: Enumerable<SpecificIngredientWhereUniqueInput>
  }

  export type IngredientPreferenceUncheckedCreateNestedManyWithoutGenericIngredientInput = {
    create?: XOR<Enumerable<IngredientPreferenceCreateWithoutGenericIngredientInput>, Enumerable<IngredientPreferenceUncheckedCreateWithoutGenericIngredientInput>>
    connectOrCreate?: Enumerable<IngredientPreferenceCreateOrConnectWithoutGenericIngredientInput>
    createMany?: IngredientPreferenceCreateManyGenericIngredientInputEnvelope
    connect?: Enumerable<IngredientPreferenceWhereUniqueInput>
  }

  export type TouchUpdateManyWithoutGenericIngredientNestedInput = {
    create?: XOR<Enumerable<TouchCreateWithoutGenericIngredientInput>, Enumerable<TouchUncheckedCreateWithoutGenericIngredientInput>>
    connectOrCreate?: Enumerable<TouchCreateOrConnectWithoutGenericIngredientInput>
    upsert?: Enumerable<TouchUpsertWithWhereUniqueWithoutGenericIngredientInput>
    createMany?: TouchCreateManyGenericIngredientInputEnvelope
    set?: Enumerable<TouchWhereUniqueInput>
    disconnect?: Enumerable<TouchWhereUniqueInput>
    delete?: Enumerable<TouchWhereUniqueInput>
    connect?: Enumerable<TouchWhereUniqueInput>
    update?: Enumerable<TouchUpdateWithWhereUniqueWithoutGenericIngredientInput>
    updateMany?: Enumerable<TouchUpdateManyWithWhereWithoutGenericIngredientInput>
    deleteMany?: Enumerable<TouchScalarWhereInput>
  }

  export type SpecificIngredientUpdateManyWithoutGenericIngredientNestedInput = {
    create?: XOR<Enumerable<SpecificIngredientCreateWithoutGenericIngredientInput>, Enumerable<SpecificIngredientUncheckedCreateWithoutGenericIngredientInput>>
    connectOrCreate?: Enumerable<SpecificIngredientCreateOrConnectWithoutGenericIngredientInput>
    upsert?: Enumerable<SpecificIngredientUpsertWithWhereUniqueWithoutGenericIngredientInput>
    createMany?: SpecificIngredientCreateManyGenericIngredientInputEnvelope
    set?: Enumerable<SpecificIngredientWhereUniqueInput>
    disconnect?: Enumerable<SpecificIngredientWhereUniqueInput>
    delete?: Enumerable<SpecificIngredientWhereUniqueInput>
    connect?: Enumerable<SpecificIngredientWhereUniqueInput>
    update?: Enumerable<SpecificIngredientUpdateWithWhereUniqueWithoutGenericIngredientInput>
    updateMany?: Enumerable<SpecificIngredientUpdateManyWithWhereWithoutGenericIngredientInput>
    deleteMany?: Enumerable<SpecificIngredientScalarWhereInput>
  }

  export type IngredientPreferenceUpdateManyWithoutGenericIngredientNestedInput = {
    create?: XOR<Enumerable<IngredientPreferenceCreateWithoutGenericIngredientInput>, Enumerable<IngredientPreferenceUncheckedCreateWithoutGenericIngredientInput>>
    connectOrCreate?: Enumerable<IngredientPreferenceCreateOrConnectWithoutGenericIngredientInput>
    upsert?: Enumerable<IngredientPreferenceUpsertWithWhereUniqueWithoutGenericIngredientInput>
    createMany?: IngredientPreferenceCreateManyGenericIngredientInputEnvelope
    set?: Enumerable<IngredientPreferenceWhereUniqueInput>
    disconnect?: Enumerable<IngredientPreferenceWhereUniqueInput>
    delete?: Enumerable<IngredientPreferenceWhereUniqueInput>
    connect?: Enumerable<IngredientPreferenceWhereUniqueInput>
    update?: Enumerable<IngredientPreferenceUpdateWithWhereUniqueWithoutGenericIngredientInput>
    updateMany?: Enumerable<IngredientPreferenceUpdateManyWithWhereWithoutGenericIngredientInput>
    deleteMany?: Enumerable<IngredientPreferenceScalarWhereInput>
  }

  export type TouchUncheckedUpdateManyWithoutGenericIngredientNestedInput = {
    create?: XOR<Enumerable<TouchCreateWithoutGenericIngredientInput>, Enumerable<TouchUncheckedCreateWithoutGenericIngredientInput>>
    connectOrCreate?: Enumerable<TouchCreateOrConnectWithoutGenericIngredientInput>
    upsert?: Enumerable<TouchUpsertWithWhereUniqueWithoutGenericIngredientInput>
    createMany?: TouchCreateManyGenericIngredientInputEnvelope
    set?: Enumerable<TouchWhereUniqueInput>
    disconnect?: Enumerable<TouchWhereUniqueInput>
    delete?: Enumerable<TouchWhereUniqueInput>
    connect?: Enumerable<TouchWhereUniqueInput>
    update?: Enumerable<TouchUpdateWithWhereUniqueWithoutGenericIngredientInput>
    updateMany?: Enumerable<TouchUpdateManyWithWhereWithoutGenericIngredientInput>
    deleteMany?: Enumerable<TouchScalarWhereInput>
  }

  export type SpecificIngredientUncheckedUpdateManyWithoutGenericIngredientNestedInput = {
    create?: XOR<Enumerable<SpecificIngredientCreateWithoutGenericIngredientInput>, Enumerable<SpecificIngredientUncheckedCreateWithoutGenericIngredientInput>>
    connectOrCreate?: Enumerable<SpecificIngredientCreateOrConnectWithoutGenericIngredientInput>
    upsert?: Enumerable<SpecificIngredientUpsertWithWhereUniqueWithoutGenericIngredientInput>
    createMany?: SpecificIngredientCreateManyGenericIngredientInputEnvelope
    set?: Enumerable<SpecificIngredientWhereUniqueInput>
    disconnect?: Enumerable<SpecificIngredientWhereUniqueInput>
    delete?: Enumerable<SpecificIngredientWhereUniqueInput>
    connect?: Enumerable<SpecificIngredientWhereUniqueInput>
    update?: Enumerable<SpecificIngredientUpdateWithWhereUniqueWithoutGenericIngredientInput>
    updateMany?: Enumerable<SpecificIngredientUpdateManyWithWhereWithoutGenericIngredientInput>
    deleteMany?: Enumerable<SpecificIngredientScalarWhereInput>
  }

  export type IngredientPreferenceUncheckedUpdateManyWithoutGenericIngredientNestedInput = {
    create?: XOR<Enumerable<IngredientPreferenceCreateWithoutGenericIngredientInput>, Enumerable<IngredientPreferenceUncheckedCreateWithoutGenericIngredientInput>>
    connectOrCreate?: Enumerable<IngredientPreferenceCreateOrConnectWithoutGenericIngredientInput>
    upsert?: Enumerable<IngredientPreferenceUpsertWithWhereUniqueWithoutGenericIngredientInput>
    createMany?: IngredientPreferenceCreateManyGenericIngredientInputEnvelope
    set?: Enumerable<IngredientPreferenceWhereUniqueInput>
    disconnect?: Enumerable<IngredientPreferenceWhereUniqueInput>
    delete?: Enumerable<IngredientPreferenceWhereUniqueInput>
    connect?: Enumerable<IngredientPreferenceWhereUniqueInput>
    update?: Enumerable<IngredientPreferenceUpdateWithWhereUniqueWithoutGenericIngredientInput>
    updateMany?: Enumerable<IngredientPreferenceUpdateManyWithWhereWithoutGenericIngredientInput>
    deleteMany?: Enumerable<IngredientPreferenceScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutIngredientInput = {
    create?: XOR<UserCreateWithoutIngredientInput, UserUncheckedCreateWithoutIngredientInput>
    connectOrCreate?: UserCreateOrConnectWithoutIngredientInput
    connect?: UserWhereUniqueInput
  }

  export type GenericIngredientCreateNestedOneWithoutSpecificIngredientInput = {
    create?: XOR<GenericIngredientCreateWithoutSpecificIngredientInput, GenericIngredientUncheckedCreateWithoutSpecificIngredientInput>
    connectOrCreate?: GenericIngredientCreateOrConnectWithoutSpecificIngredientInput
    connect?: GenericIngredientWhereUniqueInput
  }

  export type TouchCreateNestedManyWithoutSpecificIngredientInput = {
    create?: XOR<Enumerable<TouchCreateWithoutSpecificIngredientInput>, Enumerable<TouchUncheckedCreateWithoutSpecificIngredientInput>>
    connectOrCreate?: Enumerable<TouchCreateOrConnectWithoutSpecificIngredientInput>
    createMany?: TouchCreateManySpecificIngredientInputEnvelope
    connect?: Enumerable<TouchWhereUniqueInput>
  }

  export type IngredientStorageCreateNestedManyWithoutIngredientInput = {
    create?: XOR<Enumerable<IngredientStorageCreateWithoutIngredientInput>, Enumerable<IngredientStorageUncheckedCreateWithoutIngredientInput>>
    connectOrCreate?: Enumerable<IngredientStorageCreateOrConnectWithoutIngredientInput>
    createMany?: IngredientStorageCreateManyIngredientInputEnvelope
    connect?: Enumerable<IngredientStorageWhereUniqueInput>
  }

  export type IngredientPreferenceCreateNestedManyWithoutSpecificIngredientInput = {
    create?: XOR<Enumerable<IngredientPreferenceCreateWithoutSpecificIngredientInput>, Enumerable<IngredientPreferenceUncheckedCreateWithoutSpecificIngredientInput>>
    connectOrCreate?: Enumerable<IngredientPreferenceCreateOrConnectWithoutSpecificIngredientInput>
    createMany?: IngredientPreferenceCreateManySpecificIngredientInputEnvelope
    connect?: Enumerable<IngredientPreferenceWhereUniqueInput>
  }

  export type TouchUncheckedCreateNestedManyWithoutSpecificIngredientInput = {
    create?: XOR<Enumerable<TouchCreateWithoutSpecificIngredientInput>, Enumerable<TouchUncheckedCreateWithoutSpecificIngredientInput>>
    connectOrCreate?: Enumerable<TouchCreateOrConnectWithoutSpecificIngredientInput>
    createMany?: TouchCreateManySpecificIngredientInputEnvelope
    connect?: Enumerable<TouchWhereUniqueInput>
  }

  export type IngredientStorageUncheckedCreateNestedManyWithoutIngredientInput = {
    create?: XOR<Enumerable<IngredientStorageCreateWithoutIngredientInput>, Enumerable<IngredientStorageUncheckedCreateWithoutIngredientInput>>
    connectOrCreate?: Enumerable<IngredientStorageCreateOrConnectWithoutIngredientInput>
    createMany?: IngredientStorageCreateManyIngredientInputEnvelope
    connect?: Enumerable<IngredientStorageWhereUniqueInput>
  }

  export type IngredientPreferenceUncheckedCreateNestedManyWithoutSpecificIngredientInput = {
    create?: XOR<Enumerable<IngredientPreferenceCreateWithoutSpecificIngredientInput>, Enumerable<IngredientPreferenceUncheckedCreateWithoutSpecificIngredientInput>>
    connectOrCreate?: Enumerable<IngredientPreferenceCreateOrConnectWithoutSpecificIngredientInput>
    createMany?: IngredientPreferenceCreateManySpecificIngredientInputEnvelope
    connect?: Enumerable<IngredientPreferenceWhereUniqueInput>
  }

  export type UserUpdateOneWithoutIngredientNestedInput = {
    create?: XOR<UserCreateWithoutIngredientInput, UserUncheckedCreateWithoutIngredientInput>
    connectOrCreate?: UserCreateOrConnectWithoutIngredientInput
    upsert?: UserUpsertWithoutIngredientInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutIngredientInput, UserUncheckedUpdateWithoutIngredientInput>
  }

  export type GenericIngredientUpdateOneRequiredWithoutSpecificIngredientNestedInput = {
    create?: XOR<GenericIngredientCreateWithoutSpecificIngredientInput, GenericIngredientUncheckedCreateWithoutSpecificIngredientInput>
    connectOrCreate?: GenericIngredientCreateOrConnectWithoutSpecificIngredientInput
    upsert?: GenericIngredientUpsertWithoutSpecificIngredientInput
    connect?: GenericIngredientWhereUniqueInput
    update?: XOR<GenericIngredientUpdateWithoutSpecificIngredientInput, GenericIngredientUncheckedUpdateWithoutSpecificIngredientInput>
  }

  export type TouchUpdateManyWithoutSpecificIngredientNestedInput = {
    create?: XOR<Enumerable<TouchCreateWithoutSpecificIngredientInput>, Enumerable<TouchUncheckedCreateWithoutSpecificIngredientInput>>
    connectOrCreate?: Enumerable<TouchCreateOrConnectWithoutSpecificIngredientInput>
    upsert?: Enumerable<TouchUpsertWithWhereUniqueWithoutSpecificIngredientInput>
    createMany?: TouchCreateManySpecificIngredientInputEnvelope
    set?: Enumerable<TouchWhereUniqueInput>
    disconnect?: Enumerable<TouchWhereUniqueInput>
    delete?: Enumerable<TouchWhereUniqueInput>
    connect?: Enumerable<TouchWhereUniqueInput>
    update?: Enumerable<TouchUpdateWithWhereUniqueWithoutSpecificIngredientInput>
    updateMany?: Enumerable<TouchUpdateManyWithWhereWithoutSpecificIngredientInput>
    deleteMany?: Enumerable<TouchScalarWhereInput>
  }

  export type IngredientStorageUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<Enumerable<IngredientStorageCreateWithoutIngredientInput>, Enumerable<IngredientStorageUncheckedCreateWithoutIngredientInput>>
    connectOrCreate?: Enumerable<IngredientStorageCreateOrConnectWithoutIngredientInput>
    upsert?: Enumerable<IngredientStorageUpsertWithWhereUniqueWithoutIngredientInput>
    createMany?: IngredientStorageCreateManyIngredientInputEnvelope
    set?: Enumerable<IngredientStorageWhereUniqueInput>
    disconnect?: Enumerable<IngredientStorageWhereUniqueInput>
    delete?: Enumerable<IngredientStorageWhereUniqueInput>
    connect?: Enumerable<IngredientStorageWhereUniqueInput>
    update?: Enumerable<IngredientStorageUpdateWithWhereUniqueWithoutIngredientInput>
    updateMany?: Enumerable<IngredientStorageUpdateManyWithWhereWithoutIngredientInput>
    deleteMany?: Enumerable<IngredientStorageScalarWhereInput>
  }

  export type IngredientPreferenceUpdateManyWithoutSpecificIngredientNestedInput = {
    create?: XOR<Enumerable<IngredientPreferenceCreateWithoutSpecificIngredientInput>, Enumerable<IngredientPreferenceUncheckedCreateWithoutSpecificIngredientInput>>
    connectOrCreate?: Enumerable<IngredientPreferenceCreateOrConnectWithoutSpecificIngredientInput>
    upsert?: Enumerable<IngredientPreferenceUpsertWithWhereUniqueWithoutSpecificIngredientInput>
    createMany?: IngredientPreferenceCreateManySpecificIngredientInputEnvelope
    set?: Enumerable<IngredientPreferenceWhereUniqueInput>
    disconnect?: Enumerable<IngredientPreferenceWhereUniqueInput>
    delete?: Enumerable<IngredientPreferenceWhereUniqueInput>
    connect?: Enumerable<IngredientPreferenceWhereUniqueInput>
    update?: Enumerable<IngredientPreferenceUpdateWithWhereUniqueWithoutSpecificIngredientInput>
    updateMany?: Enumerable<IngredientPreferenceUpdateManyWithWhereWithoutSpecificIngredientInput>
    deleteMany?: Enumerable<IngredientPreferenceScalarWhereInput>
  }

  export type TouchUncheckedUpdateManyWithoutSpecificIngredientNestedInput = {
    create?: XOR<Enumerable<TouchCreateWithoutSpecificIngredientInput>, Enumerable<TouchUncheckedCreateWithoutSpecificIngredientInput>>
    connectOrCreate?: Enumerable<TouchCreateOrConnectWithoutSpecificIngredientInput>
    upsert?: Enumerable<TouchUpsertWithWhereUniqueWithoutSpecificIngredientInput>
    createMany?: TouchCreateManySpecificIngredientInputEnvelope
    set?: Enumerable<TouchWhereUniqueInput>
    disconnect?: Enumerable<TouchWhereUniqueInput>
    delete?: Enumerable<TouchWhereUniqueInput>
    connect?: Enumerable<TouchWhereUniqueInput>
    update?: Enumerable<TouchUpdateWithWhereUniqueWithoutSpecificIngredientInput>
    updateMany?: Enumerable<TouchUpdateManyWithWhereWithoutSpecificIngredientInput>
    deleteMany?: Enumerable<TouchScalarWhereInput>
  }

  export type IngredientStorageUncheckedUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<Enumerable<IngredientStorageCreateWithoutIngredientInput>, Enumerable<IngredientStorageUncheckedCreateWithoutIngredientInput>>
    connectOrCreate?: Enumerable<IngredientStorageCreateOrConnectWithoutIngredientInput>
    upsert?: Enumerable<IngredientStorageUpsertWithWhereUniqueWithoutIngredientInput>
    createMany?: IngredientStorageCreateManyIngredientInputEnvelope
    set?: Enumerable<IngredientStorageWhereUniqueInput>
    disconnect?: Enumerable<IngredientStorageWhereUniqueInput>
    delete?: Enumerable<IngredientStorageWhereUniqueInput>
    connect?: Enumerable<IngredientStorageWhereUniqueInput>
    update?: Enumerable<IngredientStorageUpdateWithWhereUniqueWithoutIngredientInput>
    updateMany?: Enumerable<IngredientStorageUpdateManyWithWhereWithoutIngredientInput>
    deleteMany?: Enumerable<IngredientStorageScalarWhereInput>
  }

  export type IngredientPreferenceUncheckedUpdateManyWithoutSpecificIngredientNestedInput = {
    create?: XOR<Enumerable<IngredientPreferenceCreateWithoutSpecificIngredientInput>, Enumerable<IngredientPreferenceUncheckedCreateWithoutSpecificIngredientInput>>
    connectOrCreate?: Enumerable<IngredientPreferenceCreateOrConnectWithoutSpecificIngredientInput>
    upsert?: Enumerable<IngredientPreferenceUpsertWithWhereUniqueWithoutSpecificIngredientInput>
    createMany?: IngredientPreferenceCreateManySpecificIngredientInputEnvelope
    set?: Enumerable<IngredientPreferenceWhereUniqueInput>
    disconnect?: Enumerable<IngredientPreferenceWhereUniqueInput>
    delete?: Enumerable<IngredientPreferenceWhereUniqueInput>
    connect?: Enumerable<IngredientPreferenceWhereUniqueInput>
    update?: Enumerable<IngredientPreferenceUpdateWithWhereUniqueWithoutSpecificIngredientInput>
    updateMany?: Enumerable<IngredientPreferenceUpdateManyWithWhereWithoutSpecificIngredientInput>
    deleteMany?: Enumerable<IngredientPreferenceScalarWhereInput>
  }

  export type GenericIngredientCreateNestedOneWithoutIngredientPreferenceInput = {
    create?: XOR<GenericIngredientCreateWithoutIngredientPreferenceInput, GenericIngredientUncheckedCreateWithoutIngredientPreferenceInput>
    connectOrCreate?: GenericIngredientCreateOrConnectWithoutIngredientPreferenceInput
    connect?: GenericIngredientWhereUniqueInput
  }

  export type SpecificIngredientCreateNestedOneWithoutIngredientPreferenceInput = {
    create?: XOR<SpecificIngredientCreateWithoutIngredientPreferenceInput, SpecificIngredientUncheckedCreateWithoutIngredientPreferenceInput>
    connectOrCreate?: SpecificIngredientCreateOrConnectWithoutIngredientPreferenceInput
    connect?: SpecificIngredientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutIngredientPreferenceInput = {
    create?: XOR<UserCreateWithoutIngredientPreferenceInput, UserUncheckedCreateWithoutIngredientPreferenceInput>
    connectOrCreate?: UserCreateOrConnectWithoutIngredientPreferenceInput
    connect?: UserWhereUniqueInput
  }

  export type GenericIngredientUpdateOneRequiredWithoutIngredientPreferenceNestedInput = {
    create?: XOR<GenericIngredientCreateWithoutIngredientPreferenceInput, GenericIngredientUncheckedCreateWithoutIngredientPreferenceInput>
    connectOrCreate?: GenericIngredientCreateOrConnectWithoutIngredientPreferenceInput
    upsert?: GenericIngredientUpsertWithoutIngredientPreferenceInput
    connect?: GenericIngredientWhereUniqueInput
    update?: XOR<GenericIngredientUpdateWithoutIngredientPreferenceInput, GenericIngredientUncheckedUpdateWithoutIngredientPreferenceInput>
  }

  export type SpecificIngredientUpdateOneRequiredWithoutIngredientPreferenceNestedInput = {
    create?: XOR<SpecificIngredientCreateWithoutIngredientPreferenceInput, SpecificIngredientUncheckedCreateWithoutIngredientPreferenceInput>
    connectOrCreate?: SpecificIngredientCreateOrConnectWithoutIngredientPreferenceInput
    upsert?: SpecificIngredientUpsertWithoutIngredientPreferenceInput
    connect?: SpecificIngredientWhereUniqueInput
    update?: XOR<SpecificIngredientUpdateWithoutIngredientPreferenceInput, SpecificIngredientUncheckedUpdateWithoutIngredientPreferenceInput>
  }

  export type UserUpdateOneRequiredWithoutIngredientPreferenceNestedInput = {
    create?: XOR<UserCreateWithoutIngredientPreferenceInput, UserUncheckedCreateWithoutIngredientPreferenceInput>
    connectOrCreate?: UserCreateOrConnectWithoutIngredientPreferenceInput
    upsert?: UserUpsertWithoutIngredientPreferenceInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutIngredientPreferenceInput, UserUncheckedUpdateWithoutIngredientPreferenceInput>
  }

  export type UserCreateNestedOneWithoutInventoryCreatedByInput = {
    create?: XOR<UserCreateWithoutInventoryCreatedByInput, UserUncheckedCreateWithoutInventoryCreatedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryCreatedByInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInventoryEditedByInput = {
    create?: XOR<UserCreateWithoutInventoryEditedByInput, UserUncheckedCreateWithoutInventoryEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryEditedByInput
    connect?: UserWhereUniqueInput
  }

  export type InventoryStorageCreateNestedManyWithoutInventoryInput = {
    create?: XOR<Enumerable<InventoryStorageCreateWithoutInventoryInput>, Enumerable<InventoryStorageUncheckedCreateWithoutInventoryInput>>
    connectOrCreate?: Enumerable<InventoryStorageCreateOrConnectWithoutInventoryInput>
    createMany?: InventoryStorageCreateManyInventoryInputEnvelope
    connect?: Enumerable<InventoryStorageWhereUniqueInput>
  }

  export type InventoryUserCreateNestedManyWithoutInventoryInput = {
    create?: XOR<Enumerable<InventoryUserCreateWithoutInventoryInput>, Enumerable<InventoryUserUncheckedCreateWithoutInventoryInput>>
    connectOrCreate?: Enumerable<InventoryUserCreateOrConnectWithoutInventoryInput>
    createMany?: InventoryUserCreateManyInventoryInputEnvelope
    connect?: Enumerable<InventoryUserWhereUniqueInput>
  }

  export type InventoryStorageUncheckedCreateNestedManyWithoutInventoryInput = {
    create?: XOR<Enumerable<InventoryStorageCreateWithoutInventoryInput>, Enumerable<InventoryStorageUncheckedCreateWithoutInventoryInput>>
    connectOrCreate?: Enumerable<InventoryStorageCreateOrConnectWithoutInventoryInput>
    createMany?: InventoryStorageCreateManyInventoryInputEnvelope
    connect?: Enumerable<InventoryStorageWhereUniqueInput>
  }

  export type InventoryUserUncheckedCreateNestedManyWithoutInventoryInput = {
    create?: XOR<Enumerable<InventoryUserCreateWithoutInventoryInput>, Enumerable<InventoryUserUncheckedCreateWithoutInventoryInput>>
    connectOrCreate?: Enumerable<InventoryUserCreateOrConnectWithoutInventoryInput>
    createMany?: InventoryUserCreateManyInventoryInputEnvelope
    connect?: Enumerable<InventoryUserWhereUniqueInput>
  }

  export type UserUpdateOneWithoutInventoryCreatedByNestedInput = {
    create?: XOR<UserCreateWithoutInventoryCreatedByInput, UserUncheckedCreateWithoutInventoryCreatedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryCreatedByInput
    upsert?: UserUpsertWithoutInventoryCreatedByInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutInventoryCreatedByInput, UserUncheckedUpdateWithoutInventoryCreatedByInput>
  }

  export type UserUpdateOneWithoutInventoryEditedByNestedInput = {
    create?: XOR<UserCreateWithoutInventoryEditedByInput, UserUncheckedCreateWithoutInventoryEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryEditedByInput
    upsert?: UserUpsertWithoutInventoryEditedByInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutInventoryEditedByInput, UserUncheckedUpdateWithoutInventoryEditedByInput>
  }

  export type InventoryStorageUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<Enumerable<InventoryStorageCreateWithoutInventoryInput>, Enumerable<InventoryStorageUncheckedCreateWithoutInventoryInput>>
    connectOrCreate?: Enumerable<InventoryStorageCreateOrConnectWithoutInventoryInput>
    upsert?: Enumerable<InventoryStorageUpsertWithWhereUniqueWithoutInventoryInput>
    createMany?: InventoryStorageCreateManyInventoryInputEnvelope
    set?: Enumerable<InventoryStorageWhereUniqueInput>
    disconnect?: Enumerable<InventoryStorageWhereUniqueInput>
    delete?: Enumerable<InventoryStorageWhereUniqueInput>
    connect?: Enumerable<InventoryStorageWhereUniqueInput>
    update?: Enumerable<InventoryStorageUpdateWithWhereUniqueWithoutInventoryInput>
    updateMany?: Enumerable<InventoryStorageUpdateManyWithWhereWithoutInventoryInput>
    deleteMany?: Enumerable<InventoryStorageScalarWhereInput>
  }

  export type InventoryUserUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<Enumerable<InventoryUserCreateWithoutInventoryInput>, Enumerable<InventoryUserUncheckedCreateWithoutInventoryInput>>
    connectOrCreate?: Enumerable<InventoryUserCreateOrConnectWithoutInventoryInput>
    upsert?: Enumerable<InventoryUserUpsertWithWhereUniqueWithoutInventoryInput>
    createMany?: InventoryUserCreateManyInventoryInputEnvelope
    set?: Enumerable<InventoryUserWhereUniqueInput>
    disconnect?: Enumerable<InventoryUserWhereUniqueInput>
    delete?: Enumerable<InventoryUserWhereUniqueInput>
    connect?: Enumerable<InventoryUserWhereUniqueInput>
    update?: Enumerable<InventoryUserUpdateWithWhereUniqueWithoutInventoryInput>
    updateMany?: Enumerable<InventoryUserUpdateManyWithWhereWithoutInventoryInput>
    deleteMany?: Enumerable<InventoryUserScalarWhereInput>
  }

  export type InventoryStorageUncheckedUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<Enumerable<InventoryStorageCreateWithoutInventoryInput>, Enumerable<InventoryStorageUncheckedCreateWithoutInventoryInput>>
    connectOrCreate?: Enumerable<InventoryStorageCreateOrConnectWithoutInventoryInput>
    upsert?: Enumerable<InventoryStorageUpsertWithWhereUniqueWithoutInventoryInput>
    createMany?: InventoryStorageCreateManyInventoryInputEnvelope
    set?: Enumerable<InventoryStorageWhereUniqueInput>
    disconnect?: Enumerable<InventoryStorageWhereUniqueInput>
    delete?: Enumerable<InventoryStorageWhereUniqueInput>
    connect?: Enumerable<InventoryStorageWhereUniqueInput>
    update?: Enumerable<InventoryStorageUpdateWithWhereUniqueWithoutInventoryInput>
    updateMany?: Enumerable<InventoryStorageUpdateManyWithWhereWithoutInventoryInput>
    deleteMany?: Enumerable<InventoryStorageScalarWhereInput>
  }

  export type InventoryUserUncheckedUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<Enumerable<InventoryUserCreateWithoutInventoryInput>, Enumerable<InventoryUserUncheckedCreateWithoutInventoryInput>>
    connectOrCreate?: Enumerable<InventoryUserCreateOrConnectWithoutInventoryInput>
    upsert?: Enumerable<InventoryUserUpsertWithWhereUniqueWithoutInventoryInput>
    createMany?: InventoryUserCreateManyInventoryInputEnvelope
    set?: Enumerable<InventoryUserWhereUniqueInput>
    disconnect?: Enumerable<InventoryUserWhereUniqueInput>
    delete?: Enumerable<InventoryUserWhereUniqueInput>
    connect?: Enumerable<InventoryUserWhereUniqueInput>
    update?: Enumerable<InventoryUserUpdateWithWhereUniqueWithoutInventoryInput>
    updateMany?: Enumerable<InventoryUserUpdateManyWithWhereWithoutInventoryInput>
    deleteMany?: Enumerable<InventoryUserScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutInventoryUserInput = {
    create?: XOR<UserCreateWithoutInventoryUserInput, UserUncheckedCreateWithoutInventoryUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryUserInput
    connect?: UserWhereUniqueInput
  }

  export type InventoryCreateNestedOneWithoutInventoryUserInput = {
    create?: XOR<InventoryCreateWithoutInventoryUserInput, InventoryUncheckedCreateWithoutInventoryUserInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutInventoryUserInput
    connect?: InventoryWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutInventoryUserNestedInput = {
    create?: XOR<UserCreateWithoutInventoryUserInput, UserUncheckedCreateWithoutInventoryUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryUserInput
    upsert?: UserUpsertWithoutInventoryUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutInventoryUserInput, UserUncheckedUpdateWithoutInventoryUserInput>
  }

  export type InventoryUpdateOneRequiredWithoutInventoryUserNestedInput = {
    create?: XOR<InventoryCreateWithoutInventoryUserInput, InventoryUncheckedCreateWithoutInventoryUserInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutInventoryUserInput
    upsert?: InventoryUpsertWithoutInventoryUserInput
    connect?: InventoryWhereUniqueInput
    update?: XOR<InventoryUpdateWithoutInventoryUserInput, InventoryUncheckedUpdateWithoutInventoryUserInput>
  }

  export type UserCreateNestedOneWithoutStorageInput = {
    create?: XOR<UserCreateWithoutStorageInput, UserUncheckedCreateWithoutStorageInput>
    connectOrCreate?: UserCreateOrConnectWithoutStorageInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStorageEditedByInput = {
    create?: XOR<UserCreateWithoutStorageEditedByInput, UserUncheckedCreateWithoutStorageEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutStorageEditedByInput
    connect?: UserWhereUniqueInput
  }

  export type InventoryStorageCreateNestedManyWithoutStorageInput = {
    create?: XOR<Enumerable<InventoryStorageCreateWithoutStorageInput>, Enumerable<InventoryStorageUncheckedCreateWithoutStorageInput>>
    connectOrCreate?: Enumerable<InventoryStorageCreateOrConnectWithoutStorageInput>
    createMany?: InventoryStorageCreateManyStorageInputEnvelope
    connect?: Enumerable<InventoryStorageWhereUniqueInput>
  }

  export type IngredientStorageCreateNestedManyWithoutStorageInput = {
    create?: XOR<Enumerable<IngredientStorageCreateWithoutStorageInput>, Enumerable<IngredientStorageUncheckedCreateWithoutStorageInput>>
    connectOrCreate?: Enumerable<IngredientStorageCreateOrConnectWithoutStorageInput>
    createMany?: IngredientStorageCreateManyStorageInputEnvelope
    connect?: Enumerable<IngredientStorageWhereUniqueInput>
  }

  export type StorageUserCreateNestedManyWithoutStorageInput = {
    create?: XOR<Enumerable<StorageUserCreateWithoutStorageInput>, Enumerable<StorageUserUncheckedCreateWithoutStorageInput>>
    connectOrCreate?: Enumerable<StorageUserCreateOrConnectWithoutStorageInput>
    createMany?: StorageUserCreateManyStorageInputEnvelope
    connect?: Enumerable<StorageUserWhereUniqueInput>
  }

  export type InventoryStorageUncheckedCreateNestedManyWithoutStorageInput = {
    create?: XOR<Enumerable<InventoryStorageCreateWithoutStorageInput>, Enumerable<InventoryStorageUncheckedCreateWithoutStorageInput>>
    connectOrCreate?: Enumerable<InventoryStorageCreateOrConnectWithoutStorageInput>
    createMany?: InventoryStorageCreateManyStorageInputEnvelope
    connect?: Enumerable<InventoryStorageWhereUniqueInput>
  }

  export type IngredientStorageUncheckedCreateNestedManyWithoutStorageInput = {
    create?: XOR<Enumerable<IngredientStorageCreateWithoutStorageInput>, Enumerable<IngredientStorageUncheckedCreateWithoutStorageInput>>
    connectOrCreate?: Enumerable<IngredientStorageCreateOrConnectWithoutStorageInput>
    createMany?: IngredientStorageCreateManyStorageInputEnvelope
    connect?: Enumerable<IngredientStorageWhereUniqueInput>
  }

  export type StorageUserUncheckedCreateNestedManyWithoutStorageInput = {
    create?: XOR<Enumerable<StorageUserCreateWithoutStorageInput>, Enumerable<StorageUserUncheckedCreateWithoutStorageInput>>
    connectOrCreate?: Enumerable<StorageUserCreateOrConnectWithoutStorageInput>
    createMany?: StorageUserCreateManyStorageInputEnvelope
    connect?: Enumerable<StorageUserWhereUniqueInput>
  }

  export type UserUpdateOneWithoutStorageNestedInput = {
    create?: XOR<UserCreateWithoutStorageInput, UserUncheckedCreateWithoutStorageInput>
    connectOrCreate?: UserCreateOrConnectWithoutStorageInput
    upsert?: UserUpsertWithoutStorageInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutStorageInput, UserUncheckedUpdateWithoutStorageInput>
  }

  export type UserUpdateOneWithoutStorageEditedByNestedInput = {
    create?: XOR<UserCreateWithoutStorageEditedByInput, UserUncheckedCreateWithoutStorageEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutStorageEditedByInput
    upsert?: UserUpsertWithoutStorageEditedByInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutStorageEditedByInput, UserUncheckedUpdateWithoutStorageEditedByInput>
  }

  export type InventoryStorageUpdateManyWithoutStorageNestedInput = {
    create?: XOR<Enumerable<InventoryStorageCreateWithoutStorageInput>, Enumerable<InventoryStorageUncheckedCreateWithoutStorageInput>>
    connectOrCreate?: Enumerable<InventoryStorageCreateOrConnectWithoutStorageInput>
    upsert?: Enumerable<InventoryStorageUpsertWithWhereUniqueWithoutStorageInput>
    createMany?: InventoryStorageCreateManyStorageInputEnvelope
    set?: Enumerable<InventoryStorageWhereUniqueInput>
    disconnect?: Enumerable<InventoryStorageWhereUniqueInput>
    delete?: Enumerable<InventoryStorageWhereUniqueInput>
    connect?: Enumerable<InventoryStorageWhereUniqueInput>
    update?: Enumerable<InventoryStorageUpdateWithWhereUniqueWithoutStorageInput>
    updateMany?: Enumerable<InventoryStorageUpdateManyWithWhereWithoutStorageInput>
    deleteMany?: Enumerable<InventoryStorageScalarWhereInput>
  }

  export type IngredientStorageUpdateManyWithoutStorageNestedInput = {
    create?: XOR<Enumerable<IngredientStorageCreateWithoutStorageInput>, Enumerable<IngredientStorageUncheckedCreateWithoutStorageInput>>
    connectOrCreate?: Enumerable<IngredientStorageCreateOrConnectWithoutStorageInput>
    upsert?: Enumerable<IngredientStorageUpsertWithWhereUniqueWithoutStorageInput>
    createMany?: IngredientStorageCreateManyStorageInputEnvelope
    set?: Enumerable<IngredientStorageWhereUniqueInput>
    disconnect?: Enumerable<IngredientStorageWhereUniqueInput>
    delete?: Enumerable<IngredientStorageWhereUniqueInput>
    connect?: Enumerable<IngredientStorageWhereUniqueInput>
    update?: Enumerable<IngredientStorageUpdateWithWhereUniqueWithoutStorageInput>
    updateMany?: Enumerable<IngredientStorageUpdateManyWithWhereWithoutStorageInput>
    deleteMany?: Enumerable<IngredientStorageScalarWhereInput>
  }

  export type StorageUserUpdateManyWithoutStorageNestedInput = {
    create?: XOR<Enumerable<StorageUserCreateWithoutStorageInput>, Enumerable<StorageUserUncheckedCreateWithoutStorageInput>>
    connectOrCreate?: Enumerable<StorageUserCreateOrConnectWithoutStorageInput>
    upsert?: Enumerable<StorageUserUpsertWithWhereUniqueWithoutStorageInput>
    createMany?: StorageUserCreateManyStorageInputEnvelope
    set?: Enumerable<StorageUserWhereUniqueInput>
    disconnect?: Enumerable<StorageUserWhereUniqueInput>
    delete?: Enumerable<StorageUserWhereUniqueInput>
    connect?: Enumerable<StorageUserWhereUniqueInput>
    update?: Enumerable<StorageUserUpdateWithWhereUniqueWithoutStorageInput>
    updateMany?: Enumerable<StorageUserUpdateManyWithWhereWithoutStorageInput>
    deleteMany?: Enumerable<StorageUserScalarWhereInput>
  }

  export type InventoryStorageUncheckedUpdateManyWithoutStorageNestedInput = {
    create?: XOR<Enumerable<InventoryStorageCreateWithoutStorageInput>, Enumerable<InventoryStorageUncheckedCreateWithoutStorageInput>>
    connectOrCreate?: Enumerable<InventoryStorageCreateOrConnectWithoutStorageInput>
    upsert?: Enumerable<InventoryStorageUpsertWithWhereUniqueWithoutStorageInput>
    createMany?: InventoryStorageCreateManyStorageInputEnvelope
    set?: Enumerable<InventoryStorageWhereUniqueInput>
    disconnect?: Enumerable<InventoryStorageWhereUniqueInput>
    delete?: Enumerable<InventoryStorageWhereUniqueInput>
    connect?: Enumerable<InventoryStorageWhereUniqueInput>
    update?: Enumerable<InventoryStorageUpdateWithWhereUniqueWithoutStorageInput>
    updateMany?: Enumerable<InventoryStorageUpdateManyWithWhereWithoutStorageInput>
    deleteMany?: Enumerable<InventoryStorageScalarWhereInput>
  }

  export type IngredientStorageUncheckedUpdateManyWithoutStorageNestedInput = {
    create?: XOR<Enumerable<IngredientStorageCreateWithoutStorageInput>, Enumerable<IngredientStorageUncheckedCreateWithoutStorageInput>>
    connectOrCreate?: Enumerable<IngredientStorageCreateOrConnectWithoutStorageInput>
    upsert?: Enumerable<IngredientStorageUpsertWithWhereUniqueWithoutStorageInput>
    createMany?: IngredientStorageCreateManyStorageInputEnvelope
    set?: Enumerable<IngredientStorageWhereUniqueInput>
    disconnect?: Enumerable<IngredientStorageWhereUniqueInput>
    delete?: Enumerable<IngredientStorageWhereUniqueInput>
    connect?: Enumerable<IngredientStorageWhereUniqueInput>
    update?: Enumerable<IngredientStorageUpdateWithWhereUniqueWithoutStorageInput>
    updateMany?: Enumerable<IngredientStorageUpdateManyWithWhereWithoutStorageInput>
    deleteMany?: Enumerable<IngredientStorageScalarWhereInput>
  }

  export type StorageUserUncheckedUpdateManyWithoutStorageNestedInput = {
    create?: XOR<Enumerable<StorageUserCreateWithoutStorageInput>, Enumerable<StorageUserUncheckedCreateWithoutStorageInput>>
    connectOrCreate?: Enumerable<StorageUserCreateOrConnectWithoutStorageInput>
    upsert?: Enumerable<StorageUserUpsertWithWhereUniqueWithoutStorageInput>
    createMany?: StorageUserCreateManyStorageInputEnvelope
    set?: Enumerable<StorageUserWhereUniqueInput>
    disconnect?: Enumerable<StorageUserWhereUniqueInput>
    delete?: Enumerable<StorageUserWhereUniqueInput>
    connect?: Enumerable<StorageUserWhereUniqueInput>
    update?: Enumerable<StorageUserUpdateWithWhereUniqueWithoutStorageInput>
    updateMany?: Enumerable<StorageUserUpdateManyWithWhereWithoutStorageInput>
    deleteMany?: Enumerable<StorageUserScalarWhereInput>
  }

  export type StorageCreateNestedOneWithoutInventoryStorageInput = {
    create?: XOR<StorageCreateWithoutInventoryStorageInput, StorageUncheckedCreateWithoutInventoryStorageInput>
    connectOrCreate?: StorageCreateOrConnectWithoutInventoryStorageInput
    connect?: StorageWhereUniqueInput
  }

  export type InventoryCreateNestedOneWithoutInventoryStorageInput = {
    create?: XOR<InventoryCreateWithoutInventoryStorageInput, InventoryUncheckedCreateWithoutInventoryStorageInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutInventoryStorageInput
    connect?: InventoryWhereUniqueInput
  }

  export type StorageUpdateOneRequiredWithoutInventoryStorageNestedInput = {
    create?: XOR<StorageCreateWithoutInventoryStorageInput, StorageUncheckedCreateWithoutInventoryStorageInput>
    connectOrCreate?: StorageCreateOrConnectWithoutInventoryStorageInput
    upsert?: StorageUpsertWithoutInventoryStorageInput
    connect?: StorageWhereUniqueInput
    update?: XOR<StorageUpdateWithoutInventoryStorageInput, StorageUncheckedUpdateWithoutInventoryStorageInput>
  }

  export type InventoryUpdateOneRequiredWithoutInventoryStorageNestedInput = {
    create?: XOR<InventoryCreateWithoutInventoryStorageInput, InventoryUncheckedCreateWithoutInventoryStorageInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutInventoryStorageInput
    upsert?: InventoryUpsertWithoutInventoryStorageInput
    connect?: InventoryWhereUniqueInput
    update?: XOR<InventoryUpdateWithoutInventoryStorageInput, InventoryUncheckedUpdateWithoutInventoryStorageInput>
  }

  export type SpecificIngredientCreateNestedOneWithoutIngredientStorageInput = {
    create?: XOR<SpecificIngredientCreateWithoutIngredientStorageInput, SpecificIngredientUncheckedCreateWithoutIngredientStorageInput>
    connectOrCreate?: SpecificIngredientCreateOrConnectWithoutIngredientStorageInput
    connect?: SpecificIngredientWhereUniqueInput
  }

  export type StorageCreateNestedOneWithoutIngredientStorageInput = {
    create?: XOR<StorageCreateWithoutIngredientStorageInput, StorageUncheckedCreateWithoutIngredientStorageInput>
    connectOrCreate?: StorageCreateOrConnectWithoutIngredientStorageInput
    connect?: StorageWhereUniqueInput
  }

  export type SpecificIngredientUpdateOneRequiredWithoutIngredientStorageNestedInput = {
    create?: XOR<SpecificIngredientCreateWithoutIngredientStorageInput, SpecificIngredientUncheckedCreateWithoutIngredientStorageInput>
    connectOrCreate?: SpecificIngredientCreateOrConnectWithoutIngredientStorageInput
    upsert?: SpecificIngredientUpsertWithoutIngredientStorageInput
    connect?: SpecificIngredientWhereUniqueInput
    update?: XOR<SpecificIngredientUpdateWithoutIngredientStorageInput, SpecificIngredientUncheckedUpdateWithoutIngredientStorageInput>
  }

  export type StorageUpdateOneRequiredWithoutIngredientStorageNestedInput = {
    create?: XOR<StorageCreateWithoutIngredientStorageInput, StorageUncheckedCreateWithoutIngredientStorageInput>
    connectOrCreate?: StorageCreateOrConnectWithoutIngredientStorageInput
    upsert?: StorageUpsertWithoutIngredientStorageInput
    connect?: StorageWhereUniqueInput
    update?: XOR<StorageUpdateWithoutIngredientStorageInput, StorageUncheckedUpdateWithoutIngredientStorageInput>
  }

  export type UserCreateNestedOneWithoutStorageUserInput = {
    create?: XOR<UserCreateWithoutStorageUserInput, UserUncheckedCreateWithoutStorageUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutStorageUserInput
    connect?: UserWhereUniqueInput
  }

  export type StorageCreateNestedOneWithoutStorageUserInput = {
    create?: XOR<StorageCreateWithoutStorageUserInput, StorageUncheckedCreateWithoutStorageUserInput>
    connectOrCreate?: StorageCreateOrConnectWithoutStorageUserInput
    connect?: StorageWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutStorageUserNestedInput = {
    create?: XOR<UserCreateWithoutStorageUserInput, UserUncheckedCreateWithoutStorageUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutStorageUserInput
    upsert?: UserUpsertWithoutStorageUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutStorageUserInput, UserUncheckedUpdateWithoutStorageUserInput>
  }

  export type StorageUpdateOneRequiredWithoutStorageUserNestedInput = {
    create?: XOR<StorageCreateWithoutStorageUserInput, StorageUncheckedCreateWithoutStorageUserInput>
    connectOrCreate?: StorageCreateOrConnectWithoutStorageUserInput
    upsert?: StorageUpsertWithoutStorageUserInput
    connect?: StorageWhereUniqueInput
    update?: XOR<StorageUpdateWithoutStorageUserInput, StorageUncheckedUpdateWithoutStorageUserInput>
  }

  export type UserCreateNestedOneWithoutCrewInput = {
    create?: XOR<UserCreateWithoutCrewInput, UserUncheckedCreateWithoutCrewInput>
    connectOrCreate?: UserCreateOrConnectWithoutCrewInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCrewEditedByInput = {
    create?: XOR<UserCreateWithoutCrewEditedByInput, UserUncheckedCreateWithoutCrewEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutCrewEditedByInput
    connect?: UserWhereUniqueInput
  }

  export type UserCrewCreateNestedManyWithoutCrewInput = {
    create?: XOR<Enumerable<UserCrewCreateWithoutCrewInput>, Enumerable<UserCrewUncheckedCreateWithoutCrewInput>>
    connectOrCreate?: Enumerable<UserCrewCreateOrConnectWithoutCrewInput>
    createMany?: UserCrewCreateManyCrewInputEnvelope
    connect?: Enumerable<UserCrewWhereUniqueInput>
  }

  export type UserCrewUncheckedCreateNestedManyWithoutCrewInput = {
    create?: XOR<Enumerable<UserCrewCreateWithoutCrewInput>, Enumerable<UserCrewUncheckedCreateWithoutCrewInput>>
    connectOrCreate?: Enumerable<UserCrewCreateOrConnectWithoutCrewInput>
    createMany?: UserCrewCreateManyCrewInputEnvelope
    connect?: Enumerable<UserCrewWhereUniqueInput>
  }

  export type UserUpdateOneWithoutCrewNestedInput = {
    create?: XOR<UserCreateWithoutCrewInput, UserUncheckedCreateWithoutCrewInput>
    connectOrCreate?: UserCreateOrConnectWithoutCrewInput
    upsert?: UserUpsertWithoutCrewInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCrewInput, UserUncheckedUpdateWithoutCrewInput>
  }

  export type UserUpdateOneWithoutCrewEditedByNestedInput = {
    create?: XOR<UserCreateWithoutCrewEditedByInput, UserUncheckedCreateWithoutCrewEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutCrewEditedByInput
    upsert?: UserUpsertWithoutCrewEditedByInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCrewEditedByInput, UserUncheckedUpdateWithoutCrewEditedByInput>
  }

  export type UserCrewUpdateManyWithoutCrewNestedInput = {
    create?: XOR<Enumerable<UserCrewCreateWithoutCrewInput>, Enumerable<UserCrewUncheckedCreateWithoutCrewInput>>
    connectOrCreate?: Enumerable<UserCrewCreateOrConnectWithoutCrewInput>
    upsert?: Enumerable<UserCrewUpsertWithWhereUniqueWithoutCrewInput>
    createMany?: UserCrewCreateManyCrewInputEnvelope
    set?: Enumerable<UserCrewWhereUniqueInput>
    disconnect?: Enumerable<UserCrewWhereUniqueInput>
    delete?: Enumerable<UserCrewWhereUniqueInput>
    connect?: Enumerable<UserCrewWhereUniqueInput>
    update?: Enumerable<UserCrewUpdateWithWhereUniqueWithoutCrewInput>
    updateMany?: Enumerable<UserCrewUpdateManyWithWhereWithoutCrewInput>
    deleteMany?: Enumerable<UserCrewScalarWhereInput>
  }

  export type UserCrewUncheckedUpdateManyWithoutCrewNestedInput = {
    create?: XOR<Enumerable<UserCrewCreateWithoutCrewInput>, Enumerable<UserCrewUncheckedCreateWithoutCrewInput>>
    connectOrCreate?: Enumerable<UserCrewCreateOrConnectWithoutCrewInput>
    upsert?: Enumerable<UserCrewUpsertWithWhereUniqueWithoutCrewInput>
    createMany?: UserCrewCreateManyCrewInputEnvelope
    set?: Enumerable<UserCrewWhereUniqueInput>
    disconnect?: Enumerable<UserCrewWhereUniqueInput>
    delete?: Enumerable<UserCrewWhereUniqueInput>
    connect?: Enumerable<UserCrewWhereUniqueInput>
    update?: Enumerable<UserCrewUpdateWithWhereUniqueWithoutCrewInput>
    updateMany?: Enumerable<UserCrewUpdateManyWithWhereWithoutCrewInput>
    deleteMany?: Enumerable<UserCrewScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutUserCrewInput = {
    create?: XOR<UserCreateWithoutUserCrewInput, UserUncheckedCreateWithoutUserCrewInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserCrewInput
    connect?: UserWhereUniqueInput
  }

  export type CrewCreateNestedOneWithoutUserCrewInput = {
    create?: XOR<CrewCreateWithoutUserCrewInput, CrewUncheckedCreateWithoutUserCrewInput>
    connectOrCreate?: CrewCreateOrConnectWithoutUserCrewInput
    connect?: CrewWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserCrewNestedInput = {
    create?: XOR<UserCreateWithoutUserCrewInput, UserUncheckedCreateWithoutUserCrewInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserCrewInput
    upsert?: UserUpsertWithoutUserCrewInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserCrewInput, UserUncheckedUpdateWithoutUserCrewInput>
  }

  export type CrewUpdateOneRequiredWithoutUserCrewNestedInput = {
    create?: XOR<CrewCreateWithoutUserCrewInput, CrewUncheckedCreateWithoutUserCrewInput>
    connectOrCreate?: CrewCreateOrConnectWithoutUserCrewInput
    upsert?: CrewUpsertWithoutUserCrewInput
    connect?: CrewWhereUniqueInput
    update?: XOR<CrewUpdateWithoutUserCrewInput, CrewUncheckedUpdateWithoutUserCrewInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type ProfileCreateWithoutUserInput = {
    photo: string
  }

  export type ProfileUncheckedCreateWithoutUserInput = {
    id?: number
    photo: string
  }

  export type ProfileCreateOrConnectWithoutUserInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type RecipeBookUserCreateWithoutUserInput = {
    recipeBook: RecipeBookCreateNestedOneWithoutRecipeBookUserInput
    permission: string
  }

  export type RecipeBookUserUncheckedCreateWithoutUserInput = {
    recipeBookId: number
    permission: string
  }

  export type RecipeBookUserCreateOrConnectWithoutUserInput = {
    where: RecipeBookUserWhereUniqueInput
    create: XOR<RecipeBookUserCreateWithoutUserInput, RecipeBookUserUncheckedCreateWithoutUserInput>
  }

  export type RecipeBookUserCreateManyUserInputEnvelope = {
    data: Enumerable<RecipeBookUserCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type RecipeBookCreateWithoutCreatedByInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    editedBy?: UserCreateNestedOneWithoutRecipeBookEditedByIdInput
    recipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutRecipeBookInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookUncheckedCreateWithoutCreatedByInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    editedById?: string | null
    recipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutRecipeBookInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookCreateOrConnectWithoutCreatedByInput = {
    where: RecipeBookWhereUniqueInput
    create: XOR<RecipeBookCreateWithoutCreatedByInput, RecipeBookUncheckedCreateWithoutCreatedByInput>
  }

  export type RecipeBookCreateManyCreatedByInputEnvelope = {
    data: Enumerable<RecipeBookCreateManyCreatedByInput>
    skipDuplicates?: boolean
  }

  export type RecipeBookCreateWithoutEditedByInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutRecipeBookInput
    recipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutRecipeBookInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookUncheckedCreateWithoutEditedByInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    recipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutRecipeBookInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookCreateOrConnectWithoutEditedByInput = {
    where: RecipeBookWhereUniqueInput
    create: XOR<RecipeBookCreateWithoutEditedByInput, RecipeBookUncheckedCreateWithoutEditedByInput>
  }

  export type RecipeBookCreateManyEditedByInputEnvelope = {
    data: Enumerable<RecipeBookCreateManyEditedByInput>
    skipDuplicates?: boolean
  }

  export type RecipeCreateWithoutCreatedByInput = {
    createdAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    build?: BuildCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutCreatedByInput = {
    id?: number
    createdAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    build?: BuildUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutCreatedByInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutCreatedByInput, RecipeUncheckedCreateWithoutCreatedByInput>
  }

  export type RecipeCreateManyCreatedByInputEnvelope = {
    data: Enumerable<RecipeCreateManyCreatedByInput>
    skipDuplicates?: boolean
  }

  export type BuildUserCreateWithoutUserInput = {
    build: BuildCreateNestedOneWithoutBuildUserInput
    permission: string
  }

  export type BuildUserUncheckedCreateWithoutUserInput = {
    buildId: number
    permission: string
  }

  export type BuildUserCreateOrConnectWithoutUserInput = {
    where: BuildUserWhereUniqueInput
    create: XOR<BuildUserCreateWithoutUserInput, BuildUserUncheckedCreateWithoutUserInput>
  }

  export type BuildUserCreateManyUserInputEnvelope = {
    data: Enumerable<BuildUserCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type BuildCreateWithoutCreatedByInput = {
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedBy?: UserCreateNestedOneWithoutBuildEditedByInput
    recipe?: RecipeCreateNestedOneWithoutBuildInput
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    touch?: TouchCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserCreateNestedManyWithoutBuildInput
  }

  export type BuildUncheckedCreateWithoutCreatedByInput = {
    id?: number
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedById: string
    recipeId?: number | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutBuildInput
  }

  export type BuildCreateOrConnectWithoutCreatedByInput = {
    where: BuildWhereUniqueInput
    create: XOR<BuildCreateWithoutCreatedByInput, BuildUncheckedCreateWithoutCreatedByInput>
  }

  export type BuildCreateManyCreatedByInputEnvelope = {
    data: Enumerable<BuildCreateManyCreatedByInput>
    skipDuplicates?: boolean
  }

  export type BuildCreateWithoutEditedByInput = {
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutBuildInput
    recipe?: RecipeCreateNestedOneWithoutBuildInput
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    touch?: TouchCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserCreateNestedManyWithoutBuildInput
  }

  export type BuildUncheckedCreateWithoutEditedByInput = {
    id?: number
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    recipeId?: number | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutBuildInput
  }

  export type BuildCreateOrConnectWithoutEditedByInput = {
    where: BuildWhereUniqueInput
    create: XOR<BuildCreateWithoutEditedByInput, BuildUncheckedCreateWithoutEditedByInput>
  }

  export type BuildCreateManyEditedByInputEnvelope = {
    data: Enumerable<BuildCreateManyEditedByInput>
    skipDuplicates?: boolean
  }

  export type UserCrewCreateWithoutUserInput = {
    crew: CrewCreateNestedOneWithoutUserCrewInput
    permission: string
  }

  export type UserCrewUncheckedCreateWithoutUserInput = {
    crewId: number
    permission: string
  }

  export type UserCrewCreateOrConnectWithoutUserInput = {
    where: UserCrewWhereUniqueInput
    create: XOR<UserCrewCreateWithoutUserInput, UserCrewUncheckedCreateWithoutUserInput>
  }

  export type UserCrewCreateManyUserInputEnvelope = {
    data: Enumerable<UserCrewCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type CrewCreateWithoutCreatedByInput = {
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedBy?: UserCreateNestedOneWithoutCrewEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutCrewInput
  }

  export type CrewUncheckedCreateWithoutCreatedByInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedById: string
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutCrewInput
  }

  export type CrewCreateOrConnectWithoutCreatedByInput = {
    where: CrewWhereUniqueInput
    create: XOR<CrewCreateWithoutCreatedByInput, CrewUncheckedCreateWithoutCreatedByInput>
  }

  export type CrewCreateManyCreatedByInputEnvelope = {
    data: Enumerable<CrewCreateManyCreatedByInput>
    skipDuplicates?: boolean
  }

  export type CrewCreateWithoutEditedByInput = {
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCrewInput
    userCrew?: UserCrewCreateNestedManyWithoutCrewInput
  }

  export type CrewUncheckedCreateWithoutEditedByInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutCrewInput
  }

  export type CrewCreateOrConnectWithoutEditedByInput = {
    where: CrewWhereUniqueInput
    create: XOR<CrewCreateWithoutEditedByInput, CrewUncheckedCreateWithoutEditedByInput>
  }

  export type CrewCreateManyEditedByInputEnvelope = {
    data: Enumerable<CrewCreateManyEditedByInput>
    skipDuplicates?: boolean
  }

  export type SpecificIngredientCreateWithoutCreatedByInput = {
    dateCreated?: Date | string
    genericIngredient: GenericIngredientCreateNestedOneWithoutSpecificIngredientInput
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    touch?: TouchCreateNestedManyWithoutSpecificIngredientInput
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutSpecificIngredientInput
  }

  export type SpecificIngredientUncheckedCreateWithoutCreatedByInput = {
    id?: number
    dateCreated?: Date | string
    genericIngredientId: number
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutSpecificIngredientInput
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutSpecificIngredientInput
  }

  export type SpecificIngredientCreateOrConnectWithoutCreatedByInput = {
    where: SpecificIngredientWhereUniqueInput
    create: XOR<SpecificIngredientCreateWithoutCreatedByInput, SpecificIngredientUncheckedCreateWithoutCreatedByInput>
  }

  export type SpecificIngredientCreateManyCreatedByInputEnvelope = {
    data: Enumerable<SpecificIngredientCreateManyCreatedByInput>
    skipDuplicates?: boolean
  }

  export type IngredientPreferenceCreateWithoutUserInput = {
    genericIngredient: GenericIngredientCreateNestedOneWithoutIngredientPreferenceInput
    specificIngredient: SpecificIngredientCreateNestedOneWithoutIngredientPreferenceInput
  }

  export type IngredientPreferenceUncheckedCreateWithoutUserInput = {
    genericIngredientID: number
    specificIngredientID: number
  }

  export type IngredientPreferenceCreateOrConnectWithoutUserInput = {
    where: IngredientPreferenceWhereUniqueInput
    create: XOR<IngredientPreferenceCreateWithoutUserInput, IngredientPreferenceUncheckedCreateWithoutUserInput>
  }

  export type IngredientPreferenceCreateManyUserInputEnvelope = {
    data: Enumerable<IngredientPreferenceCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type StorageUserCreateWithoutUserInput = {
    Storage: StorageCreateNestedOneWithoutStorageUserInput
    permission: string
  }

  export type StorageUserUncheckedCreateWithoutUserInput = {
    storageId: number
    permission: string
  }

  export type StorageUserCreateOrConnectWithoutUserInput = {
    where: StorageUserWhereUniqueInput
    create: XOR<StorageUserCreateWithoutUserInput, StorageUserUncheckedCreateWithoutUserInput>
  }

  export type StorageUserCreateManyUserInputEnvelope = {
    data: Enumerable<StorageUserCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type StorageCreateWithoutCreatedByInput = {
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedBy?: UserCreateNestedOneWithoutStorageEditedByInput
    inventoryStorage?: InventoryStorageCreateNestedManyWithoutStorageInput
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutStorageInput
    storageUser?: StorageUserCreateNestedManyWithoutStorageInput
  }

  export type StorageUncheckedCreateWithoutCreatedByInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedById: string
    inventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutStorageInput
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutStorageInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutStorageInput
  }

  export type StorageCreateOrConnectWithoutCreatedByInput = {
    where: StorageWhereUniqueInput
    create: XOR<StorageCreateWithoutCreatedByInput, StorageUncheckedCreateWithoutCreatedByInput>
  }

  export type StorageCreateManyCreatedByInputEnvelope = {
    data: Enumerable<StorageCreateManyCreatedByInput>
    skipDuplicates?: boolean
  }

  export type StorageCreateWithoutEditedByInput = {
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutStorageInput
    inventoryStorage?: InventoryStorageCreateNestedManyWithoutStorageInput
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutStorageInput
    storageUser?: StorageUserCreateNestedManyWithoutStorageInput
  }

  export type StorageUncheckedCreateWithoutEditedByInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    inventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutStorageInput
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutStorageInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutStorageInput
  }

  export type StorageCreateOrConnectWithoutEditedByInput = {
    where: StorageWhereUniqueInput
    create: XOR<StorageCreateWithoutEditedByInput, StorageUncheckedCreateWithoutEditedByInput>
  }

  export type StorageCreateManyEditedByInputEnvelope = {
    data: Enumerable<StorageCreateManyEditedByInput>
    skipDuplicates?: boolean
  }

  export type InventoryCreateWithoutCreatedByInput = {
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedBy?: UserCreateNestedOneWithoutInventoryEditedByInput
    inventoryStorage?: InventoryStorageCreateNestedManyWithoutInventoryInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutCreatedByInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedById: string
    inventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutInventoryInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryCreateOrConnectWithoutCreatedByInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutCreatedByInput, InventoryUncheckedCreateWithoutCreatedByInput>
  }

  export type InventoryCreateManyCreatedByInputEnvelope = {
    data: Enumerable<InventoryCreateManyCreatedByInput>
    skipDuplicates?: boolean
  }

  export type InventoryCreateWithoutEditedByInput = {
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutInventoryCreatedByInput
    inventoryStorage?: InventoryStorageCreateNestedManyWithoutInventoryInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutEditedByInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    inventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutInventoryInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryCreateOrConnectWithoutEditedByInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutEditedByInput, InventoryUncheckedCreateWithoutEditedByInput>
  }

  export type InventoryCreateManyEditedByInputEnvelope = {
    data: Enumerable<InventoryCreateManyEditedByInput>
    skipDuplicates?: boolean
  }

  export type InventoryUserCreateWithoutUserInput = {
    inventory: InventoryCreateNestedOneWithoutInventoryUserInput
    permission: string
  }

  export type InventoryUserUncheckedCreateWithoutUserInput = {
    inventoryId: number
    permission: string
  }

  export type InventoryUserCreateOrConnectWithoutUserInput = {
    where: InventoryUserWhereUniqueInput
    create: XOR<InventoryUserCreateWithoutUserInput, InventoryUserUncheckedCreateWithoutUserInput>
  }

  export type InventoryUserCreateManyUserInputEnvelope = {
    data: Enumerable<InventoryUserCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ProfileUpsertWithoutUserInput = {
    update: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type ProfileUpdateWithoutUserInput = {
    photo?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    photo?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookUserUpsertWithWhereUniqueWithoutUserInput = {
    where: RecipeBookUserWhereUniqueInput
    update: XOR<RecipeBookUserUpdateWithoutUserInput, RecipeBookUserUncheckedUpdateWithoutUserInput>
    create: XOR<RecipeBookUserCreateWithoutUserInput, RecipeBookUserUncheckedCreateWithoutUserInput>
  }

  export type RecipeBookUserUpdateWithWhereUniqueWithoutUserInput = {
    where: RecipeBookUserWhereUniqueInput
    data: XOR<RecipeBookUserUpdateWithoutUserInput, RecipeBookUserUncheckedUpdateWithoutUserInput>
  }

  export type RecipeBookUserUpdateManyWithWhereWithoutUserInput = {
    where: RecipeBookUserScalarWhereInput
    data: XOR<RecipeBookUserUpdateManyMutationInput, RecipeBookUserUncheckedUpdateManyWithoutRecipeBookUserInput>
  }

  export type RecipeBookUserScalarWhereInput = {
    AND?: Enumerable<RecipeBookUserScalarWhereInput>
    OR?: Enumerable<RecipeBookUserScalarWhereInput>
    NOT?: Enumerable<RecipeBookUserScalarWhereInput>
    userId?: StringFilter | string
    recipeBookId?: IntFilter | number
    permission?: StringFilter | string
  }

  export type RecipeBookUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: RecipeBookWhereUniqueInput
    update: XOR<RecipeBookUpdateWithoutCreatedByInput, RecipeBookUncheckedUpdateWithoutCreatedByInput>
    create: XOR<RecipeBookCreateWithoutCreatedByInput, RecipeBookUncheckedCreateWithoutCreatedByInput>
  }

  export type RecipeBookUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: RecipeBookWhereUniqueInput
    data: XOR<RecipeBookUpdateWithoutCreatedByInput, RecipeBookUncheckedUpdateWithoutCreatedByInput>
  }

  export type RecipeBookUpdateManyWithWhereWithoutCreatedByInput = {
    where: RecipeBookScalarWhereInput
    data: XOR<RecipeBookUpdateManyMutationInput, RecipeBookUncheckedUpdateManyWithoutRecipeBookInput>
  }

  export type RecipeBookScalarWhereInput = {
    AND?: Enumerable<RecipeBookScalarWhereInput>
    OR?: Enumerable<RecipeBookScalarWhereInput>
    NOT?: Enumerable<RecipeBookScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    editedAt?: DateTimeFilter | Date | string
    createdById?: StringNullableFilter | string | null
    editedById?: StringNullableFilter | string | null
  }

  export type RecipeBookUpsertWithWhereUniqueWithoutEditedByInput = {
    where: RecipeBookWhereUniqueInput
    update: XOR<RecipeBookUpdateWithoutEditedByInput, RecipeBookUncheckedUpdateWithoutEditedByInput>
    create: XOR<RecipeBookCreateWithoutEditedByInput, RecipeBookUncheckedCreateWithoutEditedByInput>
  }

  export type RecipeBookUpdateWithWhereUniqueWithoutEditedByInput = {
    where: RecipeBookWhereUniqueInput
    data: XOR<RecipeBookUpdateWithoutEditedByInput, RecipeBookUncheckedUpdateWithoutEditedByInput>
  }

  export type RecipeBookUpdateManyWithWhereWithoutEditedByInput = {
    where: RecipeBookScalarWhereInput
    data: XOR<RecipeBookUpdateManyMutationInput, RecipeBookUncheckedUpdateManyWithoutRecipeBookEditedByIdInput>
  }

  export type RecipeUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: RecipeWhereUniqueInput
    update: XOR<RecipeUpdateWithoutCreatedByInput, RecipeUncheckedUpdateWithoutCreatedByInput>
    create: XOR<RecipeCreateWithoutCreatedByInput, RecipeUncheckedCreateWithoutCreatedByInput>
  }

  export type RecipeUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: RecipeWhereUniqueInput
    data: XOR<RecipeUpdateWithoutCreatedByInput, RecipeUncheckedUpdateWithoutCreatedByInput>
  }

  export type RecipeUpdateManyWithWhereWithoutCreatedByInput = {
    where: RecipeScalarWhereInput
    data: XOR<RecipeUpdateManyMutationInput, RecipeUncheckedUpdateManyWithoutRecipeInput>
  }

  export type RecipeScalarWhereInput = {
    AND?: Enumerable<RecipeScalarWhereInput>
    OR?: Enumerable<RecipeScalarWhereInput>
    NOT?: Enumerable<RecipeScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    name?: StringFilter | string
    origin?: StringNullableFilter | string | null
    history?: StringNullableFilter | string | null
    createdById?: StringFilter | string
  }

  export type BuildUserUpsertWithWhereUniqueWithoutUserInput = {
    where: BuildUserWhereUniqueInput
    update: XOR<BuildUserUpdateWithoutUserInput, BuildUserUncheckedUpdateWithoutUserInput>
    create: XOR<BuildUserCreateWithoutUserInput, BuildUserUncheckedCreateWithoutUserInput>
  }

  export type BuildUserUpdateWithWhereUniqueWithoutUserInput = {
    where: BuildUserWhereUniqueInput
    data: XOR<BuildUserUpdateWithoutUserInput, BuildUserUncheckedUpdateWithoutUserInput>
  }

  export type BuildUserUpdateManyWithWhereWithoutUserInput = {
    where: BuildUserScalarWhereInput
    data: XOR<BuildUserUpdateManyMutationInput, BuildUserUncheckedUpdateManyWithoutBuildUserInput>
  }

  export type BuildUserScalarWhereInput = {
    AND?: Enumerable<BuildUserScalarWhereInput>
    OR?: Enumerable<BuildUserScalarWhereInput>
    NOT?: Enumerable<BuildUserScalarWhereInput>
    userId?: StringFilter | string
    buildId?: IntFilter | number
    permission?: StringFilter | string
  }

  export type BuildUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: BuildWhereUniqueInput
    update: XOR<BuildUpdateWithoutCreatedByInput, BuildUncheckedUpdateWithoutCreatedByInput>
    create: XOR<BuildCreateWithoutCreatedByInput, BuildUncheckedCreateWithoutCreatedByInput>
  }

  export type BuildUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: BuildWhereUniqueInput
    data: XOR<BuildUpdateWithoutCreatedByInput, BuildUncheckedUpdateWithoutCreatedByInput>
  }

  export type BuildUpdateManyWithWhereWithoutCreatedByInput = {
    where: BuildScalarWhereInput
    data: XOR<BuildUpdateManyMutationInput, BuildUncheckedUpdateManyWithoutBuildInput>
  }

  export type BuildScalarWhereInput = {
    AND?: Enumerable<BuildScalarWhereInput>
    OR?: Enumerable<BuildScalarWhereInput>
    NOT?: Enumerable<BuildScalarWhereInput>
    id?: IntFilter | number
    buildName?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    editedAt?: DateTimeFilter | Date | string
    createdById?: StringFilter | string
    editedById?: StringFilter | string
    recipeId?: IntNullableFilter | number | null
    instructions?: StringNullableFilter | string | null
    notes?: StringNullableFilter | string | null
    glassware?: StringNullableFilter | string | null
    ice?: StringNullableFilter | string | null
  }

  export type BuildUpsertWithWhereUniqueWithoutEditedByInput = {
    where: BuildWhereUniqueInput
    update: XOR<BuildUpdateWithoutEditedByInput, BuildUncheckedUpdateWithoutEditedByInput>
    create: XOR<BuildCreateWithoutEditedByInput, BuildUncheckedCreateWithoutEditedByInput>
  }

  export type BuildUpdateWithWhereUniqueWithoutEditedByInput = {
    where: BuildWhereUniqueInput
    data: XOR<BuildUpdateWithoutEditedByInput, BuildUncheckedUpdateWithoutEditedByInput>
  }

  export type BuildUpdateManyWithWhereWithoutEditedByInput = {
    where: BuildScalarWhereInput
    data: XOR<BuildUpdateManyMutationInput, BuildUncheckedUpdateManyWithoutBuildEditedByInput>
  }

  export type UserCrewUpsertWithWhereUniqueWithoutUserInput = {
    where: UserCrewWhereUniqueInput
    update: XOR<UserCrewUpdateWithoutUserInput, UserCrewUncheckedUpdateWithoutUserInput>
    create: XOR<UserCrewCreateWithoutUserInput, UserCrewUncheckedCreateWithoutUserInput>
  }

  export type UserCrewUpdateWithWhereUniqueWithoutUserInput = {
    where: UserCrewWhereUniqueInput
    data: XOR<UserCrewUpdateWithoutUserInput, UserCrewUncheckedUpdateWithoutUserInput>
  }

  export type UserCrewUpdateManyWithWhereWithoutUserInput = {
    where: UserCrewScalarWhereInput
    data: XOR<UserCrewUpdateManyMutationInput, UserCrewUncheckedUpdateManyWithoutUserCrewInput>
  }

  export type UserCrewScalarWhereInput = {
    AND?: Enumerable<UserCrewScalarWhereInput>
    OR?: Enumerable<UserCrewScalarWhereInput>
    NOT?: Enumerable<UserCrewScalarWhereInput>
    userId?: StringFilter | string
    crewId?: IntFilter | number
    permission?: StringFilter | string
  }

  export type CrewUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: CrewWhereUniqueInput
    update: XOR<CrewUpdateWithoutCreatedByInput, CrewUncheckedUpdateWithoutCreatedByInput>
    create: XOR<CrewCreateWithoutCreatedByInput, CrewUncheckedCreateWithoutCreatedByInput>
  }

  export type CrewUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: CrewWhereUniqueInput
    data: XOR<CrewUpdateWithoutCreatedByInput, CrewUncheckedUpdateWithoutCreatedByInput>
  }

  export type CrewUpdateManyWithWhereWithoutCreatedByInput = {
    where: CrewScalarWhereInput
    data: XOR<CrewUpdateManyMutationInput, CrewUncheckedUpdateManyWithoutCrewInput>
  }

  export type CrewScalarWhereInput = {
    AND?: Enumerable<CrewScalarWhereInput>
    OR?: Enumerable<CrewScalarWhereInput>
    NOT?: Enumerable<CrewScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    editedAt?: DateTimeFilter | Date | string
    createdById?: StringFilter | string
    editedById?: StringFilter | string
  }

  export type CrewUpsertWithWhereUniqueWithoutEditedByInput = {
    where: CrewWhereUniqueInput
    update: XOR<CrewUpdateWithoutEditedByInput, CrewUncheckedUpdateWithoutEditedByInput>
    create: XOR<CrewCreateWithoutEditedByInput, CrewUncheckedCreateWithoutEditedByInput>
  }

  export type CrewUpdateWithWhereUniqueWithoutEditedByInput = {
    where: CrewWhereUniqueInput
    data: XOR<CrewUpdateWithoutEditedByInput, CrewUncheckedUpdateWithoutEditedByInput>
  }

  export type CrewUpdateManyWithWhereWithoutEditedByInput = {
    where: CrewScalarWhereInput
    data: XOR<CrewUpdateManyMutationInput, CrewUncheckedUpdateManyWithoutCrewEditedByInput>
  }

  export type SpecificIngredientUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: SpecificIngredientWhereUniqueInput
    update: XOR<SpecificIngredientUpdateWithoutCreatedByInput, SpecificIngredientUncheckedUpdateWithoutCreatedByInput>
    create: XOR<SpecificIngredientCreateWithoutCreatedByInput, SpecificIngredientUncheckedCreateWithoutCreatedByInput>
  }

  export type SpecificIngredientUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: SpecificIngredientWhereUniqueInput
    data: XOR<SpecificIngredientUpdateWithoutCreatedByInput, SpecificIngredientUncheckedUpdateWithoutCreatedByInput>
  }

  export type SpecificIngredientUpdateManyWithWhereWithoutCreatedByInput = {
    where: SpecificIngredientScalarWhereInput
    data: XOR<SpecificIngredientUpdateManyMutationInput, SpecificIngredientUncheckedUpdateManyWithoutIngredientInput>
  }

  export type SpecificIngredientScalarWhereInput = {
    AND?: Enumerable<SpecificIngredientScalarWhereInput>
    OR?: Enumerable<SpecificIngredientScalarWhereInput>
    NOT?: Enumerable<SpecificIngredientScalarWhereInput>
    id?: IntFilter | number
    dateCreated?: DateTimeFilter | Date | string
    createdById?: StringNullableFilter | string | null
    genericIngredientId?: IntFilter | number
    name?: StringFilter | string
    description?: StringFilter | string
    price?: FloatNullableFilter | number | null
    amount?: FloatNullableFilter | number | null
    unit?: StringNullableFilter | string | null
    source?: StringNullableFilter | string | null
  }

  export type IngredientPreferenceUpsertWithWhereUniqueWithoutUserInput = {
    where: IngredientPreferenceWhereUniqueInput
    update: XOR<IngredientPreferenceUpdateWithoutUserInput, IngredientPreferenceUncheckedUpdateWithoutUserInput>
    create: XOR<IngredientPreferenceCreateWithoutUserInput, IngredientPreferenceUncheckedCreateWithoutUserInput>
  }

  export type IngredientPreferenceUpdateWithWhereUniqueWithoutUserInput = {
    where: IngredientPreferenceWhereUniqueInput
    data: XOR<IngredientPreferenceUpdateWithoutUserInput, IngredientPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type IngredientPreferenceUpdateManyWithWhereWithoutUserInput = {
    where: IngredientPreferenceScalarWhereInput
    data: XOR<IngredientPreferenceUpdateManyMutationInput, IngredientPreferenceUncheckedUpdateManyWithoutIngredientPreferenceInput>
  }

  export type IngredientPreferenceScalarWhereInput = {
    AND?: Enumerable<IngredientPreferenceScalarWhereInput>
    OR?: Enumerable<IngredientPreferenceScalarWhereInput>
    NOT?: Enumerable<IngredientPreferenceScalarWhereInput>
    genericIngredientID?: IntFilter | number
    specificIngredientID?: IntFilter | number
    userId?: StringFilter | string
  }

  export type StorageUserUpsertWithWhereUniqueWithoutUserInput = {
    where: StorageUserWhereUniqueInput
    update: XOR<StorageUserUpdateWithoutUserInput, StorageUserUncheckedUpdateWithoutUserInput>
    create: XOR<StorageUserCreateWithoutUserInput, StorageUserUncheckedCreateWithoutUserInput>
  }

  export type StorageUserUpdateWithWhereUniqueWithoutUserInput = {
    where: StorageUserWhereUniqueInput
    data: XOR<StorageUserUpdateWithoutUserInput, StorageUserUncheckedUpdateWithoutUserInput>
  }

  export type StorageUserUpdateManyWithWhereWithoutUserInput = {
    where: StorageUserScalarWhereInput
    data: XOR<StorageUserUpdateManyMutationInput, StorageUserUncheckedUpdateManyWithoutStorageUserInput>
  }

  export type StorageUserScalarWhereInput = {
    AND?: Enumerable<StorageUserScalarWhereInput>
    OR?: Enumerable<StorageUserScalarWhereInput>
    NOT?: Enumerable<StorageUserScalarWhereInput>
    userId?: StringFilter | string
    storageId?: IntFilter | number
    permission?: StringFilter | string
  }

  export type StorageUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: StorageWhereUniqueInput
    update: XOR<StorageUpdateWithoutCreatedByInput, StorageUncheckedUpdateWithoutCreatedByInput>
    create: XOR<StorageCreateWithoutCreatedByInput, StorageUncheckedCreateWithoutCreatedByInput>
  }

  export type StorageUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: StorageWhereUniqueInput
    data: XOR<StorageUpdateWithoutCreatedByInput, StorageUncheckedUpdateWithoutCreatedByInput>
  }

  export type StorageUpdateManyWithWhereWithoutCreatedByInput = {
    where: StorageScalarWhereInput
    data: XOR<StorageUpdateManyMutationInput, StorageUncheckedUpdateManyWithoutStorageInput>
  }

  export type StorageScalarWhereInput = {
    AND?: Enumerable<StorageScalarWhereInput>
    OR?: Enumerable<StorageScalarWhereInput>
    NOT?: Enumerable<StorageScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    editedAt?: DateTimeFilter | Date | string
    createdById?: StringFilter | string
    editedById?: StringFilter | string
  }

  export type StorageUpsertWithWhereUniqueWithoutEditedByInput = {
    where: StorageWhereUniqueInput
    update: XOR<StorageUpdateWithoutEditedByInput, StorageUncheckedUpdateWithoutEditedByInput>
    create: XOR<StorageCreateWithoutEditedByInput, StorageUncheckedCreateWithoutEditedByInput>
  }

  export type StorageUpdateWithWhereUniqueWithoutEditedByInput = {
    where: StorageWhereUniqueInput
    data: XOR<StorageUpdateWithoutEditedByInput, StorageUncheckedUpdateWithoutEditedByInput>
  }

  export type StorageUpdateManyWithWhereWithoutEditedByInput = {
    where: StorageScalarWhereInput
    data: XOR<StorageUpdateManyMutationInput, StorageUncheckedUpdateManyWithoutStorageEditedByInput>
  }

  export type InventoryUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: InventoryWhereUniqueInput
    update: XOR<InventoryUpdateWithoutCreatedByInput, InventoryUncheckedUpdateWithoutCreatedByInput>
    create: XOR<InventoryCreateWithoutCreatedByInput, InventoryUncheckedCreateWithoutCreatedByInput>
  }

  export type InventoryUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: InventoryWhereUniqueInput
    data: XOR<InventoryUpdateWithoutCreatedByInput, InventoryUncheckedUpdateWithoutCreatedByInput>
  }

  export type InventoryUpdateManyWithWhereWithoutCreatedByInput = {
    where: InventoryScalarWhereInput
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyWithoutInventoryCreatedByInput>
  }

  export type InventoryScalarWhereInput = {
    AND?: Enumerable<InventoryScalarWhereInput>
    OR?: Enumerable<InventoryScalarWhereInput>
    NOT?: Enumerable<InventoryScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    editedAt?: DateTimeFilter | Date | string
    createdById?: StringFilter | string
    editedById?: StringFilter | string
  }

  export type InventoryUpsertWithWhereUniqueWithoutEditedByInput = {
    where: InventoryWhereUniqueInput
    update: XOR<InventoryUpdateWithoutEditedByInput, InventoryUncheckedUpdateWithoutEditedByInput>
    create: XOR<InventoryCreateWithoutEditedByInput, InventoryUncheckedCreateWithoutEditedByInput>
  }

  export type InventoryUpdateWithWhereUniqueWithoutEditedByInput = {
    where: InventoryWhereUniqueInput
    data: XOR<InventoryUpdateWithoutEditedByInput, InventoryUncheckedUpdateWithoutEditedByInput>
  }

  export type InventoryUpdateManyWithWhereWithoutEditedByInput = {
    where: InventoryScalarWhereInput
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyWithoutInventoryEditedByInput>
  }

  export type InventoryUserUpsertWithWhereUniqueWithoutUserInput = {
    where: InventoryUserWhereUniqueInput
    update: XOR<InventoryUserUpdateWithoutUserInput, InventoryUserUncheckedUpdateWithoutUserInput>
    create: XOR<InventoryUserCreateWithoutUserInput, InventoryUserUncheckedCreateWithoutUserInput>
  }

  export type InventoryUserUpdateWithWhereUniqueWithoutUserInput = {
    where: InventoryUserWhereUniqueInput
    data: XOR<InventoryUserUpdateWithoutUserInput, InventoryUserUncheckedUpdateWithoutUserInput>
  }

  export type InventoryUserUpdateManyWithWhereWithoutUserInput = {
    where: InventoryUserScalarWhereInput
    data: XOR<InventoryUserUpdateManyMutationInput, InventoryUserUncheckedUpdateManyWithoutInventoryUserInput>
  }

  export type InventoryUserScalarWhereInput = {
    AND?: Enumerable<InventoryUserScalarWhereInput>
    OR?: Enumerable<InventoryUserScalarWhereInput>
    NOT?: Enumerable<InventoryUserScalarWhereInput>
    userId?: StringFilter | string
    inventoryId?: IntFilter | number
    permission?: StringFilter | string
  }

  export type UserCreateWithoutProfileInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutRecipeBookInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRecipeBookInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRecipeBookInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecipeBookInput, UserUncheckedCreateWithoutRecipeBookInput>
  }

  export type UserCreateWithoutRecipeBookEditedByIdInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRecipeBookEditedByIdInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRecipeBookEditedByIdInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecipeBookEditedByIdInput, UserUncheckedCreateWithoutRecipeBookEditedByIdInput>
  }

  export type RecipeBookBuildCreateWithoutRecipeBookInput = {
    build: BuildCreateNestedOneWithoutRecipeBookBuildInput
  }

  export type RecipeBookBuildUncheckedCreateWithoutRecipeBookInput = {
    buildId: number
  }

  export type RecipeBookBuildCreateOrConnectWithoutRecipeBookInput = {
    where: RecipeBookBuildWhereUniqueInput
    create: XOR<RecipeBookBuildCreateWithoutRecipeBookInput, RecipeBookBuildUncheckedCreateWithoutRecipeBookInput>
  }

  export type RecipeBookBuildCreateManyRecipeBookInputEnvelope = {
    data: Enumerable<RecipeBookBuildCreateManyRecipeBookInput>
    skipDuplicates?: boolean
  }

  export type RecipeBookUserCreateWithoutRecipeBookInput = {
    user: UserCreateNestedOneWithoutRecipeBookUserInput
    permission: string
  }

  export type RecipeBookUserUncheckedCreateWithoutRecipeBookInput = {
    userId: string
    permission: string
  }

  export type RecipeBookUserCreateOrConnectWithoutRecipeBookInput = {
    where: RecipeBookUserWhereUniqueInput
    create: XOR<RecipeBookUserCreateWithoutRecipeBookInput, RecipeBookUserUncheckedCreateWithoutRecipeBookInput>
  }

  export type RecipeBookUserCreateManyRecipeBookInputEnvelope = {
    data: Enumerable<RecipeBookUserCreateManyRecipeBookInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutRecipeBookInput = {
    update: XOR<UserUpdateWithoutRecipeBookInput, UserUncheckedUpdateWithoutRecipeBookInput>
    create: XOR<UserCreateWithoutRecipeBookInput, UserUncheckedCreateWithoutRecipeBookInput>
  }

  export type UserUpdateWithoutRecipeBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRecipeBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutRecipeBookEditedByIdInput = {
    update: XOR<UserUpdateWithoutRecipeBookEditedByIdInput, UserUncheckedUpdateWithoutRecipeBookEditedByIdInput>
    create: XOR<UserCreateWithoutRecipeBookEditedByIdInput, UserUncheckedCreateWithoutRecipeBookEditedByIdInput>
  }

  export type UserUpdateWithoutRecipeBookEditedByIdInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRecipeBookEditedByIdInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RecipeBookBuildUpsertWithWhereUniqueWithoutRecipeBookInput = {
    where: RecipeBookBuildWhereUniqueInput
    update: XOR<RecipeBookBuildUpdateWithoutRecipeBookInput, RecipeBookBuildUncheckedUpdateWithoutRecipeBookInput>
    create: XOR<RecipeBookBuildCreateWithoutRecipeBookInput, RecipeBookBuildUncheckedCreateWithoutRecipeBookInput>
  }

  export type RecipeBookBuildUpdateWithWhereUniqueWithoutRecipeBookInput = {
    where: RecipeBookBuildWhereUniqueInput
    data: XOR<RecipeBookBuildUpdateWithoutRecipeBookInput, RecipeBookBuildUncheckedUpdateWithoutRecipeBookInput>
  }

  export type RecipeBookBuildUpdateManyWithWhereWithoutRecipeBookInput = {
    where: RecipeBookBuildScalarWhereInput
    data: XOR<RecipeBookBuildUpdateManyMutationInput, RecipeBookBuildUncheckedUpdateManyWithoutRecipeBookBuildInput>
  }

  export type RecipeBookBuildScalarWhereInput = {
    AND?: Enumerable<RecipeBookBuildScalarWhereInput>
    OR?: Enumerable<RecipeBookBuildScalarWhereInput>
    NOT?: Enumerable<RecipeBookBuildScalarWhereInput>
    buildId?: IntFilter | number
    recipeBookId?: IntFilter | number
  }

  export type RecipeBookUserUpsertWithWhereUniqueWithoutRecipeBookInput = {
    where: RecipeBookUserWhereUniqueInput
    update: XOR<RecipeBookUserUpdateWithoutRecipeBookInput, RecipeBookUserUncheckedUpdateWithoutRecipeBookInput>
    create: XOR<RecipeBookUserCreateWithoutRecipeBookInput, RecipeBookUserUncheckedCreateWithoutRecipeBookInput>
  }

  export type RecipeBookUserUpdateWithWhereUniqueWithoutRecipeBookInput = {
    where: RecipeBookUserWhereUniqueInput
    data: XOR<RecipeBookUserUpdateWithoutRecipeBookInput, RecipeBookUserUncheckedUpdateWithoutRecipeBookInput>
  }

  export type RecipeBookUserUpdateManyWithWhereWithoutRecipeBookInput = {
    where: RecipeBookUserScalarWhereInput
    data: XOR<RecipeBookUserUpdateManyMutationInput, RecipeBookUserUncheckedUpdateManyWithoutRecipeBookUserInput>
  }

  export type RecipeBookCreateWithoutRecipeBookUserInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutRecipeBookInput
    editedBy?: UserCreateNestedOneWithoutRecipeBookEditedByIdInput
    recipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookUncheckedCreateWithoutRecipeBookUserInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    editedById?: string | null
    recipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookCreateOrConnectWithoutRecipeBookUserInput = {
    where: RecipeBookWhereUniqueInput
    create: XOR<RecipeBookCreateWithoutRecipeBookUserInput, RecipeBookUncheckedCreateWithoutRecipeBookUserInput>
  }

  export type UserCreateWithoutRecipeBookUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRecipeBookUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRecipeBookUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecipeBookUserInput, UserUncheckedCreateWithoutRecipeBookUserInput>
  }

  export type RecipeBookUpsertWithoutRecipeBookUserInput = {
    update: XOR<RecipeBookUpdateWithoutRecipeBookUserInput, RecipeBookUncheckedUpdateWithoutRecipeBookUserInput>
    create: XOR<RecipeBookCreateWithoutRecipeBookUserInput, RecipeBookUncheckedCreateWithoutRecipeBookUserInput>
  }

  export type RecipeBookUpdateWithoutRecipeBookUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutRecipeBookNestedInput
    editedBy?: UserUpdateOneWithoutRecipeBookEditedByIdNestedInput
    recipeBookBuild?: RecipeBookBuildUpdateManyWithoutRecipeBookNestedInput
  }

  export type RecipeBookUncheckedUpdateWithoutRecipeBookUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutRecipeBookNestedInput
  }

  export type UserUpsertWithoutRecipeBookUserInput = {
    update: XOR<UserUpdateWithoutRecipeBookUserInput, UserUncheckedUpdateWithoutRecipeBookUserInput>
    create: XOR<UserCreateWithoutRecipeBookUserInput, UserUncheckedCreateWithoutRecipeBookUserInput>
  }

  export type UserUpdateWithoutRecipeBookUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRecipeBookUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutBuildInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBuildInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBuildInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBuildInput, UserUncheckedCreateWithoutBuildInput>
  }

  export type UserCreateWithoutBuildEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBuildEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBuildEditedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBuildEditedByInput, UserUncheckedCreateWithoutBuildEditedByInput>
  }

  export type RecipeCreateWithoutBuildInput = {
    createdAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    createdBy: UserCreateNestedOneWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutBuildInput = {
    id?: number
    createdAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    createdById: string
  }

  export type RecipeCreateOrConnectWithoutBuildInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutBuildInput, RecipeUncheckedCreateWithoutBuildInput>
  }

  export type TouchCreateWithoutBuildInput = {
    order?: number | null
    amount?: number | null
    unit?: string | null
    genericIngredient: GenericIngredientCreateNestedOneWithoutTouchInput
    specificIngredient?: SpecificIngredientCreateNestedOneWithoutTouchInput
  }

  export type TouchUncheckedCreateWithoutBuildInput = {
    id?: number
    order?: number | null
    amount?: number | null
    unit?: string | null
    genericIngredientID: number
    specificIngredientID?: number | null
  }

  export type TouchCreateOrConnectWithoutBuildInput = {
    where: TouchWhereUniqueInput
    create: XOR<TouchCreateWithoutBuildInput, TouchUncheckedCreateWithoutBuildInput>
  }

  export type TouchCreateManyBuildInputEnvelope = {
    data: Enumerable<TouchCreateManyBuildInput>
    skipDuplicates?: boolean
  }

  export type RecipeBookBuildCreateWithoutBuildInput = {
    recipeBook: RecipeBookCreateNestedOneWithoutRecipeBookBuildInput
  }

  export type RecipeBookBuildUncheckedCreateWithoutBuildInput = {
    recipeBookId: number
  }

  export type RecipeBookBuildCreateOrConnectWithoutBuildInput = {
    where: RecipeBookBuildWhereUniqueInput
    create: XOR<RecipeBookBuildCreateWithoutBuildInput, RecipeBookBuildUncheckedCreateWithoutBuildInput>
  }

  export type RecipeBookBuildCreateManyBuildInputEnvelope = {
    data: Enumerable<RecipeBookBuildCreateManyBuildInput>
    skipDuplicates?: boolean
  }

  export type BuildUserCreateWithoutBuildInput = {
    user: UserCreateNestedOneWithoutBuildUserInput
    permission: string
  }

  export type BuildUserUncheckedCreateWithoutBuildInput = {
    userId: string
    permission: string
  }

  export type BuildUserCreateOrConnectWithoutBuildInput = {
    where: BuildUserWhereUniqueInput
    create: XOR<BuildUserCreateWithoutBuildInput, BuildUserUncheckedCreateWithoutBuildInput>
  }

  export type BuildUserCreateManyBuildInputEnvelope = {
    data: Enumerable<BuildUserCreateManyBuildInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBuildInput = {
    update: XOR<UserUpdateWithoutBuildInput, UserUncheckedUpdateWithoutBuildInput>
    create: XOR<UserCreateWithoutBuildInput, UserUncheckedCreateWithoutBuildInput>
  }

  export type UserUpdateWithoutBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutBuildEditedByInput = {
    update: XOR<UserUpdateWithoutBuildEditedByInput, UserUncheckedUpdateWithoutBuildEditedByInput>
    create: XOR<UserCreateWithoutBuildEditedByInput, UserUncheckedCreateWithoutBuildEditedByInput>
  }

  export type UserUpdateWithoutBuildEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBuildEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RecipeUpsertWithoutBuildInput = {
    update: XOR<RecipeUpdateWithoutBuildInput, RecipeUncheckedUpdateWithoutBuildInput>
    create: XOR<RecipeCreateWithoutBuildInput, RecipeUncheckedCreateWithoutBuildInput>
  }

  export type RecipeUpdateWithoutBuildInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneRequiredWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutBuildInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type TouchUpsertWithWhereUniqueWithoutBuildInput = {
    where: TouchWhereUniqueInput
    update: XOR<TouchUpdateWithoutBuildInput, TouchUncheckedUpdateWithoutBuildInput>
    create: XOR<TouchCreateWithoutBuildInput, TouchUncheckedCreateWithoutBuildInput>
  }

  export type TouchUpdateWithWhereUniqueWithoutBuildInput = {
    where: TouchWhereUniqueInput
    data: XOR<TouchUpdateWithoutBuildInput, TouchUncheckedUpdateWithoutBuildInput>
  }

  export type TouchUpdateManyWithWhereWithoutBuildInput = {
    where: TouchScalarWhereInput
    data: XOR<TouchUpdateManyMutationInput, TouchUncheckedUpdateManyWithoutTouchInput>
  }

  export type TouchScalarWhereInput = {
    AND?: Enumerable<TouchScalarWhereInput>
    OR?: Enumerable<TouchScalarWhereInput>
    NOT?: Enumerable<TouchScalarWhereInput>
    id?: IntFilter | number
    buildId?: IntNullableFilter | number | null
    order?: IntNullableFilter | number | null
    amount?: FloatNullableFilter | number | null
    unit?: StringNullableFilter | string | null
    genericIngredientID?: IntFilter | number
    specificIngredientID?: IntNullableFilter | number | null
  }

  export type RecipeBookBuildUpsertWithWhereUniqueWithoutBuildInput = {
    where: RecipeBookBuildWhereUniqueInput
    update: XOR<RecipeBookBuildUpdateWithoutBuildInput, RecipeBookBuildUncheckedUpdateWithoutBuildInput>
    create: XOR<RecipeBookBuildCreateWithoutBuildInput, RecipeBookBuildUncheckedCreateWithoutBuildInput>
  }

  export type RecipeBookBuildUpdateWithWhereUniqueWithoutBuildInput = {
    where: RecipeBookBuildWhereUniqueInput
    data: XOR<RecipeBookBuildUpdateWithoutBuildInput, RecipeBookBuildUncheckedUpdateWithoutBuildInput>
  }

  export type RecipeBookBuildUpdateManyWithWhereWithoutBuildInput = {
    where: RecipeBookBuildScalarWhereInput
    data: XOR<RecipeBookBuildUpdateManyMutationInput, RecipeBookBuildUncheckedUpdateManyWithoutRecipeBookBuildInput>
  }

  export type BuildUserUpsertWithWhereUniqueWithoutBuildInput = {
    where: BuildUserWhereUniqueInput
    update: XOR<BuildUserUpdateWithoutBuildInput, BuildUserUncheckedUpdateWithoutBuildInput>
    create: XOR<BuildUserCreateWithoutBuildInput, BuildUserUncheckedCreateWithoutBuildInput>
  }

  export type BuildUserUpdateWithWhereUniqueWithoutBuildInput = {
    where: BuildUserWhereUniqueInput
    data: XOR<BuildUserUpdateWithoutBuildInput, BuildUserUncheckedUpdateWithoutBuildInput>
  }

  export type BuildUserUpdateManyWithWhereWithoutBuildInput = {
    where: BuildUserScalarWhereInput
    data: XOR<BuildUserUpdateManyMutationInput, BuildUserUncheckedUpdateManyWithoutBuildUserInput>
  }

  export type UserCreateWithoutBuildUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBuildUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBuildUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBuildUserInput, UserUncheckedCreateWithoutBuildUserInput>
  }

  export type BuildCreateWithoutBuildUserInput = {
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutBuildInput
    editedBy?: UserCreateNestedOneWithoutBuildEditedByInput
    recipe?: RecipeCreateNestedOneWithoutBuildInput
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    touch?: TouchCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutBuildInput
  }

  export type BuildUncheckedCreateWithoutBuildUserInput = {
    id?: number
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    recipeId?: number | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutBuildInput
  }

  export type BuildCreateOrConnectWithoutBuildUserInput = {
    where: BuildWhereUniqueInput
    create: XOR<BuildCreateWithoutBuildUserInput, BuildUncheckedCreateWithoutBuildUserInput>
  }

  export type UserUpsertWithoutBuildUserInput = {
    update: XOR<UserUpdateWithoutBuildUserInput, UserUncheckedUpdateWithoutBuildUserInput>
    create: XOR<UserCreateWithoutBuildUserInput, UserUncheckedCreateWithoutBuildUserInput>
  }

  export type UserUpdateWithoutBuildUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBuildUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BuildUpsertWithoutBuildUserInput = {
    update: XOR<BuildUpdateWithoutBuildUserInput, BuildUncheckedUpdateWithoutBuildUserInput>
    create: XOR<BuildCreateWithoutBuildUserInput, BuildUncheckedCreateWithoutBuildUserInput>
  }

  export type BuildUpdateWithoutBuildUserInput = {
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutBuildNestedInput
    editedBy?: UserUpdateOneWithoutBuildEditedByNestedInput
    recipe?: RecipeUpdateOneWithoutBuildNestedInput
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateWithoutBuildUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutBuildNestedInput
  }

  export type UserCreateWithoutRecipeInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRecipeInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRecipeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecipeInput, UserUncheckedCreateWithoutRecipeInput>
  }

  export type BuildCreateWithoutRecipeInput = {
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutBuildInput
    editedBy?: UserCreateNestedOneWithoutBuildEditedByInput
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    touch?: TouchCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserCreateNestedManyWithoutBuildInput
  }

  export type BuildUncheckedCreateWithoutRecipeInput = {
    id?: number
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutBuildInput
  }

  export type BuildCreateOrConnectWithoutRecipeInput = {
    where: BuildWhereUniqueInput
    create: XOR<BuildCreateWithoutRecipeInput, BuildUncheckedCreateWithoutRecipeInput>
  }

  export type BuildCreateManyRecipeInputEnvelope = {
    data: Enumerable<BuildCreateManyRecipeInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutRecipeInput = {
    update: XOR<UserUpdateWithoutRecipeInput, UserUncheckedUpdateWithoutRecipeInput>
    create: XOR<UserCreateWithoutRecipeInput, UserUncheckedCreateWithoutRecipeInput>
  }

  export type UserUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BuildUpsertWithWhereUniqueWithoutRecipeInput = {
    where: BuildWhereUniqueInput
    update: XOR<BuildUpdateWithoutRecipeInput, BuildUncheckedUpdateWithoutRecipeInput>
    create: XOR<BuildCreateWithoutRecipeInput, BuildUncheckedCreateWithoutRecipeInput>
  }

  export type BuildUpdateWithWhereUniqueWithoutRecipeInput = {
    where: BuildWhereUniqueInput
    data: XOR<BuildUpdateWithoutRecipeInput, BuildUncheckedUpdateWithoutRecipeInput>
  }

  export type BuildUpdateManyWithWhereWithoutRecipeInput = {
    where: BuildScalarWhereInput
    data: XOR<BuildUpdateManyMutationInput, BuildUncheckedUpdateManyWithoutBuildInput>
  }

  export type RecipeBookCreateWithoutRecipeBookBuildInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutRecipeBookInput
    editedBy?: UserCreateNestedOneWithoutRecipeBookEditedByIdInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookUncheckedCreateWithoutRecipeBookBuildInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    editedById?: string | null
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookCreateOrConnectWithoutRecipeBookBuildInput = {
    where: RecipeBookWhereUniqueInput
    create: XOR<RecipeBookCreateWithoutRecipeBookBuildInput, RecipeBookUncheckedCreateWithoutRecipeBookBuildInput>
  }

  export type BuildCreateWithoutRecipeBookBuildInput = {
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutBuildInput
    editedBy?: UserCreateNestedOneWithoutBuildEditedByInput
    recipe?: RecipeCreateNestedOneWithoutBuildInput
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    touch?: TouchCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserCreateNestedManyWithoutBuildInput
  }

  export type BuildUncheckedCreateWithoutRecipeBookBuildInput = {
    id?: number
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    recipeId?: number | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutBuildInput
  }

  export type BuildCreateOrConnectWithoutRecipeBookBuildInput = {
    where: BuildWhereUniqueInput
    create: XOR<BuildCreateWithoutRecipeBookBuildInput, BuildUncheckedCreateWithoutRecipeBookBuildInput>
  }

  export type RecipeBookUpsertWithoutRecipeBookBuildInput = {
    update: XOR<RecipeBookUpdateWithoutRecipeBookBuildInput, RecipeBookUncheckedUpdateWithoutRecipeBookBuildInput>
    create: XOR<RecipeBookCreateWithoutRecipeBookBuildInput, RecipeBookUncheckedCreateWithoutRecipeBookBuildInput>
  }

  export type RecipeBookUpdateWithoutRecipeBookBuildInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutRecipeBookNestedInput
    editedBy?: UserUpdateOneWithoutRecipeBookEditedByIdNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutRecipeBookNestedInput
  }

  export type RecipeBookUncheckedUpdateWithoutRecipeBookBuildInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutRecipeBookNestedInput
  }

  export type BuildUpsertWithoutRecipeBookBuildInput = {
    update: XOR<BuildUpdateWithoutRecipeBookBuildInput, BuildUncheckedUpdateWithoutRecipeBookBuildInput>
    create: XOR<BuildCreateWithoutRecipeBookBuildInput, BuildUncheckedCreateWithoutRecipeBookBuildInput>
  }

  export type BuildUpdateWithoutRecipeBookBuildInput = {
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutBuildNestedInput
    editedBy?: UserUpdateOneWithoutBuildEditedByNestedInput
    recipe?: RecipeUpdateOneWithoutBuildNestedInput
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateWithoutRecipeBookBuildInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutBuildNestedInput
  }

  export type BuildCreateWithoutTouchInput = {
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutBuildInput
    editedBy?: UserCreateNestedOneWithoutBuildEditedByInput
    recipe?: RecipeCreateNestedOneWithoutBuildInput
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    RecipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserCreateNestedManyWithoutBuildInput
  }

  export type BuildUncheckedCreateWithoutTouchInput = {
    id?: number
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    recipeId?: number | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    RecipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutBuildInput
  }

  export type BuildCreateOrConnectWithoutTouchInput = {
    where: BuildWhereUniqueInput
    create: XOR<BuildCreateWithoutTouchInput, BuildUncheckedCreateWithoutTouchInput>
  }

  export type GenericIngredientCreateWithoutTouchInput = {
    name: string
    description?: string | null
    specificIngredient?: SpecificIngredientCreateNestedManyWithoutGenericIngredientInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutGenericIngredientInput
  }

  export type GenericIngredientUncheckedCreateWithoutTouchInput = {
    id?: number
    name: string
    description?: string | null
    specificIngredient?: SpecificIngredientUncheckedCreateNestedManyWithoutGenericIngredientInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutGenericIngredientInput
  }

  export type GenericIngredientCreateOrConnectWithoutTouchInput = {
    where: GenericIngredientWhereUniqueInput
    create: XOR<GenericIngredientCreateWithoutTouchInput, GenericIngredientUncheckedCreateWithoutTouchInput>
  }

  export type SpecificIngredientCreateWithoutTouchInput = {
    dateCreated?: Date | string
    createdBy?: UserCreateNestedOneWithoutIngredientInput
    genericIngredient: GenericIngredientCreateNestedOneWithoutSpecificIngredientInput
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutSpecificIngredientInput
  }

  export type SpecificIngredientUncheckedCreateWithoutTouchInput = {
    id?: number
    dateCreated?: Date | string
    createdById?: string | null
    genericIngredientId: number
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutSpecificIngredientInput
  }

  export type SpecificIngredientCreateOrConnectWithoutTouchInput = {
    where: SpecificIngredientWhereUniqueInput
    create: XOR<SpecificIngredientCreateWithoutTouchInput, SpecificIngredientUncheckedCreateWithoutTouchInput>
  }

  export type BuildUpsertWithoutTouchInput = {
    update: XOR<BuildUpdateWithoutTouchInput, BuildUncheckedUpdateWithoutTouchInput>
    create: XOR<BuildCreateWithoutTouchInput, BuildUncheckedCreateWithoutTouchInput>
  }

  export type BuildUpdateWithoutTouchInput = {
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutBuildNestedInput
    editedBy?: UserUpdateOneWithoutBuildEditedByNestedInput
    recipe?: RecipeUpdateOneWithoutBuildNestedInput
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    RecipeBookBuild?: RecipeBookBuildUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateWithoutTouchInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    RecipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutBuildNestedInput
  }

  export type GenericIngredientUpsertWithoutTouchInput = {
    update: XOR<GenericIngredientUpdateWithoutTouchInput, GenericIngredientUncheckedUpdateWithoutTouchInput>
    create: XOR<GenericIngredientCreateWithoutTouchInput, GenericIngredientUncheckedCreateWithoutTouchInput>
  }

  export type GenericIngredientUpdateWithoutTouchInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specificIngredient?: SpecificIngredientUpdateManyWithoutGenericIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutGenericIngredientNestedInput
  }

  export type GenericIngredientUncheckedUpdateWithoutTouchInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specificIngredient?: SpecificIngredientUncheckedUpdateManyWithoutGenericIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutGenericIngredientNestedInput
  }

  export type SpecificIngredientUpsertWithoutTouchInput = {
    update: XOR<SpecificIngredientUpdateWithoutTouchInput, SpecificIngredientUncheckedUpdateWithoutTouchInput>
    create: XOR<SpecificIngredientCreateWithoutTouchInput, SpecificIngredientUncheckedCreateWithoutTouchInput>
  }

  export type SpecificIngredientUpdateWithoutTouchInput = {
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutIngredientNestedInput
    genericIngredient?: GenericIngredientUpdateOneRequiredWithoutSpecificIngredientNestedInput
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientStorage?: IngredientStorageUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutSpecificIngredientNestedInput
  }

  export type SpecificIngredientUncheckedUpdateWithoutTouchInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    genericIngredientId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutSpecificIngredientNestedInput
  }

  export type TouchCreateWithoutGenericIngredientInput = {
    build?: BuildCreateNestedOneWithoutTouchInput
    order?: number | null
    amount?: number | null
    unit?: string | null
    specificIngredient?: SpecificIngredientCreateNestedOneWithoutTouchInput
  }

  export type TouchUncheckedCreateWithoutGenericIngredientInput = {
    id?: number
    buildId?: number | null
    order?: number | null
    amount?: number | null
    unit?: string | null
    specificIngredientID?: number | null
  }

  export type TouchCreateOrConnectWithoutGenericIngredientInput = {
    where: TouchWhereUniqueInput
    create: XOR<TouchCreateWithoutGenericIngredientInput, TouchUncheckedCreateWithoutGenericIngredientInput>
  }

  export type TouchCreateManyGenericIngredientInputEnvelope = {
    data: Enumerable<TouchCreateManyGenericIngredientInput>
    skipDuplicates?: boolean
  }

  export type SpecificIngredientCreateWithoutGenericIngredientInput = {
    dateCreated?: Date | string
    createdBy?: UserCreateNestedOneWithoutIngredientInput
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    touch?: TouchCreateNestedManyWithoutSpecificIngredientInput
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutSpecificIngredientInput
  }

  export type SpecificIngredientUncheckedCreateWithoutGenericIngredientInput = {
    id?: number
    dateCreated?: Date | string
    createdById?: string | null
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutSpecificIngredientInput
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutSpecificIngredientInput
  }

  export type SpecificIngredientCreateOrConnectWithoutGenericIngredientInput = {
    where: SpecificIngredientWhereUniqueInput
    create: XOR<SpecificIngredientCreateWithoutGenericIngredientInput, SpecificIngredientUncheckedCreateWithoutGenericIngredientInput>
  }

  export type SpecificIngredientCreateManyGenericIngredientInputEnvelope = {
    data: Enumerable<SpecificIngredientCreateManyGenericIngredientInput>
    skipDuplicates?: boolean
  }

  export type IngredientPreferenceCreateWithoutGenericIngredientInput = {
    specificIngredient: SpecificIngredientCreateNestedOneWithoutIngredientPreferenceInput
    user: UserCreateNestedOneWithoutIngredientPreferenceInput
  }

  export type IngredientPreferenceUncheckedCreateWithoutGenericIngredientInput = {
    specificIngredientID: number
    userId: string
  }

  export type IngredientPreferenceCreateOrConnectWithoutGenericIngredientInput = {
    where: IngredientPreferenceWhereUniqueInput
    create: XOR<IngredientPreferenceCreateWithoutGenericIngredientInput, IngredientPreferenceUncheckedCreateWithoutGenericIngredientInput>
  }

  export type IngredientPreferenceCreateManyGenericIngredientInputEnvelope = {
    data: Enumerable<IngredientPreferenceCreateManyGenericIngredientInput>
    skipDuplicates?: boolean
  }

  export type TouchUpsertWithWhereUniqueWithoutGenericIngredientInput = {
    where: TouchWhereUniqueInput
    update: XOR<TouchUpdateWithoutGenericIngredientInput, TouchUncheckedUpdateWithoutGenericIngredientInput>
    create: XOR<TouchCreateWithoutGenericIngredientInput, TouchUncheckedCreateWithoutGenericIngredientInput>
  }

  export type TouchUpdateWithWhereUniqueWithoutGenericIngredientInput = {
    where: TouchWhereUniqueInput
    data: XOR<TouchUpdateWithoutGenericIngredientInput, TouchUncheckedUpdateWithoutGenericIngredientInput>
  }

  export type TouchUpdateManyWithWhereWithoutGenericIngredientInput = {
    where: TouchScalarWhereInput
    data: XOR<TouchUpdateManyMutationInput, TouchUncheckedUpdateManyWithoutTouchInput>
  }

  export type SpecificIngredientUpsertWithWhereUniqueWithoutGenericIngredientInput = {
    where: SpecificIngredientWhereUniqueInput
    update: XOR<SpecificIngredientUpdateWithoutGenericIngredientInput, SpecificIngredientUncheckedUpdateWithoutGenericIngredientInput>
    create: XOR<SpecificIngredientCreateWithoutGenericIngredientInput, SpecificIngredientUncheckedCreateWithoutGenericIngredientInput>
  }

  export type SpecificIngredientUpdateWithWhereUniqueWithoutGenericIngredientInput = {
    where: SpecificIngredientWhereUniqueInput
    data: XOR<SpecificIngredientUpdateWithoutGenericIngredientInput, SpecificIngredientUncheckedUpdateWithoutGenericIngredientInput>
  }

  export type SpecificIngredientUpdateManyWithWhereWithoutGenericIngredientInput = {
    where: SpecificIngredientScalarWhereInput
    data: XOR<SpecificIngredientUpdateManyMutationInput, SpecificIngredientUncheckedUpdateManyWithoutSpecificIngredientInput>
  }

  export type IngredientPreferenceUpsertWithWhereUniqueWithoutGenericIngredientInput = {
    where: IngredientPreferenceWhereUniqueInput
    update: XOR<IngredientPreferenceUpdateWithoutGenericIngredientInput, IngredientPreferenceUncheckedUpdateWithoutGenericIngredientInput>
    create: XOR<IngredientPreferenceCreateWithoutGenericIngredientInput, IngredientPreferenceUncheckedCreateWithoutGenericIngredientInput>
  }

  export type IngredientPreferenceUpdateWithWhereUniqueWithoutGenericIngredientInput = {
    where: IngredientPreferenceWhereUniqueInput
    data: XOR<IngredientPreferenceUpdateWithoutGenericIngredientInput, IngredientPreferenceUncheckedUpdateWithoutGenericIngredientInput>
  }

  export type IngredientPreferenceUpdateManyWithWhereWithoutGenericIngredientInput = {
    where: IngredientPreferenceScalarWhereInput
    data: XOR<IngredientPreferenceUpdateManyMutationInput, IngredientPreferenceUncheckedUpdateManyWithoutIngredientPreferenceInput>
  }

  export type UserCreateWithoutIngredientInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutIngredientInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutIngredientInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIngredientInput, UserUncheckedCreateWithoutIngredientInput>
  }

  export type GenericIngredientCreateWithoutSpecificIngredientInput = {
    name: string
    description?: string | null
    touch?: TouchCreateNestedManyWithoutGenericIngredientInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutGenericIngredientInput
  }

  export type GenericIngredientUncheckedCreateWithoutSpecificIngredientInput = {
    id?: number
    name: string
    description?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutGenericIngredientInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutGenericIngredientInput
  }

  export type GenericIngredientCreateOrConnectWithoutSpecificIngredientInput = {
    where: GenericIngredientWhereUniqueInput
    create: XOR<GenericIngredientCreateWithoutSpecificIngredientInput, GenericIngredientUncheckedCreateWithoutSpecificIngredientInput>
  }

  export type TouchCreateWithoutSpecificIngredientInput = {
    build?: BuildCreateNestedOneWithoutTouchInput
    order?: number | null
    amount?: number | null
    unit?: string | null
    genericIngredient: GenericIngredientCreateNestedOneWithoutTouchInput
  }

  export type TouchUncheckedCreateWithoutSpecificIngredientInput = {
    id?: number
    buildId?: number | null
    order?: number | null
    amount?: number | null
    unit?: string | null
    genericIngredientID: number
  }

  export type TouchCreateOrConnectWithoutSpecificIngredientInput = {
    where: TouchWhereUniqueInput
    create: XOR<TouchCreateWithoutSpecificIngredientInput, TouchUncheckedCreateWithoutSpecificIngredientInput>
  }

  export type TouchCreateManySpecificIngredientInputEnvelope = {
    data: Enumerable<TouchCreateManySpecificIngredientInput>
    skipDuplicates?: boolean
  }

  export type IngredientStorageCreateWithoutIngredientInput = {
    Storage: StorageCreateNestedOneWithoutIngredientStorageInput
    quantity?: number | null
  }

  export type IngredientStorageUncheckedCreateWithoutIngredientInput = {
    storageId: number
    quantity?: number | null
  }

  export type IngredientStorageCreateOrConnectWithoutIngredientInput = {
    where: IngredientStorageWhereUniqueInput
    create: XOR<IngredientStorageCreateWithoutIngredientInput, IngredientStorageUncheckedCreateWithoutIngredientInput>
  }

  export type IngredientStorageCreateManyIngredientInputEnvelope = {
    data: Enumerable<IngredientStorageCreateManyIngredientInput>
    skipDuplicates?: boolean
  }

  export type IngredientPreferenceCreateWithoutSpecificIngredientInput = {
    genericIngredient: GenericIngredientCreateNestedOneWithoutIngredientPreferenceInput
    user: UserCreateNestedOneWithoutIngredientPreferenceInput
  }

  export type IngredientPreferenceUncheckedCreateWithoutSpecificIngredientInput = {
    genericIngredientID: number
    userId: string
  }

  export type IngredientPreferenceCreateOrConnectWithoutSpecificIngredientInput = {
    where: IngredientPreferenceWhereUniqueInput
    create: XOR<IngredientPreferenceCreateWithoutSpecificIngredientInput, IngredientPreferenceUncheckedCreateWithoutSpecificIngredientInput>
  }

  export type IngredientPreferenceCreateManySpecificIngredientInputEnvelope = {
    data: Enumerable<IngredientPreferenceCreateManySpecificIngredientInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutIngredientInput = {
    update: XOR<UserUpdateWithoutIngredientInput, UserUncheckedUpdateWithoutIngredientInput>
    create: XOR<UserCreateWithoutIngredientInput, UserUncheckedCreateWithoutIngredientInput>
  }

  export type UserUpdateWithoutIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GenericIngredientUpsertWithoutSpecificIngredientInput = {
    update: XOR<GenericIngredientUpdateWithoutSpecificIngredientInput, GenericIngredientUncheckedUpdateWithoutSpecificIngredientInput>
    create: XOR<GenericIngredientCreateWithoutSpecificIngredientInput, GenericIngredientUncheckedCreateWithoutSpecificIngredientInput>
  }

  export type GenericIngredientUpdateWithoutSpecificIngredientInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUpdateManyWithoutGenericIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutGenericIngredientNestedInput
  }

  export type GenericIngredientUncheckedUpdateWithoutSpecificIngredientInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutGenericIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutGenericIngredientNestedInput
  }

  export type TouchUpsertWithWhereUniqueWithoutSpecificIngredientInput = {
    where: TouchWhereUniqueInput
    update: XOR<TouchUpdateWithoutSpecificIngredientInput, TouchUncheckedUpdateWithoutSpecificIngredientInput>
    create: XOR<TouchCreateWithoutSpecificIngredientInput, TouchUncheckedCreateWithoutSpecificIngredientInput>
  }

  export type TouchUpdateWithWhereUniqueWithoutSpecificIngredientInput = {
    where: TouchWhereUniqueInput
    data: XOR<TouchUpdateWithoutSpecificIngredientInput, TouchUncheckedUpdateWithoutSpecificIngredientInput>
  }

  export type TouchUpdateManyWithWhereWithoutSpecificIngredientInput = {
    where: TouchScalarWhereInput
    data: XOR<TouchUpdateManyMutationInput, TouchUncheckedUpdateManyWithoutTouchInput>
  }

  export type IngredientStorageUpsertWithWhereUniqueWithoutIngredientInput = {
    where: IngredientStorageWhereUniqueInput
    update: XOR<IngredientStorageUpdateWithoutIngredientInput, IngredientStorageUncheckedUpdateWithoutIngredientInput>
    create: XOR<IngredientStorageCreateWithoutIngredientInput, IngredientStorageUncheckedCreateWithoutIngredientInput>
  }

  export type IngredientStorageUpdateWithWhereUniqueWithoutIngredientInput = {
    where: IngredientStorageWhereUniqueInput
    data: XOR<IngredientStorageUpdateWithoutIngredientInput, IngredientStorageUncheckedUpdateWithoutIngredientInput>
  }

  export type IngredientStorageUpdateManyWithWhereWithoutIngredientInput = {
    where: IngredientStorageScalarWhereInput
    data: XOR<IngredientStorageUpdateManyMutationInput, IngredientStorageUncheckedUpdateManyWithoutIngredientStorageInput>
  }

  export type IngredientStorageScalarWhereInput = {
    AND?: Enumerable<IngredientStorageScalarWhereInput>
    OR?: Enumerable<IngredientStorageScalarWhereInput>
    NOT?: Enumerable<IngredientStorageScalarWhereInput>
    ingredientId?: IntFilter | number
    storageId?: IntFilter | number
    quantity?: FloatNullableFilter | number | null
  }

  export type IngredientPreferenceUpsertWithWhereUniqueWithoutSpecificIngredientInput = {
    where: IngredientPreferenceWhereUniqueInput
    update: XOR<IngredientPreferenceUpdateWithoutSpecificIngredientInput, IngredientPreferenceUncheckedUpdateWithoutSpecificIngredientInput>
    create: XOR<IngredientPreferenceCreateWithoutSpecificIngredientInput, IngredientPreferenceUncheckedCreateWithoutSpecificIngredientInput>
  }

  export type IngredientPreferenceUpdateWithWhereUniqueWithoutSpecificIngredientInput = {
    where: IngredientPreferenceWhereUniqueInput
    data: XOR<IngredientPreferenceUpdateWithoutSpecificIngredientInput, IngredientPreferenceUncheckedUpdateWithoutSpecificIngredientInput>
  }

  export type IngredientPreferenceUpdateManyWithWhereWithoutSpecificIngredientInput = {
    where: IngredientPreferenceScalarWhereInput
    data: XOR<IngredientPreferenceUpdateManyMutationInput, IngredientPreferenceUncheckedUpdateManyWithoutIngredientPreferenceInput>
  }

  export type GenericIngredientCreateWithoutIngredientPreferenceInput = {
    name: string
    description?: string | null
    touch?: TouchCreateNestedManyWithoutGenericIngredientInput
    specificIngredient?: SpecificIngredientCreateNestedManyWithoutGenericIngredientInput
  }

  export type GenericIngredientUncheckedCreateWithoutIngredientPreferenceInput = {
    id?: number
    name: string
    description?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutGenericIngredientInput
    specificIngredient?: SpecificIngredientUncheckedCreateNestedManyWithoutGenericIngredientInput
  }

  export type GenericIngredientCreateOrConnectWithoutIngredientPreferenceInput = {
    where: GenericIngredientWhereUniqueInput
    create: XOR<GenericIngredientCreateWithoutIngredientPreferenceInput, GenericIngredientUncheckedCreateWithoutIngredientPreferenceInput>
  }

  export type SpecificIngredientCreateWithoutIngredientPreferenceInput = {
    dateCreated?: Date | string
    createdBy?: UserCreateNestedOneWithoutIngredientInput
    genericIngredient: GenericIngredientCreateNestedOneWithoutSpecificIngredientInput
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    touch?: TouchCreateNestedManyWithoutSpecificIngredientInput
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutIngredientInput
  }

  export type SpecificIngredientUncheckedCreateWithoutIngredientPreferenceInput = {
    id?: number
    dateCreated?: Date | string
    createdById?: string | null
    genericIngredientId: number
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutSpecificIngredientInput
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutIngredientInput
  }

  export type SpecificIngredientCreateOrConnectWithoutIngredientPreferenceInput = {
    where: SpecificIngredientWhereUniqueInput
    create: XOR<SpecificIngredientCreateWithoutIngredientPreferenceInput, SpecificIngredientUncheckedCreateWithoutIngredientPreferenceInput>
  }

  export type UserCreateWithoutIngredientPreferenceInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutIngredientPreferenceInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutIngredientPreferenceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIngredientPreferenceInput, UserUncheckedCreateWithoutIngredientPreferenceInput>
  }

  export type GenericIngredientUpsertWithoutIngredientPreferenceInput = {
    update: XOR<GenericIngredientUpdateWithoutIngredientPreferenceInput, GenericIngredientUncheckedUpdateWithoutIngredientPreferenceInput>
    create: XOR<GenericIngredientCreateWithoutIngredientPreferenceInput, GenericIngredientUncheckedCreateWithoutIngredientPreferenceInput>
  }

  export type GenericIngredientUpdateWithoutIngredientPreferenceInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUpdateManyWithoutGenericIngredientNestedInput
    specificIngredient?: SpecificIngredientUpdateManyWithoutGenericIngredientNestedInput
  }

  export type GenericIngredientUncheckedUpdateWithoutIngredientPreferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutGenericIngredientNestedInput
    specificIngredient?: SpecificIngredientUncheckedUpdateManyWithoutGenericIngredientNestedInput
  }

  export type SpecificIngredientUpsertWithoutIngredientPreferenceInput = {
    update: XOR<SpecificIngredientUpdateWithoutIngredientPreferenceInput, SpecificIngredientUncheckedUpdateWithoutIngredientPreferenceInput>
    create: XOR<SpecificIngredientCreateWithoutIngredientPreferenceInput, SpecificIngredientUncheckedCreateWithoutIngredientPreferenceInput>
  }

  export type SpecificIngredientUpdateWithoutIngredientPreferenceInput = {
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutIngredientNestedInput
    genericIngredient?: GenericIngredientUpdateOneRequiredWithoutSpecificIngredientNestedInput
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUpdateManyWithoutSpecificIngredientNestedInput
    ingredientStorage?: IngredientStorageUpdateManyWithoutIngredientNestedInput
  }

  export type SpecificIngredientUncheckedUpdateWithoutIngredientPreferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    genericIngredientId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutSpecificIngredientNestedInput
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutIngredientNestedInput
  }

  export type UserUpsertWithoutIngredientPreferenceInput = {
    update: XOR<UserUpdateWithoutIngredientPreferenceInput, UserUncheckedUpdateWithoutIngredientPreferenceInput>
    create: XOR<UserCreateWithoutIngredientPreferenceInput, UserUncheckedCreateWithoutIngredientPreferenceInput>
  }

  export type UserUpdateWithoutIngredientPreferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutIngredientPreferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutInventoryCreatedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInventoryCreatedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInventoryCreatedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInventoryCreatedByInput, UserUncheckedCreateWithoutInventoryCreatedByInput>
  }

  export type UserCreateWithoutInventoryEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInventoryEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInventoryEditedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInventoryEditedByInput, UserUncheckedCreateWithoutInventoryEditedByInput>
  }

  export type InventoryStorageCreateWithoutInventoryInput = {
    storage: StorageCreateNestedOneWithoutInventoryStorageInput
  }

  export type InventoryStorageUncheckedCreateWithoutInventoryInput = {
    storageId: number
  }

  export type InventoryStorageCreateOrConnectWithoutInventoryInput = {
    where: InventoryStorageWhereUniqueInput
    create: XOR<InventoryStorageCreateWithoutInventoryInput, InventoryStorageUncheckedCreateWithoutInventoryInput>
  }

  export type InventoryStorageCreateManyInventoryInputEnvelope = {
    data: Enumerable<InventoryStorageCreateManyInventoryInput>
    skipDuplicates?: boolean
  }

  export type InventoryUserCreateWithoutInventoryInput = {
    user: UserCreateNestedOneWithoutInventoryUserInput
    permission: string
  }

  export type InventoryUserUncheckedCreateWithoutInventoryInput = {
    userId: string
    permission: string
  }

  export type InventoryUserCreateOrConnectWithoutInventoryInput = {
    where: InventoryUserWhereUniqueInput
    create: XOR<InventoryUserCreateWithoutInventoryInput, InventoryUserUncheckedCreateWithoutInventoryInput>
  }

  export type InventoryUserCreateManyInventoryInputEnvelope = {
    data: Enumerable<InventoryUserCreateManyInventoryInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutInventoryCreatedByInput = {
    update: XOR<UserUpdateWithoutInventoryCreatedByInput, UserUncheckedUpdateWithoutInventoryCreatedByInput>
    create: XOR<UserCreateWithoutInventoryCreatedByInput, UserUncheckedCreateWithoutInventoryCreatedByInput>
  }

  export type UserUpdateWithoutInventoryCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInventoryCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutInventoryEditedByInput = {
    update: XOR<UserUpdateWithoutInventoryEditedByInput, UserUncheckedUpdateWithoutInventoryEditedByInput>
    create: XOR<UserCreateWithoutInventoryEditedByInput, UserUncheckedCreateWithoutInventoryEditedByInput>
  }

  export type UserUpdateWithoutInventoryEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInventoryEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InventoryStorageUpsertWithWhereUniqueWithoutInventoryInput = {
    where: InventoryStorageWhereUniqueInput
    update: XOR<InventoryStorageUpdateWithoutInventoryInput, InventoryStorageUncheckedUpdateWithoutInventoryInput>
    create: XOR<InventoryStorageCreateWithoutInventoryInput, InventoryStorageUncheckedCreateWithoutInventoryInput>
  }

  export type InventoryStorageUpdateWithWhereUniqueWithoutInventoryInput = {
    where: InventoryStorageWhereUniqueInput
    data: XOR<InventoryStorageUpdateWithoutInventoryInput, InventoryStorageUncheckedUpdateWithoutInventoryInput>
  }

  export type InventoryStorageUpdateManyWithWhereWithoutInventoryInput = {
    where: InventoryStorageScalarWhereInput
    data: XOR<InventoryStorageUpdateManyMutationInput, InventoryStorageUncheckedUpdateManyWithoutInventoryStorageInput>
  }

  export type InventoryStorageScalarWhereInput = {
    AND?: Enumerable<InventoryStorageScalarWhereInput>
    OR?: Enumerable<InventoryStorageScalarWhereInput>
    NOT?: Enumerable<InventoryStorageScalarWhereInput>
    inventoryId?: IntFilter | number
    storageId?: IntFilter | number
  }

  export type InventoryUserUpsertWithWhereUniqueWithoutInventoryInput = {
    where: InventoryUserWhereUniqueInput
    update: XOR<InventoryUserUpdateWithoutInventoryInput, InventoryUserUncheckedUpdateWithoutInventoryInput>
    create: XOR<InventoryUserCreateWithoutInventoryInput, InventoryUserUncheckedCreateWithoutInventoryInput>
  }

  export type InventoryUserUpdateWithWhereUniqueWithoutInventoryInput = {
    where: InventoryUserWhereUniqueInput
    data: XOR<InventoryUserUpdateWithoutInventoryInput, InventoryUserUncheckedUpdateWithoutInventoryInput>
  }

  export type InventoryUserUpdateManyWithWhereWithoutInventoryInput = {
    where: InventoryUserScalarWhereInput
    data: XOR<InventoryUserUpdateManyMutationInput, InventoryUserUncheckedUpdateManyWithoutInventoryUserInput>
  }

  export type UserCreateWithoutInventoryUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
  }

  export type UserUncheckedCreateWithoutInventoryUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
  }

  export type UserCreateOrConnectWithoutInventoryUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInventoryUserInput, UserUncheckedCreateWithoutInventoryUserInput>
  }

  export type InventoryCreateWithoutInventoryUserInput = {
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutInventoryCreatedByInput
    editedBy?: UserCreateNestedOneWithoutInventoryEditedByInput
    inventoryStorage?: InventoryStorageCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutInventoryUserInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    inventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryCreateOrConnectWithoutInventoryUserInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutInventoryUserInput, InventoryUncheckedCreateWithoutInventoryUserInput>
  }

  export type UserUpsertWithoutInventoryUserInput = {
    update: XOR<UserUpdateWithoutInventoryUserInput, UserUncheckedUpdateWithoutInventoryUserInput>
    create: XOR<UserCreateWithoutInventoryUserInput, UserUncheckedCreateWithoutInventoryUserInput>
  }

  export type UserUpdateWithoutInventoryUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
  }

  export type UserUncheckedUpdateWithoutInventoryUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
  }

  export type InventoryUpsertWithoutInventoryUserInput = {
    update: XOR<InventoryUpdateWithoutInventoryUserInput, InventoryUncheckedUpdateWithoutInventoryUserInput>
    create: XOR<InventoryCreateWithoutInventoryUserInput, InventoryUncheckedCreateWithoutInventoryUserInput>
  }

  export type InventoryUpdateWithoutInventoryUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutInventoryCreatedByNestedInput
    editedBy?: UserUpdateOneWithoutInventoryEditedByNestedInput
    inventoryStorage?: InventoryStorageUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutInventoryUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    inventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type UserCreateWithoutStorageInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStorageInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStorageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStorageInput, UserUncheckedCreateWithoutStorageInput>
  }

  export type UserCreateWithoutStorageEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStorageEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStorageEditedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStorageEditedByInput, UserUncheckedCreateWithoutStorageEditedByInput>
  }

  export type InventoryStorageCreateWithoutStorageInput = {
    inventory: InventoryCreateNestedOneWithoutInventoryStorageInput
  }

  export type InventoryStorageUncheckedCreateWithoutStorageInput = {
    inventoryId: number
  }

  export type InventoryStorageCreateOrConnectWithoutStorageInput = {
    where: InventoryStorageWhereUniqueInput
    create: XOR<InventoryStorageCreateWithoutStorageInput, InventoryStorageUncheckedCreateWithoutStorageInput>
  }

  export type InventoryStorageCreateManyStorageInputEnvelope = {
    data: Enumerable<InventoryStorageCreateManyStorageInput>
    skipDuplicates?: boolean
  }

  export type IngredientStorageCreateWithoutStorageInput = {
    ingredient: SpecificIngredientCreateNestedOneWithoutIngredientStorageInput
    quantity?: number | null
  }

  export type IngredientStorageUncheckedCreateWithoutStorageInput = {
    ingredientId: number
    quantity?: number | null
  }

  export type IngredientStorageCreateOrConnectWithoutStorageInput = {
    where: IngredientStorageWhereUniqueInput
    create: XOR<IngredientStorageCreateWithoutStorageInput, IngredientStorageUncheckedCreateWithoutStorageInput>
  }

  export type IngredientStorageCreateManyStorageInputEnvelope = {
    data: Enumerable<IngredientStorageCreateManyStorageInput>
    skipDuplicates?: boolean
  }

  export type StorageUserCreateWithoutStorageInput = {
    user: UserCreateNestedOneWithoutStorageUserInput
    permission: string
  }

  export type StorageUserUncheckedCreateWithoutStorageInput = {
    userId: string
    permission: string
  }

  export type StorageUserCreateOrConnectWithoutStorageInput = {
    where: StorageUserWhereUniqueInput
    create: XOR<StorageUserCreateWithoutStorageInput, StorageUserUncheckedCreateWithoutStorageInput>
  }

  export type StorageUserCreateManyStorageInputEnvelope = {
    data: Enumerable<StorageUserCreateManyStorageInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutStorageInput = {
    update: XOR<UserUpdateWithoutStorageInput, UserUncheckedUpdateWithoutStorageInput>
    create: XOR<UserCreateWithoutStorageInput, UserUncheckedCreateWithoutStorageInput>
  }

  export type UserUpdateWithoutStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutStorageEditedByInput = {
    update: XOR<UserUpdateWithoutStorageEditedByInput, UserUncheckedUpdateWithoutStorageEditedByInput>
    create: XOR<UserCreateWithoutStorageEditedByInput, UserUncheckedCreateWithoutStorageEditedByInput>
  }

  export type UserUpdateWithoutStorageEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStorageEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InventoryStorageUpsertWithWhereUniqueWithoutStorageInput = {
    where: InventoryStorageWhereUniqueInput
    update: XOR<InventoryStorageUpdateWithoutStorageInput, InventoryStorageUncheckedUpdateWithoutStorageInput>
    create: XOR<InventoryStorageCreateWithoutStorageInput, InventoryStorageUncheckedCreateWithoutStorageInput>
  }

  export type InventoryStorageUpdateWithWhereUniqueWithoutStorageInput = {
    where: InventoryStorageWhereUniqueInput
    data: XOR<InventoryStorageUpdateWithoutStorageInput, InventoryStorageUncheckedUpdateWithoutStorageInput>
  }

  export type InventoryStorageUpdateManyWithWhereWithoutStorageInput = {
    where: InventoryStorageScalarWhereInput
    data: XOR<InventoryStorageUpdateManyMutationInput, InventoryStorageUncheckedUpdateManyWithoutInventoryStorageInput>
  }

  export type IngredientStorageUpsertWithWhereUniqueWithoutStorageInput = {
    where: IngredientStorageWhereUniqueInput
    update: XOR<IngredientStorageUpdateWithoutStorageInput, IngredientStorageUncheckedUpdateWithoutStorageInput>
    create: XOR<IngredientStorageCreateWithoutStorageInput, IngredientStorageUncheckedCreateWithoutStorageInput>
  }

  export type IngredientStorageUpdateWithWhereUniqueWithoutStorageInput = {
    where: IngredientStorageWhereUniqueInput
    data: XOR<IngredientStorageUpdateWithoutStorageInput, IngredientStorageUncheckedUpdateWithoutStorageInput>
  }

  export type IngredientStorageUpdateManyWithWhereWithoutStorageInput = {
    where: IngredientStorageScalarWhereInput
    data: XOR<IngredientStorageUpdateManyMutationInput, IngredientStorageUncheckedUpdateManyWithoutIngredientStorageInput>
  }

  export type StorageUserUpsertWithWhereUniqueWithoutStorageInput = {
    where: StorageUserWhereUniqueInput
    update: XOR<StorageUserUpdateWithoutStorageInput, StorageUserUncheckedUpdateWithoutStorageInput>
    create: XOR<StorageUserCreateWithoutStorageInput, StorageUserUncheckedCreateWithoutStorageInput>
  }

  export type StorageUserUpdateWithWhereUniqueWithoutStorageInput = {
    where: StorageUserWhereUniqueInput
    data: XOR<StorageUserUpdateWithoutStorageInput, StorageUserUncheckedUpdateWithoutStorageInput>
  }

  export type StorageUserUpdateManyWithWhereWithoutStorageInput = {
    where: StorageUserScalarWhereInput
    data: XOR<StorageUserUpdateManyMutationInput, StorageUserUncheckedUpdateManyWithoutStorageUserInput>
  }

  export type StorageCreateWithoutInventoryStorageInput = {
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutStorageInput
    editedBy?: UserCreateNestedOneWithoutStorageEditedByInput
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutStorageInput
    storageUser?: StorageUserCreateNestedManyWithoutStorageInput
  }

  export type StorageUncheckedCreateWithoutInventoryStorageInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutStorageInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutStorageInput
  }

  export type StorageCreateOrConnectWithoutInventoryStorageInput = {
    where: StorageWhereUniqueInput
    create: XOR<StorageCreateWithoutInventoryStorageInput, StorageUncheckedCreateWithoutInventoryStorageInput>
  }

  export type InventoryCreateWithoutInventoryStorageInput = {
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutInventoryCreatedByInput
    editedBy?: UserCreateNestedOneWithoutInventoryEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutInventoryStorageInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryCreateOrConnectWithoutInventoryStorageInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutInventoryStorageInput, InventoryUncheckedCreateWithoutInventoryStorageInput>
  }

  export type StorageUpsertWithoutInventoryStorageInput = {
    update: XOR<StorageUpdateWithoutInventoryStorageInput, StorageUncheckedUpdateWithoutInventoryStorageInput>
    create: XOR<StorageCreateWithoutInventoryStorageInput, StorageUncheckedCreateWithoutInventoryStorageInput>
  }

  export type StorageUpdateWithoutInventoryStorageInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutStorageNestedInput
    editedBy?: UserUpdateOneWithoutStorageEditedByNestedInput
    ingredientStorage?: IngredientStorageUpdateManyWithoutStorageNestedInput
    storageUser?: StorageUserUpdateManyWithoutStorageNestedInput
  }

  export type StorageUncheckedUpdateWithoutInventoryStorageInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutStorageNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutStorageNestedInput
  }

  export type InventoryUpsertWithoutInventoryStorageInput = {
    update: XOR<InventoryUpdateWithoutInventoryStorageInput, InventoryUncheckedUpdateWithoutInventoryStorageInput>
    create: XOR<InventoryCreateWithoutInventoryStorageInput, InventoryUncheckedCreateWithoutInventoryStorageInput>
  }

  export type InventoryUpdateWithoutInventoryStorageInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutInventoryCreatedByNestedInput
    editedBy?: UserUpdateOneWithoutInventoryEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutInventoryStorageInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type SpecificIngredientCreateWithoutIngredientStorageInput = {
    dateCreated?: Date | string
    createdBy?: UserCreateNestedOneWithoutIngredientInput
    genericIngredient: GenericIngredientCreateNestedOneWithoutSpecificIngredientInput
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    touch?: TouchCreateNestedManyWithoutSpecificIngredientInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutSpecificIngredientInput
  }

  export type SpecificIngredientUncheckedCreateWithoutIngredientStorageInput = {
    id?: number
    dateCreated?: Date | string
    createdById?: string | null
    genericIngredientId: number
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutSpecificIngredientInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutSpecificIngredientInput
  }

  export type SpecificIngredientCreateOrConnectWithoutIngredientStorageInput = {
    where: SpecificIngredientWhereUniqueInput
    create: XOR<SpecificIngredientCreateWithoutIngredientStorageInput, SpecificIngredientUncheckedCreateWithoutIngredientStorageInput>
  }

  export type StorageCreateWithoutIngredientStorageInput = {
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutStorageInput
    editedBy?: UserCreateNestedOneWithoutStorageEditedByInput
    inventoryStorage?: InventoryStorageCreateNestedManyWithoutStorageInput
    storageUser?: StorageUserCreateNestedManyWithoutStorageInput
  }

  export type StorageUncheckedCreateWithoutIngredientStorageInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    inventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutStorageInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutStorageInput
  }

  export type StorageCreateOrConnectWithoutIngredientStorageInput = {
    where: StorageWhereUniqueInput
    create: XOR<StorageCreateWithoutIngredientStorageInput, StorageUncheckedCreateWithoutIngredientStorageInput>
  }

  export type SpecificIngredientUpsertWithoutIngredientStorageInput = {
    update: XOR<SpecificIngredientUpdateWithoutIngredientStorageInput, SpecificIngredientUncheckedUpdateWithoutIngredientStorageInput>
    create: XOR<SpecificIngredientCreateWithoutIngredientStorageInput, SpecificIngredientUncheckedCreateWithoutIngredientStorageInput>
  }

  export type SpecificIngredientUpdateWithoutIngredientStorageInput = {
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutIngredientNestedInput
    genericIngredient?: GenericIngredientUpdateOneRequiredWithoutSpecificIngredientNestedInput
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUpdateManyWithoutSpecificIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutSpecificIngredientNestedInput
  }

  export type SpecificIngredientUncheckedUpdateWithoutIngredientStorageInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    genericIngredientId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutSpecificIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutSpecificIngredientNestedInput
  }

  export type StorageUpsertWithoutIngredientStorageInput = {
    update: XOR<StorageUpdateWithoutIngredientStorageInput, StorageUncheckedUpdateWithoutIngredientStorageInput>
    create: XOR<StorageCreateWithoutIngredientStorageInput, StorageUncheckedCreateWithoutIngredientStorageInput>
  }

  export type StorageUpdateWithoutIngredientStorageInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutStorageNestedInput
    editedBy?: UserUpdateOneWithoutStorageEditedByNestedInput
    inventoryStorage?: InventoryStorageUpdateManyWithoutStorageNestedInput
    storageUser?: StorageUserUpdateManyWithoutStorageNestedInput
  }

  export type StorageUncheckedUpdateWithoutIngredientStorageInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    inventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutStorageNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutStorageNestedInput
  }

  export type UserCreateWithoutStorageUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStorageUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStorageUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStorageUserInput, UserUncheckedCreateWithoutStorageUserInput>
  }

  export type StorageCreateWithoutStorageUserInput = {
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutStorageInput
    editedBy?: UserCreateNestedOneWithoutStorageEditedByInput
    inventoryStorage?: InventoryStorageCreateNestedManyWithoutStorageInput
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutStorageInput
  }

  export type StorageUncheckedCreateWithoutStorageUserInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    inventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutStorageInput
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutStorageInput
  }

  export type StorageCreateOrConnectWithoutStorageUserInput = {
    where: StorageWhereUniqueInput
    create: XOR<StorageCreateWithoutStorageUserInput, StorageUncheckedCreateWithoutStorageUserInput>
  }

  export type UserUpsertWithoutStorageUserInput = {
    update: XOR<UserUpdateWithoutStorageUserInput, UserUncheckedUpdateWithoutStorageUserInput>
    create: XOR<UserCreateWithoutStorageUserInput, UserUncheckedCreateWithoutStorageUserInput>
  }

  export type UserUpdateWithoutStorageUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStorageUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StorageUpsertWithoutStorageUserInput = {
    update: XOR<StorageUpdateWithoutStorageUserInput, StorageUncheckedUpdateWithoutStorageUserInput>
    create: XOR<StorageCreateWithoutStorageUserInput, StorageUncheckedCreateWithoutStorageUserInput>
  }

  export type StorageUpdateWithoutStorageUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutStorageNestedInput
    editedBy?: UserUpdateOneWithoutStorageEditedByNestedInput
    inventoryStorage?: InventoryStorageUpdateManyWithoutStorageNestedInput
    ingredientStorage?: IngredientStorageUpdateManyWithoutStorageNestedInput
  }

  export type StorageUncheckedUpdateWithoutStorageUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    inventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutStorageNestedInput
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutStorageNestedInput
  }

  export type UserCreateWithoutCrewInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCrewInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCrewInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCrewInput, UserUncheckedCreateWithoutCrewInput>
  }

  export type UserCreateWithoutCrewEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCrewEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCrewEditedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCrewEditedByInput, UserUncheckedCreateWithoutCrewEditedByInput>
  }

  export type UserCrewCreateWithoutCrewInput = {
    user: UserCreateNestedOneWithoutUserCrewInput
    permission: string
  }

  export type UserCrewUncheckedCreateWithoutCrewInput = {
    userId: string
    permission: string
  }

  export type UserCrewCreateOrConnectWithoutCrewInput = {
    where: UserCrewWhereUniqueInput
    create: XOR<UserCrewCreateWithoutCrewInput, UserCrewUncheckedCreateWithoutCrewInput>
  }

  export type UserCrewCreateManyCrewInputEnvelope = {
    data: Enumerable<UserCrewCreateManyCrewInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCrewInput = {
    update: XOR<UserUpdateWithoutCrewInput, UserUncheckedUpdateWithoutCrewInput>
    create: XOR<UserCreateWithoutCrewInput, UserUncheckedCreateWithoutCrewInput>
  }

  export type UserUpdateWithoutCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutCrewEditedByInput = {
    update: XOR<UserUpdateWithoutCrewEditedByInput, UserUncheckedUpdateWithoutCrewEditedByInput>
    create: XOR<UserCreateWithoutCrewEditedByInput, UserUncheckedCreateWithoutCrewEditedByInput>
  }

  export type UserUpdateWithoutCrewEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCrewEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCrewUpsertWithWhereUniqueWithoutCrewInput = {
    where: UserCrewWhereUniqueInput
    update: XOR<UserCrewUpdateWithoutCrewInput, UserCrewUncheckedUpdateWithoutCrewInput>
    create: XOR<UserCrewCreateWithoutCrewInput, UserCrewUncheckedCreateWithoutCrewInput>
  }

  export type UserCrewUpdateWithWhereUniqueWithoutCrewInput = {
    where: UserCrewWhereUniqueInput
    data: XOR<UserCrewUpdateWithoutCrewInput, UserCrewUncheckedUpdateWithoutCrewInput>
  }

  export type UserCrewUpdateManyWithWhereWithoutCrewInput = {
    where: UserCrewScalarWhereInput
    data: XOR<UserCrewUpdateManyMutationInput, UserCrewUncheckedUpdateManyWithoutUserCrewInput>
  }

  export type UserCreateWithoutUserCrewInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserCrewInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: SpecificIngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserCrewInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserCrewInput, UserUncheckedCreateWithoutUserCrewInput>
  }

  export type CrewCreateWithoutUserCrewInput = {
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCrewInput
    editedBy?: UserCreateNestedOneWithoutCrewEditedByInput
  }

  export type CrewUncheckedCreateWithoutUserCrewInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
  }

  export type CrewCreateOrConnectWithoutUserCrewInput = {
    where: CrewWhereUniqueInput
    create: XOR<CrewCreateWithoutUserCrewInput, CrewUncheckedCreateWithoutUserCrewInput>
  }

  export type UserUpsertWithoutUserCrewInput = {
    update: XOR<UserUpdateWithoutUserCrewInput, UserUncheckedUpdateWithoutUserCrewInput>
    create: XOR<UserCreateWithoutUserCrewInput, UserUncheckedCreateWithoutUserCrewInput>
  }

  export type UserUpdateWithoutUserCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: SpecificIngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CrewUpsertWithoutUserCrewInput = {
    update: XOR<CrewUpdateWithoutUserCrewInput, CrewUncheckedUpdateWithoutUserCrewInput>
    create: XOR<CrewCreateWithoutUserCrewInput, CrewUncheckedCreateWithoutUserCrewInput>
  }

  export type CrewUpdateWithoutUserCrewInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCrewNestedInput
    editedBy?: UserUpdateOneWithoutCrewEditedByNestedInput
  }

  export type CrewUncheckedUpdateWithoutUserCrewInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookUserCreateManyUserInput = {
    recipeBookId: number
    permission: string
  }

  export type RecipeBookCreateManyCreatedByInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    editedById?: string | null
  }

  export type RecipeBookCreateManyEditedByInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
  }

  export type RecipeCreateManyCreatedByInput = {
    id?: number
    createdAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
  }

  export type BuildUserCreateManyUserInput = {
    buildId: number
    permission: string
  }

  export type BuildCreateManyCreatedByInput = {
    id?: number
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedById: string
    recipeId?: number | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
  }

  export type BuildCreateManyEditedByInput = {
    id?: number
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    recipeId?: number | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
  }

  export type UserCrewCreateManyUserInput = {
    crewId: number
    permission: string
  }

  export type CrewCreateManyCreatedByInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedById: string
  }

  export type CrewCreateManyEditedByInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
  }

  export type SpecificIngredientCreateManyCreatedByInput = {
    id?: number
    dateCreated?: Date | string
    genericIngredientId: number
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
  }

  export type IngredientPreferenceCreateManyUserInput = {
    genericIngredientID: number
    specificIngredientID: number
  }

  export type StorageUserCreateManyUserInput = {
    storageId: number
    permission: string
  }

  export type StorageCreateManyCreatedByInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedById: string
  }

  export type StorageCreateManyEditedByInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
  }

  export type InventoryCreateManyCreatedByInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedById: string
  }

  export type InventoryCreateManyEditedByInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
  }

  export type InventoryUserCreateManyUserInput = {
    inventoryId: number
    permission: string
  }

  export type RecipeBookUserUpdateWithoutUserInput = {
    recipeBook?: RecipeBookUpdateOneRequiredWithoutRecipeBookUserNestedInput
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookUserUncheckedUpdateWithoutUserInput = {
    recipeBookId?: IntFieldUpdateOperationsInput | number
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookUserUncheckedUpdateManyWithoutRecipeBookUserInput = {
    recipeBookId?: IntFieldUpdateOperationsInput | number
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookUpdateWithoutCreatedByInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedBy?: UserUpdateOneWithoutRecipeBookEditedByIdNestedInput
    recipeBookBuild?: RecipeBookBuildUpdateManyWithoutRecipeBookNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutRecipeBookNestedInput
  }

  export type RecipeBookUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutRecipeBookNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutRecipeBookNestedInput
  }

  export type RecipeBookUncheckedUpdateManyWithoutRecipeBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeBookUpdateWithoutEditedByInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutRecipeBookNestedInput
    recipeBookBuild?: RecipeBookBuildUpdateManyWithoutRecipeBookNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutRecipeBookNestedInput
  }

  export type RecipeBookUncheckedUpdateWithoutEditedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutRecipeBookNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutRecipeBookNestedInput
  }

  export type RecipeBookUncheckedUpdateManyWithoutRecipeBookEditedByIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeUpdateWithoutCreatedByInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    build?: BuildUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    build?: BuildUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateManyWithoutRecipeInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BuildUserUpdateWithoutUserInput = {
    build?: BuildUpdateOneRequiredWithoutBuildUserNestedInput
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type BuildUserUncheckedUpdateWithoutUserInput = {
    buildId?: IntFieldUpdateOperationsInput | number
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type BuildUserUncheckedUpdateManyWithoutBuildUserInput = {
    buildId?: IntFieldUpdateOperationsInput | number
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type BuildUpdateWithoutCreatedByInput = {
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedBy?: UserUpdateOneWithoutBuildEditedByNestedInput
    recipe?: RecipeUpdateOneWithoutBuildNestedInput
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: StringFieldUpdateOperationsInput | string
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateManyWithoutBuildInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: StringFieldUpdateOperationsInput | string
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BuildUpdateWithoutEditedByInput = {
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutBuildNestedInput
    recipe?: RecipeUpdateOneWithoutBuildNestedInput
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateWithoutEditedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateManyWithoutBuildEditedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCrewUpdateWithoutUserInput = {
    crew?: CrewUpdateOneRequiredWithoutUserCrewNestedInput
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type UserCrewUncheckedUpdateWithoutUserInput = {
    crewId?: IntFieldUpdateOperationsInput | number
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type UserCrewUncheckedUpdateManyWithoutUserCrewInput = {
    crewId?: IntFieldUpdateOperationsInput | number
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type CrewUpdateWithoutCreatedByInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedBy?: UserUpdateOneWithoutCrewEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutCrewNestedInput
  }

  export type CrewUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: StringFieldUpdateOperationsInput | string
    userCrew?: UserCrewUncheckedUpdateManyWithoutCrewNestedInput
  }

  export type CrewUncheckedUpdateManyWithoutCrewInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: StringFieldUpdateOperationsInput | string
  }

  export type CrewUpdateWithoutEditedByInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCrewNestedInput
    userCrew?: UserCrewUpdateManyWithoutCrewNestedInput
  }

  export type CrewUncheckedUpdateWithoutEditedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    userCrew?: UserCrewUncheckedUpdateManyWithoutCrewNestedInput
  }

  export type CrewUncheckedUpdateManyWithoutCrewEditedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type SpecificIngredientUpdateWithoutCreatedByInput = {
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    genericIngredient?: GenericIngredientUpdateOneRequiredWithoutSpecificIngredientNestedInput
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUpdateManyWithoutSpecificIngredientNestedInput
    ingredientStorage?: IngredientStorageUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutSpecificIngredientNestedInput
  }

  export type SpecificIngredientUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    genericIngredientId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutSpecificIngredientNestedInput
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutSpecificIngredientNestedInput
  }

  export type SpecificIngredientUncheckedUpdateManyWithoutIngredientInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    genericIngredientId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IngredientPreferenceUpdateWithoutUserInput = {
    genericIngredient?: GenericIngredientUpdateOneRequiredWithoutIngredientPreferenceNestedInput
    specificIngredient?: SpecificIngredientUpdateOneRequiredWithoutIngredientPreferenceNestedInput
  }

  export type IngredientPreferenceUncheckedUpdateWithoutUserInput = {
    genericIngredientID?: IntFieldUpdateOperationsInput | number
    specificIngredientID?: IntFieldUpdateOperationsInput | number
  }

  export type IngredientPreferenceUncheckedUpdateManyWithoutIngredientPreferenceInput = {
    genericIngredientID?: IntFieldUpdateOperationsInput | number
    specificIngredientID?: IntFieldUpdateOperationsInput | number
  }

  export type StorageUserUpdateWithoutUserInput = {
    Storage?: StorageUpdateOneRequiredWithoutStorageUserNestedInput
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type StorageUserUncheckedUpdateWithoutUserInput = {
    storageId?: IntFieldUpdateOperationsInput | number
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type StorageUserUncheckedUpdateManyWithoutStorageUserInput = {
    storageId?: IntFieldUpdateOperationsInput | number
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type StorageUpdateWithoutCreatedByInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedBy?: UserUpdateOneWithoutStorageEditedByNestedInput
    inventoryStorage?: InventoryStorageUpdateManyWithoutStorageNestedInput
    ingredientStorage?: IngredientStorageUpdateManyWithoutStorageNestedInput
    storageUser?: StorageUserUpdateManyWithoutStorageNestedInput
  }

  export type StorageUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: StringFieldUpdateOperationsInput | string
    inventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutStorageNestedInput
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutStorageNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutStorageNestedInput
  }

  export type StorageUncheckedUpdateManyWithoutStorageInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: StringFieldUpdateOperationsInput | string
  }

  export type StorageUpdateWithoutEditedByInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutStorageNestedInput
    inventoryStorage?: InventoryStorageUpdateManyWithoutStorageNestedInput
    ingredientStorage?: IngredientStorageUpdateManyWithoutStorageNestedInput
    storageUser?: StorageUserUpdateManyWithoutStorageNestedInput
  }

  export type StorageUncheckedUpdateWithoutEditedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    inventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutStorageNestedInput
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutStorageNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutStorageNestedInput
  }

  export type StorageUncheckedUpdateManyWithoutStorageEditedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryUpdateWithoutCreatedByInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedBy?: UserUpdateOneWithoutInventoryEditedByNestedInput
    inventoryStorage?: InventoryStorageUpdateManyWithoutInventoryNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: StringFieldUpdateOperationsInput | string
    inventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutInventoryNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateManyWithoutInventoryCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryUpdateWithoutEditedByInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutInventoryCreatedByNestedInput
    inventoryStorage?: InventoryStorageUpdateManyWithoutInventoryNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutEditedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    inventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutInventoryNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateManyWithoutInventoryEditedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryUserUpdateWithoutUserInput = {
    inventory?: InventoryUpdateOneRequiredWithoutInventoryUserNestedInput
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryUserUncheckedUpdateWithoutUserInput = {
    inventoryId?: IntFieldUpdateOperationsInput | number
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryUserUncheckedUpdateManyWithoutInventoryUserInput = {
    inventoryId?: IntFieldUpdateOperationsInput | number
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookBuildCreateManyRecipeBookInput = {
    buildId: number
  }

  export type RecipeBookUserCreateManyRecipeBookInput = {
    userId: string
    permission: string
  }

  export type RecipeBookBuildUpdateWithoutRecipeBookInput = {
    build?: BuildUpdateOneRequiredWithoutRecipeBookBuildNestedInput
  }

  export type RecipeBookBuildUncheckedUpdateWithoutRecipeBookInput = {
    buildId?: IntFieldUpdateOperationsInput | number
  }

  export type RecipeBookBuildUncheckedUpdateManyWithoutRecipeBookBuildInput = {
    buildId?: IntFieldUpdateOperationsInput | number
  }

  export type RecipeBookUserUpdateWithoutRecipeBookInput = {
    user?: UserUpdateOneRequiredWithoutRecipeBookUserNestedInput
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookUserUncheckedUpdateWithoutRecipeBookInput = {
    userId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type TouchCreateManyBuildInput = {
    id?: number
    order?: number | null
    amount?: number | null
    unit?: string | null
    genericIngredientID: number
    specificIngredientID?: number | null
  }

  export type RecipeBookBuildCreateManyBuildInput = {
    recipeBookId: number
  }

  export type BuildUserCreateManyBuildInput = {
    userId: string
    permission: string
  }

  export type TouchUpdateWithoutBuildInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    genericIngredient?: GenericIngredientUpdateOneRequiredWithoutTouchNestedInput
    specificIngredient?: SpecificIngredientUpdateOneWithoutTouchNestedInput
  }

  export type TouchUncheckedUpdateWithoutBuildInput = {
    id?: IntFieldUpdateOperationsInput | number
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    genericIngredientID?: IntFieldUpdateOperationsInput | number
    specificIngredientID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TouchUncheckedUpdateManyWithoutTouchInput = {
    id?: IntFieldUpdateOperationsInput | number
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    genericIngredientID?: IntFieldUpdateOperationsInput | number
    specificIngredientID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RecipeBookBuildUpdateWithoutBuildInput = {
    recipeBook?: RecipeBookUpdateOneRequiredWithoutRecipeBookBuildNestedInput
  }

  export type RecipeBookBuildUncheckedUpdateWithoutBuildInput = {
    recipeBookId?: IntFieldUpdateOperationsInput | number
  }

  export type BuildUserUpdateWithoutBuildInput = {
    user?: UserUpdateOneRequiredWithoutBuildUserNestedInput
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type BuildUserUncheckedUpdateWithoutBuildInput = {
    userId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type BuildCreateManyRecipeInput = {
    id?: number
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
  }

  export type BuildUpdateWithoutRecipeInput = {
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutBuildNestedInput
    editedBy?: UserUpdateOneWithoutBuildEditedByNestedInput
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateWithoutRecipeInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutBuildNestedInput
  }

  export type TouchCreateManyGenericIngredientInput = {
    id?: number
    buildId?: number | null
    order?: number | null
    amount?: number | null
    unit?: string | null
    specificIngredientID?: number | null
  }

  export type SpecificIngredientCreateManyGenericIngredientInput = {
    id?: number
    dateCreated?: Date | string
    createdById?: string | null
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
  }

  export type IngredientPreferenceCreateManyGenericIngredientInput = {
    specificIngredientID: number
    userId: string
  }

  export type TouchUpdateWithoutGenericIngredientInput = {
    build?: BuildUpdateOneWithoutTouchNestedInput
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    specificIngredient?: SpecificIngredientUpdateOneWithoutTouchNestedInput
  }

  export type TouchUncheckedUpdateWithoutGenericIngredientInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildId?: NullableIntFieldUpdateOperationsInput | number | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    specificIngredientID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpecificIngredientUpdateWithoutGenericIngredientInput = {
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutIngredientNestedInput
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUpdateManyWithoutSpecificIngredientNestedInput
    ingredientStorage?: IngredientStorageUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutSpecificIngredientNestedInput
  }

  export type SpecificIngredientUncheckedUpdateWithoutGenericIngredientInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutSpecificIngredientNestedInput
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutSpecificIngredientNestedInput
  }

  export type SpecificIngredientUncheckedUpdateManyWithoutSpecificIngredientInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IngredientPreferenceUpdateWithoutGenericIngredientInput = {
    specificIngredient?: SpecificIngredientUpdateOneRequiredWithoutIngredientPreferenceNestedInput
    user?: UserUpdateOneRequiredWithoutIngredientPreferenceNestedInput
  }

  export type IngredientPreferenceUncheckedUpdateWithoutGenericIngredientInput = {
    specificIngredientID?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TouchCreateManySpecificIngredientInput = {
    id?: number
    buildId?: number | null
    order?: number | null
    amount?: number | null
    unit?: string | null
    genericIngredientID: number
  }

  export type IngredientStorageCreateManyIngredientInput = {
    storageId: number
    quantity?: number | null
  }

  export type IngredientPreferenceCreateManySpecificIngredientInput = {
    genericIngredientID: number
    userId: string
  }

  export type TouchUpdateWithoutSpecificIngredientInput = {
    build?: BuildUpdateOneWithoutTouchNestedInput
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    genericIngredient?: GenericIngredientUpdateOneRequiredWithoutTouchNestedInput
  }

  export type TouchUncheckedUpdateWithoutSpecificIngredientInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildId?: NullableIntFieldUpdateOperationsInput | number | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    genericIngredientID?: IntFieldUpdateOperationsInput | number
  }

  export type IngredientStorageUpdateWithoutIngredientInput = {
    Storage?: StorageUpdateOneRequiredWithoutIngredientStorageNestedInput
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type IngredientStorageUncheckedUpdateWithoutIngredientInput = {
    storageId?: IntFieldUpdateOperationsInput | number
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type IngredientStorageUncheckedUpdateManyWithoutIngredientStorageInput = {
    storageId?: IntFieldUpdateOperationsInput | number
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type IngredientPreferenceUpdateWithoutSpecificIngredientInput = {
    genericIngredient?: GenericIngredientUpdateOneRequiredWithoutIngredientPreferenceNestedInput
    user?: UserUpdateOneRequiredWithoutIngredientPreferenceNestedInput
  }

  export type IngredientPreferenceUncheckedUpdateWithoutSpecificIngredientInput = {
    genericIngredientID?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryStorageCreateManyInventoryInput = {
    storageId: number
  }

  export type InventoryUserCreateManyInventoryInput = {
    userId: string
    permission: string
  }

  export type InventoryStorageUpdateWithoutInventoryInput = {
    storage?: StorageUpdateOneRequiredWithoutInventoryStorageNestedInput
  }

  export type InventoryStorageUncheckedUpdateWithoutInventoryInput = {
    storageId?: IntFieldUpdateOperationsInput | number
  }

  export type InventoryStorageUncheckedUpdateManyWithoutInventoryStorageInput = {
    storageId?: IntFieldUpdateOperationsInput | number
  }

  export type InventoryUserUpdateWithoutInventoryInput = {
    user?: UserUpdateOneRequiredWithoutInventoryUserNestedInput
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryUserUncheckedUpdateWithoutInventoryInput = {
    userId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryStorageCreateManyStorageInput = {
    inventoryId: number
  }

  export type IngredientStorageCreateManyStorageInput = {
    ingredientId: number
    quantity?: number | null
  }

  export type StorageUserCreateManyStorageInput = {
    userId: string
    permission: string
  }

  export type InventoryStorageUpdateWithoutStorageInput = {
    inventory?: InventoryUpdateOneRequiredWithoutInventoryStorageNestedInput
  }

  export type InventoryStorageUncheckedUpdateWithoutStorageInput = {
    inventoryId?: IntFieldUpdateOperationsInput | number
  }

  export type IngredientStorageUpdateWithoutStorageInput = {
    ingredient?: SpecificIngredientUpdateOneRequiredWithoutIngredientStorageNestedInput
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type IngredientStorageUncheckedUpdateWithoutStorageInput = {
    ingredientId?: IntFieldUpdateOperationsInput | number
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type StorageUserUpdateWithoutStorageInput = {
    user?: UserUpdateOneRequiredWithoutStorageUserNestedInput
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type StorageUserUncheckedUpdateWithoutStorageInput = {
    userId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type UserCrewCreateManyCrewInput = {
    userId: string
    permission: string
  }

  export type UserCrewUpdateWithoutCrewInput = {
    user?: UserUpdateOneRequiredWithoutUserCrewNestedInput
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type UserCrewUncheckedUpdateWithoutCrewInput = {
    userId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}