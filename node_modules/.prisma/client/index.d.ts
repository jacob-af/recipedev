
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model User
 * 
 */
export type User = {
  id: string
  userName: string
  firstName: string | null
  lastName: string | null
  dateJoined: Date
  lastEdited: Date
  email: string
  password: string
}

/**
 * Model Profile
 * 
 */
export type Profile = {
  id: number
  userId: string
  photo: string
}

/**
 * Model RecipeBook
 * 
 */
export type RecipeBook = {
  id: number
  name: string
  createdAt: Date
  editedAt: Date
  createdById: string | null
  editedById: string | null
}

/**
 * Model RecipeBookUser
 * 
 */
export type RecipeBookUser = {
  id: number
  userId: string
  recipeBookId: number
  partner: boolean
  manager: boolean
}

/**
 * Model Build
 * 
 */
export type Build = {
  id: number
  buildName: string
  createdAt: Date
  editedAt: Date
  createdById: string
  editedById: string
  recipeId: number | null
  instructions: string | null
  notes: string | null
  glassware: string | null
  ice: string | null
}

/**
 * Model UserBuild
 * 
 */
export type UserBuild = {
  id: number
  userId: string
  buildId: number
  partner: boolean
  manager: boolean
}

/**
 * Model Recipe
 * 
 */
export type Recipe = {
  id: number
  createdAt: Date
  name: string
  origin: string | null
  history: string | null
  createdById: string
}

/**
 * Model RecipeBookBuild
 * 
 */
export type RecipeBookBuild = {
  id: number
  buildId: number
  recipeBookId: number
}

/**
 * Model Touch
 * 
 */
export type Touch = {
  id: number
  ingredientName: string
  ingredientId: number | null
  buildId: number | null
  order: number | null
  amount: number | null
  unit: string | null
}

/**
 * Model Ingredient
 * 
 */
export type Ingredient = {
  id: number
  dateCreated: Date
  createdById: string | null
  name: string
  price: number | null
  amount: number | null
  unit: string | null
}

/**
 * Model Inventory
 * 
 */
export type Inventory = {
  id: number
  name: string
  createdAt: Date
  editedAt: Date
  createdById: string
  editedById: string
}

/**
 * Model InventoryStorage
 * 
 */
export type InventoryStorage = {
  id: number
  inventoryId: number
  storageId: number
}

/**
 * Model Storage
 * 
 */
export type Storage = {
  id: number
  name: string
  createdAt: Date
  editedAt: Date
  createdById: string
  editedById: string
}

/**
 * Model ingredientStorage
 * 
 */
export type ingredientStorage = {
  id: number
  createdAt: Date
  editedAt: Date
  ingredientId: number | null
  quantity: number | null
  storageId: number | null
}

/**
 * Model UserStorage
 * 
 */
export type UserStorage = {
  id: number
  createdAt: Date
  editedAt: Date
  userId: string
  quantity: number | null
  storageId: number | null
  partner: boolean
  manager: boolean
}

/**
 * Model Crew
 * 
 */
export type Crew = {
  id: number
  createdAt: Date
  editedAt: Date
  createdById: string
  editedById: string
}

/**
 * Model UserCrew
 * 
 */
export type UserCrew = {
  id: number
  userId: string
  crewId: number
  partner: boolean
  manager: boolean
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<GlobalReject>;

  /**
   * `prisma.recipeBook`: Exposes CRUD operations for the **RecipeBook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecipeBooks
    * const recipeBooks = await prisma.recipeBook.findMany()
    * ```
    */
  get recipeBook(): Prisma.RecipeBookDelegate<GlobalReject>;

  /**
   * `prisma.recipeBookUser`: Exposes CRUD operations for the **RecipeBookUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecipeBookUsers
    * const recipeBookUsers = await prisma.recipeBookUser.findMany()
    * ```
    */
  get recipeBookUser(): Prisma.RecipeBookUserDelegate<GlobalReject>;

  /**
   * `prisma.build`: Exposes CRUD operations for the **Build** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Builds
    * const builds = await prisma.build.findMany()
    * ```
    */
  get build(): Prisma.BuildDelegate<GlobalReject>;

  /**
   * `prisma.userBuild`: Exposes CRUD operations for the **UserBuild** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserBuilds
    * const userBuilds = await prisma.userBuild.findMany()
    * ```
    */
  get userBuild(): Prisma.UserBuildDelegate<GlobalReject>;

  /**
   * `prisma.recipe`: Exposes CRUD operations for the **Recipe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recipes
    * const recipes = await prisma.recipe.findMany()
    * ```
    */
  get recipe(): Prisma.RecipeDelegate<GlobalReject>;

  /**
   * `prisma.recipeBookBuild`: Exposes CRUD operations for the **RecipeBookBuild** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecipeBookBuilds
    * const recipeBookBuilds = await prisma.recipeBookBuild.findMany()
    * ```
    */
  get recipeBookBuild(): Prisma.RecipeBookBuildDelegate<GlobalReject>;

  /**
   * `prisma.touch`: Exposes CRUD operations for the **Touch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Touches
    * const touches = await prisma.touch.findMany()
    * ```
    */
  get touch(): Prisma.TouchDelegate<GlobalReject>;

  /**
   * `prisma.ingredient`: Exposes CRUD operations for the **Ingredient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ingredients
    * const ingredients = await prisma.ingredient.findMany()
    * ```
    */
  get ingredient(): Prisma.IngredientDelegate<GlobalReject>;

  /**
   * `prisma.inventory`: Exposes CRUD operations for the **Inventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventories
    * const inventories = await prisma.inventory.findMany()
    * ```
    */
  get inventory(): Prisma.InventoryDelegate<GlobalReject>;

  /**
   * `prisma.inventoryStorage`: Exposes CRUD operations for the **InventoryStorage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryStorages
    * const inventoryStorages = await prisma.inventoryStorage.findMany()
    * ```
    */
  get inventoryStorage(): Prisma.InventoryStorageDelegate<GlobalReject>;

  /**
   * `prisma.storage`: Exposes CRUD operations for the **Storage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Storages
    * const storages = await prisma.storage.findMany()
    * ```
    */
  get storage(): Prisma.StorageDelegate<GlobalReject>;

  /**
   * `prisma.ingredientStorage`: Exposes CRUD operations for the **ingredientStorage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IngredientStorages
    * const ingredientStorages = await prisma.ingredientStorage.findMany()
    * ```
    */
  get ingredientStorage(): Prisma.ingredientStorageDelegate<GlobalReject>;

  /**
   * `prisma.userStorage`: Exposes CRUD operations for the **UserStorage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserStorages
    * const userStorages = await prisma.userStorage.findMany()
    * ```
    */
  get userStorage(): Prisma.UserStorageDelegate<GlobalReject>;

  /**
   * `prisma.crew`: Exposes CRUD operations for the **Crew** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Crews
    * const crews = await prisma.crew.findMany()
    * ```
    */
  get crew(): Prisma.CrewDelegate<GlobalReject>;

  /**
   * `prisma.userCrew`: Exposes CRUD operations for the **UserCrew** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserCrews
    * const userCrews = await prisma.userCrew.findMany()
    * ```
    */
  get userCrew(): Prisma.UserCrewDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export import Metrics = runtime.Metrics
  export import Metric = runtime.Metric
  export import MetricHistogram = runtime.MetricHistogram
  export import MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
   * Prisma Client JS version: 4.3.1
   * Query Engine version: c875e43600dfe042452e0b868f7a48b817b9640b
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export import FieldRef = runtime.FieldRef

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    User: 'User',
    Profile: 'Profile',
    RecipeBook: 'RecipeBook',
    RecipeBookUser: 'RecipeBookUser',
    Build: 'Build',
    UserBuild: 'UserBuild',
    Recipe: 'Recipe',
    RecipeBookBuild: 'RecipeBookBuild',
    Touch: 'Touch',
    Ingredient: 'Ingredient',
    Inventory: 'Inventory',
    InventoryStorage: 'InventoryStorage',
    Storage: 'Storage',
    ingredientStorage: 'ingredientStorage',
    UserStorage: 'UserStorage',
    Crew: 'Crew',
    UserCrew: 'UserCrew'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    recipeBookUser: number
    recipeBook: number
    recipeBookEditedById: number
    userCrew: number
    crew: number
    crewEditedBy: number
    userBuild: number
    build: number
    buildEditedBy: number
    recipe: number
    ingredient: number
    userStorage: number
    storage: number
    storageEditedBy: number
    inventoryCreatedBy: number
    inventoryEditedBy: number
  }

  export type UserCountOutputTypeSelect = {
    recipeBookUser?: boolean
    recipeBook?: boolean
    recipeBookEditedById?: boolean
    userCrew?: boolean
    crew?: boolean
    crewEditedBy?: boolean
    userBuild?: boolean
    build?: boolean
    buildEditedBy?: boolean
    recipe?: boolean
    ingredient?: boolean
    userStorage?: boolean
    storage?: boolean
    storageEditedBy?: boolean
    inventoryCreatedBy?: boolean
    inventoryEditedBy?: boolean
  }

  export type UserCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UserCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UserCountOutputType
    : S extends undefined
    ? never
    : S extends UserCountOutputTypeArgs
    ?'include' extends U
    ? UserCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
    : UserCountOutputType
  : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type RecipeBookCountOutputType
   */


  export type RecipeBookCountOutputType = {
    recipeBookBuild: number
    recipeBookUser: number
  }

  export type RecipeBookCountOutputTypeSelect = {
    recipeBookBuild?: boolean
    recipeBookUser?: boolean
  }

  export type RecipeBookCountOutputTypeGetPayload<
    S extends boolean | null | undefined | RecipeBookCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? RecipeBookCountOutputType
    : S extends undefined
    ? never
    : S extends RecipeBookCountOutputTypeArgs
    ?'include' extends U
    ? RecipeBookCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof RecipeBookCountOutputType ? RecipeBookCountOutputType[P] : never
  } 
    : RecipeBookCountOutputType
  : RecipeBookCountOutputType




  // Custom InputTypes

  /**
   * RecipeBookCountOutputType without action
   */
  export type RecipeBookCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RecipeBookCountOutputType
     * 
    **/
    select?: RecipeBookCountOutputTypeSelect | null
  }



  /**
   * Count Type BuildCountOutputType
   */


  export type BuildCountOutputType = {
    touch: number
    RecipeBookBuild: number
    userBuild: number
  }

  export type BuildCountOutputTypeSelect = {
    touch?: boolean
    RecipeBookBuild?: boolean
    userBuild?: boolean
  }

  export type BuildCountOutputTypeGetPayload<
    S extends boolean | null | undefined | BuildCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? BuildCountOutputType
    : S extends undefined
    ? never
    : S extends BuildCountOutputTypeArgs
    ?'include' extends U
    ? BuildCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof BuildCountOutputType ? BuildCountOutputType[P] : never
  } 
    : BuildCountOutputType
  : BuildCountOutputType




  // Custom InputTypes

  /**
   * BuildCountOutputType without action
   */
  export type BuildCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BuildCountOutputType
     * 
    **/
    select?: BuildCountOutputTypeSelect | null
  }



  /**
   * Count Type RecipeCountOutputType
   */


  export type RecipeCountOutputType = {
    build: number
  }

  export type RecipeCountOutputTypeSelect = {
    build?: boolean
  }

  export type RecipeCountOutputTypeGetPayload<
    S extends boolean | null | undefined | RecipeCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? RecipeCountOutputType
    : S extends undefined
    ? never
    : S extends RecipeCountOutputTypeArgs
    ?'include' extends U
    ? RecipeCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof RecipeCountOutputType ? RecipeCountOutputType[P] : never
  } 
    : RecipeCountOutputType
  : RecipeCountOutputType




  // Custom InputTypes

  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RecipeCountOutputType
     * 
    **/
    select?: RecipeCountOutputTypeSelect | null
  }



  /**
   * Count Type IngredientCountOutputType
   */


  export type IngredientCountOutputType = {
    touch: number
    ingredientStorage: number
  }

  export type IngredientCountOutputTypeSelect = {
    touch?: boolean
    ingredientStorage?: boolean
  }

  export type IngredientCountOutputTypeGetPayload<
    S extends boolean | null | undefined | IngredientCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? IngredientCountOutputType
    : S extends undefined
    ? never
    : S extends IngredientCountOutputTypeArgs
    ?'include' extends U
    ? IngredientCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof IngredientCountOutputType ? IngredientCountOutputType[P] : never
  } 
    : IngredientCountOutputType
  : IngredientCountOutputType




  // Custom InputTypes

  /**
   * IngredientCountOutputType without action
   */
  export type IngredientCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the IngredientCountOutputType
     * 
    **/
    select?: IngredientCountOutputTypeSelect | null
  }



  /**
   * Count Type InventoryCountOutputType
   */


  export type InventoryCountOutputType = {
    InventoryStorage: number
  }

  export type InventoryCountOutputTypeSelect = {
    InventoryStorage?: boolean
  }

  export type InventoryCountOutputTypeGetPayload<
    S extends boolean | null | undefined | InventoryCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? InventoryCountOutputType
    : S extends undefined
    ? never
    : S extends InventoryCountOutputTypeArgs
    ?'include' extends U
    ? InventoryCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof InventoryCountOutputType ? InventoryCountOutputType[P] : never
  } 
    : InventoryCountOutputType
  : InventoryCountOutputType




  // Custom InputTypes

  /**
   * InventoryCountOutputType without action
   */
  export type InventoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the InventoryCountOutputType
     * 
    **/
    select?: InventoryCountOutputTypeSelect | null
  }



  /**
   * Count Type StorageCountOutputType
   */


  export type StorageCountOutputType = {
    inventoryStorage: number
    ingredientStorage: number
    userStorage: number
  }

  export type StorageCountOutputTypeSelect = {
    inventoryStorage?: boolean
    ingredientStorage?: boolean
    userStorage?: boolean
  }

  export type StorageCountOutputTypeGetPayload<
    S extends boolean | null | undefined | StorageCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? StorageCountOutputType
    : S extends undefined
    ? never
    : S extends StorageCountOutputTypeArgs
    ?'include' extends U
    ? StorageCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof StorageCountOutputType ? StorageCountOutputType[P] : never
  } 
    : StorageCountOutputType
  : StorageCountOutputType




  // Custom InputTypes

  /**
   * StorageCountOutputType without action
   */
  export type StorageCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the StorageCountOutputType
     * 
    **/
    select?: StorageCountOutputTypeSelect | null
  }



  /**
   * Count Type CrewCountOutputType
   */


  export type CrewCountOutputType = {
    userCrew: number
  }

  export type CrewCountOutputTypeSelect = {
    userCrew?: boolean
  }

  export type CrewCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CrewCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CrewCountOutputType
    : S extends undefined
    ? never
    : S extends CrewCountOutputTypeArgs
    ?'include' extends U
    ? CrewCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CrewCountOutputType ? CrewCountOutputType[P] : never
  } 
    : CrewCountOutputType
  : CrewCountOutputType




  // Custom InputTypes

  /**
   * CrewCountOutputType without action
   */
  export type CrewCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CrewCountOutputType
     * 
    **/
    select?: CrewCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    userName: string | null
    firstName: string | null
    lastName: string | null
    dateJoined: Date | null
    lastEdited: Date | null
    email: string | null
    password: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    userName: string | null
    firstName: string | null
    lastName: string | null
    dateJoined: Date | null
    lastEdited: Date | null
    email: string | null
    password: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    userName: number
    firstName: number
    lastName: number
    dateJoined: number
    lastEdited: number
    email: number
    password: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    userName?: true
    firstName?: true
    lastName?: true
    dateJoined?: true
    lastEdited?: true
    email?: true
    password?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    userName?: true
    firstName?: true
    lastName?: true
    dateJoined?: true
    lastEdited?: true
    email?: true
    password?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    userName?: true
    firstName?: true
    lastName?: true
    dateJoined?: true
    lastEdited?: true
    email?: true
    password?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    userName: string
    firstName: string | null
    lastName: string | null
    dateJoined: Date
    lastEdited: Date
    email: string
    password: string
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    userName?: boolean
    firstName?: boolean
    lastName?: boolean
    dateJoined?: boolean
    lastEdited?: boolean
    email?: boolean
    password?: boolean
    profile?: boolean | ProfileArgs
    recipeBookUser?: boolean | RecipeBookUserFindManyArgs
    recipeBook?: boolean | RecipeBookFindManyArgs
    recipeBookEditedById?: boolean | RecipeBookFindManyArgs
    userCrew?: boolean | UserCrewFindManyArgs
    crew?: boolean | CrewFindManyArgs
    crewEditedBy?: boolean | CrewFindManyArgs
    userBuild?: boolean | UserBuildFindManyArgs
    build?: boolean | BuildFindManyArgs
    buildEditedBy?: boolean | BuildFindManyArgs
    recipe?: boolean | RecipeFindManyArgs
    ingredient?: boolean | IngredientFindManyArgs
    userStorage?: boolean | UserStorageFindManyArgs
    storage?: boolean | StorageFindManyArgs
    storageEditedBy?: boolean | StorageFindManyArgs
    inventoryCreatedBy?: boolean | InventoryFindManyArgs
    inventoryEditedBy?: boolean | InventoryFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserInclude = {
    profile?: boolean | ProfileArgs
    recipeBookUser?: boolean | RecipeBookUserFindManyArgs
    recipeBook?: boolean | RecipeBookFindManyArgs
    recipeBookEditedById?: boolean | RecipeBookFindManyArgs
    userCrew?: boolean | UserCrewFindManyArgs
    crew?: boolean | CrewFindManyArgs
    crewEditedBy?: boolean | CrewFindManyArgs
    userBuild?: boolean | UserBuildFindManyArgs
    build?: boolean | BuildFindManyArgs
    buildEditedBy?: boolean | BuildFindManyArgs
    recipe?: boolean | RecipeFindManyArgs
    ingredient?: boolean | IngredientFindManyArgs
    userStorage?: boolean | UserStorageFindManyArgs
    storage?: boolean | StorageFindManyArgs
    storageEditedBy?: boolean | StorageFindManyArgs
    inventoryCreatedBy?: boolean | InventoryFindManyArgs
    inventoryEditedBy?: boolean | InventoryFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]:
        P extends 'profile' ? ProfileGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'recipeBookUser' ? Array < RecipeBookUserGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'recipeBook' ? Array < RecipeBookGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'recipeBookEditedById' ? Array < RecipeBookGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'userCrew' ? Array < UserCrewGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'crew' ? Array < CrewGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'crewEditedBy' ? Array < CrewGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'userBuild' ? Array < UserBuildGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'build' ? Array < BuildGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'buildEditedBy' ? Array < BuildGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'recipe' ? Array < RecipeGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'ingredient' ? Array < IngredientGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'userStorage' ? Array < UserStorageGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'storage' ? Array < StorageGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'storageEditedBy' ? Array < StorageGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'inventoryCreatedBy' ? Array < InventoryGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'inventoryEditedBy' ? Array < InventoryGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'profile' ? ProfileGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'recipeBookUser' ? Array < RecipeBookUserGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'recipeBook' ? Array < RecipeBookGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'recipeBookEditedById' ? Array < RecipeBookGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'userCrew' ? Array < UserCrewGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'crew' ? Array < CrewGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'crewEditedBy' ? Array < CrewGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'userBuild' ? Array < UserBuildGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'build' ? Array < BuildGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'buildEditedBy' ? Array < BuildGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'recipe' ? Array < RecipeGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'ingredient' ? Array < IngredientGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'userStorage' ? Array < UserStorageGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'storage' ? Array < StorageGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'storageEditedBy' ? Array < StorageGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'inventoryCreatedBy' ? Array < InventoryGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'inventoryEditedBy' ? Array < InventoryGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof User ? User[P] : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Find one User that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    profile<T extends ProfileArgs = {}>(args?: Subset<T, ProfileArgs>): CheckSelect<T, Prisma__ProfileClient<Profile | null >, Prisma__ProfileClient<ProfileGetPayload<T> | null >>;

    recipeBookUser<T extends RecipeBookUserFindManyArgs = {}>(args?: Subset<T, RecipeBookUserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RecipeBookUser>>, PrismaPromise<Array<RecipeBookUserGetPayload<T>>>>;

    recipeBook<T extends RecipeBookFindManyArgs = {}>(args?: Subset<T, RecipeBookFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RecipeBook>>, PrismaPromise<Array<RecipeBookGetPayload<T>>>>;

    recipeBookEditedById<T extends RecipeBookFindManyArgs = {}>(args?: Subset<T, RecipeBookFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RecipeBook>>, PrismaPromise<Array<RecipeBookGetPayload<T>>>>;

    userCrew<T extends UserCrewFindManyArgs = {}>(args?: Subset<T, UserCrewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserCrew>>, PrismaPromise<Array<UserCrewGetPayload<T>>>>;

    crew<T extends CrewFindManyArgs = {}>(args?: Subset<T, CrewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Crew>>, PrismaPromise<Array<CrewGetPayload<T>>>>;

    crewEditedBy<T extends CrewFindManyArgs = {}>(args?: Subset<T, CrewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Crew>>, PrismaPromise<Array<CrewGetPayload<T>>>>;

    userBuild<T extends UserBuildFindManyArgs = {}>(args?: Subset<T, UserBuildFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserBuild>>, PrismaPromise<Array<UserBuildGetPayload<T>>>>;

    build<T extends BuildFindManyArgs = {}>(args?: Subset<T, BuildFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Build>>, PrismaPromise<Array<BuildGetPayload<T>>>>;

    buildEditedBy<T extends BuildFindManyArgs = {}>(args?: Subset<T, BuildFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Build>>, PrismaPromise<Array<BuildGetPayload<T>>>>;

    recipe<T extends RecipeFindManyArgs = {}>(args?: Subset<T, RecipeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Recipe>>, PrismaPromise<Array<RecipeGetPayload<T>>>>;

    ingredient<T extends IngredientFindManyArgs = {}>(args?: Subset<T, IngredientFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Ingredient>>, PrismaPromise<Array<IngredientGetPayload<T>>>>;

    userStorage<T extends UserStorageFindManyArgs = {}>(args?: Subset<T, UserStorageFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserStorage>>, PrismaPromise<Array<UserStorageGetPayload<T>>>>;

    storage<T extends StorageFindManyArgs = {}>(args?: Subset<T, StorageFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Storage>>, PrismaPromise<Array<StorageGetPayload<T>>>>;

    storageEditedBy<T extends StorageFindManyArgs = {}>(args?: Subset<T, StorageFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Storage>>, PrismaPromise<Array<StorageGetPayload<T>>>>;

    inventoryCreatedBy<T extends InventoryFindManyArgs = {}>(args?: Subset<T, InventoryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Inventory>>, PrismaPromise<Array<InventoryGetPayload<T>>>>;

    inventoryEditedBy<T extends InventoryFindManyArgs = {}>(args?: Subset<T, InventoryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Inventory>>, PrismaPromise<Array<InventoryGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }

  /**
   * User: findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User: findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     * 
    **/
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     * 
    **/
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User: findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = UserFindUniqueArgsBase
      

  /**
   * User: findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = UserFindFirstArgsBase
      

  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model Profile
   */


  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileAvgAggregateOutputType = {
    id: number | null
  }

  export type ProfileSumAggregateOutputType = {
    id: number | null
  }

  export type ProfileMinAggregateOutputType = {
    id: number | null
    userId: string | null
    photo: string | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    photo: string | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    userId: number
    photo: number
    _all: number
  }


  export type ProfileAvgAggregateInputType = {
    id?: true
  }

  export type ProfileSumAggregateInputType = {
    id?: true
  }

  export type ProfileMinAggregateInputType = {
    id?: true
    userId?: true
    photo?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    photo?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    userId?: true
    photo?: true
    _all?: true
  }

  export type ProfileAggregateArgs = {
    /**
     * Filter which Profile to aggregate.
     * 
    **/
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     * 
    **/
    orderBy?: Enumerable<ProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs = {
    where?: ProfileWhereInput
    orderBy?: Enumerable<ProfileOrderByWithAggregationInput>
    by: Array<ProfileScalarFieldEnum>
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _avg?: ProfileAvgAggregateInputType
    _sum?: ProfileSumAggregateInputType
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }


  export type ProfileGroupByOutputType = {
    id: number
    userId: string
    photo: string
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect = {
    id?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    photo?: boolean
  }

  export type ProfileInclude = {
    user?: boolean | UserArgs
  }

  export type ProfileGetPayload<
    S extends boolean | null | undefined | ProfileArgs,
    U = keyof S
      > = S extends true
        ? Profile
    : S extends undefined
    ? never
    : S extends ProfileArgs | ProfileFindManyArgs
    ?'include' extends U
    ? Profile  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Profile ? Profile[P] : never
  } 
    : Profile
  : Profile


  type ProfileCountArgs = Merge<
    Omit<ProfileFindManyArgs, 'select' | 'include'> & {
      select?: ProfileCountAggregateInputType | true
    }
  >

  export interface ProfileDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProfileFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProfileFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Profile'> extends True ? CheckSelect<T, Prisma__ProfileClient<Profile>, Prisma__ProfileClient<ProfileGetPayload<T>>> : CheckSelect<T, Prisma__ProfileClient<Profile | null >, Prisma__ProfileClient<ProfileGetPayload<T> | null >>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProfileFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProfileFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Profile'> extends True ? CheckSelect<T, Prisma__ProfileClient<Profile>, Prisma__ProfileClient<ProfileGetPayload<T>>> : CheckSelect<T, Prisma__ProfileClient<Profile | null >, Prisma__ProfileClient<ProfileGetPayload<T> | null >>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProfileFindManyArgs>(
      args?: SelectSubset<T, ProfileFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Profile>>, PrismaPromise<Array<ProfileGetPayload<T>>>>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
    **/
    create<T extends ProfileCreateArgs>(
      args: SelectSubset<T, ProfileCreateArgs>
    ): CheckSelect<T, Prisma__ProfileClient<Profile>, Prisma__ProfileClient<ProfileGetPayload<T>>>

    /**
     * Create many Profiles.
     *     @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     *     @example
     *     // Create many Profiles
     *     const profile = await prisma.profile.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProfileCreateManyArgs>(
      args?: SelectSubset<T, ProfileCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
    **/
    delete<T extends ProfileDeleteArgs>(
      args: SelectSubset<T, ProfileDeleteArgs>
    ): CheckSelect<T, Prisma__ProfileClient<Profile>, Prisma__ProfileClient<ProfileGetPayload<T>>>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProfileUpdateArgs>(
      args: SelectSubset<T, ProfileUpdateArgs>
    ): CheckSelect<T, Prisma__ProfileClient<Profile>, Prisma__ProfileClient<ProfileGetPayload<T>>>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProfileDeleteManyArgs>(
      args?: SelectSubset<T, ProfileDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProfileUpdateManyArgs>(
      args: SelectSubset<T, ProfileUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
    **/
    upsert<T extends ProfileUpsertArgs>(
      args: SelectSubset<T, ProfileUpsertArgs>
    ): CheckSelect<T, Prisma__ProfileClient<Profile>, Prisma__ProfileClient<ProfileGetPayload<T>>>

    /**
     * Find one Profile that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProfileFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ProfileClient<Profile>, Prisma__ProfileClient<ProfileGetPayload<T>>>

    /**
     * Find the first Profile that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProfileFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ProfileClient<Profile>, Prisma__ProfileClient<ProfileGetPayload<T>>>

    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProfileClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Profile base type for findUnique actions
   */
  export type ProfileFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * Filter, which Profile to fetch.
     * 
    **/
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile: findUnique
   */
  export interface ProfileFindUniqueArgs extends ProfileFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Profile base type for findFirst actions
   */
  export type ProfileFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * Filter, which Profile to fetch.
     * 
    **/
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     * 
    **/
    orderBy?: Enumerable<ProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     * 
    **/
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     * 
    **/
    distinct?: Enumerable<ProfileScalarFieldEnum>
  }

  /**
   * Profile: findFirst
   */
  export interface ProfileFindFirstArgs extends ProfileFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * Filter, which Profiles to fetch.
     * 
    **/
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     * 
    **/
    orderBy?: Enumerable<ProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     * 
    **/
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProfileScalarFieldEnum>
  }


  /**
   * Profile create
   */
  export type ProfileCreateArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * The data needed to create a Profile.
     * 
    **/
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }


  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs = {
    /**
     * The data used to create many Profiles.
     * 
    **/
    data: Enumerable<ProfileCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Profile update
   */
  export type ProfileUpdateArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * The data needed to update a Profile.
     * 
    **/
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     * 
    **/
    where: ProfileWhereUniqueInput
  }


  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs = {
    /**
     * The data used to update Profiles.
     * 
    **/
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     * 
    **/
    where?: ProfileWhereInput
  }


  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * The filter to search for the Profile to update in case it exists.
     * 
    **/
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     * 
    **/
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }


  /**
   * Profile delete
   */
  export type ProfileDeleteArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * Filter which Profile to delete.
     * 
    **/
    where: ProfileWhereUniqueInput
  }


  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs = {
    /**
     * Filter which Profiles to delete
     * 
    **/
    where?: ProfileWhereInput
  }


  /**
   * Profile: findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs = ProfileFindUniqueArgsBase
      

  /**
   * Profile: findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs = ProfileFindFirstArgsBase
      

  /**
   * Profile without action
   */
  export type ProfileArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
  }



  /**
   * Model RecipeBook
   */


  export type AggregateRecipeBook = {
    _count: RecipeBookCountAggregateOutputType | null
    _avg: RecipeBookAvgAggregateOutputType | null
    _sum: RecipeBookSumAggregateOutputType | null
    _min: RecipeBookMinAggregateOutputType | null
    _max: RecipeBookMaxAggregateOutputType | null
  }

  export type RecipeBookAvgAggregateOutputType = {
    id: number | null
  }

  export type RecipeBookSumAggregateOutputType = {
    id: number | null
  }

  export type RecipeBookMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
  }

  export type RecipeBookMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
  }

  export type RecipeBookCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    editedAt: number
    createdById: number
    editedById: number
    _all: number
  }


  export type RecipeBookAvgAggregateInputType = {
    id?: true
  }

  export type RecipeBookSumAggregateInputType = {
    id?: true
  }

  export type RecipeBookMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
  }

  export type RecipeBookMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
  }

  export type RecipeBookCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
    _all?: true
  }

  export type RecipeBookAggregateArgs = {
    /**
     * Filter which RecipeBook to aggregate.
     * 
    **/
    where?: RecipeBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBooks to fetch.
     * 
    **/
    orderBy?: Enumerable<RecipeBookOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RecipeBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBooks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBooks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecipeBooks
    **/
    _count?: true | RecipeBookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecipeBookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecipeBookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeBookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeBookMaxAggregateInputType
  }

  export type GetRecipeBookAggregateType<T extends RecipeBookAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipeBook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipeBook[P]>
      : GetScalarType<T[P], AggregateRecipeBook[P]>
  }




  export type RecipeBookGroupByArgs = {
    where?: RecipeBookWhereInput
    orderBy?: Enumerable<RecipeBookOrderByWithAggregationInput>
    by: Array<RecipeBookScalarFieldEnum>
    having?: RecipeBookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeBookCountAggregateInputType | true
    _avg?: RecipeBookAvgAggregateInputType
    _sum?: RecipeBookSumAggregateInputType
    _min?: RecipeBookMinAggregateInputType
    _max?: RecipeBookMaxAggregateInputType
  }


  export type RecipeBookGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    editedAt: Date
    createdById: string | null
    editedById: string | null
    _count: RecipeBookCountAggregateOutputType | null
    _avg: RecipeBookAvgAggregateOutputType | null
    _sum: RecipeBookSumAggregateOutputType | null
    _min: RecipeBookMinAggregateOutputType | null
    _max: RecipeBookMaxAggregateOutputType | null
  }

  type GetRecipeBookGroupByPayload<T extends RecipeBookGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RecipeBookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeBookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeBookGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeBookGroupByOutputType[P]>
        }
      >
    >


  export type RecipeBookSelect = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    editedAt?: boolean
    createdById?: boolean
    editedById?: boolean
    createdBy?: boolean | UserArgs
    editedBy?: boolean | UserArgs
    recipeBookBuild?: boolean | RecipeBookBuildFindManyArgs
    recipeBookUser?: boolean | RecipeBookUserFindManyArgs
    _count?: boolean | RecipeBookCountOutputTypeArgs
  }

  export type RecipeBookInclude = {
    createdBy?: boolean | UserArgs
    editedBy?: boolean | UserArgs
    recipeBookBuild?: boolean | RecipeBookBuildFindManyArgs
    recipeBookUser?: boolean | RecipeBookUserFindManyArgs
    _count?: boolean | RecipeBookCountOutputTypeArgs
  }

  export type RecipeBookGetPayload<
    S extends boolean | null | undefined | RecipeBookArgs,
    U = keyof S
      > = S extends true
        ? RecipeBook
    : S extends undefined
    ? never
    : S extends RecipeBookArgs | RecipeBookFindManyArgs
    ?'include' extends U
    ? RecipeBook  & {
    [P in TrueKeys<S['include']>]:
        P extends 'createdBy' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'editedBy' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'recipeBookBuild' ? Array < RecipeBookBuildGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'recipeBookUser' ? Array < RecipeBookUserGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? RecipeBookCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'createdBy' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'editedBy' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'recipeBookBuild' ? Array < RecipeBookBuildGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'recipeBookUser' ? Array < RecipeBookUserGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? RecipeBookCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof RecipeBook ? RecipeBook[P] : never
  } 
    : RecipeBook
  : RecipeBook


  type RecipeBookCountArgs = Merge<
    Omit<RecipeBookFindManyArgs, 'select' | 'include'> & {
      select?: RecipeBookCountAggregateInputType | true
    }
  >

  export interface RecipeBookDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one RecipeBook that matches the filter.
     * @param {RecipeBookFindUniqueArgs} args - Arguments to find a RecipeBook
     * @example
     * // Get one RecipeBook
     * const recipeBook = await prisma.recipeBook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RecipeBookFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RecipeBookFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RecipeBook'> extends True ? CheckSelect<T, Prisma__RecipeBookClient<RecipeBook>, Prisma__RecipeBookClient<RecipeBookGetPayload<T>>> : CheckSelect<T, Prisma__RecipeBookClient<RecipeBook | null >, Prisma__RecipeBookClient<RecipeBookGetPayload<T> | null >>

    /**
     * Find the first RecipeBook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookFindFirstArgs} args - Arguments to find a RecipeBook
     * @example
     * // Get one RecipeBook
     * const recipeBook = await prisma.recipeBook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RecipeBookFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RecipeBookFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RecipeBook'> extends True ? CheckSelect<T, Prisma__RecipeBookClient<RecipeBook>, Prisma__RecipeBookClient<RecipeBookGetPayload<T>>> : CheckSelect<T, Prisma__RecipeBookClient<RecipeBook | null >, Prisma__RecipeBookClient<RecipeBookGetPayload<T> | null >>

    /**
     * Find zero or more RecipeBooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecipeBooks
     * const recipeBooks = await prisma.recipeBook.findMany()
     * 
     * // Get first 10 RecipeBooks
     * const recipeBooks = await prisma.recipeBook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeBookWithIdOnly = await prisma.recipeBook.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RecipeBookFindManyArgs>(
      args?: SelectSubset<T, RecipeBookFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RecipeBook>>, PrismaPromise<Array<RecipeBookGetPayload<T>>>>

    /**
     * Create a RecipeBook.
     * @param {RecipeBookCreateArgs} args - Arguments to create a RecipeBook.
     * @example
     * // Create one RecipeBook
     * const RecipeBook = await prisma.recipeBook.create({
     *   data: {
     *     // ... data to create a RecipeBook
     *   }
     * })
     * 
    **/
    create<T extends RecipeBookCreateArgs>(
      args: SelectSubset<T, RecipeBookCreateArgs>
    ): CheckSelect<T, Prisma__RecipeBookClient<RecipeBook>, Prisma__RecipeBookClient<RecipeBookGetPayload<T>>>

    /**
     * Create many RecipeBooks.
     *     @param {RecipeBookCreateManyArgs} args - Arguments to create many RecipeBooks.
     *     @example
     *     // Create many RecipeBooks
     *     const recipeBook = await prisma.recipeBook.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RecipeBookCreateManyArgs>(
      args?: SelectSubset<T, RecipeBookCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RecipeBook.
     * @param {RecipeBookDeleteArgs} args - Arguments to delete one RecipeBook.
     * @example
     * // Delete one RecipeBook
     * const RecipeBook = await prisma.recipeBook.delete({
     *   where: {
     *     // ... filter to delete one RecipeBook
     *   }
     * })
     * 
    **/
    delete<T extends RecipeBookDeleteArgs>(
      args: SelectSubset<T, RecipeBookDeleteArgs>
    ): CheckSelect<T, Prisma__RecipeBookClient<RecipeBook>, Prisma__RecipeBookClient<RecipeBookGetPayload<T>>>

    /**
     * Update one RecipeBook.
     * @param {RecipeBookUpdateArgs} args - Arguments to update one RecipeBook.
     * @example
     * // Update one RecipeBook
     * const recipeBook = await prisma.recipeBook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RecipeBookUpdateArgs>(
      args: SelectSubset<T, RecipeBookUpdateArgs>
    ): CheckSelect<T, Prisma__RecipeBookClient<RecipeBook>, Prisma__RecipeBookClient<RecipeBookGetPayload<T>>>

    /**
     * Delete zero or more RecipeBooks.
     * @param {RecipeBookDeleteManyArgs} args - Arguments to filter RecipeBooks to delete.
     * @example
     * // Delete a few RecipeBooks
     * const { count } = await prisma.recipeBook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RecipeBookDeleteManyArgs>(
      args?: SelectSubset<T, RecipeBookDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecipeBooks
     * const recipeBook = await prisma.recipeBook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RecipeBookUpdateManyArgs>(
      args: SelectSubset<T, RecipeBookUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RecipeBook.
     * @param {RecipeBookUpsertArgs} args - Arguments to update or create a RecipeBook.
     * @example
     * // Update or create a RecipeBook
     * const recipeBook = await prisma.recipeBook.upsert({
     *   create: {
     *     // ... data to create a RecipeBook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecipeBook we want to update
     *   }
     * })
    **/
    upsert<T extends RecipeBookUpsertArgs>(
      args: SelectSubset<T, RecipeBookUpsertArgs>
    ): CheckSelect<T, Prisma__RecipeBookClient<RecipeBook>, Prisma__RecipeBookClient<RecipeBookGetPayload<T>>>

    /**
     * Find one RecipeBook that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {RecipeBookFindUniqueOrThrowArgs} args - Arguments to find a RecipeBook
     * @example
     * // Get one RecipeBook
     * const recipeBook = await prisma.recipeBook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RecipeBookFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RecipeBookFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__RecipeBookClient<RecipeBook>, Prisma__RecipeBookClient<RecipeBookGetPayload<T>>>

    /**
     * Find the first RecipeBook that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookFindFirstOrThrowArgs} args - Arguments to find a RecipeBook
     * @example
     * // Get one RecipeBook
     * const recipeBook = await prisma.recipeBook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RecipeBookFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RecipeBookFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__RecipeBookClient<RecipeBook>, Prisma__RecipeBookClient<RecipeBookGetPayload<T>>>

    /**
     * Count the number of RecipeBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookCountArgs} args - Arguments to filter RecipeBooks to count.
     * @example
     * // Count the number of RecipeBooks
     * const count = await prisma.recipeBook.count({
     *   where: {
     *     // ... the filter for the RecipeBooks we want to count
     *   }
     * })
    **/
    count<T extends RecipeBookCountArgs>(
      args?: Subset<T, RecipeBookCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeBookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecipeBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeBookAggregateArgs>(args: Subset<T, RecipeBookAggregateArgs>): PrismaPromise<GetRecipeBookAggregateType<T>>

    /**
     * Group by RecipeBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeBookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeBookGroupByArgs['orderBy'] }
        : { orderBy?: RecipeBookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeBookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeBookGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RecipeBook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RecipeBookClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    createdBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    editedBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    recipeBookBuild<T extends RecipeBookBuildFindManyArgs = {}>(args?: Subset<T, RecipeBookBuildFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RecipeBookBuild>>, PrismaPromise<Array<RecipeBookBuildGetPayload<T>>>>;

    recipeBookUser<T extends RecipeBookUserFindManyArgs = {}>(args?: Subset<T, RecipeBookUserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RecipeBookUser>>, PrismaPromise<Array<RecipeBookUserGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RecipeBook base type for findUnique actions
   */
  export type RecipeBookFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RecipeBook
     * 
    **/
    select?: RecipeBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookInclude | null
    /**
     * Filter, which RecipeBook to fetch.
     * 
    **/
    where: RecipeBookWhereUniqueInput
  }

  /**
   * RecipeBook: findUnique
   */
  export interface RecipeBookFindUniqueArgs extends RecipeBookFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RecipeBook base type for findFirst actions
   */
  export type RecipeBookFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RecipeBook
     * 
    **/
    select?: RecipeBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookInclude | null
    /**
     * Filter, which RecipeBook to fetch.
     * 
    **/
    where?: RecipeBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBooks to fetch.
     * 
    **/
    orderBy?: Enumerable<RecipeBookOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeBooks.
     * 
    **/
    cursor?: RecipeBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBooks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBooks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeBooks.
     * 
    **/
    distinct?: Enumerable<RecipeBookScalarFieldEnum>
  }

  /**
   * RecipeBook: findFirst
   */
  export interface RecipeBookFindFirstArgs extends RecipeBookFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RecipeBook findMany
   */
  export type RecipeBookFindManyArgs = {
    /**
     * Select specific fields to fetch from the RecipeBook
     * 
    **/
    select?: RecipeBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookInclude | null
    /**
     * Filter, which RecipeBooks to fetch.
     * 
    **/
    where?: RecipeBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBooks to fetch.
     * 
    **/
    orderBy?: Enumerable<RecipeBookOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecipeBooks.
     * 
    **/
    cursor?: RecipeBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBooks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBooks.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RecipeBookScalarFieldEnum>
  }


  /**
   * RecipeBook create
   */
  export type RecipeBookCreateArgs = {
    /**
     * Select specific fields to fetch from the RecipeBook
     * 
    **/
    select?: RecipeBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookInclude | null
    /**
     * The data needed to create a RecipeBook.
     * 
    **/
    data: XOR<RecipeBookCreateInput, RecipeBookUncheckedCreateInput>
  }


  /**
   * RecipeBook createMany
   */
  export type RecipeBookCreateManyArgs = {
    /**
     * The data used to create many RecipeBooks.
     * 
    **/
    data: Enumerable<RecipeBookCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RecipeBook update
   */
  export type RecipeBookUpdateArgs = {
    /**
     * Select specific fields to fetch from the RecipeBook
     * 
    **/
    select?: RecipeBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookInclude | null
    /**
     * The data needed to update a RecipeBook.
     * 
    **/
    data: XOR<RecipeBookUpdateInput, RecipeBookUncheckedUpdateInput>
    /**
     * Choose, which RecipeBook to update.
     * 
    **/
    where: RecipeBookWhereUniqueInput
  }


  /**
   * RecipeBook updateMany
   */
  export type RecipeBookUpdateManyArgs = {
    /**
     * The data used to update RecipeBooks.
     * 
    **/
    data: XOR<RecipeBookUpdateManyMutationInput, RecipeBookUncheckedUpdateManyInput>
    /**
     * Filter which RecipeBooks to update
     * 
    **/
    where?: RecipeBookWhereInput
  }


  /**
   * RecipeBook upsert
   */
  export type RecipeBookUpsertArgs = {
    /**
     * Select specific fields to fetch from the RecipeBook
     * 
    **/
    select?: RecipeBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookInclude | null
    /**
     * The filter to search for the RecipeBook to update in case it exists.
     * 
    **/
    where: RecipeBookWhereUniqueInput
    /**
     * In case the RecipeBook found by the `where` argument doesn't exist, create a new RecipeBook with this data.
     * 
    **/
    create: XOR<RecipeBookCreateInput, RecipeBookUncheckedCreateInput>
    /**
     * In case the RecipeBook was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RecipeBookUpdateInput, RecipeBookUncheckedUpdateInput>
  }


  /**
   * RecipeBook delete
   */
  export type RecipeBookDeleteArgs = {
    /**
     * Select specific fields to fetch from the RecipeBook
     * 
    **/
    select?: RecipeBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookInclude | null
    /**
     * Filter which RecipeBook to delete.
     * 
    **/
    where: RecipeBookWhereUniqueInput
  }


  /**
   * RecipeBook deleteMany
   */
  export type RecipeBookDeleteManyArgs = {
    /**
     * Filter which RecipeBooks to delete
     * 
    **/
    where?: RecipeBookWhereInput
  }


  /**
   * RecipeBook: findUniqueOrThrow
   */
  export type RecipeBookFindUniqueOrThrowArgs = RecipeBookFindUniqueArgsBase
      

  /**
   * RecipeBook: findFirstOrThrow
   */
  export type RecipeBookFindFirstOrThrowArgs = RecipeBookFindFirstArgsBase
      

  /**
   * RecipeBook without action
   */
  export type RecipeBookArgs = {
    /**
     * Select specific fields to fetch from the RecipeBook
     * 
    **/
    select?: RecipeBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookInclude | null
  }



  /**
   * Model RecipeBookUser
   */


  export type AggregateRecipeBookUser = {
    _count: RecipeBookUserCountAggregateOutputType | null
    _avg: RecipeBookUserAvgAggregateOutputType | null
    _sum: RecipeBookUserSumAggregateOutputType | null
    _min: RecipeBookUserMinAggregateOutputType | null
    _max: RecipeBookUserMaxAggregateOutputType | null
  }

  export type RecipeBookUserAvgAggregateOutputType = {
    id: number | null
    recipeBookId: number | null
  }

  export type RecipeBookUserSumAggregateOutputType = {
    id: number | null
    recipeBookId: number | null
  }

  export type RecipeBookUserMinAggregateOutputType = {
    id: number | null
    userId: string | null
    recipeBookId: number | null
    partner: boolean | null
    manager: boolean | null
  }

  export type RecipeBookUserMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    recipeBookId: number | null
    partner: boolean | null
    manager: boolean | null
  }

  export type RecipeBookUserCountAggregateOutputType = {
    id: number
    userId: number
    recipeBookId: number
    partner: number
    manager: number
    _all: number
  }


  export type RecipeBookUserAvgAggregateInputType = {
    id?: true
    recipeBookId?: true
  }

  export type RecipeBookUserSumAggregateInputType = {
    id?: true
    recipeBookId?: true
  }

  export type RecipeBookUserMinAggregateInputType = {
    id?: true
    userId?: true
    recipeBookId?: true
    partner?: true
    manager?: true
  }

  export type RecipeBookUserMaxAggregateInputType = {
    id?: true
    userId?: true
    recipeBookId?: true
    partner?: true
    manager?: true
  }

  export type RecipeBookUserCountAggregateInputType = {
    id?: true
    userId?: true
    recipeBookId?: true
    partner?: true
    manager?: true
    _all?: true
  }

  export type RecipeBookUserAggregateArgs = {
    /**
     * Filter which RecipeBookUser to aggregate.
     * 
    **/
    where?: RecipeBookUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBookUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<RecipeBookUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RecipeBookUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBookUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBookUsers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecipeBookUsers
    **/
    _count?: true | RecipeBookUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecipeBookUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecipeBookUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeBookUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeBookUserMaxAggregateInputType
  }

  export type GetRecipeBookUserAggregateType<T extends RecipeBookUserAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipeBookUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipeBookUser[P]>
      : GetScalarType<T[P], AggregateRecipeBookUser[P]>
  }




  export type RecipeBookUserGroupByArgs = {
    where?: RecipeBookUserWhereInput
    orderBy?: Enumerable<RecipeBookUserOrderByWithAggregationInput>
    by: Array<RecipeBookUserScalarFieldEnum>
    having?: RecipeBookUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeBookUserCountAggregateInputType | true
    _avg?: RecipeBookUserAvgAggregateInputType
    _sum?: RecipeBookUserSumAggregateInputType
    _min?: RecipeBookUserMinAggregateInputType
    _max?: RecipeBookUserMaxAggregateInputType
  }


  export type RecipeBookUserGroupByOutputType = {
    id: number
    userId: string
    recipeBookId: number
    partner: boolean
    manager: boolean
    _count: RecipeBookUserCountAggregateOutputType | null
    _avg: RecipeBookUserAvgAggregateOutputType | null
    _sum: RecipeBookUserSumAggregateOutputType | null
    _min: RecipeBookUserMinAggregateOutputType | null
    _max: RecipeBookUserMaxAggregateOutputType | null
  }

  type GetRecipeBookUserGroupByPayload<T extends RecipeBookUserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RecipeBookUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeBookUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeBookUserGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeBookUserGroupByOutputType[P]>
        }
      >
    >


  export type RecipeBookUserSelect = {
    id?: boolean
    userId?: boolean
    recipeBookId?: boolean
    recipeBook?: boolean | RecipeBookArgs
    user?: boolean | UserArgs
    partner?: boolean
    manager?: boolean
  }

  export type RecipeBookUserInclude = {
    recipeBook?: boolean | RecipeBookArgs
    user?: boolean | UserArgs
  }

  export type RecipeBookUserGetPayload<
    S extends boolean | null | undefined | RecipeBookUserArgs,
    U = keyof S
      > = S extends true
        ? RecipeBookUser
    : S extends undefined
    ? never
    : S extends RecipeBookUserArgs | RecipeBookUserFindManyArgs
    ?'include' extends U
    ? RecipeBookUser  & {
    [P in TrueKeys<S['include']>]:
        P extends 'recipeBook' ? RecipeBookGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'recipeBook' ? RecipeBookGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof RecipeBookUser ? RecipeBookUser[P] : never
  } 
    : RecipeBookUser
  : RecipeBookUser


  type RecipeBookUserCountArgs = Merge<
    Omit<RecipeBookUserFindManyArgs, 'select' | 'include'> & {
      select?: RecipeBookUserCountAggregateInputType | true
    }
  >

  export interface RecipeBookUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one RecipeBookUser that matches the filter.
     * @param {RecipeBookUserFindUniqueArgs} args - Arguments to find a RecipeBookUser
     * @example
     * // Get one RecipeBookUser
     * const recipeBookUser = await prisma.recipeBookUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RecipeBookUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RecipeBookUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RecipeBookUser'> extends True ? CheckSelect<T, Prisma__RecipeBookUserClient<RecipeBookUser>, Prisma__RecipeBookUserClient<RecipeBookUserGetPayload<T>>> : CheckSelect<T, Prisma__RecipeBookUserClient<RecipeBookUser | null >, Prisma__RecipeBookUserClient<RecipeBookUserGetPayload<T> | null >>

    /**
     * Find the first RecipeBookUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookUserFindFirstArgs} args - Arguments to find a RecipeBookUser
     * @example
     * // Get one RecipeBookUser
     * const recipeBookUser = await prisma.recipeBookUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RecipeBookUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RecipeBookUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RecipeBookUser'> extends True ? CheckSelect<T, Prisma__RecipeBookUserClient<RecipeBookUser>, Prisma__RecipeBookUserClient<RecipeBookUserGetPayload<T>>> : CheckSelect<T, Prisma__RecipeBookUserClient<RecipeBookUser | null >, Prisma__RecipeBookUserClient<RecipeBookUserGetPayload<T> | null >>

    /**
     * Find zero or more RecipeBookUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecipeBookUsers
     * const recipeBookUsers = await prisma.recipeBookUser.findMany()
     * 
     * // Get first 10 RecipeBookUsers
     * const recipeBookUsers = await prisma.recipeBookUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeBookUserWithIdOnly = await prisma.recipeBookUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RecipeBookUserFindManyArgs>(
      args?: SelectSubset<T, RecipeBookUserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RecipeBookUser>>, PrismaPromise<Array<RecipeBookUserGetPayload<T>>>>

    /**
     * Create a RecipeBookUser.
     * @param {RecipeBookUserCreateArgs} args - Arguments to create a RecipeBookUser.
     * @example
     * // Create one RecipeBookUser
     * const RecipeBookUser = await prisma.recipeBookUser.create({
     *   data: {
     *     // ... data to create a RecipeBookUser
     *   }
     * })
     * 
    **/
    create<T extends RecipeBookUserCreateArgs>(
      args: SelectSubset<T, RecipeBookUserCreateArgs>
    ): CheckSelect<T, Prisma__RecipeBookUserClient<RecipeBookUser>, Prisma__RecipeBookUserClient<RecipeBookUserGetPayload<T>>>

    /**
     * Create many RecipeBookUsers.
     *     @param {RecipeBookUserCreateManyArgs} args - Arguments to create many RecipeBookUsers.
     *     @example
     *     // Create many RecipeBookUsers
     *     const recipeBookUser = await prisma.recipeBookUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RecipeBookUserCreateManyArgs>(
      args?: SelectSubset<T, RecipeBookUserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RecipeBookUser.
     * @param {RecipeBookUserDeleteArgs} args - Arguments to delete one RecipeBookUser.
     * @example
     * // Delete one RecipeBookUser
     * const RecipeBookUser = await prisma.recipeBookUser.delete({
     *   where: {
     *     // ... filter to delete one RecipeBookUser
     *   }
     * })
     * 
    **/
    delete<T extends RecipeBookUserDeleteArgs>(
      args: SelectSubset<T, RecipeBookUserDeleteArgs>
    ): CheckSelect<T, Prisma__RecipeBookUserClient<RecipeBookUser>, Prisma__RecipeBookUserClient<RecipeBookUserGetPayload<T>>>

    /**
     * Update one RecipeBookUser.
     * @param {RecipeBookUserUpdateArgs} args - Arguments to update one RecipeBookUser.
     * @example
     * // Update one RecipeBookUser
     * const recipeBookUser = await prisma.recipeBookUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RecipeBookUserUpdateArgs>(
      args: SelectSubset<T, RecipeBookUserUpdateArgs>
    ): CheckSelect<T, Prisma__RecipeBookUserClient<RecipeBookUser>, Prisma__RecipeBookUserClient<RecipeBookUserGetPayload<T>>>

    /**
     * Delete zero or more RecipeBookUsers.
     * @param {RecipeBookUserDeleteManyArgs} args - Arguments to filter RecipeBookUsers to delete.
     * @example
     * // Delete a few RecipeBookUsers
     * const { count } = await prisma.recipeBookUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RecipeBookUserDeleteManyArgs>(
      args?: SelectSubset<T, RecipeBookUserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeBookUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecipeBookUsers
     * const recipeBookUser = await prisma.recipeBookUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RecipeBookUserUpdateManyArgs>(
      args: SelectSubset<T, RecipeBookUserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RecipeBookUser.
     * @param {RecipeBookUserUpsertArgs} args - Arguments to update or create a RecipeBookUser.
     * @example
     * // Update or create a RecipeBookUser
     * const recipeBookUser = await prisma.recipeBookUser.upsert({
     *   create: {
     *     // ... data to create a RecipeBookUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecipeBookUser we want to update
     *   }
     * })
    **/
    upsert<T extends RecipeBookUserUpsertArgs>(
      args: SelectSubset<T, RecipeBookUserUpsertArgs>
    ): CheckSelect<T, Prisma__RecipeBookUserClient<RecipeBookUser>, Prisma__RecipeBookUserClient<RecipeBookUserGetPayload<T>>>

    /**
     * Find one RecipeBookUser that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {RecipeBookUserFindUniqueOrThrowArgs} args - Arguments to find a RecipeBookUser
     * @example
     * // Get one RecipeBookUser
     * const recipeBookUser = await prisma.recipeBookUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RecipeBookUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RecipeBookUserFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__RecipeBookUserClient<RecipeBookUser>, Prisma__RecipeBookUserClient<RecipeBookUserGetPayload<T>>>

    /**
     * Find the first RecipeBookUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookUserFindFirstOrThrowArgs} args - Arguments to find a RecipeBookUser
     * @example
     * // Get one RecipeBookUser
     * const recipeBookUser = await prisma.recipeBookUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RecipeBookUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RecipeBookUserFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__RecipeBookUserClient<RecipeBookUser>, Prisma__RecipeBookUserClient<RecipeBookUserGetPayload<T>>>

    /**
     * Count the number of RecipeBookUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookUserCountArgs} args - Arguments to filter RecipeBookUsers to count.
     * @example
     * // Count the number of RecipeBookUsers
     * const count = await prisma.recipeBookUser.count({
     *   where: {
     *     // ... the filter for the RecipeBookUsers we want to count
     *   }
     * })
    **/
    count<T extends RecipeBookUserCountArgs>(
      args?: Subset<T, RecipeBookUserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeBookUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecipeBookUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeBookUserAggregateArgs>(args: Subset<T, RecipeBookUserAggregateArgs>): PrismaPromise<GetRecipeBookUserAggregateType<T>>

    /**
     * Group by RecipeBookUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeBookUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeBookUserGroupByArgs['orderBy'] }
        : { orderBy?: RecipeBookUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeBookUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeBookUserGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RecipeBookUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RecipeBookUserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    recipeBook<T extends RecipeBookArgs = {}>(args?: Subset<T, RecipeBookArgs>): CheckSelect<T, Prisma__RecipeBookClient<RecipeBook | null >, Prisma__RecipeBookClient<RecipeBookGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RecipeBookUser base type for findUnique actions
   */
  export type RecipeBookUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     * 
    **/
    select?: RecipeBookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookUserInclude | null
    /**
     * Filter, which RecipeBookUser to fetch.
     * 
    **/
    where: RecipeBookUserWhereUniqueInput
  }

  /**
   * RecipeBookUser: findUnique
   */
  export interface RecipeBookUserFindUniqueArgs extends RecipeBookUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RecipeBookUser base type for findFirst actions
   */
  export type RecipeBookUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     * 
    **/
    select?: RecipeBookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookUserInclude | null
    /**
     * Filter, which RecipeBookUser to fetch.
     * 
    **/
    where?: RecipeBookUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBookUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<RecipeBookUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeBookUsers.
     * 
    **/
    cursor?: RecipeBookUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBookUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBookUsers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeBookUsers.
     * 
    **/
    distinct?: Enumerable<RecipeBookUserScalarFieldEnum>
  }

  /**
   * RecipeBookUser: findFirst
   */
  export interface RecipeBookUserFindFirstArgs extends RecipeBookUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RecipeBookUser findMany
   */
  export type RecipeBookUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     * 
    **/
    select?: RecipeBookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookUserInclude | null
    /**
     * Filter, which RecipeBookUsers to fetch.
     * 
    **/
    where?: RecipeBookUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBookUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<RecipeBookUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecipeBookUsers.
     * 
    **/
    cursor?: RecipeBookUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBookUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBookUsers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RecipeBookUserScalarFieldEnum>
  }


  /**
   * RecipeBookUser create
   */
  export type RecipeBookUserCreateArgs = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     * 
    **/
    select?: RecipeBookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookUserInclude | null
    /**
     * The data needed to create a RecipeBookUser.
     * 
    **/
    data: XOR<RecipeBookUserCreateInput, RecipeBookUserUncheckedCreateInput>
  }


  /**
   * RecipeBookUser createMany
   */
  export type RecipeBookUserCreateManyArgs = {
    /**
     * The data used to create many RecipeBookUsers.
     * 
    **/
    data: Enumerable<RecipeBookUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RecipeBookUser update
   */
  export type RecipeBookUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     * 
    **/
    select?: RecipeBookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookUserInclude | null
    /**
     * The data needed to update a RecipeBookUser.
     * 
    **/
    data: XOR<RecipeBookUserUpdateInput, RecipeBookUserUncheckedUpdateInput>
    /**
     * Choose, which RecipeBookUser to update.
     * 
    **/
    where: RecipeBookUserWhereUniqueInput
  }


  /**
   * RecipeBookUser updateMany
   */
  export type RecipeBookUserUpdateManyArgs = {
    /**
     * The data used to update RecipeBookUsers.
     * 
    **/
    data: XOR<RecipeBookUserUpdateManyMutationInput, RecipeBookUserUncheckedUpdateManyInput>
    /**
     * Filter which RecipeBookUsers to update
     * 
    **/
    where?: RecipeBookUserWhereInput
  }


  /**
   * RecipeBookUser upsert
   */
  export type RecipeBookUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     * 
    **/
    select?: RecipeBookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookUserInclude | null
    /**
     * The filter to search for the RecipeBookUser to update in case it exists.
     * 
    **/
    where: RecipeBookUserWhereUniqueInput
    /**
     * In case the RecipeBookUser found by the `where` argument doesn't exist, create a new RecipeBookUser with this data.
     * 
    **/
    create: XOR<RecipeBookUserCreateInput, RecipeBookUserUncheckedCreateInput>
    /**
     * In case the RecipeBookUser was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RecipeBookUserUpdateInput, RecipeBookUserUncheckedUpdateInput>
  }


  /**
   * RecipeBookUser delete
   */
  export type RecipeBookUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     * 
    **/
    select?: RecipeBookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookUserInclude | null
    /**
     * Filter which RecipeBookUser to delete.
     * 
    **/
    where: RecipeBookUserWhereUniqueInput
  }


  /**
   * RecipeBookUser deleteMany
   */
  export type RecipeBookUserDeleteManyArgs = {
    /**
     * Filter which RecipeBookUsers to delete
     * 
    **/
    where?: RecipeBookUserWhereInput
  }


  /**
   * RecipeBookUser: findUniqueOrThrow
   */
  export type RecipeBookUserFindUniqueOrThrowArgs = RecipeBookUserFindUniqueArgsBase
      

  /**
   * RecipeBookUser: findFirstOrThrow
   */
  export type RecipeBookUserFindFirstOrThrowArgs = RecipeBookUserFindFirstArgsBase
      

  /**
   * RecipeBookUser without action
   */
  export type RecipeBookUserArgs = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     * 
    **/
    select?: RecipeBookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookUserInclude | null
  }



  /**
   * Model Build
   */


  export type AggregateBuild = {
    _count: BuildCountAggregateOutputType | null
    _avg: BuildAvgAggregateOutputType | null
    _sum: BuildSumAggregateOutputType | null
    _min: BuildMinAggregateOutputType | null
    _max: BuildMaxAggregateOutputType | null
  }

  export type BuildAvgAggregateOutputType = {
    id: number | null
    recipeId: number | null
  }

  export type BuildSumAggregateOutputType = {
    id: number | null
    recipeId: number | null
  }

  export type BuildMinAggregateOutputType = {
    id: number | null
    buildName: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
    recipeId: number | null
    instructions: string | null
    notes: string | null
    glassware: string | null
    ice: string | null
  }

  export type BuildMaxAggregateOutputType = {
    id: number | null
    buildName: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
    recipeId: number | null
    instructions: string | null
    notes: string | null
    glassware: string | null
    ice: string | null
  }

  export type BuildCountAggregateOutputType = {
    id: number
    buildName: number
    createdAt: number
    editedAt: number
    createdById: number
    editedById: number
    recipeId: number
    instructions: number
    notes: number
    glassware: number
    ice: number
    _all: number
  }


  export type BuildAvgAggregateInputType = {
    id?: true
    recipeId?: true
  }

  export type BuildSumAggregateInputType = {
    id?: true
    recipeId?: true
  }

  export type BuildMinAggregateInputType = {
    id?: true
    buildName?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
    recipeId?: true
    instructions?: true
    notes?: true
    glassware?: true
    ice?: true
  }

  export type BuildMaxAggregateInputType = {
    id?: true
    buildName?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
    recipeId?: true
    instructions?: true
    notes?: true
    glassware?: true
    ice?: true
  }

  export type BuildCountAggregateInputType = {
    id?: true
    buildName?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
    recipeId?: true
    instructions?: true
    notes?: true
    glassware?: true
    ice?: true
    _all?: true
  }

  export type BuildAggregateArgs = {
    /**
     * Filter which Build to aggregate.
     * 
    **/
    where?: BuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Builds to fetch.
     * 
    **/
    orderBy?: Enumerable<BuildOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: BuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Builds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Builds.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Builds
    **/
    _count?: true | BuildCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BuildAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BuildSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuildMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuildMaxAggregateInputType
  }

  export type GetBuildAggregateType<T extends BuildAggregateArgs> = {
        [P in keyof T & keyof AggregateBuild]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuild[P]>
      : GetScalarType<T[P], AggregateBuild[P]>
  }




  export type BuildGroupByArgs = {
    where?: BuildWhereInput
    orderBy?: Enumerable<BuildOrderByWithAggregationInput>
    by: Array<BuildScalarFieldEnum>
    having?: BuildScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuildCountAggregateInputType | true
    _avg?: BuildAvgAggregateInputType
    _sum?: BuildSumAggregateInputType
    _min?: BuildMinAggregateInputType
    _max?: BuildMaxAggregateInputType
  }


  export type BuildGroupByOutputType = {
    id: number
    buildName: string
    createdAt: Date
    editedAt: Date
    createdById: string
    editedById: string
    recipeId: number | null
    instructions: string | null
    notes: string | null
    glassware: string | null
    ice: string | null
    _count: BuildCountAggregateOutputType | null
    _avg: BuildAvgAggregateOutputType | null
    _sum: BuildSumAggregateOutputType | null
    _min: BuildMinAggregateOutputType | null
    _max: BuildMaxAggregateOutputType | null
  }

  type GetBuildGroupByPayload<T extends BuildGroupByArgs> = PrismaPromise<
    Array<
      PickArray<BuildGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuildGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuildGroupByOutputType[P]>
            : GetScalarType<T[P], BuildGroupByOutputType[P]>
        }
      >
    >


  export type BuildSelect = {
    id?: boolean
    buildName?: boolean
    createdAt?: boolean
    editedAt?: boolean
    createdById?: boolean
    editedById?: boolean
    createdBy?: boolean | UserArgs
    editedBy?: boolean | UserArgs
    recipe?: boolean | RecipeArgs
    recipeId?: boolean
    instructions?: boolean
    notes?: boolean
    glassware?: boolean
    ice?: boolean
    touch?: boolean | TouchFindManyArgs
    RecipeBookBuild?: boolean | RecipeBookBuildFindManyArgs
    userBuild?: boolean | UserBuildFindManyArgs
    _count?: boolean | BuildCountOutputTypeArgs
  }

  export type BuildInclude = {
    createdBy?: boolean | UserArgs
    editedBy?: boolean | UserArgs
    recipe?: boolean | RecipeArgs
    touch?: boolean | TouchFindManyArgs
    RecipeBookBuild?: boolean | RecipeBookBuildFindManyArgs
    userBuild?: boolean | UserBuildFindManyArgs
    _count?: boolean | BuildCountOutputTypeArgs
  }

  export type BuildGetPayload<
    S extends boolean | null | undefined | BuildArgs,
    U = keyof S
      > = S extends true
        ? Build
    : S extends undefined
    ? never
    : S extends BuildArgs | BuildFindManyArgs
    ?'include' extends U
    ? Build  & {
    [P in TrueKeys<S['include']>]:
        P extends 'createdBy' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'editedBy' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'recipe' ? RecipeGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'touch' ? Array < TouchGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'RecipeBookBuild' ? Array < RecipeBookBuildGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'userBuild' ? Array < UserBuildGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? BuildCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'createdBy' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'editedBy' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'recipe' ? RecipeGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'touch' ? Array < TouchGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'RecipeBookBuild' ? Array < RecipeBookBuildGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'userBuild' ? Array < UserBuildGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? BuildCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Build ? Build[P] : never
  } 
    : Build
  : Build


  type BuildCountArgs = Merge<
    Omit<BuildFindManyArgs, 'select' | 'include'> & {
      select?: BuildCountAggregateInputType | true
    }
  >

  export interface BuildDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Build that matches the filter.
     * @param {BuildFindUniqueArgs} args - Arguments to find a Build
     * @example
     * // Get one Build
     * const build = await prisma.build.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BuildFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BuildFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Build'> extends True ? CheckSelect<T, Prisma__BuildClient<Build>, Prisma__BuildClient<BuildGetPayload<T>>> : CheckSelect<T, Prisma__BuildClient<Build | null >, Prisma__BuildClient<BuildGetPayload<T> | null >>

    /**
     * Find the first Build that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildFindFirstArgs} args - Arguments to find a Build
     * @example
     * // Get one Build
     * const build = await prisma.build.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BuildFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BuildFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Build'> extends True ? CheckSelect<T, Prisma__BuildClient<Build>, Prisma__BuildClient<BuildGetPayload<T>>> : CheckSelect<T, Prisma__BuildClient<Build | null >, Prisma__BuildClient<BuildGetPayload<T> | null >>

    /**
     * Find zero or more Builds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Builds
     * const builds = await prisma.build.findMany()
     * 
     * // Get first 10 Builds
     * const builds = await prisma.build.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buildWithIdOnly = await prisma.build.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BuildFindManyArgs>(
      args?: SelectSubset<T, BuildFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Build>>, PrismaPromise<Array<BuildGetPayload<T>>>>

    /**
     * Create a Build.
     * @param {BuildCreateArgs} args - Arguments to create a Build.
     * @example
     * // Create one Build
     * const Build = await prisma.build.create({
     *   data: {
     *     // ... data to create a Build
     *   }
     * })
     * 
    **/
    create<T extends BuildCreateArgs>(
      args: SelectSubset<T, BuildCreateArgs>
    ): CheckSelect<T, Prisma__BuildClient<Build>, Prisma__BuildClient<BuildGetPayload<T>>>

    /**
     * Create many Builds.
     *     @param {BuildCreateManyArgs} args - Arguments to create many Builds.
     *     @example
     *     // Create many Builds
     *     const build = await prisma.build.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BuildCreateManyArgs>(
      args?: SelectSubset<T, BuildCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Build.
     * @param {BuildDeleteArgs} args - Arguments to delete one Build.
     * @example
     * // Delete one Build
     * const Build = await prisma.build.delete({
     *   where: {
     *     // ... filter to delete one Build
     *   }
     * })
     * 
    **/
    delete<T extends BuildDeleteArgs>(
      args: SelectSubset<T, BuildDeleteArgs>
    ): CheckSelect<T, Prisma__BuildClient<Build>, Prisma__BuildClient<BuildGetPayload<T>>>

    /**
     * Update one Build.
     * @param {BuildUpdateArgs} args - Arguments to update one Build.
     * @example
     * // Update one Build
     * const build = await prisma.build.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BuildUpdateArgs>(
      args: SelectSubset<T, BuildUpdateArgs>
    ): CheckSelect<T, Prisma__BuildClient<Build>, Prisma__BuildClient<BuildGetPayload<T>>>

    /**
     * Delete zero or more Builds.
     * @param {BuildDeleteManyArgs} args - Arguments to filter Builds to delete.
     * @example
     * // Delete a few Builds
     * const { count } = await prisma.build.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BuildDeleteManyArgs>(
      args?: SelectSubset<T, BuildDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Builds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Builds
     * const build = await prisma.build.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BuildUpdateManyArgs>(
      args: SelectSubset<T, BuildUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Build.
     * @param {BuildUpsertArgs} args - Arguments to update or create a Build.
     * @example
     * // Update or create a Build
     * const build = await prisma.build.upsert({
     *   create: {
     *     // ... data to create a Build
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Build we want to update
     *   }
     * })
    **/
    upsert<T extends BuildUpsertArgs>(
      args: SelectSubset<T, BuildUpsertArgs>
    ): CheckSelect<T, Prisma__BuildClient<Build>, Prisma__BuildClient<BuildGetPayload<T>>>

    /**
     * Find one Build that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {BuildFindUniqueOrThrowArgs} args - Arguments to find a Build
     * @example
     * // Get one Build
     * const build = await prisma.build.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BuildFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BuildFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__BuildClient<Build>, Prisma__BuildClient<BuildGetPayload<T>>>

    /**
     * Find the first Build that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildFindFirstOrThrowArgs} args - Arguments to find a Build
     * @example
     * // Get one Build
     * const build = await prisma.build.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BuildFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BuildFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__BuildClient<Build>, Prisma__BuildClient<BuildGetPayload<T>>>

    /**
     * Count the number of Builds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildCountArgs} args - Arguments to filter Builds to count.
     * @example
     * // Count the number of Builds
     * const count = await prisma.build.count({
     *   where: {
     *     // ... the filter for the Builds we want to count
     *   }
     * })
    **/
    count<T extends BuildCountArgs>(
      args?: Subset<T, BuildCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuildCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Build.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuildAggregateArgs>(args: Subset<T, BuildAggregateArgs>): PrismaPromise<GetBuildAggregateType<T>>

    /**
     * Group by Build.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuildGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuildGroupByArgs['orderBy'] }
        : { orderBy?: BuildGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuildGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuildGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Build.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BuildClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    createdBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    editedBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    recipe<T extends RecipeArgs = {}>(args?: Subset<T, RecipeArgs>): CheckSelect<T, Prisma__RecipeClient<Recipe | null >, Prisma__RecipeClient<RecipeGetPayload<T> | null >>;

    touch<T extends TouchFindManyArgs = {}>(args?: Subset<T, TouchFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Touch>>, PrismaPromise<Array<TouchGetPayload<T>>>>;

    RecipeBookBuild<T extends RecipeBookBuildFindManyArgs = {}>(args?: Subset<T, RecipeBookBuildFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RecipeBookBuild>>, PrismaPromise<Array<RecipeBookBuildGetPayload<T>>>>;

    userBuild<T extends UserBuildFindManyArgs = {}>(args?: Subset<T, UserBuildFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserBuild>>, PrismaPromise<Array<UserBuildGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Build base type for findUnique actions
   */
  export type BuildFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Build
     * 
    **/
    select?: BuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BuildInclude | null
    /**
     * Filter, which Build to fetch.
     * 
    **/
    where: BuildWhereUniqueInput
  }

  /**
   * Build: findUnique
   */
  export interface BuildFindUniqueArgs extends BuildFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Build base type for findFirst actions
   */
  export type BuildFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Build
     * 
    **/
    select?: BuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BuildInclude | null
    /**
     * Filter, which Build to fetch.
     * 
    **/
    where?: BuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Builds to fetch.
     * 
    **/
    orderBy?: Enumerable<BuildOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Builds.
     * 
    **/
    cursor?: BuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Builds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Builds.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Builds.
     * 
    **/
    distinct?: Enumerable<BuildScalarFieldEnum>
  }

  /**
   * Build: findFirst
   */
  export interface BuildFindFirstArgs extends BuildFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Build findMany
   */
  export type BuildFindManyArgs = {
    /**
     * Select specific fields to fetch from the Build
     * 
    **/
    select?: BuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BuildInclude | null
    /**
     * Filter, which Builds to fetch.
     * 
    **/
    where?: BuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Builds to fetch.
     * 
    **/
    orderBy?: Enumerable<BuildOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Builds.
     * 
    **/
    cursor?: BuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Builds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Builds.
     * 
    **/
    skip?: number
    distinct?: Enumerable<BuildScalarFieldEnum>
  }


  /**
   * Build create
   */
  export type BuildCreateArgs = {
    /**
     * Select specific fields to fetch from the Build
     * 
    **/
    select?: BuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BuildInclude | null
    /**
     * The data needed to create a Build.
     * 
    **/
    data: XOR<BuildCreateInput, BuildUncheckedCreateInput>
  }


  /**
   * Build createMany
   */
  export type BuildCreateManyArgs = {
    /**
     * The data used to create many Builds.
     * 
    **/
    data: Enumerable<BuildCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Build update
   */
  export type BuildUpdateArgs = {
    /**
     * Select specific fields to fetch from the Build
     * 
    **/
    select?: BuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BuildInclude | null
    /**
     * The data needed to update a Build.
     * 
    **/
    data: XOR<BuildUpdateInput, BuildUncheckedUpdateInput>
    /**
     * Choose, which Build to update.
     * 
    **/
    where: BuildWhereUniqueInput
  }


  /**
   * Build updateMany
   */
  export type BuildUpdateManyArgs = {
    /**
     * The data used to update Builds.
     * 
    **/
    data: XOR<BuildUpdateManyMutationInput, BuildUncheckedUpdateManyInput>
    /**
     * Filter which Builds to update
     * 
    **/
    where?: BuildWhereInput
  }


  /**
   * Build upsert
   */
  export type BuildUpsertArgs = {
    /**
     * Select specific fields to fetch from the Build
     * 
    **/
    select?: BuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BuildInclude | null
    /**
     * The filter to search for the Build to update in case it exists.
     * 
    **/
    where: BuildWhereUniqueInput
    /**
     * In case the Build found by the `where` argument doesn't exist, create a new Build with this data.
     * 
    **/
    create: XOR<BuildCreateInput, BuildUncheckedCreateInput>
    /**
     * In case the Build was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<BuildUpdateInput, BuildUncheckedUpdateInput>
  }


  /**
   * Build delete
   */
  export type BuildDeleteArgs = {
    /**
     * Select specific fields to fetch from the Build
     * 
    **/
    select?: BuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BuildInclude | null
    /**
     * Filter which Build to delete.
     * 
    **/
    where: BuildWhereUniqueInput
  }


  /**
   * Build deleteMany
   */
  export type BuildDeleteManyArgs = {
    /**
     * Filter which Builds to delete
     * 
    **/
    where?: BuildWhereInput
  }


  /**
   * Build: findUniqueOrThrow
   */
  export type BuildFindUniqueOrThrowArgs = BuildFindUniqueArgsBase
      

  /**
   * Build: findFirstOrThrow
   */
  export type BuildFindFirstOrThrowArgs = BuildFindFirstArgsBase
      

  /**
   * Build without action
   */
  export type BuildArgs = {
    /**
     * Select specific fields to fetch from the Build
     * 
    **/
    select?: BuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BuildInclude | null
  }



  /**
   * Model UserBuild
   */


  export type AggregateUserBuild = {
    _count: UserBuildCountAggregateOutputType | null
    _avg: UserBuildAvgAggregateOutputType | null
    _sum: UserBuildSumAggregateOutputType | null
    _min: UserBuildMinAggregateOutputType | null
    _max: UserBuildMaxAggregateOutputType | null
  }

  export type UserBuildAvgAggregateOutputType = {
    id: number | null
    buildId: number | null
  }

  export type UserBuildSumAggregateOutputType = {
    id: number | null
    buildId: number | null
  }

  export type UserBuildMinAggregateOutputType = {
    id: number | null
    userId: string | null
    buildId: number | null
    partner: boolean | null
    manager: boolean | null
  }

  export type UserBuildMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    buildId: number | null
    partner: boolean | null
    manager: boolean | null
  }

  export type UserBuildCountAggregateOutputType = {
    id: number
    userId: number
    buildId: number
    partner: number
    manager: number
    _all: number
  }


  export type UserBuildAvgAggregateInputType = {
    id?: true
    buildId?: true
  }

  export type UserBuildSumAggregateInputType = {
    id?: true
    buildId?: true
  }

  export type UserBuildMinAggregateInputType = {
    id?: true
    userId?: true
    buildId?: true
    partner?: true
    manager?: true
  }

  export type UserBuildMaxAggregateInputType = {
    id?: true
    userId?: true
    buildId?: true
    partner?: true
    manager?: true
  }

  export type UserBuildCountAggregateInputType = {
    id?: true
    userId?: true
    buildId?: true
    partner?: true
    manager?: true
    _all?: true
  }

  export type UserBuildAggregateArgs = {
    /**
     * Filter which UserBuild to aggregate.
     * 
    **/
    where?: UserBuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBuilds to fetch.
     * 
    **/
    orderBy?: Enumerable<UserBuildOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserBuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBuilds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBuilds.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserBuilds
    **/
    _count?: true | UserBuildCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserBuildAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserBuildSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserBuildMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserBuildMaxAggregateInputType
  }

  export type GetUserBuildAggregateType<T extends UserBuildAggregateArgs> = {
        [P in keyof T & keyof AggregateUserBuild]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserBuild[P]>
      : GetScalarType<T[P], AggregateUserBuild[P]>
  }




  export type UserBuildGroupByArgs = {
    where?: UserBuildWhereInput
    orderBy?: Enumerable<UserBuildOrderByWithAggregationInput>
    by: Array<UserBuildScalarFieldEnum>
    having?: UserBuildScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserBuildCountAggregateInputType | true
    _avg?: UserBuildAvgAggregateInputType
    _sum?: UserBuildSumAggregateInputType
    _min?: UserBuildMinAggregateInputType
    _max?: UserBuildMaxAggregateInputType
  }


  export type UserBuildGroupByOutputType = {
    id: number
    userId: string
    buildId: number
    partner: boolean
    manager: boolean
    _count: UserBuildCountAggregateOutputType | null
    _avg: UserBuildAvgAggregateOutputType | null
    _sum: UserBuildSumAggregateOutputType | null
    _min: UserBuildMinAggregateOutputType | null
    _max: UserBuildMaxAggregateOutputType | null
  }

  type GetUserBuildGroupByPayload<T extends UserBuildGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserBuildGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserBuildGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserBuildGroupByOutputType[P]>
            : GetScalarType<T[P], UserBuildGroupByOutputType[P]>
        }
      >
    >


  export type UserBuildSelect = {
    id?: boolean
    userId?: boolean
    buildId?: boolean
    user?: boolean | UserArgs
    build?: boolean | BuildArgs
    partner?: boolean
    manager?: boolean
  }

  export type UserBuildInclude = {
    user?: boolean | UserArgs
    build?: boolean | BuildArgs
  }

  export type UserBuildGetPayload<
    S extends boolean | null | undefined | UserBuildArgs,
    U = keyof S
      > = S extends true
        ? UserBuild
    : S extends undefined
    ? never
    : S extends UserBuildArgs | UserBuildFindManyArgs
    ?'include' extends U
    ? UserBuild  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'build' ? BuildGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'build' ? BuildGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof UserBuild ? UserBuild[P] : never
  } 
    : UserBuild
  : UserBuild


  type UserBuildCountArgs = Merge<
    Omit<UserBuildFindManyArgs, 'select' | 'include'> & {
      select?: UserBuildCountAggregateInputType | true
    }
  >

  export interface UserBuildDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one UserBuild that matches the filter.
     * @param {UserBuildFindUniqueArgs} args - Arguments to find a UserBuild
     * @example
     * // Get one UserBuild
     * const userBuild = await prisma.userBuild.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserBuildFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserBuildFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserBuild'> extends True ? CheckSelect<T, Prisma__UserBuildClient<UserBuild>, Prisma__UserBuildClient<UserBuildGetPayload<T>>> : CheckSelect<T, Prisma__UserBuildClient<UserBuild | null >, Prisma__UserBuildClient<UserBuildGetPayload<T> | null >>

    /**
     * Find the first UserBuild that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBuildFindFirstArgs} args - Arguments to find a UserBuild
     * @example
     * // Get one UserBuild
     * const userBuild = await prisma.userBuild.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserBuildFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserBuildFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserBuild'> extends True ? CheckSelect<T, Prisma__UserBuildClient<UserBuild>, Prisma__UserBuildClient<UserBuildGetPayload<T>>> : CheckSelect<T, Prisma__UserBuildClient<UserBuild | null >, Prisma__UserBuildClient<UserBuildGetPayload<T> | null >>

    /**
     * Find zero or more UserBuilds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBuildFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserBuilds
     * const userBuilds = await prisma.userBuild.findMany()
     * 
     * // Get first 10 UserBuilds
     * const userBuilds = await prisma.userBuild.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userBuildWithIdOnly = await prisma.userBuild.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserBuildFindManyArgs>(
      args?: SelectSubset<T, UserBuildFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserBuild>>, PrismaPromise<Array<UserBuildGetPayload<T>>>>

    /**
     * Create a UserBuild.
     * @param {UserBuildCreateArgs} args - Arguments to create a UserBuild.
     * @example
     * // Create one UserBuild
     * const UserBuild = await prisma.userBuild.create({
     *   data: {
     *     // ... data to create a UserBuild
     *   }
     * })
     * 
    **/
    create<T extends UserBuildCreateArgs>(
      args: SelectSubset<T, UserBuildCreateArgs>
    ): CheckSelect<T, Prisma__UserBuildClient<UserBuild>, Prisma__UserBuildClient<UserBuildGetPayload<T>>>

    /**
     * Create many UserBuilds.
     *     @param {UserBuildCreateManyArgs} args - Arguments to create many UserBuilds.
     *     @example
     *     // Create many UserBuilds
     *     const userBuild = await prisma.userBuild.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserBuildCreateManyArgs>(
      args?: SelectSubset<T, UserBuildCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserBuild.
     * @param {UserBuildDeleteArgs} args - Arguments to delete one UserBuild.
     * @example
     * // Delete one UserBuild
     * const UserBuild = await prisma.userBuild.delete({
     *   where: {
     *     // ... filter to delete one UserBuild
     *   }
     * })
     * 
    **/
    delete<T extends UserBuildDeleteArgs>(
      args: SelectSubset<T, UserBuildDeleteArgs>
    ): CheckSelect<T, Prisma__UserBuildClient<UserBuild>, Prisma__UserBuildClient<UserBuildGetPayload<T>>>

    /**
     * Update one UserBuild.
     * @param {UserBuildUpdateArgs} args - Arguments to update one UserBuild.
     * @example
     * // Update one UserBuild
     * const userBuild = await prisma.userBuild.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserBuildUpdateArgs>(
      args: SelectSubset<T, UserBuildUpdateArgs>
    ): CheckSelect<T, Prisma__UserBuildClient<UserBuild>, Prisma__UserBuildClient<UserBuildGetPayload<T>>>

    /**
     * Delete zero or more UserBuilds.
     * @param {UserBuildDeleteManyArgs} args - Arguments to filter UserBuilds to delete.
     * @example
     * // Delete a few UserBuilds
     * const { count } = await prisma.userBuild.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserBuildDeleteManyArgs>(
      args?: SelectSubset<T, UserBuildDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBuilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBuildUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserBuilds
     * const userBuild = await prisma.userBuild.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserBuildUpdateManyArgs>(
      args: SelectSubset<T, UserBuildUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserBuild.
     * @param {UserBuildUpsertArgs} args - Arguments to update or create a UserBuild.
     * @example
     * // Update or create a UserBuild
     * const userBuild = await prisma.userBuild.upsert({
     *   create: {
     *     // ... data to create a UserBuild
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserBuild we want to update
     *   }
     * })
    **/
    upsert<T extends UserBuildUpsertArgs>(
      args: SelectSubset<T, UserBuildUpsertArgs>
    ): CheckSelect<T, Prisma__UserBuildClient<UserBuild>, Prisma__UserBuildClient<UserBuildGetPayload<T>>>

    /**
     * Find one UserBuild that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {UserBuildFindUniqueOrThrowArgs} args - Arguments to find a UserBuild
     * @example
     * // Get one UserBuild
     * const userBuild = await prisma.userBuild.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserBuildFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserBuildFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__UserBuildClient<UserBuild>, Prisma__UserBuildClient<UserBuildGetPayload<T>>>

    /**
     * Find the first UserBuild that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBuildFindFirstOrThrowArgs} args - Arguments to find a UserBuild
     * @example
     * // Get one UserBuild
     * const userBuild = await prisma.userBuild.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserBuildFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserBuildFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__UserBuildClient<UserBuild>, Prisma__UserBuildClient<UserBuildGetPayload<T>>>

    /**
     * Count the number of UserBuilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBuildCountArgs} args - Arguments to filter UserBuilds to count.
     * @example
     * // Count the number of UserBuilds
     * const count = await prisma.userBuild.count({
     *   where: {
     *     // ... the filter for the UserBuilds we want to count
     *   }
     * })
    **/
    count<T extends UserBuildCountArgs>(
      args?: Subset<T, UserBuildCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserBuildCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserBuild.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBuildAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserBuildAggregateArgs>(args: Subset<T, UserBuildAggregateArgs>): PrismaPromise<GetUserBuildAggregateType<T>>

    /**
     * Group by UserBuild.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBuildGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserBuildGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserBuildGroupByArgs['orderBy'] }
        : { orderBy?: UserBuildGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserBuildGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserBuildGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserBuild.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserBuildClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    build<T extends BuildArgs = {}>(args?: Subset<T, BuildArgs>): CheckSelect<T, Prisma__BuildClient<Build | null >, Prisma__BuildClient<BuildGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserBuild base type for findUnique actions
   */
  export type UserBuildFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserBuild
     * 
    **/
    select?: UserBuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserBuildInclude | null
    /**
     * Filter, which UserBuild to fetch.
     * 
    **/
    where: UserBuildWhereUniqueInput
  }

  /**
   * UserBuild: findUnique
   */
  export interface UserBuildFindUniqueArgs extends UserBuildFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserBuild base type for findFirst actions
   */
  export type UserBuildFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserBuild
     * 
    **/
    select?: UserBuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserBuildInclude | null
    /**
     * Filter, which UserBuild to fetch.
     * 
    **/
    where?: UserBuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBuilds to fetch.
     * 
    **/
    orderBy?: Enumerable<UserBuildOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBuilds.
     * 
    **/
    cursor?: UserBuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBuilds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBuilds.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBuilds.
     * 
    **/
    distinct?: Enumerable<UserBuildScalarFieldEnum>
  }

  /**
   * UserBuild: findFirst
   */
  export interface UserBuildFindFirstArgs extends UserBuildFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserBuild findMany
   */
  export type UserBuildFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserBuild
     * 
    **/
    select?: UserBuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserBuildInclude | null
    /**
     * Filter, which UserBuilds to fetch.
     * 
    **/
    where?: UserBuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBuilds to fetch.
     * 
    **/
    orderBy?: Enumerable<UserBuildOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserBuilds.
     * 
    **/
    cursor?: UserBuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBuilds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBuilds.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserBuildScalarFieldEnum>
  }


  /**
   * UserBuild create
   */
  export type UserBuildCreateArgs = {
    /**
     * Select specific fields to fetch from the UserBuild
     * 
    **/
    select?: UserBuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserBuildInclude | null
    /**
     * The data needed to create a UserBuild.
     * 
    **/
    data: XOR<UserBuildCreateInput, UserBuildUncheckedCreateInput>
  }


  /**
   * UserBuild createMany
   */
  export type UserBuildCreateManyArgs = {
    /**
     * The data used to create many UserBuilds.
     * 
    **/
    data: Enumerable<UserBuildCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserBuild update
   */
  export type UserBuildUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserBuild
     * 
    **/
    select?: UserBuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserBuildInclude | null
    /**
     * The data needed to update a UserBuild.
     * 
    **/
    data: XOR<UserBuildUpdateInput, UserBuildUncheckedUpdateInput>
    /**
     * Choose, which UserBuild to update.
     * 
    **/
    where: UserBuildWhereUniqueInput
  }


  /**
   * UserBuild updateMany
   */
  export type UserBuildUpdateManyArgs = {
    /**
     * The data used to update UserBuilds.
     * 
    **/
    data: XOR<UserBuildUpdateManyMutationInput, UserBuildUncheckedUpdateManyInput>
    /**
     * Filter which UserBuilds to update
     * 
    **/
    where?: UserBuildWhereInput
  }


  /**
   * UserBuild upsert
   */
  export type UserBuildUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserBuild
     * 
    **/
    select?: UserBuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserBuildInclude | null
    /**
     * The filter to search for the UserBuild to update in case it exists.
     * 
    **/
    where: UserBuildWhereUniqueInput
    /**
     * In case the UserBuild found by the `where` argument doesn't exist, create a new UserBuild with this data.
     * 
    **/
    create: XOR<UserBuildCreateInput, UserBuildUncheckedCreateInput>
    /**
     * In case the UserBuild was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserBuildUpdateInput, UserBuildUncheckedUpdateInput>
  }


  /**
   * UserBuild delete
   */
  export type UserBuildDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserBuild
     * 
    **/
    select?: UserBuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserBuildInclude | null
    /**
     * Filter which UserBuild to delete.
     * 
    **/
    where: UserBuildWhereUniqueInput
  }


  /**
   * UserBuild deleteMany
   */
  export type UserBuildDeleteManyArgs = {
    /**
     * Filter which UserBuilds to delete
     * 
    **/
    where?: UserBuildWhereInput
  }


  /**
   * UserBuild: findUniqueOrThrow
   */
  export type UserBuildFindUniqueOrThrowArgs = UserBuildFindUniqueArgsBase
      

  /**
   * UserBuild: findFirstOrThrow
   */
  export type UserBuildFindFirstOrThrowArgs = UserBuildFindFirstArgsBase
      

  /**
   * UserBuild without action
   */
  export type UserBuildArgs = {
    /**
     * Select specific fields to fetch from the UserBuild
     * 
    **/
    select?: UserBuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserBuildInclude | null
  }



  /**
   * Model Recipe
   */


  export type AggregateRecipe = {
    _count: RecipeCountAggregateOutputType | null
    _avg: RecipeAvgAggregateOutputType | null
    _sum: RecipeSumAggregateOutputType | null
    _min: RecipeMinAggregateOutputType | null
    _max: RecipeMaxAggregateOutputType | null
  }

  export type RecipeAvgAggregateOutputType = {
    id: number | null
  }

  export type RecipeSumAggregateOutputType = {
    id: number | null
  }

  export type RecipeMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    origin: string | null
    history: string | null
    createdById: string | null
  }

  export type RecipeMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    origin: string | null
    history: string | null
    createdById: string | null
  }

  export type RecipeCountAggregateOutputType = {
    id: number
    createdAt: number
    name: number
    origin: number
    history: number
    createdById: number
    _all: number
  }


  export type RecipeAvgAggregateInputType = {
    id?: true
  }

  export type RecipeSumAggregateInputType = {
    id?: true
  }

  export type RecipeMinAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    origin?: true
    history?: true
    createdById?: true
  }

  export type RecipeMaxAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    origin?: true
    history?: true
    createdById?: true
  }

  export type RecipeCountAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    origin?: true
    history?: true
    createdById?: true
    _all?: true
  }

  export type RecipeAggregateArgs = {
    /**
     * Filter which Recipe to aggregate.
     * 
    **/
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     * 
    **/
    orderBy?: Enumerable<RecipeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Recipes
    **/
    _count?: true | RecipeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecipeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecipeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeMaxAggregateInputType
  }

  export type GetRecipeAggregateType<T extends RecipeAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipe[P]>
      : GetScalarType<T[P], AggregateRecipe[P]>
  }




  export type RecipeGroupByArgs = {
    where?: RecipeWhereInput
    orderBy?: Enumerable<RecipeOrderByWithAggregationInput>
    by: Array<RecipeScalarFieldEnum>
    having?: RecipeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeCountAggregateInputType | true
    _avg?: RecipeAvgAggregateInputType
    _sum?: RecipeSumAggregateInputType
    _min?: RecipeMinAggregateInputType
    _max?: RecipeMaxAggregateInputType
  }


  export type RecipeGroupByOutputType = {
    id: number
    createdAt: Date
    name: string
    origin: string | null
    history: string | null
    createdById: string
    _count: RecipeCountAggregateOutputType | null
    _avg: RecipeAvgAggregateOutputType | null
    _sum: RecipeSumAggregateOutputType | null
    _min: RecipeMinAggregateOutputType | null
    _max: RecipeMaxAggregateOutputType | null
  }

  type GetRecipeGroupByPayload<T extends RecipeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RecipeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeGroupByOutputType[P]>
        }
      >
    >


  export type RecipeSelect = {
    id?: boolean
    createdAt?: boolean
    name?: boolean
    origin?: boolean
    history?: boolean
    createdBy?: boolean | UserArgs
    createdById?: boolean
    build?: boolean | BuildFindManyArgs
    _count?: boolean | RecipeCountOutputTypeArgs
  }

  export type RecipeInclude = {
    createdBy?: boolean | UserArgs
    build?: boolean | BuildFindManyArgs
    _count?: boolean | RecipeCountOutputTypeArgs
  }

  export type RecipeGetPayload<
    S extends boolean | null | undefined | RecipeArgs,
    U = keyof S
      > = S extends true
        ? Recipe
    : S extends undefined
    ? never
    : S extends RecipeArgs | RecipeFindManyArgs
    ?'include' extends U
    ? Recipe  & {
    [P in TrueKeys<S['include']>]:
        P extends 'createdBy' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'build' ? Array < BuildGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? RecipeCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'createdBy' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'build' ? Array < BuildGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? RecipeCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Recipe ? Recipe[P] : never
  } 
    : Recipe
  : Recipe


  type RecipeCountArgs = Merge<
    Omit<RecipeFindManyArgs, 'select' | 'include'> & {
      select?: RecipeCountAggregateInputType | true
    }
  >

  export interface RecipeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Recipe that matches the filter.
     * @param {RecipeFindUniqueArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RecipeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RecipeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Recipe'> extends True ? CheckSelect<T, Prisma__RecipeClient<Recipe>, Prisma__RecipeClient<RecipeGetPayload<T>>> : CheckSelect<T, Prisma__RecipeClient<Recipe | null >, Prisma__RecipeClient<RecipeGetPayload<T> | null >>

    /**
     * Find the first Recipe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindFirstArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RecipeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RecipeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Recipe'> extends True ? CheckSelect<T, Prisma__RecipeClient<Recipe>, Prisma__RecipeClient<RecipeGetPayload<T>>> : CheckSelect<T, Prisma__RecipeClient<Recipe | null >, Prisma__RecipeClient<RecipeGetPayload<T> | null >>

    /**
     * Find zero or more Recipes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recipes
     * const recipes = await prisma.recipe.findMany()
     * 
     * // Get first 10 Recipes
     * const recipes = await prisma.recipe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeWithIdOnly = await prisma.recipe.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RecipeFindManyArgs>(
      args?: SelectSubset<T, RecipeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Recipe>>, PrismaPromise<Array<RecipeGetPayload<T>>>>

    /**
     * Create a Recipe.
     * @param {RecipeCreateArgs} args - Arguments to create a Recipe.
     * @example
     * // Create one Recipe
     * const Recipe = await prisma.recipe.create({
     *   data: {
     *     // ... data to create a Recipe
     *   }
     * })
     * 
    **/
    create<T extends RecipeCreateArgs>(
      args: SelectSubset<T, RecipeCreateArgs>
    ): CheckSelect<T, Prisma__RecipeClient<Recipe>, Prisma__RecipeClient<RecipeGetPayload<T>>>

    /**
     * Create many Recipes.
     *     @param {RecipeCreateManyArgs} args - Arguments to create many Recipes.
     *     @example
     *     // Create many Recipes
     *     const recipe = await prisma.recipe.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RecipeCreateManyArgs>(
      args?: SelectSubset<T, RecipeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Recipe.
     * @param {RecipeDeleteArgs} args - Arguments to delete one Recipe.
     * @example
     * // Delete one Recipe
     * const Recipe = await prisma.recipe.delete({
     *   where: {
     *     // ... filter to delete one Recipe
     *   }
     * })
     * 
    **/
    delete<T extends RecipeDeleteArgs>(
      args: SelectSubset<T, RecipeDeleteArgs>
    ): CheckSelect<T, Prisma__RecipeClient<Recipe>, Prisma__RecipeClient<RecipeGetPayload<T>>>

    /**
     * Update one Recipe.
     * @param {RecipeUpdateArgs} args - Arguments to update one Recipe.
     * @example
     * // Update one Recipe
     * const recipe = await prisma.recipe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RecipeUpdateArgs>(
      args: SelectSubset<T, RecipeUpdateArgs>
    ): CheckSelect<T, Prisma__RecipeClient<Recipe>, Prisma__RecipeClient<RecipeGetPayload<T>>>

    /**
     * Delete zero or more Recipes.
     * @param {RecipeDeleteManyArgs} args - Arguments to filter Recipes to delete.
     * @example
     * // Delete a few Recipes
     * const { count } = await prisma.recipe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RecipeDeleteManyArgs>(
      args?: SelectSubset<T, RecipeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recipes
     * const recipe = await prisma.recipe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RecipeUpdateManyArgs>(
      args: SelectSubset<T, RecipeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Recipe.
     * @param {RecipeUpsertArgs} args - Arguments to update or create a Recipe.
     * @example
     * // Update or create a Recipe
     * const recipe = await prisma.recipe.upsert({
     *   create: {
     *     // ... data to create a Recipe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recipe we want to update
     *   }
     * })
    **/
    upsert<T extends RecipeUpsertArgs>(
      args: SelectSubset<T, RecipeUpsertArgs>
    ): CheckSelect<T, Prisma__RecipeClient<Recipe>, Prisma__RecipeClient<RecipeGetPayload<T>>>

    /**
     * Find one Recipe that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {RecipeFindUniqueOrThrowArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RecipeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RecipeFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__RecipeClient<Recipe>, Prisma__RecipeClient<RecipeGetPayload<T>>>

    /**
     * Find the first Recipe that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindFirstOrThrowArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RecipeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RecipeFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__RecipeClient<Recipe>, Prisma__RecipeClient<RecipeGetPayload<T>>>

    /**
     * Count the number of Recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeCountArgs} args - Arguments to filter Recipes to count.
     * @example
     * // Count the number of Recipes
     * const count = await prisma.recipe.count({
     *   where: {
     *     // ... the filter for the Recipes we want to count
     *   }
     * })
    **/
    count<T extends RecipeCountArgs>(
      args?: Subset<T, RecipeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeAggregateArgs>(args: Subset<T, RecipeAggregateArgs>): PrismaPromise<GetRecipeAggregateType<T>>

    /**
     * Group by Recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeGroupByArgs['orderBy'] }
        : { orderBy?: RecipeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Recipe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RecipeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    createdBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    build<T extends BuildFindManyArgs = {}>(args?: Subset<T, BuildFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Build>>, PrismaPromise<Array<BuildGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Recipe base type for findUnique actions
   */
  export type RecipeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Recipe
     * 
    **/
    select?: RecipeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeInclude | null
    /**
     * Filter, which Recipe to fetch.
     * 
    **/
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe: findUnique
   */
  export interface RecipeFindUniqueArgs extends RecipeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Recipe base type for findFirst actions
   */
  export type RecipeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Recipe
     * 
    **/
    select?: RecipeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeInclude | null
    /**
     * Filter, which Recipe to fetch.
     * 
    **/
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     * 
    **/
    orderBy?: Enumerable<RecipeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recipes.
     * 
    **/
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recipes.
     * 
    **/
    distinct?: Enumerable<RecipeScalarFieldEnum>
  }

  /**
   * Recipe: findFirst
   */
  export interface RecipeFindFirstArgs extends RecipeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Recipe findMany
   */
  export type RecipeFindManyArgs = {
    /**
     * Select specific fields to fetch from the Recipe
     * 
    **/
    select?: RecipeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeInclude | null
    /**
     * Filter, which Recipes to fetch.
     * 
    **/
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     * 
    **/
    orderBy?: Enumerable<RecipeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Recipes.
     * 
    **/
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RecipeScalarFieldEnum>
  }


  /**
   * Recipe create
   */
  export type RecipeCreateArgs = {
    /**
     * Select specific fields to fetch from the Recipe
     * 
    **/
    select?: RecipeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeInclude | null
    /**
     * The data needed to create a Recipe.
     * 
    **/
    data: XOR<RecipeCreateInput, RecipeUncheckedCreateInput>
  }


  /**
   * Recipe createMany
   */
  export type RecipeCreateManyArgs = {
    /**
     * The data used to create many Recipes.
     * 
    **/
    data: Enumerable<RecipeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Recipe update
   */
  export type RecipeUpdateArgs = {
    /**
     * Select specific fields to fetch from the Recipe
     * 
    **/
    select?: RecipeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeInclude | null
    /**
     * The data needed to update a Recipe.
     * 
    **/
    data: XOR<RecipeUpdateInput, RecipeUncheckedUpdateInput>
    /**
     * Choose, which Recipe to update.
     * 
    **/
    where: RecipeWhereUniqueInput
  }


  /**
   * Recipe updateMany
   */
  export type RecipeUpdateManyArgs = {
    /**
     * The data used to update Recipes.
     * 
    **/
    data: XOR<RecipeUpdateManyMutationInput, RecipeUncheckedUpdateManyInput>
    /**
     * Filter which Recipes to update
     * 
    **/
    where?: RecipeWhereInput
  }


  /**
   * Recipe upsert
   */
  export type RecipeUpsertArgs = {
    /**
     * Select specific fields to fetch from the Recipe
     * 
    **/
    select?: RecipeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeInclude | null
    /**
     * The filter to search for the Recipe to update in case it exists.
     * 
    **/
    where: RecipeWhereUniqueInput
    /**
     * In case the Recipe found by the `where` argument doesn't exist, create a new Recipe with this data.
     * 
    **/
    create: XOR<RecipeCreateInput, RecipeUncheckedCreateInput>
    /**
     * In case the Recipe was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RecipeUpdateInput, RecipeUncheckedUpdateInput>
  }


  /**
   * Recipe delete
   */
  export type RecipeDeleteArgs = {
    /**
     * Select specific fields to fetch from the Recipe
     * 
    **/
    select?: RecipeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeInclude | null
    /**
     * Filter which Recipe to delete.
     * 
    **/
    where: RecipeWhereUniqueInput
  }


  /**
   * Recipe deleteMany
   */
  export type RecipeDeleteManyArgs = {
    /**
     * Filter which Recipes to delete
     * 
    **/
    where?: RecipeWhereInput
  }


  /**
   * Recipe: findUniqueOrThrow
   */
  export type RecipeFindUniqueOrThrowArgs = RecipeFindUniqueArgsBase
      

  /**
   * Recipe: findFirstOrThrow
   */
  export type RecipeFindFirstOrThrowArgs = RecipeFindFirstArgsBase
      

  /**
   * Recipe without action
   */
  export type RecipeArgs = {
    /**
     * Select specific fields to fetch from the Recipe
     * 
    **/
    select?: RecipeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeInclude | null
  }



  /**
   * Model RecipeBookBuild
   */


  export type AggregateRecipeBookBuild = {
    _count: RecipeBookBuildCountAggregateOutputType | null
    _avg: RecipeBookBuildAvgAggregateOutputType | null
    _sum: RecipeBookBuildSumAggregateOutputType | null
    _min: RecipeBookBuildMinAggregateOutputType | null
    _max: RecipeBookBuildMaxAggregateOutputType | null
  }

  export type RecipeBookBuildAvgAggregateOutputType = {
    id: number | null
    buildId: number | null
    recipeBookId: number | null
  }

  export type RecipeBookBuildSumAggregateOutputType = {
    id: number | null
    buildId: number | null
    recipeBookId: number | null
  }

  export type RecipeBookBuildMinAggregateOutputType = {
    id: number | null
    buildId: number | null
    recipeBookId: number | null
  }

  export type RecipeBookBuildMaxAggregateOutputType = {
    id: number | null
    buildId: number | null
    recipeBookId: number | null
  }

  export type RecipeBookBuildCountAggregateOutputType = {
    id: number
    buildId: number
    recipeBookId: number
    _all: number
  }


  export type RecipeBookBuildAvgAggregateInputType = {
    id?: true
    buildId?: true
    recipeBookId?: true
  }

  export type RecipeBookBuildSumAggregateInputType = {
    id?: true
    buildId?: true
    recipeBookId?: true
  }

  export type RecipeBookBuildMinAggregateInputType = {
    id?: true
    buildId?: true
    recipeBookId?: true
  }

  export type RecipeBookBuildMaxAggregateInputType = {
    id?: true
    buildId?: true
    recipeBookId?: true
  }

  export type RecipeBookBuildCountAggregateInputType = {
    id?: true
    buildId?: true
    recipeBookId?: true
    _all?: true
  }

  export type RecipeBookBuildAggregateArgs = {
    /**
     * Filter which RecipeBookBuild to aggregate.
     * 
    **/
    where?: RecipeBookBuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBookBuilds to fetch.
     * 
    **/
    orderBy?: Enumerable<RecipeBookBuildOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RecipeBookBuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBookBuilds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBookBuilds.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecipeBookBuilds
    **/
    _count?: true | RecipeBookBuildCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecipeBookBuildAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecipeBookBuildSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeBookBuildMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeBookBuildMaxAggregateInputType
  }

  export type GetRecipeBookBuildAggregateType<T extends RecipeBookBuildAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipeBookBuild]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipeBookBuild[P]>
      : GetScalarType<T[P], AggregateRecipeBookBuild[P]>
  }




  export type RecipeBookBuildGroupByArgs = {
    where?: RecipeBookBuildWhereInput
    orderBy?: Enumerable<RecipeBookBuildOrderByWithAggregationInput>
    by: Array<RecipeBookBuildScalarFieldEnum>
    having?: RecipeBookBuildScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeBookBuildCountAggregateInputType | true
    _avg?: RecipeBookBuildAvgAggregateInputType
    _sum?: RecipeBookBuildSumAggregateInputType
    _min?: RecipeBookBuildMinAggregateInputType
    _max?: RecipeBookBuildMaxAggregateInputType
  }


  export type RecipeBookBuildGroupByOutputType = {
    id: number
    buildId: number
    recipeBookId: number
    _count: RecipeBookBuildCountAggregateOutputType | null
    _avg: RecipeBookBuildAvgAggregateOutputType | null
    _sum: RecipeBookBuildSumAggregateOutputType | null
    _min: RecipeBookBuildMinAggregateOutputType | null
    _max: RecipeBookBuildMaxAggregateOutputType | null
  }

  type GetRecipeBookBuildGroupByPayload<T extends RecipeBookBuildGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RecipeBookBuildGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeBookBuildGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeBookBuildGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeBookBuildGroupByOutputType[P]>
        }
      >
    >


  export type RecipeBookBuildSelect = {
    id?: boolean
    buildId?: boolean
    recipeBookId?: boolean
    recipeBook?: boolean | RecipeBookArgs
    build?: boolean | BuildArgs
  }

  export type RecipeBookBuildInclude = {
    recipeBook?: boolean | RecipeBookArgs
    build?: boolean | BuildArgs
  }

  export type RecipeBookBuildGetPayload<
    S extends boolean | null | undefined | RecipeBookBuildArgs,
    U = keyof S
      > = S extends true
        ? RecipeBookBuild
    : S extends undefined
    ? never
    : S extends RecipeBookBuildArgs | RecipeBookBuildFindManyArgs
    ?'include' extends U
    ? RecipeBookBuild  & {
    [P in TrueKeys<S['include']>]:
        P extends 'recipeBook' ? RecipeBookGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'build' ? BuildGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'recipeBook' ? RecipeBookGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'build' ? BuildGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof RecipeBookBuild ? RecipeBookBuild[P] : never
  } 
    : RecipeBookBuild
  : RecipeBookBuild


  type RecipeBookBuildCountArgs = Merge<
    Omit<RecipeBookBuildFindManyArgs, 'select' | 'include'> & {
      select?: RecipeBookBuildCountAggregateInputType | true
    }
  >

  export interface RecipeBookBuildDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one RecipeBookBuild that matches the filter.
     * @param {RecipeBookBuildFindUniqueArgs} args - Arguments to find a RecipeBookBuild
     * @example
     * // Get one RecipeBookBuild
     * const recipeBookBuild = await prisma.recipeBookBuild.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RecipeBookBuildFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RecipeBookBuildFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RecipeBookBuild'> extends True ? CheckSelect<T, Prisma__RecipeBookBuildClient<RecipeBookBuild>, Prisma__RecipeBookBuildClient<RecipeBookBuildGetPayload<T>>> : CheckSelect<T, Prisma__RecipeBookBuildClient<RecipeBookBuild | null >, Prisma__RecipeBookBuildClient<RecipeBookBuildGetPayload<T> | null >>

    /**
     * Find the first RecipeBookBuild that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookBuildFindFirstArgs} args - Arguments to find a RecipeBookBuild
     * @example
     * // Get one RecipeBookBuild
     * const recipeBookBuild = await prisma.recipeBookBuild.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RecipeBookBuildFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RecipeBookBuildFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RecipeBookBuild'> extends True ? CheckSelect<T, Prisma__RecipeBookBuildClient<RecipeBookBuild>, Prisma__RecipeBookBuildClient<RecipeBookBuildGetPayload<T>>> : CheckSelect<T, Prisma__RecipeBookBuildClient<RecipeBookBuild | null >, Prisma__RecipeBookBuildClient<RecipeBookBuildGetPayload<T> | null >>

    /**
     * Find zero or more RecipeBookBuilds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookBuildFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecipeBookBuilds
     * const recipeBookBuilds = await prisma.recipeBookBuild.findMany()
     * 
     * // Get first 10 RecipeBookBuilds
     * const recipeBookBuilds = await prisma.recipeBookBuild.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeBookBuildWithIdOnly = await prisma.recipeBookBuild.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RecipeBookBuildFindManyArgs>(
      args?: SelectSubset<T, RecipeBookBuildFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RecipeBookBuild>>, PrismaPromise<Array<RecipeBookBuildGetPayload<T>>>>

    /**
     * Create a RecipeBookBuild.
     * @param {RecipeBookBuildCreateArgs} args - Arguments to create a RecipeBookBuild.
     * @example
     * // Create one RecipeBookBuild
     * const RecipeBookBuild = await prisma.recipeBookBuild.create({
     *   data: {
     *     // ... data to create a RecipeBookBuild
     *   }
     * })
     * 
    **/
    create<T extends RecipeBookBuildCreateArgs>(
      args: SelectSubset<T, RecipeBookBuildCreateArgs>
    ): CheckSelect<T, Prisma__RecipeBookBuildClient<RecipeBookBuild>, Prisma__RecipeBookBuildClient<RecipeBookBuildGetPayload<T>>>

    /**
     * Create many RecipeBookBuilds.
     *     @param {RecipeBookBuildCreateManyArgs} args - Arguments to create many RecipeBookBuilds.
     *     @example
     *     // Create many RecipeBookBuilds
     *     const recipeBookBuild = await prisma.recipeBookBuild.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RecipeBookBuildCreateManyArgs>(
      args?: SelectSubset<T, RecipeBookBuildCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RecipeBookBuild.
     * @param {RecipeBookBuildDeleteArgs} args - Arguments to delete one RecipeBookBuild.
     * @example
     * // Delete one RecipeBookBuild
     * const RecipeBookBuild = await prisma.recipeBookBuild.delete({
     *   where: {
     *     // ... filter to delete one RecipeBookBuild
     *   }
     * })
     * 
    **/
    delete<T extends RecipeBookBuildDeleteArgs>(
      args: SelectSubset<T, RecipeBookBuildDeleteArgs>
    ): CheckSelect<T, Prisma__RecipeBookBuildClient<RecipeBookBuild>, Prisma__RecipeBookBuildClient<RecipeBookBuildGetPayload<T>>>

    /**
     * Update one RecipeBookBuild.
     * @param {RecipeBookBuildUpdateArgs} args - Arguments to update one RecipeBookBuild.
     * @example
     * // Update one RecipeBookBuild
     * const recipeBookBuild = await prisma.recipeBookBuild.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RecipeBookBuildUpdateArgs>(
      args: SelectSubset<T, RecipeBookBuildUpdateArgs>
    ): CheckSelect<T, Prisma__RecipeBookBuildClient<RecipeBookBuild>, Prisma__RecipeBookBuildClient<RecipeBookBuildGetPayload<T>>>

    /**
     * Delete zero or more RecipeBookBuilds.
     * @param {RecipeBookBuildDeleteManyArgs} args - Arguments to filter RecipeBookBuilds to delete.
     * @example
     * // Delete a few RecipeBookBuilds
     * const { count } = await prisma.recipeBookBuild.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RecipeBookBuildDeleteManyArgs>(
      args?: SelectSubset<T, RecipeBookBuildDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeBookBuilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookBuildUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecipeBookBuilds
     * const recipeBookBuild = await prisma.recipeBookBuild.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RecipeBookBuildUpdateManyArgs>(
      args: SelectSubset<T, RecipeBookBuildUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RecipeBookBuild.
     * @param {RecipeBookBuildUpsertArgs} args - Arguments to update or create a RecipeBookBuild.
     * @example
     * // Update or create a RecipeBookBuild
     * const recipeBookBuild = await prisma.recipeBookBuild.upsert({
     *   create: {
     *     // ... data to create a RecipeBookBuild
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecipeBookBuild we want to update
     *   }
     * })
    **/
    upsert<T extends RecipeBookBuildUpsertArgs>(
      args: SelectSubset<T, RecipeBookBuildUpsertArgs>
    ): CheckSelect<T, Prisma__RecipeBookBuildClient<RecipeBookBuild>, Prisma__RecipeBookBuildClient<RecipeBookBuildGetPayload<T>>>

    /**
     * Find one RecipeBookBuild that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {RecipeBookBuildFindUniqueOrThrowArgs} args - Arguments to find a RecipeBookBuild
     * @example
     * // Get one RecipeBookBuild
     * const recipeBookBuild = await prisma.recipeBookBuild.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RecipeBookBuildFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RecipeBookBuildFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__RecipeBookBuildClient<RecipeBookBuild>, Prisma__RecipeBookBuildClient<RecipeBookBuildGetPayload<T>>>

    /**
     * Find the first RecipeBookBuild that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookBuildFindFirstOrThrowArgs} args - Arguments to find a RecipeBookBuild
     * @example
     * // Get one RecipeBookBuild
     * const recipeBookBuild = await prisma.recipeBookBuild.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RecipeBookBuildFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RecipeBookBuildFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__RecipeBookBuildClient<RecipeBookBuild>, Prisma__RecipeBookBuildClient<RecipeBookBuildGetPayload<T>>>

    /**
     * Count the number of RecipeBookBuilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookBuildCountArgs} args - Arguments to filter RecipeBookBuilds to count.
     * @example
     * // Count the number of RecipeBookBuilds
     * const count = await prisma.recipeBookBuild.count({
     *   where: {
     *     // ... the filter for the RecipeBookBuilds we want to count
     *   }
     * })
    **/
    count<T extends RecipeBookBuildCountArgs>(
      args?: Subset<T, RecipeBookBuildCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeBookBuildCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecipeBookBuild.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookBuildAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeBookBuildAggregateArgs>(args: Subset<T, RecipeBookBuildAggregateArgs>): PrismaPromise<GetRecipeBookBuildAggregateType<T>>

    /**
     * Group by RecipeBookBuild.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookBuildGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeBookBuildGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeBookBuildGroupByArgs['orderBy'] }
        : { orderBy?: RecipeBookBuildGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeBookBuildGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeBookBuildGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RecipeBookBuild.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RecipeBookBuildClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    recipeBook<T extends RecipeBookArgs = {}>(args?: Subset<T, RecipeBookArgs>): CheckSelect<T, Prisma__RecipeBookClient<RecipeBook | null >, Prisma__RecipeBookClient<RecipeBookGetPayload<T> | null >>;

    build<T extends BuildArgs = {}>(args?: Subset<T, BuildArgs>): CheckSelect<T, Prisma__BuildClient<Build | null >, Prisma__BuildClient<BuildGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RecipeBookBuild base type for findUnique actions
   */
  export type RecipeBookBuildFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     * 
    **/
    select?: RecipeBookBuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookBuildInclude | null
    /**
     * Filter, which RecipeBookBuild to fetch.
     * 
    **/
    where: RecipeBookBuildWhereUniqueInput
  }

  /**
   * RecipeBookBuild: findUnique
   */
  export interface RecipeBookBuildFindUniqueArgs extends RecipeBookBuildFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RecipeBookBuild base type for findFirst actions
   */
  export type RecipeBookBuildFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     * 
    **/
    select?: RecipeBookBuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookBuildInclude | null
    /**
     * Filter, which RecipeBookBuild to fetch.
     * 
    **/
    where?: RecipeBookBuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBookBuilds to fetch.
     * 
    **/
    orderBy?: Enumerable<RecipeBookBuildOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeBookBuilds.
     * 
    **/
    cursor?: RecipeBookBuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBookBuilds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBookBuilds.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeBookBuilds.
     * 
    **/
    distinct?: Enumerable<RecipeBookBuildScalarFieldEnum>
  }

  /**
   * RecipeBookBuild: findFirst
   */
  export interface RecipeBookBuildFindFirstArgs extends RecipeBookBuildFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RecipeBookBuild findMany
   */
  export type RecipeBookBuildFindManyArgs = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     * 
    **/
    select?: RecipeBookBuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookBuildInclude | null
    /**
     * Filter, which RecipeBookBuilds to fetch.
     * 
    **/
    where?: RecipeBookBuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBookBuilds to fetch.
     * 
    **/
    orderBy?: Enumerable<RecipeBookBuildOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecipeBookBuilds.
     * 
    **/
    cursor?: RecipeBookBuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBookBuilds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBookBuilds.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RecipeBookBuildScalarFieldEnum>
  }


  /**
   * RecipeBookBuild create
   */
  export type RecipeBookBuildCreateArgs = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     * 
    **/
    select?: RecipeBookBuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookBuildInclude | null
    /**
     * The data needed to create a RecipeBookBuild.
     * 
    **/
    data: XOR<RecipeBookBuildCreateInput, RecipeBookBuildUncheckedCreateInput>
  }


  /**
   * RecipeBookBuild createMany
   */
  export type RecipeBookBuildCreateManyArgs = {
    /**
     * The data used to create many RecipeBookBuilds.
     * 
    **/
    data: Enumerable<RecipeBookBuildCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RecipeBookBuild update
   */
  export type RecipeBookBuildUpdateArgs = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     * 
    **/
    select?: RecipeBookBuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookBuildInclude | null
    /**
     * The data needed to update a RecipeBookBuild.
     * 
    **/
    data: XOR<RecipeBookBuildUpdateInput, RecipeBookBuildUncheckedUpdateInput>
    /**
     * Choose, which RecipeBookBuild to update.
     * 
    **/
    where: RecipeBookBuildWhereUniqueInput
  }


  /**
   * RecipeBookBuild updateMany
   */
  export type RecipeBookBuildUpdateManyArgs = {
    /**
     * The data used to update RecipeBookBuilds.
     * 
    **/
    data: XOR<RecipeBookBuildUpdateManyMutationInput, RecipeBookBuildUncheckedUpdateManyInput>
    /**
     * Filter which RecipeBookBuilds to update
     * 
    **/
    where?: RecipeBookBuildWhereInput
  }


  /**
   * RecipeBookBuild upsert
   */
  export type RecipeBookBuildUpsertArgs = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     * 
    **/
    select?: RecipeBookBuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookBuildInclude | null
    /**
     * The filter to search for the RecipeBookBuild to update in case it exists.
     * 
    **/
    where: RecipeBookBuildWhereUniqueInput
    /**
     * In case the RecipeBookBuild found by the `where` argument doesn't exist, create a new RecipeBookBuild with this data.
     * 
    **/
    create: XOR<RecipeBookBuildCreateInput, RecipeBookBuildUncheckedCreateInput>
    /**
     * In case the RecipeBookBuild was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RecipeBookBuildUpdateInput, RecipeBookBuildUncheckedUpdateInput>
  }


  /**
   * RecipeBookBuild delete
   */
  export type RecipeBookBuildDeleteArgs = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     * 
    **/
    select?: RecipeBookBuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookBuildInclude | null
    /**
     * Filter which RecipeBookBuild to delete.
     * 
    **/
    where: RecipeBookBuildWhereUniqueInput
  }


  /**
   * RecipeBookBuild deleteMany
   */
  export type RecipeBookBuildDeleteManyArgs = {
    /**
     * Filter which RecipeBookBuilds to delete
     * 
    **/
    where?: RecipeBookBuildWhereInput
  }


  /**
   * RecipeBookBuild: findUniqueOrThrow
   */
  export type RecipeBookBuildFindUniqueOrThrowArgs = RecipeBookBuildFindUniqueArgsBase
      

  /**
   * RecipeBookBuild: findFirstOrThrow
   */
  export type RecipeBookBuildFindFirstOrThrowArgs = RecipeBookBuildFindFirstArgsBase
      

  /**
   * RecipeBookBuild without action
   */
  export type RecipeBookBuildArgs = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     * 
    **/
    select?: RecipeBookBuildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeBookBuildInclude | null
  }



  /**
   * Model Touch
   */


  export type AggregateTouch = {
    _count: TouchCountAggregateOutputType | null
    _avg: TouchAvgAggregateOutputType | null
    _sum: TouchSumAggregateOutputType | null
    _min: TouchMinAggregateOutputType | null
    _max: TouchMaxAggregateOutputType | null
  }

  export type TouchAvgAggregateOutputType = {
    id: number | null
    ingredientId: number | null
    buildId: number | null
    order: number | null
    amount: number | null
  }

  export type TouchSumAggregateOutputType = {
    id: number | null
    ingredientId: number | null
    buildId: number | null
    order: number | null
    amount: number | null
  }

  export type TouchMinAggregateOutputType = {
    id: number | null
    ingredientName: string | null
    ingredientId: number | null
    buildId: number | null
    order: number | null
    amount: number | null
    unit: string | null
  }

  export type TouchMaxAggregateOutputType = {
    id: number | null
    ingredientName: string | null
    ingredientId: number | null
    buildId: number | null
    order: number | null
    amount: number | null
    unit: string | null
  }

  export type TouchCountAggregateOutputType = {
    id: number
    ingredientName: number
    ingredientId: number
    buildId: number
    order: number
    amount: number
    unit: number
    _all: number
  }


  export type TouchAvgAggregateInputType = {
    id?: true
    ingredientId?: true
    buildId?: true
    order?: true
    amount?: true
  }

  export type TouchSumAggregateInputType = {
    id?: true
    ingredientId?: true
    buildId?: true
    order?: true
    amount?: true
  }

  export type TouchMinAggregateInputType = {
    id?: true
    ingredientName?: true
    ingredientId?: true
    buildId?: true
    order?: true
    amount?: true
    unit?: true
  }

  export type TouchMaxAggregateInputType = {
    id?: true
    ingredientName?: true
    ingredientId?: true
    buildId?: true
    order?: true
    amount?: true
    unit?: true
  }

  export type TouchCountAggregateInputType = {
    id?: true
    ingredientName?: true
    ingredientId?: true
    buildId?: true
    order?: true
    amount?: true
    unit?: true
    _all?: true
  }

  export type TouchAggregateArgs = {
    /**
     * Filter which Touch to aggregate.
     * 
    **/
    where?: TouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Touches to fetch.
     * 
    **/
    orderBy?: Enumerable<TouchOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Touches from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Touches.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Touches
    **/
    _count?: true | TouchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TouchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TouchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TouchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TouchMaxAggregateInputType
  }

  export type GetTouchAggregateType<T extends TouchAggregateArgs> = {
        [P in keyof T & keyof AggregateTouch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTouch[P]>
      : GetScalarType<T[P], AggregateTouch[P]>
  }




  export type TouchGroupByArgs = {
    where?: TouchWhereInput
    orderBy?: Enumerable<TouchOrderByWithAggregationInput>
    by: Array<TouchScalarFieldEnum>
    having?: TouchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TouchCountAggregateInputType | true
    _avg?: TouchAvgAggregateInputType
    _sum?: TouchSumAggregateInputType
    _min?: TouchMinAggregateInputType
    _max?: TouchMaxAggregateInputType
  }


  export type TouchGroupByOutputType = {
    id: number
    ingredientName: string
    ingredientId: number | null
    buildId: number | null
    order: number | null
    amount: number | null
    unit: string | null
    _count: TouchCountAggregateOutputType | null
    _avg: TouchAvgAggregateOutputType | null
    _sum: TouchSumAggregateOutputType | null
    _min: TouchMinAggregateOutputType | null
    _max: TouchMaxAggregateOutputType | null
  }

  type GetTouchGroupByPayload<T extends TouchGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TouchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TouchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TouchGroupByOutputType[P]>
            : GetScalarType<T[P], TouchGroupByOutputType[P]>
        }
      >
    >


  export type TouchSelect = {
    id?: boolean
    ingredientName?: boolean
    ingredientId?: boolean
    ingredient?: boolean | IngredientArgs
    build?: boolean | BuildArgs
    buildId?: boolean
    order?: boolean
    amount?: boolean
    unit?: boolean
  }

  export type TouchInclude = {
    ingredient?: boolean | IngredientArgs
    build?: boolean | BuildArgs
  }

  export type TouchGetPayload<
    S extends boolean | null | undefined | TouchArgs,
    U = keyof S
      > = S extends true
        ? Touch
    : S extends undefined
    ? never
    : S extends TouchArgs | TouchFindManyArgs
    ?'include' extends U
    ? Touch  & {
    [P in TrueKeys<S['include']>]:
        P extends 'ingredient' ? IngredientGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'build' ? BuildGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'ingredient' ? IngredientGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'build' ? BuildGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof Touch ? Touch[P] : never
  } 
    : Touch
  : Touch


  type TouchCountArgs = Merge<
    Omit<TouchFindManyArgs, 'select' | 'include'> & {
      select?: TouchCountAggregateInputType | true
    }
  >

  export interface TouchDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Touch that matches the filter.
     * @param {TouchFindUniqueArgs} args - Arguments to find a Touch
     * @example
     * // Get one Touch
     * const touch = await prisma.touch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TouchFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TouchFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Touch'> extends True ? CheckSelect<T, Prisma__TouchClient<Touch>, Prisma__TouchClient<TouchGetPayload<T>>> : CheckSelect<T, Prisma__TouchClient<Touch | null >, Prisma__TouchClient<TouchGetPayload<T> | null >>

    /**
     * Find the first Touch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchFindFirstArgs} args - Arguments to find a Touch
     * @example
     * // Get one Touch
     * const touch = await prisma.touch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TouchFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TouchFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Touch'> extends True ? CheckSelect<T, Prisma__TouchClient<Touch>, Prisma__TouchClient<TouchGetPayload<T>>> : CheckSelect<T, Prisma__TouchClient<Touch | null >, Prisma__TouchClient<TouchGetPayload<T> | null >>

    /**
     * Find zero or more Touches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Touches
     * const touches = await prisma.touch.findMany()
     * 
     * // Get first 10 Touches
     * const touches = await prisma.touch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const touchWithIdOnly = await prisma.touch.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TouchFindManyArgs>(
      args?: SelectSubset<T, TouchFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Touch>>, PrismaPromise<Array<TouchGetPayload<T>>>>

    /**
     * Create a Touch.
     * @param {TouchCreateArgs} args - Arguments to create a Touch.
     * @example
     * // Create one Touch
     * const Touch = await prisma.touch.create({
     *   data: {
     *     // ... data to create a Touch
     *   }
     * })
     * 
    **/
    create<T extends TouchCreateArgs>(
      args: SelectSubset<T, TouchCreateArgs>
    ): CheckSelect<T, Prisma__TouchClient<Touch>, Prisma__TouchClient<TouchGetPayload<T>>>

    /**
     * Create many Touches.
     *     @param {TouchCreateManyArgs} args - Arguments to create many Touches.
     *     @example
     *     // Create many Touches
     *     const touch = await prisma.touch.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TouchCreateManyArgs>(
      args?: SelectSubset<T, TouchCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Touch.
     * @param {TouchDeleteArgs} args - Arguments to delete one Touch.
     * @example
     * // Delete one Touch
     * const Touch = await prisma.touch.delete({
     *   where: {
     *     // ... filter to delete one Touch
     *   }
     * })
     * 
    **/
    delete<T extends TouchDeleteArgs>(
      args: SelectSubset<T, TouchDeleteArgs>
    ): CheckSelect<T, Prisma__TouchClient<Touch>, Prisma__TouchClient<TouchGetPayload<T>>>

    /**
     * Update one Touch.
     * @param {TouchUpdateArgs} args - Arguments to update one Touch.
     * @example
     * // Update one Touch
     * const touch = await prisma.touch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TouchUpdateArgs>(
      args: SelectSubset<T, TouchUpdateArgs>
    ): CheckSelect<T, Prisma__TouchClient<Touch>, Prisma__TouchClient<TouchGetPayload<T>>>

    /**
     * Delete zero or more Touches.
     * @param {TouchDeleteManyArgs} args - Arguments to filter Touches to delete.
     * @example
     * // Delete a few Touches
     * const { count } = await prisma.touch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TouchDeleteManyArgs>(
      args?: SelectSubset<T, TouchDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Touches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Touches
     * const touch = await prisma.touch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TouchUpdateManyArgs>(
      args: SelectSubset<T, TouchUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Touch.
     * @param {TouchUpsertArgs} args - Arguments to update or create a Touch.
     * @example
     * // Update or create a Touch
     * const touch = await prisma.touch.upsert({
     *   create: {
     *     // ... data to create a Touch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Touch we want to update
     *   }
     * })
    **/
    upsert<T extends TouchUpsertArgs>(
      args: SelectSubset<T, TouchUpsertArgs>
    ): CheckSelect<T, Prisma__TouchClient<Touch>, Prisma__TouchClient<TouchGetPayload<T>>>

    /**
     * Find one Touch that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {TouchFindUniqueOrThrowArgs} args - Arguments to find a Touch
     * @example
     * // Get one Touch
     * const touch = await prisma.touch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TouchFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TouchFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__TouchClient<Touch>, Prisma__TouchClient<TouchGetPayload<T>>>

    /**
     * Find the first Touch that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchFindFirstOrThrowArgs} args - Arguments to find a Touch
     * @example
     * // Get one Touch
     * const touch = await prisma.touch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TouchFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TouchFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__TouchClient<Touch>, Prisma__TouchClient<TouchGetPayload<T>>>

    /**
     * Count the number of Touches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchCountArgs} args - Arguments to filter Touches to count.
     * @example
     * // Count the number of Touches
     * const count = await prisma.touch.count({
     *   where: {
     *     // ... the filter for the Touches we want to count
     *   }
     * })
    **/
    count<T extends TouchCountArgs>(
      args?: Subset<T, TouchCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TouchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Touch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TouchAggregateArgs>(args: Subset<T, TouchAggregateArgs>): PrismaPromise<GetTouchAggregateType<T>>

    /**
     * Group by Touch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TouchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TouchGroupByArgs['orderBy'] }
        : { orderBy?: TouchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TouchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTouchGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Touch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TouchClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    ingredient<T extends IngredientArgs = {}>(args?: Subset<T, IngredientArgs>): CheckSelect<T, Prisma__IngredientClient<Ingredient | null >, Prisma__IngredientClient<IngredientGetPayload<T> | null >>;

    build<T extends BuildArgs = {}>(args?: Subset<T, BuildArgs>): CheckSelect<T, Prisma__BuildClient<Build | null >, Prisma__BuildClient<BuildGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Touch base type for findUnique actions
   */
  export type TouchFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Touch
     * 
    **/
    select?: TouchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TouchInclude | null
    /**
     * Filter, which Touch to fetch.
     * 
    **/
    where: TouchWhereUniqueInput
  }

  /**
   * Touch: findUnique
   */
  export interface TouchFindUniqueArgs extends TouchFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Touch base type for findFirst actions
   */
  export type TouchFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Touch
     * 
    **/
    select?: TouchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TouchInclude | null
    /**
     * Filter, which Touch to fetch.
     * 
    **/
    where?: TouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Touches to fetch.
     * 
    **/
    orderBy?: Enumerable<TouchOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Touches.
     * 
    **/
    cursor?: TouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Touches from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Touches.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Touches.
     * 
    **/
    distinct?: Enumerable<TouchScalarFieldEnum>
  }

  /**
   * Touch: findFirst
   */
  export interface TouchFindFirstArgs extends TouchFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Touch findMany
   */
  export type TouchFindManyArgs = {
    /**
     * Select specific fields to fetch from the Touch
     * 
    **/
    select?: TouchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TouchInclude | null
    /**
     * Filter, which Touches to fetch.
     * 
    **/
    where?: TouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Touches to fetch.
     * 
    **/
    orderBy?: Enumerable<TouchOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Touches.
     * 
    **/
    cursor?: TouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Touches from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Touches.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TouchScalarFieldEnum>
  }


  /**
   * Touch create
   */
  export type TouchCreateArgs = {
    /**
     * Select specific fields to fetch from the Touch
     * 
    **/
    select?: TouchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TouchInclude | null
    /**
     * The data needed to create a Touch.
     * 
    **/
    data: XOR<TouchCreateInput, TouchUncheckedCreateInput>
  }


  /**
   * Touch createMany
   */
  export type TouchCreateManyArgs = {
    /**
     * The data used to create many Touches.
     * 
    **/
    data: Enumerable<TouchCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Touch update
   */
  export type TouchUpdateArgs = {
    /**
     * Select specific fields to fetch from the Touch
     * 
    **/
    select?: TouchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TouchInclude | null
    /**
     * The data needed to update a Touch.
     * 
    **/
    data: XOR<TouchUpdateInput, TouchUncheckedUpdateInput>
    /**
     * Choose, which Touch to update.
     * 
    **/
    where: TouchWhereUniqueInput
  }


  /**
   * Touch updateMany
   */
  export type TouchUpdateManyArgs = {
    /**
     * The data used to update Touches.
     * 
    **/
    data: XOR<TouchUpdateManyMutationInput, TouchUncheckedUpdateManyInput>
    /**
     * Filter which Touches to update
     * 
    **/
    where?: TouchWhereInput
  }


  /**
   * Touch upsert
   */
  export type TouchUpsertArgs = {
    /**
     * Select specific fields to fetch from the Touch
     * 
    **/
    select?: TouchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TouchInclude | null
    /**
     * The filter to search for the Touch to update in case it exists.
     * 
    **/
    where: TouchWhereUniqueInput
    /**
     * In case the Touch found by the `where` argument doesn't exist, create a new Touch with this data.
     * 
    **/
    create: XOR<TouchCreateInput, TouchUncheckedCreateInput>
    /**
     * In case the Touch was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TouchUpdateInput, TouchUncheckedUpdateInput>
  }


  /**
   * Touch delete
   */
  export type TouchDeleteArgs = {
    /**
     * Select specific fields to fetch from the Touch
     * 
    **/
    select?: TouchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TouchInclude | null
    /**
     * Filter which Touch to delete.
     * 
    **/
    where: TouchWhereUniqueInput
  }


  /**
   * Touch deleteMany
   */
  export type TouchDeleteManyArgs = {
    /**
     * Filter which Touches to delete
     * 
    **/
    where?: TouchWhereInput
  }


  /**
   * Touch: findUniqueOrThrow
   */
  export type TouchFindUniqueOrThrowArgs = TouchFindUniqueArgsBase
      

  /**
   * Touch: findFirstOrThrow
   */
  export type TouchFindFirstOrThrowArgs = TouchFindFirstArgsBase
      

  /**
   * Touch without action
   */
  export type TouchArgs = {
    /**
     * Select specific fields to fetch from the Touch
     * 
    **/
    select?: TouchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TouchInclude | null
  }



  /**
   * Model Ingredient
   */


  export type AggregateIngredient = {
    _count: IngredientCountAggregateOutputType | null
    _avg: IngredientAvgAggregateOutputType | null
    _sum: IngredientSumAggregateOutputType | null
    _min: IngredientMinAggregateOutputType | null
    _max: IngredientMaxAggregateOutputType | null
  }

  export type IngredientAvgAggregateOutputType = {
    id: number | null
    price: number | null
    amount: number | null
  }

  export type IngredientSumAggregateOutputType = {
    id: number | null
    price: number | null
    amount: number | null
  }

  export type IngredientMinAggregateOutputType = {
    id: number | null
    dateCreated: Date | null
    createdById: string | null
    name: string | null
    price: number | null
    amount: number | null
    unit: string | null
  }

  export type IngredientMaxAggregateOutputType = {
    id: number | null
    dateCreated: Date | null
    createdById: string | null
    name: string | null
    price: number | null
    amount: number | null
    unit: string | null
  }

  export type IngredientCountAggregateOutputType = {
    id: number
    dateCreated: number
    createdById: number
    name: number
    price: number
    amount: number
    unit: number
    _all: number
  }


  export type IngredientAvgAggregateInputType = {
    id?: true
    price?: true
    amount?: true
  }

  export type IngredientSumAggregateInputType = {
    id?: true
    price?: true
    amount?: true
  }

  export type IngredientMinAggregateInputType = {
    id?: true
    dateCreated?: true
    createdById?: true
    name?: true
    price?: true
    amount?: true
    unit?: true
  }

  export type IngredientMaxAggregateInputType = {
    id?: true
    dateCreated?: true
    createdById?: true
    name?: true
    price?: true
    amount?: true
    unit?: true
  }

  export type IngredientCountAggregateInputType = {
    id?: true
    dateCreated?: true
    createdById?: true
    name?: true
    price?: true
    amount?: true
    unit?: true
    _all?: true
  }

  export type IngredientAggregateArgs = {
    /**
     * Filter which Ingredient to aggregate.
     * 
    **/
    where?: IngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ingredients to fetch.
     * 
    **/
    orderBy?: Enumerable<IngredientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: IngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ingredients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ingredients.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ingredients
    **/
    _count?: true | IngredientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IngredientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IngredientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IngredientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IngredientMaxAggregateInputType
  }

  export type GetIngredientAggregateType<T extends IngredientAggregateArgs> = {
        [P in keyof T & keyof AggregateIngredient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIngredient[P]>
      : GetScalarType<T[P], AggregateIngredient[P]>
  }




  export type IngredientGroupByArgs = {
    where?: IngredientWhereInput
    orderBy?: Enumerable<IngredientOrderByWithAggregationInput>
    by: Array<IngredientScalarFieldEnum>
    having?: IngredientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IngredientCountAggregateInputType | true
    _avg?: IngredientAvgAggregateInputType
    _sum?: IngredientSumAggregateInputType
    _min?: IngredientMinAggregateInputType
    _max?: IngredientMaxAggregateInputType
  }


  export type IngredientGroupByOutputType = {
    id: number
    dateCreated: Date
    createdById: string | null
    name: string
    price: number | null
    amount: number | null
    unit: string | null
    _count: IngredientCountAggregateOutputType | null
    _avg: IngredientAvgAggregateOutputType | null
    _sum: IngredientSumAggregateOutputType | null
    _min: IngredientMinAggregateOutputType | null
    _max: IngredientMaxAggregateOutputType | null
  }

  type GetIngredientGroupByPayload<T extends IngredientGroupByArgs> = PrismaPromise<
    Array<
      PickArray<IngredientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IngredientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IngredientGroupByOutputType[P]>
            : GetScalarType<T[P], IngredientGroupByOutputType[P]>
        }
      >
    >


  export type IngredientSelect = {
    id?: boolean
    dateCreated?: boolean
    createdBy?: boolean | UserArgs
    createdById?: boolean
    name?: boolean
    price?: boolean
    amount?: boolean
    unit?: boolean
    touch?: boolean | TouchFindManyArgs
    ingredientStorage?: boolean | ingredientStorageFindManyArgs
    _count?: boolean | IngredientCountOutputTypeArgs
  }

  export type IngredientInclude = {
    createdBy?: boolean | UserArgs
    touch?: boolean | TouchFindManyArgs
    ingredientStorage?: boolean | ingredientStorageFindManyArgs
    _count?: boolean | IngredientCountOutputTypeArgs
  }

  export type IngredientGetPayload<
    S extends boolean | null | undefined | IngredientArgs,
    U = keyof S
      > = S extends true
        ? Ingredient
    : S extends undefined
    ? never
    : S extends IngredientArgs | IngredientFindManyArgs
    ?'include' extends U
    ? Ingredient  & {
    [P in TrueKeys<S['include']>]:
        P extends 'createdBy' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'touch' ? Array < TouchGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'ingredientStorage' ? Array < ingredientStorageGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? IngredientCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'createdBy' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'touch' ? Array < TouchGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'ingredientStorage' ? Array < ingredientStorageGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? IngredientCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Ingredient ? Ingredient[P] : never
  } 
    : Ingredient
  : Ingredient


  type IngredientCountArgs = Merge<
    Omit<IngredientFindManyArgs, 'select' | 'include'> & {
      select?: IngredientCountAggregateInputType | true
    }
  >

  export interface IngredientDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Ingredient that matches the filter.
     * @param {IngredientFindUniqueArgs} args - Arguments to find a Ingredient
     * @example
     * // Get one Ingredient
     * const ingredient = await prisma.ingredient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IngredientFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, IngredientFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Ingredient'> extends True ? CheckSelect<T, Prisma__IngredientClient<Ingredient>, Prisma__IngredientClient<IngredientGetPayload<T>>> : CheckSelect<T, Prisma__IngredientClient<Ingredient | null >, Prisma__IngredientClient<IngredientGetPayload<T> | null >>

    /**
     * Find the first Ingredient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientFindFirstArgs} args - Arguments to find a Ingredient
     * @example
     * // Get one Ingredient
     * const ingredient = await prisma.ingredient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IngredientFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, IngredientFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Ingredient'> extends True ? CheckSelect<T, Prisma__IngredientClient<Ingredient>, Prisma__IngredientClient<IngredientGetPayload<T>>> : CheckSelect<T, Prisma__IngredientClient<Ingredient | null >, Prisma__IngredientClient<IngredientGetPayload<T> | null >>

    /**
     * Find zero or more Ingredients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ingredients
     * const ingredients = await prisma.ingredient.findMany()
     * 
     * // Get first 10 Ingredients
     * const ingredients = await prisma.ingredient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ingredientWithIdOnly = await prisma.ingredient.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends IngredientFindManyArgs>(
      args?: SelectSubset<T, IngredientFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Ingredient>>, PrismaPromise<Array<IngredientGetPayload<T>>>>

    /**
     * Create a Ingredient.
     * @param {IngredientCreateArgs} args - Arguments to create a Ingredient.
     * @example
     * // Create one Ingredient
     * const Ingredient = await prisma.ingredient.create({
     *   data: {
     *     // ... data to create a Ingredient
     *   }
     * })
     * 
    **/
    create<T extends IngredientCreateArgs>(
      args: SelectSubset<T, IngredientCreateArgs>
    ): CheckSelect<T, Prisma__IngredientClient<Ingredient>, Prisma__IngredientClient<IngredientGetPayload<T>>>

    /**
     * Create many Ingredients.
     *     @param {IngredientCreateManyArgs} args - Arguments to create many Ingredients.
     *     @example
     *     // Create many Ingredients
     *     const ingredient = await prisma.ingredient.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IngredientCreateManyArgs>(
      args?: SelectSubset<T, IngredientCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Ingredient.
     * @param {IngredientDeleteArgs} args - Arguments to delete one Ingredient.
     * @example
     * // Delete one Ingredient
     * const Ingredient = await prisma.ingredient.delete({
     *   where: {
     *     // ... filter to delete one Ingredient
     *   }
     * })
     * 
    **/
    delete<T extends IngredientDeleteArgs>(
      args: SelectSubset<T, IngredientDeleteArgs>
    ): CheckSelect<T, Prisma__IngredientClient<Ingredient>, Prisma__IngredientClient<IngredientGetPayload<T>>>

    /**
     * Update one Ingredient.
     * @param {IngredientUpdateArgs} args - Arguments to update one Ingredient.
     * @example
     * // Update one Ingredient
     * const ingredient = await prisma.ingredient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IngredientUpdateArgs>(
      args: SelectSubset<T, IngredientUpdateArgs>
    ): CheckSelect<T, Prisma__IngredientClient<Ingredient>, Prisma__IngredientClient<IngredientGetPayload<T>>>

    /**
     * Delete zero or more Ingredients.
     * @param {IngredientDeleteManyArgs} args - Arguments to filter Ingredients to delete.
     * @example
     * // Delete a few Ingredients
     * const { count } = await prisma.ingredient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IngredientDeleteManyArgs>(
      args?: SelectSubset<T, IngredientDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ingredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ingredients
     * const ingredient = await prisma.ingredient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IngredientUpdateManyArgs>(
      args: SelectSubset<T, IngredientUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Ingredient.
     * @param {IngredientUpsertArgs} args - Arguments to update or create a Ingredient.
     * @example
     * // Update or create a Ingredient
     * const ingredient = await prisma.ingredient.upsert({
     *   create: {
     *     // ... data to create a Ingredient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ingredient we want to update
     *   }
     * })
    **/
    upsert<T extends IngredientUpsertArgs>(
      args: SelectSubset<T, IngredientUpsertArgs>
    ): CheckSelect<T, Prisma__IngredientClient<Ingredient>, Prisma__IngredientClient<IngredientGetPayload<T>>>

    /**
     * Find one Ingredient that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {IngredientFindUniqueOrThrowArgs} args - Arguments to find a Ingredient
     * @example
     * // Get one Ingredient
     * const ingredient = await prisma.ingredient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends IngredientFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, IngredientFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__IngredientClient<Ingredient>, Prisma__IngredientClient<IngredientGetPayload<T>>>

    /**
     * Find the first Ingredient that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientFindFirstOrThrowArgs} args - Arguments to find a Ingredient
     * @example
     * // Get one Ingredient
     * const ingredient = await prisma.ingredient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends IngredientFindFirstOrThrowArgs>(
      args?: SelectSubset<T, IngredientFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__IngredientClient<Ingredient>, Prisma__IngredientClient<IngredientGetPayload<T>>>

    /**
     * Count the number of Ingredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientCountArgs} args - Arguments to filter Ingredients to count.
     * @example
     * // Count the number of Ingredients
     * const count = await prisma.ingredient.count({
     *   where: {
     *     // ... the filter for the Ingredients we want to count
     *   }
     * })
    **/
    count<T extends IngredientCountArgs>(
      args?: Subset<T, IngredientCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IngredientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ingredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IngredientAggregateArgs>(args: Subset<T, IngredientAggregateArgs>): PrismaPromise<GetIngredientAggregateType<T>>

    /**
     * Group by Ingredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IngredientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IngredientGroupByArgs['orderBy'] }
        : { orderBy?: IngredientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IngredientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIngredientGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Ingredient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__IngredientClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    createdBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    touch<T extends TouchFindManyArgs = {}>(args?: Subset<T, TouchFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Touch>>, PrismaPromise<Array<TouchGetPayload<T>>>>;

    ingredientStorage<T extends ingredientStorageFindManyArgs = {}>(args?: Subset<T, ingredientStorageFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ingredientStorage>>, PrismaPromise<Array<ingredientStorageGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Ingredient base type for findUnique actions
   */
  export type IngredientFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Ingredient
     * 
    **/
    select?: IngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IngredientInclude | null
    /**
     * Filter, which Ingredient to fetch.
     * 
    **/
    where: IngredientWhereUniqueInput
  }

  /**
   * Ingredient: findUnique
   */
  export interface IngredientFindUniqueArgs extends IngredientFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Ingredient base type for findFirst actions
   */
  export type IngredientFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Ingredient
     * 
    **/
    select?: IngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IngredientInclude | null
    /**
     * Filter, which Ingredient to fetch.
     * 
    **/
    where?: IngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ingredients to fetch.
     * 
    **/
    orderBy?: Enumerable<IngredientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ingredients.
     * 
    **/
    cursor?: IngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ingredients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ingredients.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ingredients.
     * 
    **/
    distinct?: Enumerable<IngredientScalarFieldEnum>
  }

  /**
   * Ingredient: findFirst
   */
  export interface IngredientFindFirstArgs extends IngredientFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Ingredient findMany
   */
  export type IngredientFindManyArgs = {
    /**
     * Select specific fields to fetch from the Ingredient
     * 
    **/
    select?: IngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IngredientInclude | null
    /**
     * Filter, which Ingredients to fetch.
     * 
    **/
    where?: IngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ingredients to fetch.
     * 
    **/
    orderBy?: Enumerable<IngredientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ingredients.
     * 
    **/
    cursor?: IngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ingredients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ingredients.
     * 
    **/
    skip?: number
    distinct?: Enumerable<IngredientScalarFieldEnum>
  }


  /**
   * Ingredient create
   */
  export type IngredientCreateArgs = {
    /**
     * Select specific fields to fetch from the Ingredient
     * 
    **/
    select?: IngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IngredientInclude | null
    /**
     * The data needed to create a Ingredient.
     * 
    **/
    data: XOR<IngredientCreateInput, IngredientUncheckedCreateInput>
  }


  /**
   * Ingredient createMany
   */
  export type IngredientCreateManyArgs = {
    /**
     * The data used to create many Ingredients.
     * 
    **/
    data: Enumerable<IngredientCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Ingredient update
   */
  export type IngredientUpdateArgs = {
    /**
     * Select specific fields to fetch from the Ingredient
     * 
    **/
    select?: IngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IngredientInclude | null
    /**
     * The data needed to update a Ingredient.
     * 
    **/
    data: XOR<IngredientUpdateInput, IngredientUncheckedUpdateInput>
    /**
     * Choose, which Ingredient to update.
     * 
    **/
    where: IngredientWhereUniqueInput
  }


  /**
   * Ingredient updateMany
   */
  export type IngredientUpdateManyArgs = {
    /**
     * The data used to update Ingredients.
     * 
    **/
    data: XOR<IngredientUpdateManyMutationInput, IngredientUncheckedUpdateManyInput>
    /**
     * Filter which Ingredients to update
     * 
    **/
    where?: IngredientWhereInput
  }


  /**
   * Ingredient upsert
   */
  export type IngredientUpsertArgs = {
    /**
     * Select specific fields to fetch from the Ingredient
     * 
    **/
    select?: IngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IngredientInclude | null
    /**
     * The filter to search for the Ingredient to update in case it exists.
     * 
    **/
    where: IngredientWhereUniqueInput
    /**
     * In case the Ingredient found by the `where` argument doesn't exist, create a new Ingredient with this data.
     * 
    **/
    create: XOR<IngredientCreateInput, IngredientUncheckedCreateInput>
    /**
     * In case the Ingredient was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<IngredientUpdateInput, IngredientUncheckedUpdateInput>
  }


  /**
   * Ingredient delete
   */
  export type IngredientDeleteArgs = {
    /**
     * Select specific fields to fetch from the Ingredient
     * 
    **/
    select?: IngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IngredientInclude | null
    /**
     * Filter which Ingredient to delete.
     * 
    **/
    where: IngredientWhereUniqueInput
  }


  /**
   * Ingredient deleteMany
   */
  export type IngredientDeleteManyArgs = {
    /**
     * Filter which Ingredients to delete
     * 
    **/
    where?: IngredientWhereInput
  }


  /**
   * Ingredient: findUniqueOrThrow
   */
  export type IngredientFindUniqueOrThrowArgs = IngredientFindUniqueArgsBase
      

  /**
   * Ingredient: findFirstOrThrow
   */
  export type IngredientFindFirstOrThrowArgs = IngredientFindFirstArgsBase
      

  /**
   * Ingredient without action
   */
  export type IngredientArgs = {
    /**
     * Select specific fields to fetch from the Ingredient
     * 
    **/
    select?: IngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IngredientInclude | null
  }



  /**
   * Model Inventory
   */


  export type AggregateInventory = {
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  export type InventoryAvgAggregateOutputType = {
    id: number | null
  }

  export type InventorySumAggregateOutputType = {
    id: number | null
  }

  export type InventoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
  }

  export type InventoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
  }

  export type InventoryCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    editedAt: number
    createdById: number
    editedById: number
    _all: number
  }


  export type InventoryAvgAggregateInputType = {
    id?: true
  }

  export type InventorySumAggregateInputType = {
    id?: true
  }

  export type InventoryMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
  }

  export type InventoryMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
  }

  export type InventoryCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
    _all?: true
  }

  export type InventoryAggregateArgs = {
    /**
     * Filter which Inventory to aggregate.
     * 
    **/
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     * 
    **/
    orderBy?: Enumerable<InventoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inventories
    **/
    _count?: true | InventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMaxAggregateInputType
  }

  export type GetInventoryAggregateType<T extends InventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventory[P]>
      : GetScalarType<T[P], AggregateInventory[P]>
  }




  export type InventoryGroupByArgs = {
    where?: InventoryWhereInput
    orderBy?: Enumerable<InventoryOrderByWithAggregationInput>
    by: Array<InventoryScalarFieldEnum>
    having?: InventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryCountAggregateInputType | true
    _avg?: InventoryAvgAggregateInputType
    _sum?: InventorySumAggregateInputType
    _min?: InventoryMinAggregateInputType
    _max?: InventoryMaxAggregateInputType
  }


  export type InventoryGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    editedAt: Date
    createdById: string
    editedById: string
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  type GetInventoryGroupByPayload<T extends InventoryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryGroupByOutputType[P]>
        }
      >
    >


  export type InventorySelect = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    editedAt?: boolean
    createdById?: boolean
    editedById?: boolean
    createdBy?: boolean | UserArgs
    editedBy?: boolean | UserArgs
    InventoryStorage?: boolean | InventoryStorageFindManyArgs
    _count?: boolean | InventoryCountOutputTypeArgs
  }

  export type InventoryInclude = {
    createdBy?: boolean | UserArgs
    editedBy?: boolean | UserArgs
    InventoryStorage?: boolean | InventoryStorageFindManyArgs
    _count?: boolean | InventoryCountOutputTypeArgs
  }

  export type InventoryGetPayload<
    S extends boolean | null | undefined | InventoryArgs,
    U = keyof S
      > = S extends true
        ? Inventory
    : S extends undefined
    ? never
    : S extends InventoryArgs | InventoryFindManyArgs
    ?'include' extends U
    ? Inventory  & {
    [P in TrueKeys<S['include']>]:
        P extends 'createdBy' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'editedBy' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'InventoryStorage' ? Array < InventoryStorageGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? InventoryCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'createdBy' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'editedBy' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'InventoryStorage' ? Array < InventoryStorageGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? InventoryCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Inventory ? Inventory[P] : never
  } 
    : Inventory
  : Inventory


  type InventoryCountArgs = Merge<
    Omit<InventoryFindManyArgs, 'select' | 'include'> & {
      select?: InventoryCountAggregateInputType | true
    }
  >

  export interface InventoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Inventory that matches the filter.
     * @param {InventoryFindUniqueArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InventoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InventoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Inventory'> extends True ? CheckSelect<T, Prisma__InventoryClient<Inventory>, Prisma__InventoryClient<InventoryGetPayload<T>>> : CheckSelect<T, Prisma__InventoryClient<Inventory | null >, Prisma__InventoryClient<InventoryGetPayload<T> | null >>

    /**
     * Find the first Inventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InventoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InventoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Inventory'> extends True ? CheckSelect<T, Prisma__InventoryClient<Inventory>, Prisma__InventoryClient<InventoryGetPayload<T>>> : CheckSelect<T, Prisma__InventoryClient<Inventory | null >, Prisma__InventoryClient<InventoryGetPayload<T> | null >>

    /**
     * Find zero or more Inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventories
     * const inventories = await prisma.inventory.findMany()
     * 
     * // Get first 10 Inventories
     * const inventories = await prisma.inventory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryWithIdOnly = await prisma.inventory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InventoryFindManyArgs>(
      args?: SelectSubset<T, InventoryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Inventory>>, PrismaPromise<Array<InventoryGetPayload<T>>>>

    /**
     * Create a Inventory.
     * @param {InventoryCreateArgs} args - Arguments to create a Inventory.
     * @example
     * // Create one Inventory
     * const Inventory = await prisma.inventory.create({
     *   data: {
     *     // ... data to create a Inventory
     *   }
     * })
     * 
    **/
    create<T extends InventoryCreateArgs>(
      args: SelectSubset<T, InventoryCreateArgs>
    ): CheckSelect<T, Prisma__InventoryClient<Inventory>, Prisma__InventoryClient<InventoryGetPayload<T>>>

    /**
     * Create many Inventories.
     *     @param {InventoryCreateManyArgs} args - Arguments to create many Inventories.
     *     @example
     *     // Create many Inventories
     *     const inventory = await prisma.inventory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InventoryCreateManyArgs>(
      args?: SelectSubset<T, InventoryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Inventory.
     * @param {InventoryDeleteArgs} args - Arguments to delete one Inventory.
     * @example
     * // Delete one Inventory
     * const Inventory = await prisma.inventory.delete({
     *   where: {
     *     // ... filter to delete one Inventory
     *   }
     * })
     * 
    **/
    delete<T extends InventoryDeleteArgs>(
      args: SelectSubset<T, InventoryDeleteArgs>
    ): CheckSelect<T, Prisma__InventoryClient<Inventory>, Prisma__InventoryClient<InventoryGetPayload<T>>>

    /**
     * Update one Inventory.
     * @param {InventoryUpdateArgs} args - Arguments to update one Inventory.
     * @example
     * // Update one Inventory
     * const inventory = await prisma.inventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InventoryUpdateArgs>(
      args: SelectSubset<T, InventoryUpdateArgs>
    ): CheckSelect<T, Prisma__InventoryClient<Inventory>, Prisma__InventoryClient<InventoryGetPayload<T>>>

    /**
     * Delete zero or more Inventories.
     * @param {InventoryDeleteManyArgs} args - Arguments to filter Inventories to delete.
     * @example
     * // Delete a few Inventories
     * const { count } = await prisma.inventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InventoryDeleteManyArgs>(
      args?: SelectSubset<T, InventoryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InventoryUpdateManyArgs>(
      args: SelectSubset<T, InventoryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Inventory.
     * @param {InventoryUpsertArgs} args - Arguments to update or create a Inventory.
     * @example
     * // Update or create a Inventory
     * const inventory = await prisma.inventory.upsert({
     *   create: {
     *     // ... data to create a Inventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventory we want to update
     *   }
     * })
    **/
    upsert<T extends InventoryUpsertArgs>(
      args: SelectSubset<T, InventoryUpsertArgs>
    ): CheckSelect<T, Prisma__InventoryClient<Inventory>, Prisma__InventoryClient<InventoryGetPayload<T>>>

    /**
     * Find one Inventory that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {InventoryFindUniqueOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InventoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, InventoryFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__InventoryClient<Inventory>, Prisma__InventoryClient<InventoryGetPayload<T>>>

    /**
     * Find the first Inventory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InventoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, InventoryFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__InventoryClient<Inventory>, Prisma__InventoryClient<InventoryGetPayload<T>>>

    /**
     * Count the number of Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCountArgs} args - Arguments to filter Inventories to count.
     * @example
     * // Count the number of Inventories
     * const count = await prisma.inventory.count({
     *   where: {
     *     // ... the filter for the Inventories we want to count
     *   }
     * })
    **/
    count<T extends InventoryCountArgs>(
      args?: Subset<T, InventoryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryAggregateArgs>(args: Subset<T, InventoryAggregateArgs>): PrismaPromise<GetInventoryAggregateType<T>>

    /**
     * Group by Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryGroupByArgs['orderBy'] }
        : { orderBy?: InventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Inventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InventoryClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    createdBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    editedBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    InventoryStorage<T extends InventoryStorageFindManyArgs = {}>(args?: Subset<T, InventoryStorageFindManyArgs>): CheckSelect<T, PrismaPromise<Array<InventoryStorage>>, PrismaPromise<Array<InventoryStorageGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Inventory base type for findUnique actions
   */
  export type InventoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Inventory
     * 
    **/
    select?: InventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryInclude | null
    /**
     * Filter, which Inventory to fetch.
     * 
    **/
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory: findUnique
   */
  export interface InventoryFindUniqueArgs extends InventoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Inventory base type for findFirst actions
   */
  export type InventoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Inventory
     * 
    **/
    select?: InventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryInclude | null
    /**
     * Filter, which Inventory to fetch.
     * 
    **/
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     * 
    **/
    orderBy?: Enumerable<InventoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     * 
    **/
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     * 
    **/
    distinct?: Enumerable<InventoryScalarFieldEnum>
  }

  /**
   * Inventory: findFirst
   */
  export interface InventoryFindFirstArgs extends InventoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Inventory findMany
   */
  export type InventoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the Inventory
     * 
    **/
    select?: InventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryInclude | null
    /**
     * Filter, which Inventories to fetch.
     * 
    **/
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     * 
    **/
    orderBy?: Enumerable<InventoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inventories.
     * 
    **/
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InventoryScalarFieldEnum>
  }


  /**
   * Inventory create
   */
  export type InventoryCreateArgs = {
    /**
     * Select specific fields to fetch from the Inventory
     * 
    **/
    select?: InventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryInclude | null
    /**
     * The data needed to create a Inventory.
     * 
    **/
    data: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
  }


  /**
   * Inventory createMany
   */
  export type InventoryCreateManyArgs = {
    /**
     * The data used to create many Inventories.
     * 
    **/
    data: Enumerable<InventoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Inventory update
   */
  export type InventoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the Inventory
     * 
    **/
    select?: InventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryInclude | null
    /**
     * The data needed to update a Inventory.
     * 
    **/
    data: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
    /**
     * Choose, which Inventory to update.
     * 
    **/
    where: InventoryWhereUniqueInput
  }


  /**
   * Inventory updateMany
   */
  export type InventoryUpdateManyArgs = {
    /**
     * The data used to update Inventories.
     * 
    **/
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyInput>
    /**
     * Filter which Inventories to update
     * 
    **/
    where?: InventoryWhereInput
  }


  /**
   * Inventory upsert
   */
  export type InventoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the Inventory
     * 
    **/
    select?: InventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryInclude | null
    /**
     * The filter to search for the Inventory to update in case it exists.
     * 
    **/
    where: InventoryWhereUniqueInput
    /**
     * In case the Inventory found by the `where` argument doesn't exist, create a new Inventory with this data.
     * 
    **/
    create: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
    /**
     * In case the Inventory was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
  }


  /**
   * Inventory delete
   */
  export type InventoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the Inventory
     * 
    **/
    select?: InventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryInclude | null
    /**
     * Filter which Inventory to delete.
     * 
    **/
    where: InventoryWhereUniqueInput
  }


  /**
   * Inventory deleteMany
   */
  export type InventoryDeleteManyArgs = {
    /**
     * Filter which Inventories to delete
     * 
    **/
    where?: InventoryWhereInput
  }


  /**
   * Inventory: findUniqueOrThrow
   */
  export type InventoryFindUniqueOrThrowArgs = InventoryFindUniqueArgsBase
      

  /**
   * Inventory: findFirstOrThrow
   */
  export type InventoryFindFirstOrThrowArgs = InventoryFindFirstArgsBase
      

  /**
   * Inventory without action
   */
  export type InventoryArgs = {
    /**
     * Select specific fields to fetch from the Inventory
     * 
    **/
    select?: InventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryInclude | null
  }



  /**
   * Model InventoryStorage
   */


  export type AggregateInventoryStorage = {
    _count: InventoryStorageCountAggregateOutputType | null
    _avg: InventoryStorageAvgAggregateOutputType | null
    _sum: InventoryStorageSumAggregateOutputType | null
    _min: InventoryStorageMinAggregateOutputType | null
    _max: InventoryStorageMaxAggregateOutputType | null
  }

  export type InventoryStorageAvgAggregateOutputType = {
    id: number | null
    inventoryId: number | null
    storageId: number | null
  }

  export type InventoryStorageSumAggregateOutputType = {
    id: number | null
    inventoryId: number | null
    storageId: number | null
  }

  export type InventoryStorageMinAggregateOutputType = {
    id: number | null
    inventoryId: number | null
    storageId: number | null
  }

  export type InventoryStorageMaxAggregateOutputType = {
    id: number | null
    inventoryId: number | null
    storageId: number | null
  }

  export type InventoryStorageCountAggregateOutputType = {
    id: number
    inventoryId: number
    storageId: number
    _all: number
  }


  export type InventoryStorageAvgAggregateInputType = {
    id?: true
    inventoryId?: true
    storageId?: true
  }

  export type InventoryStorageSumAggregateInputType = {
    id?: true
    inventoryId?: true
    storageId?: true
  }

  export type InventoryStorageMinAggregateInputType = {
    id?: true
    inventoryId?: true
    storageId?: true
  }

  export type InventoryStorageMaxAggregateInputType = {
    id?: true
    inventoryId?: true
    storageId?: true
  }

  export type InventoryStorageCountAggregateInputType = {
    id?: true
    inventoryId?: true
    storageId?: true
    _all?: true
  }

  export type InventoryStorageAggregateArgs = {
    /**
     * Filter which InventoryStorage to aggregate.
     * 
    **/
    where?: InventoryStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryStorages to fetch.
     * 
    **/
    orderBy?: Enumerable<InventoryStorageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: InventoryStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryStorages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryStorages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryStorages
    **/
    _count?: true | InventoryStorageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryStorageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryStorageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryStorageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryStorageMaxAggregateInputType
  }

  export type GetInventoryStorageAggregateType<T extends InventoryStorageAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryStorage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryStorage[P]>
      : GetScalarType<T[P], AggregateInventoryStorage[P]>
  }




  export type InventoryStorageGroupByArgs = {
    where?: InventoryStorageWhereInput
    orderBy?: Enumerable<InventoryStorageOrderByWithAggregationInput>
    by: Array<InventoryStorageScalarFieldEnum>
    having?: InventoryStorageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryStorageCountAggregateInputType | true
    _avg?: InventoryStorageAvgAggregateInputType
    _sum?: InventoryStorageSumAggregateInputType
    _min?: InventoryStorageMinAggregateInputType
    _max?: InventoryStorageMaxAggregateInputType
  }


  export type InventoryStorageGroupByOutputType = {
    id: number
    inventoryId: number
    storageId: number
    _count: InventoryStorageCountAggregateOutputType | null
    _avg: InventoryStorageAvgAggregateOutputType | null
    _sum: InventoryStorageSumAggregateOutputType | null
    _min: InventoryStorageMinAggregateOutputType | null
    _max: InventoryStorageMaxAggregateOutputType | null
  }

  type GetInventoryStorageGroupByPayload<T extends InventoryStorageGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InventoryStorageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryStorageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryStorageGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryStorageGroupByOutputType[P]>
        }
      >
    >


  export type InventoryStorageSelect = {
    id?: boolean
    inventoryId?: boolean
    storageId?: boolean
    storage?: boolean | StorageArgs
    inventory?: boolean | InventoryArgs
  }

  export type InventoryStorageInclude = {
    storage?: boolean | StorageArgs
    inventory?: boolean | InventoryArgs
  }

  export type InventoryStorageGetPayload<
    S extends boolean | null | undefined | InventoryStorageArgs,
    U = keyof S
      > = S extends true
        ? InventoryStorage
    : S extends undefined
    ? never
    : S extends InventoryStorageArgs | InventoryStorageFindManyArgs
    ?'include' extends U
    ? InventoryStorage  & {
    [P in TrueKeys<S['include']>]:
        P extends 'storage' ? StorageGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'inventory' ? InventoryGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'storage' ? StorageGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'inventory' ? InventoryGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof InventoryStorage ? InventoryStorage[P] : never
  } 
    : InventoryStorage
  : InventoryStorage


  type InventoryStorageCountArgs = Merge<
    Omit<InventoryStorageFindManyArgs, 'select' | 'include'> & {
      select?: InventoryStorageCountAggregateInputType | true
    }
  >

  export interface InventoryStorageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one InventoryStorage that matches the filter.
     * @param {InventoryStorageFindUniqueArgs} args - Arguments to find a InventoryStorage
     * @example
     * // Get one InventoryStorage
     * const inventoryStorage = await prisma.inventoryStorage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InventoryStorageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InventoryStorageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'InventoryStorage'> extends True ? CheckSelect<T, Prisma__InventoryStorageClient<InventoryStorage>, Prisma__InventoryStorageClient<InventoryStorageGetPayload<T>>> : CheckSelect<T, Prisma__InventoryStorageClient<InventoryStorage | null >, Prisma__InventoryStorageClient<InventoryStorageGetPayload<T> | null >>

    /**
     * Find the first InventoryStorage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryStorageFindFirstArgs} args - Arguments to find a InventoryStorage
     * @example
     * // Get one InventoryStorage
     * const inventoryStorage = await prisma.inventoryStorage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InventoryStorageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InventoryStorageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'InventoryStorage'> extends True ? CheckSelect<T, Prisma__InventoryStorageClient<InventoryStorage>, Prisma__InventoryStorageClient<InventoryStorageGetPayload<T>>> : CheckSelect<T, Prisma__InventoryStorageClient<InventoryStorage | null >, Prisma__InventoryStorageClient<InventoryStorageGetPayload<T> | null >>

    /**
     * Find zero or more InventoryStorages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryStorageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryStorages
     * const inventoryStorages = await prisma.inventoryStorage.findMany()
     * 
     * // Get first 10 InventoryStorages
     * const inventoryStorages = await prisma.inventoryStorage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryStorageWithIdOnly = await prisma.inventoryStorage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InventoryStorageFindManyArgs>(
      args?: SelectSubset<T, InventoryStorageFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<InventoryStorage>>, PrismaPromise<Array<InventoryStorageGetPayload<T>>>>

    /**
     * Create a InventoryStorage.
     * @param {InventoryStorageCreateArgs} args - Arguments to create a InventoryStorage.
     * @example
     * // Create one InventoryStorage
     * const InventoryStorage = await prisma.inventoryStorage.create({
     *   data: {
     *     // ... data to create a InventoryStorage
     *   }
     * })
     * 
    **/
    create<T extends InventoryStorageCreateArgs>(
      args: SelectSubset<T, InventoryStorageCreateArgs>
    ): CheckSelect<T, Prisma__InventoryStorageClient<InventoryStorage>, Prisma__InventoryStorageClient<InventoryStorageGetPayload<T>>>

    /**
     * Create many InventoryStorages.
     *     @param {InventoryStorageCreateManyArgs} args - Arguments to create many InventoryStorages.
     *     @example
     *     // Create many InventoryStorages
     *     const inventoryStorage = await prisma.inventoryStorage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InventoryStorageCreateManyArgs>(
      args?: SelectSubset<T, InventoryStorageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a InventoryStorage.
     * @param {InventoryStorageDeleteArgs} args - Arguments to delete one InventoryStorage.
     * @example
     * // Delete one InventoryStorage
     * const InventoryStorage = await prisma.inventoryStorage.delete({
     *   where: {
     *     // ... filter to delete one InventoryStorage
     *   }
     * })
     * 
    **/
    delete<T extends InventoryStorageDeleteArgs>(
      args: SelectSubset<T, InventoryStorageDeleteArgs>
    ): CheckSelect<T, Prisma__InventoryStorageClient<InventoryStorage>, Prisma__InventoryStorageClient<InventoryStorageGetPayload<T>>>

    /**
     * Update one InventoryStorage.
     * @param {InventoryStorageUpdateArgs} args - Arguments to update one InventoryStorage.
     * @example
     * // Update one InventoryStorage
     * const inventoryStorage = await prisma.inventoryStorage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InventoryStorageUpdateArgs>(
      args: SelectSubset<T, InventoryStorageUpdateArgs>
    ): CheckSelect<T, Prisma__InventoryStorageClient<InventoryStorage>, Prisma__InventoryStorageClient<InventoryStorageGetPayload<T>>>

    /**
     * Delete zero or more InventoryStorages.
     * @param {InventoryStorageDeleteManyArgs} args - Arguments to filter InventoryStorages to delete.
     * @example
     * // Delete a few InventoryStorages
     * const { count } = await prisma.inventoryStorage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InventoryStorageDeleteManyArgs>(
      args?: SelectSubset<T, InventoryStorageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryStorages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryStorageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryStorages
     * const inventoryStorage = await prisma.inventoryStorage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InventoryStorageUpdateManyArgs>(
      args: SelectSubset<T, InventoryStorageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one InventoryStorage.
     * @param {InventoryStorageUpsertArgs} args - Arguments to update or create a InventoryStorage.
     * @example
     * // Update or create a InventoryStorage
     * const inventoryStorage = await prisma.inventoryStorage.upsert({
     *   create: {
     *     // ... data to create a InventoryStorage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryStorage we want to update
     *   }
     * })
    **/
    upsert<T extends InventoryStorageUpsertArgs>(
      args: SelectSubset<T, InventoryStorageUpsertArgs>
    ): CheckSelect<T, Prisma__InventoryStorageClient<InventoryStorage>, Prisma__InventoryStorageClient<InventoryStorageGetPayload<T>>>

    /**
     * Find one InventoryStorage that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {InventoryStorageFindUniqueOrThrowArgs} args - Arguments to find a InventoryStorage
     * @example
     * // Get one InventoryStorage
     * const inventoryStorage = await prisma.inventoryStorage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InventoryStorageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, InventoryStorageFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__InventoryStorageClient<InventoryStorage>, Prisma__InventoryStorageClient<InventoryStorageGetPayload<T>>>

    /**
     * Find the first InventoryStorage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryStorageFindFirstOrThrowArgs} args - Arguments to find a InventoryStorage
     * @example
     * // Get one InventoryStorage
     * const inventoryStorage = await prisma.inventoryStorage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InventoryStorageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, InventoryStorageFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__InventoryStorageClient<InventoryStorage>, Prisma__InventoryStorageClient<InventoryStorageGetPayload<T>>>

    /**
     * Count the number of InventoryStorages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryStorageCountArgs} args - Arguments to filter InventoryStorages to count.
     * @example
     * // Count the number of InventoryStorages
     * const count = await prisma.inventoryStorage.count({
     *   where: {
     *     // ... the filter for the InventoryStorages we want to count
     *   }
     * })
    **/
    count<T extends InventoryStorageCountArgs>(
      args?: Subset<T, InventoryStorageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryStorageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryStorage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryStorageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryStorageAggregateArgs>(args: Subset<T, InventoryStorageAggregateArgs>): PrismaPromise<GetInventoryStorageAggregateType<T>>

    /**
     * Group by InventoryStorage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryStorageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryStorageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryStorageGroupByArgs['orderBy'] }
        : { orderBy?: InventoryStorageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryStorageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryStorageGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryStorage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InventoryStorageClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    storage<T extends StorageArgs = {}>(args?: Subset<T, StorageArgs>): CheckSelect<T, Prisma__StorageClient<Storage | null >, Prisma__StorageClient<StorageGetPayload<T> | null >>;

    inventory<T extends InventoryArgs = {}>(args?: Subset<T, InventoryArgs>): CheckSelect<T, Prisma__InventoryClient<Inventory | null >, Prisma__InventoryClient<InventoryGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * InventoryStorage base type for findUnique actions
   */
  export type InventoryStorageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     * 
    **/
    select?: InventoryStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryStorageInclude | null
    /**
     * Filter, which InventoryStorage to fetch.
     * 
    **/
    where: InventoryStorageWhereUniqueInput
  }

  /**
   * InventoryStorage: findUnique
   */
  export interface InventoryStorageFindUniqueArgs extends InventoryStorageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * InventoryStorage base type for findFirst actions
   */
  export type InventoryStorageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     * 
    **/
    select?: InventoryStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryStorageInclude | null
    /**
     * Filter, which InventoryStorage to fetch.
     * 
    **/
    where?: InventoryStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryStorages to fetch.
     * 
    **/
    orderBy?: Enumerable<InventoryStorageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryStorages.
     * 
    **/
    cursor?: InventoryStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryStorages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryStorages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryStorages.
     * 
    **/
    distinct?: Enumerable<InventoryStorageScalarFieldEnum>
  }

  /**
   * InventoryStorage: findFirst
   */
  export interface InventoryStorageFindFirstArgs extends InventoryStorageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * InventoryStorage findMany
   */
  export type InventoryStorageFindManyArgs = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     * 
    **/
    select?: InventoryStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryStorageInclude | null
    /**
     * Filter, which InventoryStorages to fetch.
     * 
    **/
    where?: InventoryStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryStorages to fetch.
     * 
    **/
    orderBy?: Enumerable<InventoryStorageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryStorages.
     * 
    **/
    cursor?: InventoryStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryStorages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryStorages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InventoryStorageScalarFieldEnum>
  }


  /**
   * InventoryStorage create
   */
  export type InventoryStorageCreateArgs = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     * 
    **/
    select?: InventoryStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryStorageInclude | null
    /**
     * The data needed to create a InventoryStorage.
     * 
    **/
    data: XOR<InventoryStorageCreateInput, InventoryStorageUncheckedCreateInput>
  }


  /**
   * InventoryStorage createMany
   */
  export type InventoryStorageCreateManyArgs = {
    /**
     * The data used to create many InventoryStorages.
     * 
    **/
    data: Enumerable<InventoryStorageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * InventoryStorage update
   */
  export type InventoryStorageUpdateArgs = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     * 
    **/
    select?: InventoryStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryStorageInclude | null
    /**
     * The data needed to update a InventoryStorage.
     * 
    **/
    data: XOR<InventoryStorageUpdateInput, InventoryStorageUncheckedUpdateInput>
    /**
     * Choose, which InventoryStorage to update.
     * 
    **/
    where: InventoryStorageWhereUniqueInput
  }


  /**
   * InventoryStorage updateMany
   */
  export type InventoryStorageUpdateManyArgs = {
    /**
     * The data used to update InventoryStorages.
     * 
    **/
    data: XOR<InventoryStorageUpdateManyMutationInput, InventoryStorageUncheckedUpdateManyInput>
    /**
     * Filter which InventoryStorages to update
     * 
    **/
    where?: InventoryStorageWhereInput
  }


  /**
   * InventoryStorage upsert
   */
  export type InventoryStorageUpsertArgs = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     * 
    **/
    select?: InventoryStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryStorageInclude | null
    /**
     * The filter to search for the InventoryStorage to update in case it exists.
     * 
    **/
    where: InventoryStorageWhereUniqueInput
    /**
     * In case the InventoryStorage found by the `where` argument doesn't exist, create a new InventoryStorage with this data.
     * 
    **/
    create: XOR<InventoryStorageCreateInput, InventoryStorageUncheckedCreateInput>
    /**
     * In case the InventoryStorage was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<InventoryStorageUpdateInput, InventoryStorageUncheckedUpdateInput>
  }


  /**
   * InventoryStorage delete
   */
  export type InventoryStorageDeleteArgs = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     * 
    **/
    select?: InventoryStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryStorageInclude | null
    /**
     * Filter which InventoryStorage to delete.
     * 
    **/
    where: InventoryStorageWhereUniqueInput
  }


  /**
   * InventoryStorage deleteMany
   */
  export type InventoryStorageDeleteManyArgs = {
    /**
     * Filter which InventoryStorages to delete
     * 
    **/
    where?: InventoryStorageWhereInput
  }


  /**
   * InventoryStorage: findUniqueOrThrow
   */
  export type InventoryStorageFindUniqueOrThrowArgs = InventoryStorageFindUniqueArgsBase
      

  /**
   * InventoryStorage: findFirstOrThrow
   */
  export type InventoryStorageFindFirstOrThrowArgs = InventoryStorageFindFirstArgsBase
      

  /**
   * InventoryStorage without action
   */
  export type InventoryStorageArgs = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     * 
    **/
    select?: InventoryStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InventoryStorageInclude | null
  }



  /**
   * Model Storage
   */


  export type AggregateStorage = {
    _count: StorageCountAggregateOutputType | null
    _avg: StorageAvgAggregateOutputType | null
    _sum: StorageSumAggregateOutputType | null
    _min: StorageMinAggregateOutputType | null
    _max: StorageMaxAggregateOutputType | null
  }

  export type StorageAvgAggregateOutputType = {
    id: number | null
  }

  export type StorageSumAggregateOutputType = {
    id: number | null
  }

  export type StorageMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
  }

  export type StorageMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
  }

  export type StorageCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    editedAt: number
    createdById: number
    editedById: number
    _all: number
  }


  export type StorageAvgAggregateInputType = {
    id?: true
  }

  export type StorageSumAggregateInputType = {
    id?: true
  }

  export type StorageMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
  }

  export type StorageMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
  }

  export type StorageCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
    _all?: true
  }

  export type StorageAggregateArgs = {
    /**
     * Filter which Storage to aggregate.
     * 
    **/
    where?: StorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Storages to fetch.
     * 
    **/
    orderBy?: Enumerable<StorageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: StorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Storages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Storages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Storages
    **/
    _count?: true | StorageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StorageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StorageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StorageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StorageMaxAggregateInputType
  }

  export type GetStorageAggregateType<T extends StorageAggregateArgs> = {
        [P in keyof T & keyof AggregateStorage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStorage[P]>
      : GetScalarType<T[P], AggregateStorage[P]>
  }




  export type StorageGroupByArgs = {
    where?: StorageWhereInput
    orderBy?: Enumerable<StorageOrderByWithAggregationInput>
    by: Array<StorageScalarFieldEnum>
    having?: StorageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StorageCountAggregateInputType | true
    _avg?: StorageAvgAggregateInputType
    _sum?: StorageSumAggregateInputType
    _min?: StorageMinAggregateInputType
    _max?: StorageMaxAggregateInputType
  }


  export type StorageGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    editedAt: Date
    createdById: string
    editedById: string
    _count: StorageCountAggregateOutputType | null
    _avg: StorageAvgAggregateOutputType | null
    _sum: StorageSumAggregateOutputType | null
    _min: StorageMinAggregateOutputType | null
    _max: StorageMaxAggregateOutputType | null
  }

  type GetStorageGroupByPayload<T extends StorageGroupByArgs> = PrismaPromise<
    Array<
      PickArray<StorageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StorageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StorageGroupByOutputType[P]>
            : GetScalarType<T[P], StorageGroupByOutputType[P]>
        }
      >
    >


  export type StorageSelect = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    editedAt?: boolean
    createdById?: boolean
    editedById?: boolean
    createdBy?: boolean | UserArgs
    editedBy?: boolean | UserArgs
    inventoryStorage?: boolean | InventoryStorageFindManyArgs
    ingredientStorage?: boolean | ingredientStorageFindManyArgs
    userStorage?: boolean | UserStorageFindManyArgs
    _count?: boolean | StorageCountOutputTypeArgs
  }

  export type StorageInclude = {
    createdBy?: boolean | UserArgs
    editedBy?: boolean | UserArgs
    inventoryStorage?: boolean | InventoryStorageFindManyArgs
    ingredientStorage?: boolean | ingredientStorageFindManyArgs
    userStorage?: boolean | UserStorageFindManyArgs
    _count?: boolean | StorageCountOutputTypeArgs
  }

  export type StorageGetPayload<
    S extends boolean | null | undefined | StorageArgs,
    U = keyof S
      > = S extends true
        ? Storage
    : S extends undefined
    ? never
    : S extends StorageArgs | StorageFindManyArgs
    ?'include' extends U
    ? Storage  & {
    [P in TrueKeys<S['include']>]:
        P extends 'createdBy' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'editedBy' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'inventoryStorage' ? Array < InventoryStorageGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'ingredientStorage' ? Array < ingredientStorageGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'userStorage' ? Array < UserStorageGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? StorageCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'createdBy' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'editedBy' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'inventoryStorage' ? Array < InventoryStorageGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'ingredientStorage' ? Array < ingredientStorageGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'userStorage' ? Array < UserStorageGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? StorageCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Storage ? Storage[P] : never
  } 
    : Storage
  : Storage


  type StorageCountArgs = Merge<
    Omit<StorageFindManyArgs, 'select' | 'include'> & {
      select?: StorageCountAggregateInputType | true
    }
  >

  export interface StorageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Storage that matches the filter.
     * @param {StorageFindUniqueArgs} args - Arguments to find a Storage
     * @example
     * // Get one Storage
     * const storage = await prisma.storage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StorageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StorageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Storage'> extends True ? CheckSelect<T, Prisma__StorageClient<Storage>, Prisma__StorageClient<StorageGetPayload<T>>> : CheckSelect<T, Prisma__StorageClient<Storage | null >, Prisma__StorageClient<StorageGetPayload<T> | null >>

    /**
     * Find the first Storage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageFindFirstArgs} args - Arguments to find a Storage
     * @example
     * // Get one Storage
     * const storage = await prisma.storage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StorageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StorageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Storage'> extends True ? CheckSelect<T, Prisma__StorageClient<Storage>, Prisma__StorageClient<StorageGetPayload<T>>> : CheckSelect<T, Prisma__StorageClient<Storage | null >, Prisma__StorageClient<StorageGetPayload<T> | null >>

    /**
     * Find zero or more Storages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Storages
     * const storages = await prisma.storage.findMany()
     * 
     * // Get first 10 Storages
     * const storages = await prisma.storage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storageWithIdOnly = await prisma.storage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StorageFindManyArgs>(
      args?: SelectSubset<T, StorageFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Storage>>, PrismaPromise<Array<StorageGetPayload<T>>>>

    /**
     * Create a Storage.
     * @param {StorageCreateArgs} args - Arguments to create a Storage.
     * @example
     * // Create one Storage
     * const Storage = await prisma.storage.create({
     *   data: {
     *     // ... data to create a Storage
     *   }
     * })
     * 
    **/
    create<T extends StorageCreateArgs>(
      args: SelectSubset<T, StorageCreateArgs>
    ): CheckSelect<T, Prisma__StorageClient<Storage>, Prisma__StorageClient<StorageGetPayload<T>>>

    /**
     * Create many Storages.
     *     @param {StorageCreateManyArgs} args - Arguments to create many Storages.
     *     @example
     *     // Create many Storages
     *     const storage = await prisma.storage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StorageCreateManyArgs>(
      args?: SelectSubset<T, StorageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Storage.
     * @param {StorageDeleteArgs} args - Arguments to delete one Storage.
     * @example
     * // Delete one Storage
     * const Storage = await prisma.storage.delete({
     *   where: {
     *     // ... filter to delete one Storage
     *   }
     * })
     * 
    **/
    delete<T extends StorageDeleteArgs>(
      args: SelectSubset<T, StorageDeleteArgs>
    ): CheckSelect<T, Prisma__StorageClient<Storage>, Prisma__StorageClient<StorageGetPayload<T>>>

    /**
     * Update one Storage.
     * @param {StorageUpdateArgs} args - Arguments to update one Storage.
     * @example
     * // Update one Storage
     * const storage = await prisma.storage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StorageUpdateArgs>(
      args: SelectSubset<T, StorageUpdateArgs>
    ): CheckSelect<T, Prisma__StorageClient<Storage>, Prisma__StorageClient<StorageGetPayload<T>>>

    /**
     * Delete zero or more Storages.
     * @param {StorageDeleteManyArgs} args - Arguments to filter Storages to delete.
     * @example
     * // Delete a few Storages
     * const { count } = await prisma.storage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StorageDeleteManyArgs>(
      args?: SelectSubset<T, StorageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Storages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Storages
     * const storage = await prisma.storage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StorageUpdateManyArgs>(
      args: SelectSubset<T, StorageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Storage.
     * @param {StorageUpsertArgs} args - Arguments to update or create a Storage.
     * @example
     * // Update or create a Storage
     * const storage = await prisma.storage.upsert({
     *   create: {
     *     // ... data to create a Storage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Storage we want to update
     *   }
     * })
    **/
    upsert<T extends StorageUpsertArgs>(
      args: SelectSubset<T, StorageUpsertArgs>
    ): CheckSelect<T, Prisma__StorageClient<Storage>, Prisma__StorageClient<StorageGetPayload<T>>>

    /**
     * Find one Storage that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {StorageFindUniqueOrThrowArgs} args - Arguments to find a Storage
     * @example
     * // Get one Storage
     * const storage = await prisma.storage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StorageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, StorageFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__StorageClient<Storage>, Prisma__StorageClient<StorageGetPayload<T>>>

    /**
     * Find the first Storage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageFindFirstOrThrowArgs} args - Arguments to find a Storage
     * @example
     * // Get one Storage
     * const storage = await prisma.storage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StorageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, StorageFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__StorageClient<Storage>, Prisma__StorageClient<StorageGetPayload<T>>>

    /**
     * Count the number of Storages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageCountArgs} args - Arguments to filter Storages to count.
     * @example
     * // Count the number of Storages
     * const count = await prisma.storage.count({
     *   where: {
     *     // ... the filter for the Storages we want to count
     *   }
     * })
    **/
    count<T extends StorageCountArgs>(
      args?: Subset<T, StorageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StorageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Storage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StorageAggregateArgs>(args: Subset<T, StorageAggregateArgs>): PrismaPromise<GetStorageAggregateType<T>>

    /**
     * Group by Storage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StorageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StorageGroupByArgs['orderBy'] }
        : { orderBy?: StorageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StorageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStorageGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Storage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StorageClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    createdBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    editedBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    inventoryStorage<T extends InventoryStorageFindManyArgs = {}>(args?: Subset<T, InventoryStorageFindManyArgs>): CheckSelect<T, PrismaPromise<Array<InventoryStorage>>, PrismaPromise<Array<InventoryStorageGetPayload<T>>>>;

    ingredientStorage<T extends ingredientStorageFindManyArgs = {}>(args?: Subset<T, ingredientStorageFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ingredientStorage>>, PrismaPromise<Array<ingredientStorageGetPayload<T>>>>;

    userStorage<T extends UserStorageFindManyArgs = {}>(args?: Subset<T, UserStorageFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserStorage>>, PrismaPromise<Array<UserStorageGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Storage base type for findUnique actions
   */
  export type StorageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Storage
     * 
    **/
    select?: StorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StorageInclude | null
    /**
     * Filter, which Storage to fetch.
     * 
    **/
    where: StorageWhereUniqueInput
  }

  /**
   * Storage: findUnique
   */
  export interface StorageFindUniqueArgs extends StorageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Storage base type for findFirst actions
   */
  export type StorageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Storage
     * 
    **/
    select?: StorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StorageInclude | null
    /**
     * Filter, which Storage to fetch.
     * 
    **/
    where?: StorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Storages to fetch.
     * 
    **/
    orderBy?: Enumerable<StorageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Storages.
     * 
    **/
    cursor?: StorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Storages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Storages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Storages.
     * 
    **/
    distinct?: Enumerable<StorageScalarFieldEnum>
  }

  /**
   * Storage: findFirst
   */
  export interface StorageFindFirstArgs extends StorageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Storage findMany
   */
  export type StorageFindManyArgs = {
    /**
     * Select specific fields to fetch from the Storage
     * 
    **/
    select?: StorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StorageInclude | null
    /**
     * Filter, which Storages to fetch.
     * 
    **/
    where?: StorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Storages to fetch.
     * 
    **/
    orderBy?: Enumerable<StorageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Storages.
     * 
    **/
    cursor?: StorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Storages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Storages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StorageScalarFieldEnum>
  }


  /**
   * Storage create
   */
  export type StorageCreateArgs = {
    /**
     * Select specific fields to fetch from the Storage
     * 
    **/
    select?: StorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StorageInclude | null
    /**
     * The data needed to create a Storage.
     * 
    **/
    data: XOR<StorageCreateInput, StorageUncheckedCreateInput>
  }


  /**
   * Storage createMany
   */
  export type StorageCreateManyArgs = {
    /**
     * The data used to create many Storages.
     * 
    **/
    data: Enumerable<StorageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Storage update
   */
  export type StorageUpdateArgs = {
    /**
     * Select specific fields to fetch from the Storage
     * 
    **/
    select?: StorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StorageInclude | null
    /**
     * The data needed to update a Storage.
     * 
    **/
    data: XOR<StorageUpdateInput, StorageUncheckedUpdateInput>
    /**
     * Choose, which Storage to update.
     * 
    **/
    where: StorageWhereUniqueInput
  }


  /**
   * Storage updateMany
   */
  export type StorageUpdateManyArgs = {
    /**
     * The data used to update Storages.
     * 
    **/
    data: XOR<StorageUpdateManyMutationInput, StorageUncheckedUpdateManyInput>
    /**
     * Filter which Storages to update
     * 
    **/
    where?: StorageWhereInput
  }


  /**
   * Storage upsert
   */
  export type StorageUpsertArgs = {
    /**
     * Select specific fields to fetch from the Storage
     * 
    **/
    select?: StorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StorageInclude | null
    /**
     * The filter to search for the Storage to update in case it exists.
     * 
    **/
    where: StorageWhereUniqueInput
    /**
     * In case the Storage found by the `where` argument doesn't exist, create a new Storage with this data.
     * 
    **/
    create: XOR<StorageCreateInput, StorageUncheckedCreateInput>
    /**
     * In case the Storage was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<StorageUpdateInput, StorageUncheckedUpdateInput>
  }


  /**
   * Storage delete
   */
  export type StorageDeleteArgs = {
    /**
     * Select specific fields to fetch from the Storage
     * 
    **/
    select?: StorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StorageInclude | null
    /**
     * Filter which Storage to delete.
     * 
    **/
    where: StorageWhereUniqueInput
  }


  /**
   * Storage deleteMany
   */
  export type StorageDeleteManyArgs = {
    /**
     * Filter which Storages to delete
     * 
    **/
    where?: StorageWhereInput
  }


  /**
   * Storage: findUniqueOrThrow
   */
  export type StorageFindUniqueOrThrowArgs = StorageFindUniqueArgsBase
      

  /**
   * Storage: findFirstOrThrow
   */
  export type StorageFindFirstOrThrowArgs = StorageFindFirstArgsBase
      

  /**
   * Storage without action
   */
  export type StorageArgs = {
    /**
     * Select specific fields to fetch from the Storage
     * 
    **/
    select?: StorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StorageInclude | null
  }



  /**
   * Model ingredientStorage
   */


  export type AggregateIngredientStorage = {
    _count: IngredientStorageCountAggregateOutputType | null
    _avg: IngredientStorageAvgAggregateOutputType | null
    _sum: IngredientStorageSumAggregateOutputType | null
    _min: IngredientStorageMinAggregateOutputType | null
    _max: IngredientStorageMaxAggregateOutputType | null
  }

  export type IngredientStorageAvgAggregateOutputType = {
    id: number | null
    ingredientId: number | null
    quantity: number | null
    storageId: number | null
  }

  export type IngredientStorageSumAggregateOutputType = {
    id: number | null
    ingredientId: number | null
    quantity: number | null
    storageId: number | null
  }

  export type IngredientStorageMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    editedAt: Date | null
    ingredientId: number | null
    quantity: number | null
    storageId: number | null
  }

  export type IngredientStorageMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    editedAt: Date | null
    ingredientId: number | null
    quantity: number | null
    storageId: number | null
  }

  export type IngredientStorageCountAggregateOutputType = {
    id: number
    createdAt: number
    editedAt: number
    ingredientId: number
    quantity: number
    storageId: number
    _all: number
  }


  export type IngredientStorageAvgAggregateInputType = {
    id?: true
    ingredientId?: true
    quantity?: true
    storageId?: true
  }

  export type IngredientStorageSumAggregateInputType = {
    id?: true
    ingredientId?: true
    quantity?: true
    storageId?: true
  }

  export type IngredientStorageMinAggregateInputType = {
    id?: true
    createdAt?: true
    editedAt?: true
    ingredientId?: true
    quantity?: true
    storageId?: true
  }

  export type IngredientStorageMaxAggregateInputType = {
    id?: true
    createdAt?: true
    editedAt?: true
    ingredientId?: true
    quantity?: true
    storageId?: true
  }

  export type IngredientStorageCountAggregateInputType = {
    id?: true
    createdAt?: true
    editedAt?: true
    ingredientId?: true
    quantity?: true
    storageId?: true
    _all?: true
  }

  export type IngredientStorageAggregateArgs = {
    /**
     * Filter which ingredientStorage to aggregate.
     * 
    **/
    where?: ingredientStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ingredientStorages to fetch.
     * 
    **/
    orderBy?: Enumerable<ingredientStorageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ingredientStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ingredientStorages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ingredientStorages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ingredientStorages
    **/
    _count?: true | IngredientStorageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IngredientStorageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IngredientStorageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IngredientStorageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IngredientStorageMaxAggregateInputType
  }

  export type GetIngredientStorageAggregateType<T extends IngredientStorageAggregateArgs> = {
        [P in keyof T & keyof AggregateIngredientStorage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIngredientStorage[P]>
      : GetScalarType<T[P], AggregateIngredientStorage[P]>
  }




  export type IngredientStorageGroupByArgs = {
    where?: ingredientStorageWhereInput
    orderBy?: Enumerable<ingredientStorageOrderByWithAggregationInput>
    by: Array<IngredientStorageScalarFieldEnum>
    having?: ingredientStorageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IngredientStorageCountAggregateInputType | true
    _avg?: IngredientStorageAvgAggregateInputType
    _sum?: IngredientStorageSumAggregateInputType
    _min?: IngredientStorageMinAggregateInputType
    _max?: IngredientStorageMaxAggregateInputType
  }


  export type IngredientStorageGroupByOutputType = {
    id: number
    createdAt: Date
    editedAt: Date
    ingredientId: number | null
    quantity: number | null
    storageId: number | null
    _count: IngredientStorageCountAggregateOutputType | null
    _avg: IngredientStorageAvgAggregateOutputType | null
    _sum: IngredientStorageSumAggregateOutputType | null
    _min: IngredientStorageMinAggregateOutputType | null
    _max: IngredientStorageMaxAggregateOutputType | null
  }

  type GetIngredientStorageGroupByPayload<T extends IngredientStorageGroupByArgs> = PrismaPromise<
    Array<
      PickArray<IngredientStorageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IngredientStorageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IngredientStorageGroupByOutputType[P]>
            : GetScalarType<T[P], IngredientStorageGroupByOutputType[P]>
        }
      >
    >


  export type ingredientStorageSelect = {
    id?: boolean
    createdAt?: boolean
    editedAt?: boolean
    ingredientId?: boolean
    ingredient?: boolean | IngredientArgs
    quantity?: boolean
    Storage?: boolean | StorageArgs
    storageId?: boolean
  }

  export type ingredientStorageInclude = {
    ingredient?: boolean | IngredientArgs
    Storage?: boolean | StorageArgs
  }

  export type ingredientStorageGetPayload<
    S extends boolean | null | undefined | ingredientStorageArgs,
    U = keyof S
      > = S extends true
        ? ingredientStorage
    : S extends undefined
    ? never
    : S extends ingredientStorageArgs | ingredientStorageFindManyArgs
    ?'include' extends U
    ? ingredientStorage  & {
    [P in TrueKeys<S['include']>]:
        P extends 'ingredient' ? IngredientGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'Storage' ? StorageGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'ingredient' ? IngredientGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'Storage' ? StorageGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof ingredientStorage ? ingredientStorage[P] : never
  } 
    : ingredientStorage
  : ingredientStorage


  type ingredientStorageCountArgs = Merge<
    Omit<ingredientStorageFindManyArgs, 'select' | 'include'> & {
      select?: IngredientStorageCountAggregateInputType | true
    }
  >

  export interface ingredientStorageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one IngredientStorage that matches the filter.
     * @param {ingredientStorageFindUniqueArgs} args - Arguments to find a IngredientStorage
     * @example
     * // Get one IngredientStorage
     * const ingredientStorage = await prisma.ingredientStorage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ingredientStorageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ingredientStorageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ingredientStorage'> extends True ? CheckSelect<T, Prisma__ingredientStorageClient<ingredientStorage>, Prisma__ingredientStorageClient<ingredientStorageGetPayload<T>>> : CheckSelect<T, Prisma__ingredientStorageClient<ingredientStorage | null >, Prisma__ingredientStorageClient<ingredientStorageGetPayload<T> | null >>

    /**
     * Find the first IngredientStorage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ingredientStorageFindFirstArgs} args - Arguments to find a IngredientStorage
     * @example
     * // Get one IngredientStorage
     * const ingredientStorage = await prisma.ingredientStorage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ingredientStorageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ingredientStorageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ingredientStorage'> extends True ? CheckSelect<T, Prisma__ingredientStorageClient<ingredientStorage>, Prisma__ingredientStorageClient<ingredientStorageGetPayload<T>>> : CheckSelect<T, Prisma__ingredientStorageClient<ingredientStorage | null >, Prisma__ingredientStorageClient<ingredientStorageGetPayload<T> | null >>

    /**
     * Find zero or more IngredientStorages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ingredientStorageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IngredientStorages
     * const ingredientStorages = await prisma.ingredientStorage.findMany()
     * 
     * // Get first 10 IngredientStorages
     * const ingredientStorages = await prisma.ingredientStorage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ingredientStorageWithIdOnly = await prisma.ingredientStorage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ingredientStorageFindManyArgs>(
      args?: SelectSubset<T, ingredientStorageFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ingredientStorage>>, PrismaPromise<Array<ingredientStorageGetPayload<T>>>>

    /**
     * Create a IngredientStorage.
     * @param {ingredientStorageCreateArgs} args - Arguments to create a IngredientStorage.
     * @example
     * // Create one IngredientStorage
     * const IngredientStorage = await prisma.ingredientStorage.create({
     *   data: {
     *     // ... data to create a IngredientStorage
     *   }
     * })
     * 
    **/
    create<T extends ingredientStorageCreateArgs>(
      args: SelectSubset<T, ingredientStorageCreateArgs>
    ): CheckSelect<T, Prisma__ingredientStorageClient<ingredientStorage>, Prisma__ingredientStorageClient<ingredientStorageGetPayload<T>>>

    /**
     * Create many IngredientStorages.
     *     @param {ingredientStorageCreateManyArgs} args - Arguments to create many IngredientStorages.
     *     @example
     *     // Create many IngredientStorages
     *     const ingredientStorage = await prisma.ingredientStorage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ingredientStorageCreateManyArgs>(
      args?: SelectSubset<T, ingredientStorageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a IngredientStorage.
     * @param {ingredientStorageDeleteArgs} args - Arguments to delete one IngredientStorage.
     * @example
     * // Delete one IngredientStorage
     * const IngredientStorage = await prisma.ingredientStorage.delete({
     *   where: {
     *     // ... filter to delete one IngredientStorage
     *   }
     * })
     * 
    **/
    delete<T extends ingredientStorageDeleteArgs>(
      args: SelectSubset<T, ingredientStorageDeleteArgs>
    ): CheckSelect<T, Prisma__ingredientStorageClient<ingredientStorage>, Prisma__ingredientStorageClient<ingredientStorageGetPayload<T>>>

    /**
     * Update one IngredientStorage.
     * @param {ingredientStorageUpdateArgs} args - Arguments to update one IngredientStorage.
     * @example
     * // Update one IngredientStorage
     * const ingredientStorage = await prisma.ingredientStorage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ingredientStorageUpdateArgs>(
      args: SelectSubset<T, ingredientStorageUpdateArgs>
    ): CheckSelect<T, Prisma__ingredientStorageClient<ingredientStorage>, Prisma__ingredientStorageClient<ingredientStorageGetPayload<T>>>

    /**
     * Delete zero or more IngredientStorages.
     * @param {ingredientStorageDeleteManyArgs} args - Arguments to filter IngredientStorages to delete.
     * @example
     * // Delete a few IngredientStorages
     * const { count } = await prisma.ingredientStorage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ingredientStorageDeleteManyArgs>(
      args?: SelectSubset<T, ingredientStorageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more IngredientStorages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ingredientStorageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IngredientStorages
     * const ingredientStorage = await prisma.ingredientStorage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ingredientStorageUpdateManyArgs>(
      args: SelectSubset<T, ingredientStorageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one IngredientStorage.
     * @param {ingredientStorageUpsertArgs} args - Arguments to update or create a IngredientStorage.
     * @example
     * // Update or create a IngredientStorage
     * const ingredientStorage = await prisma.ingredientStorage.upsert({
     *   create: {
     *     // ... data to create a IngredientStorage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IngredientStorage we want to update
     *   }
     * })
    **/
    upsert<T extends ingredientStorageUpsertArgs>(
      args: SelectSubset<T, ingredientStorageUpsertArgs>
    ): CheckSelect<T, Prisma__ingredientStorageClient<ingredientStorage>, Prisma__ingredientStorageClient<ingredientStorageGetPayload<T>>>

    /**
     * Find one IngredientStorage that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ingredientStorageFindUniqueOrThrowArgs} args - Arguments to find a IngredientStorage
     * @example
     * // Get one IngredientStorage
     * const ingredientStorage = await prisma.ingredientStorage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ingredientStorageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ingredientStorageFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ingredientStorageClient<ingredientStorage>, Prisma__ingredientStorageClient<ingredientStorageGetPayload<T>>>

    /**
     * Find the first IngredientStorage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ingredientStorageFindFirstOrThrowArgs} args - Arguments to find a IngredientStorage
     * @example
     * // Get one IngredientStorage
     * const ingredientStorage = await prisma.ingredientStorage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ingredientStorageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ingredientStorageFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ingredientStorageClient<ingredientStorage>, Prisma__ingredientStorageClient<ingredientStorageGetPayload<T>>>

    /**
     * Count the number of IngredientStorages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ingredientStorageCountArgs} args - Arguments to filter IngredientStorages to count.
     * @example
     * // Count the number of IngredientStorages
     * const count = await prisma.ingredientStorage.count({
     *   where: {
     *     // ... the filter for the IngredientStorages we want to count
     *   }
     * })
    **/
    count<T extends ingredientStorageCountArgs>(
      args?: Subset<T, ingredientStorageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IngredientStorageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IngredientStorage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientStorageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IngredientStorageAggregateArgs>(args: Subset<T, IngredientStorageAggregateArgs>): PrismaPromise<GetIngredientStorageAggregateType<T>>

    /**
     * Group by IngredientStorage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientStorageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IngredientStorageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IngredientStorageGroupByArgs['orderBy'] }
        : { orderBy?: IngredientStorageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IngredientStorageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIngredientStorageGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ingredientStorage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ingredientStorageClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    ingredient<T extends IngredientArgs = {}>(args?: Subset<T, IngredientArgs>): CheckSelect<T, Prisma__IngredientClient<Ingredient | null >, Prisma__IngredientClient<IngredientGetPayload<T> | null >>;

    Storage<T extends StorageArgs = {}>(args?: Subset<T, StorageArgs>): CheckSelect<T, Prisma__StorageClient<Storage | null >, Prisma__StorageClient<StorageGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ingredientStorage base type for findUnique actions
   */
  export type ingredientStorageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ingredientStorage
     * 
    **/
    select?: ingredientStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ingredientStorageInclude | null
    /**
     * Filter, which ingredientStorage to fetch.
     * 
    **/
    where: ingredientStorageWhereUniqueInput
  }

  /**
   * ingredientStorage: findUnique
   */
  export interface ingredientStorageFindUniqueArgs extends ingredientStorageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ingredientStorage base type for findFirst actions
   */
  export type ingredientStorageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ingredientStorage
     * 
    **/
    select?: ingredientStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ingredientStorageInclude | null
    /**
     * Filter, which ingredientStorage to fetch.
     * 
    **/
    where?: ingredientStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ingredientStorages to fetch.
     * 
    **/
    orderBy?: Enumerable<ingredientStorageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ingredientStorages.
     * 
    **/
    cursor?: ingredientStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ingredientStorages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ingredientStorages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ingredientStorages.
     * 
    **/
    distinct?: Enumerable<IngredientStorageScalarFieldEnum>
  }

  /**
   * ingredientStorage: findFirst
   */
  export interface ingredientStorageFindFirstArgs extends ingredientStorageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ingredientStorage findMany
   */
  export type ingredientStorageFindManyArgs = {
    /**
     * Select specific fields to fetch from the ingredientStorage
     * 
    **/
    select?: ingredientStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ingredientStorageInclude | null
    /**
     * Filter, which ingredientStorages to fetch.
     * 
    **/
    where?: ingredientStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ingredientStorages to fetch.
     * 
    **/
    orderBy?: Enumerable<ingredientStorageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ingredientStorages.
     * 
    **/
    cursor?: ingredientStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ingredientStorages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ingredientStorages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<IngredientStorageScalarFieldEnum>
  }


  /**
   * ingredientStorage create
   */
  export type ingredientStorageCreateArgs = {
    /**
     * Select specific fields to fetch from the ingredientStorage
     * 
    **/
    select?: ingredientStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ingredientStorageInclude | null
    /**
     * The data needed to create a ingredientStorage.
     * 
    **/
    data: XOR<ingredientStorageCreateInput, ingredientStorageUncheckedCreateInput>
  }


  /**
   * ingredientStorage createMany
   */
  export type ingredientStorageCreateManyArgs = {
    /**
     * The data used to create many ingredientStorages.
     * 
    **/
    data: Enumerable<ingredientStorageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ingredientStorage update
   */
  export type ingredientStorageUpdateArgs = {
    /**
     * Select specific fields to fetch from the ingredientStorage
     * 
    **/
    select?: ingredientStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ingredientStorageInclude | null
    /**
     * The data needed to update a ingredientStorage.
     * 
    **/
    data: XOR<ingredientStorageUpdateInput, ingredientStorageUncheckedUpdateInput>
    /**
     * Choose, which ingredientStorage to update.
     * 
    **/
    where: ingredientStorageWhereUniqueInput
  }


  /**
   * ingredientStorage updateMany
   */
  export type ingredientStorageUpdateManyArgs = {
    /**
     * The data used to update ingredientStorages.
     * 
    **/
    data: XOR<ingredientStorageUpdateManyMutationInput, ingredientStorageUncheckedUpdateManyInput>
    /**
     * Filter which ingredientStorages to update
     * 
    **/
    where?: ingredientStorageWhereInput
  }


  /**
   * ingredientStorage upsert
   */
  export type ingredientStorageUpsertArgs = {
    /**
     * Select specific fields to fetch from the ingredientStorage
     * 
    **/
    select?: ingredientStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ingredientStorageInclude | null
    /**
     * The filter to search for the ingredientStorage to update in case it exists.
     * 
    **/
    where: ingredientStorageWhereUniqueInput
    /**
     * In case the ingredientStorage found by the `where` argument doesn't exist, create a new ingredientStorage with this data.
     * 
    **/
    create: XOR<ingredientStorageCreateInput, ingredientStorageUncheckedCreateInput>
    /**
     * In case the ingredientStorage was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ingredientStorageUpdateInput, ingredientStorageUncheckedUpdateInput>
  }


  /**
   * ingredientStorage delete
   */
  export type ingredientStorageDeleteArgs = {
    /**
     * Select specific fields to fetch from the ingredientStorage
     * 
    **/
    select?: ingredientStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ingredientStorageInclude | null
    /**
     * Filter which ingredientStorage to delete.
     * 
    **/
    where: ingredientStorageWhereUniqueInput
  }


  /**
   * ingredientStorage deleteMany
   */
  export type ingredientStorageDeleteManyArgs = {
    /**
     * Filter which ingredientStorages to delete
     * 
    **/
    where?: ingredientStorageWhereInput
  }


  /**
   * ingredientStorage: findUniqueOrThrow
   */
  export type ingredientStorageFindUniqueOrThrowArgs = ingredientStorageFindUniqueArgsBase
      

  /**
   * ingredientStorage: findFirstOrThrow
   */
  export type ingredientStorageFindFirstOrThrowArgs = ingredientStorageFindFirstArgsBase
      

  /**
   * ingredientStorage without action
   */
  export type ingredientStorageArgs = {
    /**
     * Select specific fields to fetch from the ingredientStorage
     * 
    **/
    select?: ingredientStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ingredientStorageInclude | null
  }



  /**
   * Model UserStorage
   */


  export type AggregateUserStorage = {
    _count: UserStorageCountAggregateOutputType | null
    _avg: UserStorageAvgAggregateOutputType | null
    _sum: UserStorageSumAggregateOutputType | null
    _min: UserStorageMinAggregateOutputType | null
    _max: UserStorageMaxAggregateOutputType | null
  }

  export type UserStorageAvgAggregateOutputType = {
    id: number | null
    quantity: number | null
    storageId: number | null
  }

  export type UserStorageSumAggregateOutputType = {
    id: number | null
    quantity: number | null
    storageId: number | null
  }

  export type UserStorageMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    editedAt: Date | null
    userId: string | null
    quantity: number | null
    storageId: number | null
    partner: boolean | null
    manager: boolean | null
  }

  export type UserStorageMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    editedAt: Date | null
    userId: string | null
    quantity: number | null
    storageId: number | null
    partner: boolean | null
    manager: boolean | null
  }

  export type UserStorageCountAggregateOutputType = {
    id: number
    createdAt: number
    editedAt: number
    userId: number
    quantity: number
    storageId: number
    partner: number
    manager: number
    _all: number
  }


  export type UserStorageAvgAggregateInputType = {
    id?: true
    quantity?: true
    storageId?: true
  }

  export type UserStorageSumAggregateInputType = {
    id?: true
    quantity?: true
    storageId?: true
  }

  export type UserStorageMinAggregateInputType = {
    id?: true
    createdAt?: true
    editedAt?: true
    userId?: true
    quantity?: true
    storageId?: true
    partner?: true
    manager?: true
  }

  export type UserStorageMaxAggregateInputType = {
    id?: true
    createdAt?: true
    editedAt?: true
    userId?: true
    quantity?: true
    storageId?: true
    partner?: true
    manager?: true
  }

  export type UserStorageCountAggregateInputType = {
    id?: true
    createdAt?: true
    editedAt?: true
    userId?: true
    quantity?: true
    storageId?: true
    partner?: true
    manager?: true
    _all?: true
  }

  export type UserStorageAggregateArgs = {
    /**
     * Filter which UserStorage to aggregate.
     * 
    **/
    where?: UserStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStorages to fetch.
     * 
    **/
    orderBy?: Enumerable<UserStorageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStorages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStorages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserStorages
    **/
    _count?: true | UserStorageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserStorageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserStorageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserStorageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserStorageMaxAggregateInputType
  }

  export type GetUserStorageAggregateType<T extends UserStorageAggregateArgs> = {
        [P in keyof T & keyof AggregateUserStorage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserStorage[P]>
      : GetScalarType<T[P], AggregateUserStorage[P]>
  }




  export type UserStorageGroupByArgs = {
    where?: UserStorageWhereInput
    orderBy?: Enumerable<UserStorageOrderByWithAggregationInput>
    by: Array<UserStorageScalarFieldEnum>
    having?: UserStorageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserStorageCountAggregateInputType | true
    _avg?: UserStorageAvgAggregateInputType
    _sum?: UserStorageSumAggregateInputType
    _min?: UserStorageMinAggregateInputType
    _max?: UserStorageMaxAggregateInputType
  }


  export type UserStorageGroupByOutputType = {
    id: number
    createdAt: Date
    editedAt: Date
    userId: string
    quantity: number | null
    storageId: number | null
    partner: boolean
    manager: boolean
    _count: UserStorageCountAggregateOutputType | null
    _avg: UserStorageAvgAggregateOutputType | null
    _sum: UserStorageSumAggregateOutputType | null
    _min: UserStorageMinAggregateOutputType | null
    _max: UserStorageMaxAggregateOutputType | null
  }

  type GetUserStorageGroupByPayload<T extends UserStorageGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserStorageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserStorageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserStorageGroupByOutputType[P]>
            : GetScalarType<T[P], UserStorageGroupByOutputType[P]>
        }
      >
    >


  export type UserStorageSelect = {
    id?: boolean
    createdAt?: boolean
    editedAt?: boolean
    userId?: boolean
    user?: boolean | UserArgs
    quantity?: boolean
    Storage?: boolean | StorageArgs
    storageId?: boolean
    partner?: boolean
    manager?: boolean
  }

  export type UserStorageInclude = {
    user?: boolean | UserArgs
    Storage?: boolean | StorageArgs
  }

  export type UserStorageGetPayload<
    S extends boolean | null | undefined | UserStorageArgs,
    U = keyof S
      > = S extends true
        ? UserStorage
    : S extends undefined
    ? never
    : S extends UserStorageArgs | UserStorageFindManyArgs
    ?'include' extends U
    ? UserStorage  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'Storage' ? StorageGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'Storage' ? StorageGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof UserStorage ? UserStorage[P] : never
  } 
    : UserStorage
  : UserStorage


  type UserStorageCountArgs = Merge<
    Omit<UserStorageFindManyArgs, 'select' | 'include'> & {
      select?: UserStorageCountAggregateInputType | true
    }
  >

  export interface UserStorageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one UserStorage that matches the filter.
     * @param {UserStorageFindUniqueArgs} args - Arguments to find a UserStorage
     * @example
     * // Get one UserStorage
     * const userStorage = await prisma.userStorage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserStorageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserStorageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserStorage'> extends True ? CheckSelect<T, Prisma__UserStorageClient<UserStorage>, Prisma__UserStorageClient<UserStorageGetPayload<T>>> : CheckSelect<T, Prisma__UserStorageClient<UserStorage | null >, Prisma__UserStorageClient<UserStorageGetPayload<T> | null >>

    /**
     * Find the first UserStorage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStorageFindFirstArgs} args - Arguments to find a UserStorage
     * @example
     * // Get one UserStorage
     * const userStorage = await prisma.userStorage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserStorageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserStorageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserStorage'> extends True ? CheckSelect<T, Prisma__UserStorageClient<UserStorage>, Prisma__UserStorageClient<UserStorageGetPayload<T>>> : CheckSelect<T, Prisma__UserStorageClient<UserStorage | null >, Prisma__UserStorageClient<UserStorageGetPayload<T> | null >>

    /**
     * Find zero or more UserStorages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStorageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserStorages
     * const userStorages = await prisma.userStorage.findMany()
     * 
     * // Get first 10 UserStorages
     * const userStorages = await prisma.userStorage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userStorageWithIdOnly = await prisma.userStorage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserStorageFindManyArgs>(
      args?: SelectSubset<T, UserStorageFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserStorage>>, PrismaPromise<Array<UserStorageGetPayload<T>>>>

    /**
     * Create a UserStorage.
     * @param {UserStorageCreateArgs} args - Arguments to create a UserStorage.
     * @example
     * // Create one UserStorage
     * const UserStorage = await prisma.userStorage.create({
     *   data: {
     *     // ... data to create a UserStorage
     *   }
     * })
     * 
    **/
    create<T extends UserStorageCreateArgs>(
      args: SelectSubset<T, UserStorageCreateArgs>
    ): CheckSelect<T, Prisma__UserStorageClient<UserStorage>, Prisma__UserStorageClient<UserStorageGetPayload<T>>>

    /**
     * Create many UserStorages.
     *     @param {UserStorageCreateManyArgs} args - Arguments to create many UserStorages.
     *     @example
     *     // Create many UserStorages
     *     const userStorage = await prisma.userStorage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserStorageCreateManyArgs>(
      args?: SelectSubset<T, UserStorageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserStorage.
     * @param {UserStorageDeleteArgs} args - Arguments to delete one UserStorage.
     * @example
     * // Delete one UserStorage
     * const UserStorage = await prisma.userStorage.delete({
     *   where: {
     *     // ... filter to delete one UserStorage
     *   }
     * })
     * 
    **/
    delete<T extends UserStorageDeleteArgs>(
      args: SelectSubset<T, UserStorageDeleteArgs>
    ): CheckSelect<T, Prisma__UserStorageClient<UserStorage>, Prisma__UserStorageClient<UserStorageGetPayload<T>>>

    /**
     * Update one UserStorage.
     * @param {UserStorageUpdateArgs} args - Arguments to update one UserStorage.
     * @example
     * // Update one UserStorage
     * const userStorage = await prisma.userStorage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserStorageUpdateArgs>(
      args: SelectSubset<T, UserStorageUpdateArgs>
    ): CheckSelect<T, Prisma__UserStorageClient<UserStorage>, Prisma__UserStorageClient<UserStorageGetPayload<T>>>

    /**
     * Delete zero or more UserStorages.
     * @param {UserStorageDeleteManyArgs} args - Arguments to filter UserStorages to delete.
     * @example
     * // Delete a few UserStorages
     * const { count } = await prisma.userStorage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserStorageDeleteManyArgs>(
      args?: SelectSubset<T, UserStorageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserStorages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStorageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserStorages
     * const userStorage = await prisma.userStorage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserStorageUpdateManyArgs>(
      args: SelectSubset<T, UserStorageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserStorage.
     * @param {UserStorageUpsertArgs} args - Arguments to update or create a UserStorage.
     * @example
     * // Update or create a UserStorage
     * const userStorage = await prisma.userStorage.upsert({
     *   create: {
     *     // ... data to create a UserStorage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserStorage we want to update
     *   }
     * })
    **/
    upsert<T extends UserStorageUpsertArgs>(
      args: SelectSubset<T, UserStorageUpsertArgs>
    ): CheckSelect<T, Prisma__UserStorageClient<UserStorage>, Prisma__UserStorageClient<UserStorageGetPayload<T>>>

    /**
     * Find one UserStorage that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {UserStorageFindUniqueOrThrowArgs} args - Arguments to find a UserStorage
     * @example
     * // Get one UserStorage
     * const userStorage = await prisma.userStorage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserStorageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserStorageFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__UserStorageClient<UserStorage>, Prisma__UserStorageClient<UserStorageGetPayload<T>>>

    /**
     * Find the first UserStorage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStorageFindFirstOrThrowArgs} args - Arguments to find a UserStorage
     * @example
     * // Get one UserStorage
     * const userStorage = await prisma.userStorage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserStorageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserStorageFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__UserStorageClient<UserStorage>, Prisma__UserStorageClient<UserStorageGetPayload<T>>>

    /**
     * Count the number of UserStorages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStorageCountArgs} args - Arguments to filter UserStorages to count.
     * @example
     * // Count the number of UserStorages
     * const count = await prisma.userStorage.count({
     *   where: {
     *     // ... the filter for the UserStorages we want to count
     *   }
     * })
    **/
    count<T extends UserStorageCountArgs>(
      args?: Subset<T, UserStorageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserStorageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserStorage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStorageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserStorageAggregateArgs>(args: Subset<T, UserStorageAggregateArgs>): PrismaPromise<GetUserStorageAggregateType<T>>

    /**
     * Group by UserStorage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStorageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserStorageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserStorageGroupByArgs['orderBy'] }
        : { orderBy?: UserStorageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserStorageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserStorageGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserStorage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserStorageClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    Storage<T extends StorageArgs = {}>(args?: Subset<T, StorageArgs>): CheckSelect<T, Prisma__StorageClient<Storage | null >, Prisma__StorageClient<StorageGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserStorage base type for findUnique actions
   */
  export type UserStorageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserStorage
     * 
    **/
    select?: UserStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserStorageInclude | null
    /**
     * Filter, which UserStorage to fetch.
     * 
    **/
    where: UserStorageWhereUniqueInput
  }

  /**
   * UserStorage: findUnique
   */
  export interface UserStorageFindUniqueArgs extends UserStorageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserStorage base type for findFirst actions
   */
  export type UserStorageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserStorage
     * 
    **/
    select?: UserStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserStorageInclude | null
    /**
     * Filter, which UserStorage to fetch.
     * 
    **/
    where?: UserStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStorages to fetch.
     * 
    **/
    orderBy?: Enumerable<UserStorageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserStorages.
     * 
    **/
    cursor?: UserStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStorages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStorages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserStorages.
     * 
    **/
    distinct?: Enumerable<UserStorageScalarFieldEnum>
  }

  /**
   * UserStorage: findFirst
   */
  export interface UserStorageFindFirstArgs extends UserStorageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserStorage findMany
   */
  export type UserStorageFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserStorage
     * 
    **/
    select?: UserStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserStorageInclude | null
    /**
     * Filter, which UserStorages to fetch.
     * 
    **/
    where?: UserStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStorages to fetch.
     * 
    **/
    orderBy?: Enumerable<UserStorageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserStorages.
     * 
    **/
    cursor?: UserStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStorages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStorages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserStorageScalarFieldEnum>
  }


  /**
   * UserStorage create
   */
  export type UserStorageCreateArgs = {
    /**
     * Select specific fields to fetch from the UserStorage
     * 
    **/
    select?: UserStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserStorageInclude | null
    /**
     * The data needed to create a UserStorage.
     * 
    **/
    data: XOR<UserStorageCreateInput, UserStorageUncheckedCreateInput>
  }


  /**
   * UserStorage createMany
   */
  export type UserStorageCreateManyArgs = {
    /**
     * The data used to create many UserStorages.
     * 
    **/
    data: Enumerable<UserStorageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserStorage update
   */
  export type UserStorageUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserStorage
     * 
    **/
    select?: UserStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserStorageInclude | null
    /**
     * The data needed to update a UserStorage.
     * 
    **/
    data: XOR<UserStorageUpdateInput, UserStorageUncheckedUpdateInput>
    /**
     * Choose, which UserStorage to update.
     * 
    **/
    where: UserStorageWhereUniqueInput
  }


  /**
   * UserStorage updateMany
   */
  export type UserStorageUpdateManyArgs = {
    /**
     * The data used to update UserStorages.
     * 
    **/
    data: XOR<UserStorageUpdateManyMutationInput, UserStorageUncheckedUpdateManyInput>
    /**
     * Filter which UserStorages to update
     * 
    **/
    where?: UserStorageWhereInput
  }


  /**
   * UserStorage upsert
   */
  export type UserStorageUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserStorage
     * 
    **/
    select?: UserStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserStorageInclude | null
    /**
     * The filter to search for the UserStorage to update in case it exists.
     * 
    **/
    where: UserStorageWhereUniqueInput
    /**
     * In case the UserStorage found by the `where` argument doesn't exist, create a new UserStorage with this data.
     * 
    **/
    create: XOR<UserStorageCreateInput, UserStorageUncheckedCreateInput>
    /**
     * In case the UserStorage was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserStorageUpdateInput, UserStorageUncheckedUpdateInput>
  }


  /**
   * UserStorage delete
   */
  export type UserStorageDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserStorage
     * 
    **/
    select?: UserStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserStorageInclude | null
    /**
     * Filter which UserStorage to delete.
     * 
    **/
    where: UserStorageWhereUniqueInput
  }


  /**
   * UserStorage deleteMany
   */
  export type UserStorageDeleteManyArgs = {
    /**
     * Filter which UserStorages to delete
     * 
    **/
    where?: UserStorageWhereInput
  }


  /**
   * UserStorage: findUniqueOrThrow
   */
  export type UserStorageFindUniqueOrThrowArgs = UserStorageFindUniqueArgsBase
      

  /**
   * UserStorage: findFirstOrThrow
   */
  export type UserStorageFindFirstOrThrowArgs = UserStorageFindFirstArgsBase
      

  /**
   * UserStorage without action
   */
  export type UserStorageArgs = {
    /**
     * Select specific fields to fetch from the UserStorage
     * 
    **/
    select?: UserStorageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserStorageInclude | null
  }



  /**
   * Model Crew
   */


  export type AggregateCrew = {
    _count: CrewCountAggregateOutputType | null
    _avg: CrewAvgAggregateOutputType | null
    _sum: CrewSumAggregateOutputType | null
    _min: CrewMinAggregateOutputType | null
    _max: CrewMaxAggregateOutputType | null
  }

  export type CrewAvgAggregateOutputType = {
    id: number | null
  }

  export type CrewSumAggregateOutputType = {
    id: number | null
  }

  export type CrewMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
  }

  export type CrewMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
  }

  export type CrewCountAggregateOutputType = {
    id: number
    createdAt: number
    editedAt: number
    createdById: number
    editedById: number
    _all: number
  }


  export type CrewAvgAggregateInputType = {
    id?: true
  }

  export type CrewSumAggregateInputType = {
    id?: true
  }

  export type CrewMinAggregateInputType = {
    id?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
  }

  export type CrewMaxAggregateInputType = {
    id?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
  }

  export type CrewCountAggregateInputType = {
    id?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
    _all?: true
  }

  export type CrewAggregateArgs = {
    /**
     * Filter which Crew to aggregate.
     * 
    **/
    where?: CrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crews to fetch.
     * 
    **/
    orderBy?: Enumerable<CrewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crews.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Crews
    **/
    _count?: true | CrewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CrewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CrewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrewMaxAggregateInputType
  }

  export type GetCrewAggregateType<T extends CrewAggregateArgs> = {
        [P in keyof T & keyof AggregateCrew]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrew[P]>
      : GetScalarType<T[P], AggregateCrew[P]>
  }




  export type CrewGroupByArgs = {
    where?: CrewWhereInput
    orderBy?: Enumerable<CrewOrderByWithAggregationInput>
    by: Array<CrewScalarFieldEnum>
    having?: CrewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrewCountAggregateInputType | true
    _avg?: CrewAvgAggregateInputType
    _sum?: CrewSumAggregateInputType
    _min?: CrewMinAggregateInputType
    _max?: CrewMaxAggregateInputType
  }


  export type CrewGroupByOutputType = {
    id: number
    createdAt: Date
    editedAt: Date
    createdById: string
    editedById: string
    _count: CrewCountAggregateOutputType | null
    _avg: CrewAvgAggregateOutputType | null
    _sum: CrewSumAggregateOutputType | null
    _min: CrewMinAggregateOutputType | null
    _max: CrewMaxAggregateOutputType | null
  }

  type GetCrewGroupByPayload<T extends CrewGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CrewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrewGroupByOutputType[P]>
            : GetScalarType<T[P], CrewGroupByOutputType[P]>
        }
      >
    >


  export type CrewSelect = {
    id?: boolean
    createdAt?: boolean
    editedAt?: boolean
    createdById?: boolean
    editedById?: boolean
    createdBy?: boolean | UserArgs
    editedBy?: boolean | UserArgs
    userCrew?: boolean | UserCrewFindManyArgs
    _count?: boolean | CrewCountOutputTypeArgs
  }

  export type CrewInclude = {
    createdBy?: boolean | UserArgs
    editedBy?: boolean | UserArgs
    userCrew?: boolean | UserCrewFindManyArgs
    _count?: boolean | CrewCountOutputTypeArgs
  }

  export type CrewGetPayload<
    S extends boolean | null | undefined | CrewArgs,
    U = keyof S
      > = S extends true
        ? Crew
    : S extends undefined
    ? never
    : S extends CrewArgs | CrewFindManyArgs
    ?'include' extends U
    ? Crew  & {
    [P in TrueKeys<S['include']>]:
        P extends 'createdBy' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'editedBy' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'userCrew' ? Array < UserCrewGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? CrewCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'createdBy' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'editedBy' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'userCrew' ? Array < UserCrewGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? CrewCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Crew ? Crew[P] : never
  } 
    : Crew
  : Crew


  type CrewCountArgs = Merge<
    Omit<CrewFindManyArgs, 'select' | 'include'> & {
      select?: CrewCountAggregateInputType | true
    }
  >

  export interface CrewDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Crew that matches the filter.
     * @param {CrewFindUniqueArgs} args - Arguments to find a Crew
     * @example
     * // Get one Crew
     * const crew = await prisma.crew.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CrewFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CrewFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Crew'> extends True ? CheckSelect<T, Prisma__CrewClient<Crew>, Prisma__CrewClient<CrewGetPayload<T>>> : CheckSelect<T, Prisma__CrewClient<Crew | null >, Prisma__CrewClient<CrewGetPayload<T> | null >>

    /**
     * Find the first Crew that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewFindFirstArgs} args - Arguments to find a Crew
     * @example
     * // Get one Crew
     * const crew = await prisma.crew.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CrewFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CrewFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Crew'> extends True ? CheckSelect<T, Prisma__CrewClient<Crew>, Prisma__CrewClient<CrewGetPayload<T>>> : CheckSelect<T, Prisma__CrewClient<Crew | null >, Prisma__CrewClient<CrewGetPayload<T> | null >>

    /**
     * Find zero or more Crews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Crews
     * const crews = await prisma.crew.findMany()
     * 
     * // Get first 10 Crews
     * const crews = await prisma.crew.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const crewWithIdOnly = await prisma.crew.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CrewFindManyArgs>(
      args?: SelectSubset<T, CrewFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Crew>>, PrismaPromise<Array<CrewGetPayload<T>>>>

    /**
     * Create a Crew.
     * @param {CrewCreateArgs} args - Arguments to create a Crew.
     * @example
     * // Create one Crew
     * const Crew = await prisma.crew.create({
     *   data: {
     *     // ... data to create a Crew
     *   }
     * })
     * 
    **/
    create<T extends CrewCreateArgs>(
      args: SelectSubset<T, CrewCreateArgs>
    ): CheckSelect<T, Prisma__CrewClient<Crew>, Prisma__CrewClient<CrewGetPayload<T>>>

    /**
     * Create many Crews.
     *     @param {CrewCreateManyArgs} args - Arguments to create many Crews.
     *     @example
     *     // Create many Crews
     *     const crew = await prisma.crew.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CrewCreateManyArgs>(
      args?: SelectSubset<T, CrewCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Crew.
     * @param {CrewDeleteArgs} args - Arguments to delete one Crew.
     * @example
     * // Delete one Crew
     * const Crew = await prisma.crew.delete({
     *   where: {
     *     // ... filter to delete one Crew
     *   }
     * })
     * 
    **/
    delete<T extends CrewDeleteArgs>(
      args: SelectSubset<T, CrewDeleteArgs>
    ): CheckSelect<T, Prisma__CrewClient<Crew>, Prisma__CrewClient<CrewGetPayload<T>>>

    /**
     * Update one Crew.
     * @param {CrewUpdateArgs} args - Arguments to update one Crew.
     * @example
     * // Update one Crew
     * const crew = await prisma.crew.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CrewUpdateArgs>(
      args: SelectSubset<T, CrewUpdateArgs>
    ): CheckSelect<T, Prisma__CrewClient<Crew>, Prisma__CrewClient<CrewGetPayload<T>>>

    /**
     * Delete zero or more Crews.
     * @param {CrewDeleteManyArgs} args - Arguments to filter Crews to delete.
     * @example
     * // Delete a few Crews
     * const { count } = await prisma.crew.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CrewDeleteManyArgs>(
      args?: SelectSubset<T, CrewDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Crews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Crews
     * const crew = await prisma.crew.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CrewUpdateManyArgs>(
      args: SelectSubset<T, CrewUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Crew.
     * @param {CrewUpsertArgs} args - Arguments to update or create a Crew.
     * @example
     * // Update or create a Crew
     * const crew = await prisma.crew.upsert({
     *   create: {
     *     // ... data to create a Crew
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Crew we want to update
     *   }
     * })
    **/
    upsert<T extends CrewUpsertArgs>(
      args: SelectSubset<T, CrewUpsertArgs>
    ): CheckSelect<T, Prisma__CrewClient<Crew>, Prisma__CrewClient<CrewGetPayload<T>>>

    /**
     * Find one Crew that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CrewFindUniqueOrThrowArgs} args - Arguments to find a Crew
     * @example
     * // Get one Crew
     * const crew = await prisma.crew.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CrewFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CrewFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__CrewClient<Crew>, Prisma__CrewClient<CrewGetPayload<T>>>

    /**
     * Find the first Crew that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewFindFirstOrThrowArgs} args - Arguments to find a Crew
     * @example
     * // Get one Crew
     * const crew = await prisma.crew.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CrewFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CrewFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__CrewClient<Crew>, Prisma__CrewClient<CrewGetPayload<T>>>

    /**
     * Count the number of Crews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewCountArgs} args - Arguments to filter Crews to count.
     * @example
     * // Count the number of Crews
     * const count = await prisma.crew.count({
     *   where: {
     *     // ... the filter for the Crews we want to count
     *   }
     * })
    **/
    count<T extends CrewCountArgs>(
      args?: Subset<T, CrewCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Crew.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrewAggregateArgs>(args: Subset<T, CrewAggregateArgs>): PrismaPromise<GetCrewAggregateType<T>>

    /**
     * Group by Crew.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrewGroupByArgs['orderBy'] }
        : { orderBy?: CrewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrewGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Crew.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CrewClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    createdBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    editedBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    userCrew<T extends UserCrewFindManyArgs = {}>(args?: Subset<T, UserCrewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserCrew>>, PrismaPromise<Array<UserCrewGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Crew base type for findUnique actions
   */
  export type CrewFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Crew
     * 
    **/
    select?: CrewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CrewInclude | null
    /**
     * Filter, which Crew to fetch.
     * 
    **/
    where: CrewWhereUniqueInput
  }

  /**
   * Crew: findUnique
   */
  export interface CrewFindUniqueArgs extends CrewFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Crew base type for findFirst actions
   */
  export type CrewFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Crew
     * 
    **/
    select?: CrewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CrewInclude | null
    /**
     * Filter, which Crew to fetch.
     * 
    **/
    where?: CrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crews to fetch.
     * 
    **/
    orderBy?: Enumerable<CrewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Crews.
     * 
    **/
    cursor?: CrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crews.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Crews.
     * 
    **/
    distinct?: Enumerable<CrewScalarFieldEnum>
  }

  /**
   * Crew: findFirst
   */
  export interface CrewFindFirstArgs extends CrewFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Crew findMany
   */
  export type CrewFindManyArgs = {
    /**
     * Select specific fields to fetch from the Crew
     * 
    **/
    select?: CrewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CrewInclude | null
    /**
     * Filter, which Crews to fetch.
     * 
    **/
    where?: CrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crews to fetch.
     * 
    **/
    orderBy?: Enumerable<CrewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Crews.
     * 
    **/
    cursor?: CrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crews.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CrewScalarFieldEnum>
  }


  /**
   * Crew create
   */
  export type CrewCreateArgs = {
    /**
     * Select specific fields to fetch from the Crew
     * 
    **/
    select?: CrewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CrewInclude | null
    /**
     * The data needed to create a Crew.
     * 
    **/
    data: XOR<CrewCreateInput, CrewUncheckedCreateInput>
  }


  /**
   * Crew createMany
   */
  export type CrewCreateManyArgs = {
    /**
     * The data used to create many Crews.
     * 
    **/
    data: Enumerable<CrewCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Crew update
   */
  export type CrewUpdateArgs = {
    /**
     * Select specific fields to fetch from the Crew
     * 
    **/
    select?: CrewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CrewInclude | null
    /**
     * The data needed to update a Crew.
     * 
    **/
    data: XOR<CrewUpdateInput, CrewUncheckedUpdateInput>
    /**
     * Choose, which Crew to update.
     * 
    **/
    where: CrewWhereUniqueInput
  }


  /**
   * Crew updateMany
   */
  export type CrewUpdateManyArgs = {
    /**
     * The data used to update Crews.
     * 
    **/
    data: XOR<CrewUpdateManyMutationInput, CrewUncheckedUpdateManyInput>
    /**
     * Filter which Crews to update
     * 
    **/
    where?: CrewWhereInput
  }


  /**
   * Crew upsert
   */
  export type CrewUpsertArgs = {
    /**
     * Select specific fields to fetch from the Crew
     * 
    **/
    select?: CrewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CrewInclude | null
    /**
     * The filter to search for the Crew to update in case it exists.
     * 
    **/
    where: CrewWhereUniqueInput
    /**
     * In case the Crew found by the `where` argument doesn't exist, create a new Crew with this data.
     * 
    **/
    create: XOR<CrewCreateInput, CrewUncheckedCreateInput>
    /**
     * In case the Crew was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CrewUpdateInput, CrewUncheckedUpdateInput>
  }


  /**
   * Crew delete
   */
  export type CrewDeleteArgs = {
    /**
     * Select specific fields to fetch from the Crew
     * 
    **/
    select?: CrewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CrewInclude | null
    /**
     * Filter which Crew to delete.
     * 
    **/
    where: CrewWhereUniqueInput
  }


  /**
   * Crew deleteMany
   */
  export type CrewDeleteManyArgs = {
    /**
     * Filter which Crews to delete
     * 
    **/
    where?: CrewWhereInput
  }


  /**
   * Crew: findUniqueOrThrow
   */
  export type CrewFindUniqueOrThrowArgs = CrewFindUniqueArgsBase
      

  /**
   * Crew: findFirstOrThrow
   */
  export type CrewFindFirstOrThrowArgs = CrewFindFirstArgsBase
      

  /**
   * Crew without action
   */
  export type CrewArgs = {
    /**
     * Select specific fields to fetch from the Crew
     * 
    **/
    select?: CrewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CrewInclude | null
  }



  /**
   * Model UserCrew
   */


  export type AggregateUserCrew = {
    _count: UserCrewCountAggregateOutputType | null
    _avg: UserCrewAvgAggregateOutputType | null
    _sum: UserCrewSumAggregateOutputType | null
    _min: UserCrewMinAggregateOutputType | null
    _max: UserCrewMaxAggregateOutputType | null
  }

  export type UserCrewAvgAggregateOutputType = {
    id: number | null
    crewId: number | null
  }

  export type UserCrewSumAggregateOutputType = {
    id: number | null
    crewId: number | null
  }

  export type UserCrewMinAggregateOutputType = {
    id: number | null
    userId: string | null
    crewId: number | null
    partner: boolean | null
    manager: boolean | null
  }

  export type UserCrewMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    crewId: number | null
    partner: boolean | null
    manager: boolean | null
  }

  export type UserCrewCountAggregateOutputType = {
    id: number
    userId: number
    crewId: number
    partner: number
    manager: number
    _all: number
  }


  export type UserCrewAvgAggregateInputType = {
    id?: true
    crewId?: true
  }

  export type UserCrewSumAggregateInputType = {
    id?: true
    crewId?: true
  }

  export type UserCrewMinAggregateInputType = {
    id?: true
    userId?: true
    crewId?: true
    partner?: true
    manager?: true
  }

  export type UserCrewMaxAggregateInputType = {
    id?: true
    userId?: true
    crewId?: true
    partner?: true
    manager?: true
  }

  export type UserCrewCountAggregateInputType = {
    id?: true
    userId?: true
    crewId?: true
    partner?: true
    manager?: true
    _all?: true
  }

  export type UserCrewAggregateArgs = {
    /**
     * Filter which UserCrew to aggregate.
     * 
    **/
    where?: UserCrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCrews to fetch.
     * 
    **/
    orderBy?: Enumerable<UserCrewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserCrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCrews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCrews.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserCrews
    **/
    _count?: true | UserCrewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserCrewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserCrewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserCrewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserCrewMaxAggregateInputType
  }

  export type GetUserCrewAggregateType<T extends UserCrewAggregateArgs> = {
        [P in keyof T & keyof AggregateUserCrew]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserCrew[P]>
      : GetScalarType<T[P], AggregateUserCrew[P]>
  }




  export type UserCrewGroupByArgs = {
    where?: UserCrewWhereInput
    orderBy?: Enumerable<UserCrewOrderByWithAggregationInput>
    by: Array<UserCrewScalarFieldEnum>
    having?: UserCrewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCrewCountAggregateInputType | true
    _avg?: UserCrewAvgAggregateInputType
    _sum?: UserCrewSumAggregateInputType
    _min?: UserCrewMinAggregateInputType
    _max?: UserCrewMaxAggregateInputType
  }


  export type UserCrewGroupByOutputType = {
    id: number
    userId: string
    crewId: number
    partner: boolean
    manager: boolean
    _count: UserCrewCountAggregateOutputType | null
    _avg: UserCrewAvgAggregateOutputType | null
    _sum: UserCrewSumAggregateOutputType | null
    _min: UserCrewMinAggregateOutputType | null
    _max: UserCrewMaxAggregateOutputType | null
  }

  type GetUserCrewGroupByPayload<T extends UserCrewGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserCrewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserCrewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserCrewGroupByOutputType[P]>
            : GetScalarType<T[P], UserCrewGroupByOutputType[P]>
        }
      >
    >


  export type UserCrewSelect = {
    id?: boolean
    userId?: boolean
    crewId?: boolean
    user?: boolean | UserArgs
    crew?: boolean | CrewArgs
    partner?: boolean
    manager?: boolean
  }

  export type UserCrewInclude = {
    user?: boolean | UserArgs
    crew?: boolean | CrewArgs
  }

  export type UserCrewGetPayload<
    S extends boolean | null | undefined | UserCrewArgs,
    U = keyof S
      > = S extends true
        ? UserCrew
    : S extends undefined
    ? never
    : S extends UserCrewArgs | UserCrewFindManyArgs
    ?'include' extends U
    ? UserCrew  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'crew' ? CrewGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'crew' ? CrewGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof UserCrew ? UserCrew[P] : never
  } 
    : UserCrew
  : UserCrew


  type UserCrewCountArgs = Merge<
    Omit<UserCrewFindManyArgs, 'select' | 'include'> & {
      select?: UserCrewCountAggregateInputType | true
    }
  >

  export interface UserCrewDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one UserCrew that matches the filter.
     * @param {UserCrewFindUniqueArgs} args - Arguments to find a UserCrew
     * @example
     * // Get one UserCrew
     * const userCrew = await prisma.userCrew.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserCrewFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserCrewFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserCrew'> extends True ? CheckSelect<T, Prisma__UserCrewClient<UserCrew>, Prisma__UserCrewClient<UserCrewGetPayload<T>>> : CheckSelect<T, Prisma__UserCrewClient<UserCrew | null >, Prisma__UserCrewClient<UserCrewGetPayload<T> | null >>

    /**
     * Find the first UserCrew that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCrewFindFirstArgs} args - Arguments to find a UserCrew
     * @example
     * // Get one UserCrew
     * const userCrew = await prisma.userCrew.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserCrewFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserCrewFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserCrew'> extends True ? CheckSelect<T, Prisma__UserCrewClient<UserCrew>, Prisma__UserCrewClient<UserCrewGetPayload<T>>> : CheckSelect<T, Prisma__UserCrewClient<UserCrew | null >, Prisma__UserCrewClient<UserCrewGetPayload<T> | null >>

    /**
     * Find zero or more UserCrews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCrewFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserCrews
     * const userCrews = await prisma.userCrew.findMany()
     * 
     * // Get first 10 UserCrews
     * const userCrews = await prisma.userCrew.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userCrewWithIdOnly = await prisma.userCrew.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserCrewFindManyArgs>(
      args?: SelectSubset<T, UserCrewFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserCrew>>, PrismaPromise<Array<UserCrewGetPayload<T>>>>

    /**
     * Create a UserCrew.
     * @param {UserCrewCreateArgs} args - Arguments to create a UserCrew.
     * @example
     * // Create one UserCrew
     * const UserCrew = await prisma.userCrew.create({
     *   data: {
     *     // ... data to create a UserCrew
     *   }
     * })
     * 
    **/
    create<T extends UserCrewCreateArgs>(
      args: SelectSubset<T, UserCrewCreateArgs>
    ): CheckSelect<T, Prisma__UserCrewClient<UserCrew>, Prisma__UserCrewClient<UserCrewGetPayload<T>>>

    /**
     * Create many UserCrews.
     *     @param {UserCrewCreateManyArgs} args - Arguments to create many UserCrews.
     *     @example
     *     // Create many UserCrews
     *     const userCrew = await prisma.userCrew.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCrewCreateManyArgs>(
      args?: SelectSubset<T, UserCrewCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserCrew.
     * @param {UserCrewDeleteArgs} args - Arguments to delete one UserCrew.
     * @example
     * // Delete one UserCrew
     * const UserCrew = await prisma.userCrew.delete({
     *   where: {
     *     // ... filter to delete one UserCrew
     *   }
     * })
     * 
    **/
    delete<T extends UserCrewDeleteArgs>(
      args: SelectSubset<T, UserCrewDeleteArgs>
    ): CheckSelect<T, Prisma__UserCrewClient<UserCrew>, Prisma__UserCrewClient<UserCrewGetPayload<T>>>

    /**
     * Update one UserCrew.
     * @param {UserCrewUpdateArgs} args - Arguments to update one UserCrew.
     * @example
     * // Update one UserCrew
     * const userCrew = await prisma.userCrew.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserCrewUpdateArgs>(
      args: SelectSubset<T, UserCrewUpdateArgs>
    ): CheckSelect<T, Prisma__UserCrewClient<UserCrew>, Prisma__UserCrewClient<UserCrewGetPayload<T>>>

    /**
     * Delete zero or more UserCrews.
     * @param {UserCrewDeleteManyArgs} args - Arguments to filter UserCrews to delete.
     * @example
     * // Delete a few UserCrews
     * const { count } = await prisma.userCrew.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserCrewDeleteManyArgs>(
      args?: SelectSubset<T, UserCrewDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCrews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCrewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserCrews
     * const userCrew = await prisma.userCrew.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserCrewUpdateManyArgs>(
      args: SelectSubset<T, UserCrewUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserCrew.
     * @param {UserCrewUpsertArgs} args - Arguments to update or create a UserCrew.
     * @example
     * // Update or create a UserCrew
     * const userCrew = await prisma.userCrew.upsert({
     *   create: {
     *     // ... data to create a UserCrew
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserCrew we want to update
     *   }
     * })
    **/
    upsert<T extends UserCrewUpsertArgs>(
      args: SelectSubset<T, UserCrewUpsertArgs>
    ): CheckSelect<T, Prisma__UserCrewClient<UserCrew>, Prisma__UserCrewClient<UserCrewGetPayload<T>>>

    /**
     * Find one UserCrew that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {UserCrewFindUniqueOrThrowArgs} args - Arguments to find a UserCrew
     * @example
     * // Get one UserCrew
     * const userCrew = await prisma.userCrew.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserCrewFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserCrewFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__UserCrewClient<UserCrew>, Prisma__UserCrewClient<UserCrewGetPayload<T>>>

    /**
     * Find the first UserCrew that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCrewFindFirstOrThrowArgs} args - Arguments to find a UserCrew
     * @example
     * // Get one UserCrew
     * const userCrew = await prisma.userCrew.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserCrewFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserCrewFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__UserCrewClient<UserCrew>, Prisma__UserCrewClient<UserCrewGetPayload<T>>>

    /**
     * Count the number of UserCrews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCrewCountArgs} args - Arguments to filter UserCrews to count.
     * @example
     * // Count the number of UserCrews
     * const count = await prisma.userCrew.count({
     *   where: {
     *     // ... the filter for the UserCrews we want to count
     *   }
     * })
    **/
    count<T extends UserCrewCountArgs>(
      args?: Subset<T, UserCrewCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCrewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserCrew.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCrewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserCrewAggregateArgs>(args: Subset<T, UserCrewAggregateArgs>): PrismaPromise<GetUserCrewAggregateType<T>>

    /**
     * Group by UserCrew.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCrewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserCrewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserCrewGroupByArgs['orderBy'] }
        : { orderBy?: UserCrewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserCrewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserCrewGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserCrew.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserCrewClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    crew<T extends CrewArgs = {}>(args?: Subset<T, CrewArgs>): CheckSelect<T, Prisma__CrewClient<Crew | null >, Prisma__CrewClient<CrewGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserCrew base type for findUnique actions
   */
  export type UserCrewFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserCrew
     * 
    **/
    select?: UserCrewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserCrewInclude | null
    /**
     * Filter, which UserCrew to fetch.
     * 
    **/
    where: UserCrewWhereUniqueInput
  }

  /**
   * UserCrew: findUnique
   */
  export interface UserCrewFindUniqueArgs extends UserCrewFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserCrew base type for findFirst actions
   */
  export type UserCrewFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserCrew
     * 
    **/
    select?: UserCrewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserCrewInclude | null
    /**
     * Filter, which UserCrew to fetch.
     * 
    **/
    where?: UserCrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCrews to fetch.
     * 
    **/
    orderBy?: Enumerable<UserCrewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCrews.
     * 
    **/
    cursor?: UserCrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCrews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCrews.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCrews.
     * 
    **/
    distinct?: Enumerable<UserCrewScalarFieldEnum>
  }

  /**
   * UserCrew: findFirst
   */
  export interface UserCrewFindFirstArgs extends UserCrewFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserCrew findMany
   */
  export type UserCrewFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserCrew
     * 
    **/
    select?: UserCrewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserCrewInclude | null
    /**
     * Filter, which UserCrews to fetch.
     * 
    **/
    where?: UserCrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCrews to fetch.
     * 
    **/
    orderBy?: Enumerable<UserCrewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserCrews.
     * 
    **/
    cursor?: UserCrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCrews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCrews.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserCrewScalarFieldEnum>
  }


  /**
   * UserCrew create
   */
  export type UserCrewCreateArgs = {
    /**
     * Select specific fields to fetch from the UserCrew
     * 
    **/
    select?: UserCrewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserCrewInclude | null
    /**
     * The data needed to create a UserCrew.
     * 
    **/
    data: XOR<UserCrewCreateInput, UserCrewUncheckedCreateInput>
  }


  /**
   * UserCrew createMany
   */
  export type UserCrewCreateManyArgs = {
    /**
     * The data used to create many UserCrews.
     * 
    **/
    data: Enumerable<UserCrewCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserCrew update
   */
  export type UserCrewUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserCrew
     * 
    **/
    select?: UserCrewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserCrewInclude | null
    /**
     * The data needed to update a UserCrew.
     * 
    **/
    data: XOR<UserCrewUpdateInput, UserCrewUncheckedUpdateInput>
    /**
     * Choose, which UserCrew to update.
     * 
    **/
    where: UserCrewWhereUniqueInput
  }


  /**
   * UserCrew updateMany
   */
  export type UserCrewUpdateManyArgs = {
    /**
     * The data used to update UserCrews.
     * 
    **/
    data: XOR<UserCrewUpdateManyMutationInput, UserCrewUncheckedUpdateManyInput>
    /**
     * Filter which UserCrews to update
     * 
    **/
    where?: UserCrewWhereInput
  }


  /**
   * UserCrew upsert
   */
  export type UserCrewUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserCrew
     * 
    **/
    select?: UserCrewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserCrewInclude | null
    /**
     * The filter to search for the UserCrew to update in case it exists.
     * 
    **/
    where: UserCrewWhereUniqueInput
    /**
     * In case the UserCrew found by the `where` argument doesn't exist, create a new UserCrew with this data.
     * 
    **/
    create: XOR<UserCrewCreateInput, UserCrewUncheckedCreateInput>
    /**
     * In case the UserCrew was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserCrewUpdateInput, UserCrewUncheckedUpdateInput>
  }


  /**
   * UserCrew delete
   */
  export type UserCrewDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserCrew
     * 
    **/
    select?: UserCrewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserCrewInclude | null
    /**
     * Filter which UserCrew to delete.
     * 
    **/
    where: UserCrewWhereUniqueInput
  }


  /**
   * UserCrew deleteMany
   */
  export type UserCrewDeleteManyArgs = {
    /**
     * Filter which UserCrews to delete
     * 
    **/
    where?: UserCrewWhereInput
  }


  /**
   * UserCrew: findUniqueOrThrow
   */
  export type UserCrewFindUniqueOrThrowArgs = UserCrewFindUniqueArgsBase
      

  /**
   * UserCrew: findFirstOrThrow
   */
  export type UserCrewFindFirstOrThrowArgs = UserCrewFindFirstArgsBase
      

  /**
   * UserCrew without action
   */
  export type UserCrewArgs = {
    /**
     * Select specific fields to fetch from the UserCrew
     * 
    **/
    select?: UserCrewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserCrewInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const BuildScalarFieldEnum: {
    id: 'id',
    buildName: 'buildName',
    createdAt: 'createdAt',
    editedAt: 'editedAt',
    createdById: 'createdById',
    editedById: 'editedById',
    recipeId: 'recipeId',
    instructions: 'instructions',
    notes: 'notes',
    glassware: 'glassware',
    ice: 'ice'
  };

  export type BuildScalarFieldEnum = (typeof BuildScalarFieldEnum)[keyof typeof BuildScalarFieldEnum]


  export const CrewScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    editedAt: 'editedAt',
    createdById: 'createdById',
    editedById: 'editedById'
  };

  export type CrewScalarFieldEnum = (typeof CrewScalarFieldEnum)[keyof typeof CrewScalarFieldEnum]


  export const IngredientScalarFieldEnum: {
    id: 'id',
    dateCreated: 'dateCreated',
    createdById: 'createdById',
    name: 'name',
    price: 'price',
    amount: 'amount',
    unit: 'unit'
  };

  export type IngredientScalarFieldEnum = (typeof IngredientScalarFieldEnum)[keyof typeof IngredientScalarFieldEnum]


  export const IngredientStorageScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    editedAt: 'editedAt',
    ingredientId: 'ingredientId',
    quantity: 'quantity',
    storageId: 'storageId'
  };

  export type IngredientStorageScalarFieldEnum = (typeof IngredientStorageScalarFieldEnum)[keyof typeof IngredientStorageScalarFieldEnum]


  export const InventoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    editedAt: 'editedAt',
    createdById: 'createdById',
    editedById: 'editedById'
  };

  export type InventoryScalarFieldEnum = (typeof InventoryScalarFieldEnum)[keyof typeof InventoryScalarFieldEnum]


  export const InventoryStorageScalarFieldEnum: {
    id: 'id',
    inventoryId: 'inventoryId',
    storageId: 'storageId'
  };

  export type InventoryStorageScalarFieldEnum = (typeof InventoryStorageScalarFieldEnum)[keyof typeof InventoryStorageScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    photo: 'photo'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const RecipeBookBuildScalarFieldEnum: {
    id: 'id',
    buildId: 'buildId',
    recipeBookId: 'recipeBookId'
  };

  export type RecipeBookBuildScalarFieldEnum = (typeof RecipeBookBuildScalarFieldEnum)[keyof typeof RecipeBookBuildScalarFieldEnum]


  export const RecipeBookScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    editedAt: 'editedAt',
    createdById: 'createdById',
    editedById: 'editedById'
  };

  export type RecipeBookScalarFieldEnum = (typeof RecipeBookScalarFieldEnum)[keyof typeof RecipeBookScalarFieldEnum]


  export const RecipeBookUserScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    recipeBookId: 'recipeBookId',
    partner: 'partner',
    manager: 'manager'
  };

  export type RecipeBookUserScalarFieldEnum = (typeof RecipeBookUserScalarFieldEnum)[keyof typeof RecipeBookUserScalarFieldEnum]


  export const RecipeScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    name: 'name',
    origin: 'origin',
    history: 'history',
    createdById: 'createdById'
  };

  export type RecipeScalarFieldEnum = (typeof RecipeScalarFieldEnum)[keyof typeof RecipeScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const StorageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    editedAt: 'editedAt',
    createdById: 'createdById',
    editedById: 'editedById'
  };

  export type StorageScalarFieldEnum = (typeof StorageScalarFieldEnum)[keyof typeof StorageScalarFieldEnum]


  export const TouchScalarFieldEnum: {
    id: 'id',
    ingredientName: 'ingredientName',
    ingredientId: 'ingredientId',
    buildId: 'buildId',
    order: 'order',
    amount: 'amount',
    unit: 'unit'
  };

  export type TouchScalarFieldEnum = (typeof TouchScalarFieldEnum)[keyof typeof TouchScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserBuildScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    buildId: 'buildId',
    partner: 'partner',
    manager: 'manager'
  };

  export type UserBuildScalarFieldEnum = (typeof UserBuildScalarFieldEnum)[keyof typeof UserBuildScalarFieldEnum]


  export const UserCrewScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    crewId: 'crewId',
    partner: 'partner',
    manager: 'manager'
  };

  export type UserCrewScalarFieldEnum = (typeof UserCrewScalarFieldEnum)[keyof typeof UserCrewScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    userName: 'userName',
    firstName: 'firstName',
    lastName: 'lastName',
    dateJoined: 'dateJoined',
    lastEdited: 'lastEdited',
    email: 'email',
    password: 'password'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserStorageScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    editedAt: 'editedAt',
    userId: 'userId',
    quantity: 'quantity',
    storageId: 'storageId',
    partner: 'partner',
    manager: 'manager'
  };

  export type UserStorageScalarFieldEnum = (typeof UserStorageScalarFieldEnum)[keyof typeof UserStorageScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    userName?: StringFilter | string
    firstName?: StringNullableFilter | string | null
    lastName?: StringNullableFilter | string | null
    dateJoined?: DateTimeFilter | Date | string
    lastEdited?: DateTimeFilter | Date | string
    email?: StringFilter | string
    password?: StringFilter | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput> | null
    recipeBookUser?: RecipeBookUserListRelationFilter
    recipeBook?: RecipeBookListRelationFilter
    recipeBookEditedById?: RecipeBookListRelationFilter
    userCrew?: UserCrewListRelationFilter
    crew?: CrewListRelationFilter
    crewEditedBy?: CrewListRelationFilter
    userBuild?: UserBuildListRelationFilter
    build?: BuildListRelationFilter
    buildEditedBy?: BuildListRelationFilter
    recipe?: RecipeListRelationFilter
    ingredient?: IngredientListRelationFilter
    userStorage?: UserStorageListRelationFilter
    storage?: StorageListRelationFilter
    storageEditedBy?: StorageListRelationFilter
    inventoryCreatedBy?: InventoryListRelationFilter
    inventoryEditedBy?: InventoryListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    userName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateJoined?: SortOrder
    lastEdited?: SortOrder
    email?: SortOrder
    password?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    recipeBookUser?: RecipeBookUserOrderByRelationAggregateInput
    recipeBook?: RecipeBookOrderByRelationAggregateInput
    recipeBookEditedById?: RecipeBookOrderByRelationAggregateInput
    userCrew?: UserCrewOrderByRelationAggregateInput
    crew?: CrewOrderByRelationAggregateInput
    crewEditedBy?: CrewOrderByRelationAggregateInput
    userBuild?: UserBuildOrderByRelationAggregateInput
    build?: BuildOrderByRelationAggregateInput
    buildEditedBy?: BuildOrderByRelationAggregateInput
    recipe?: RecipeOrderByRelationAggregateInput
    ingredient?: IngredientOrderByRelationAggregateInput
    userStorage?: UserStorageOrderByRelationAggregateInput
    storage?: StorageOrderByRelationAggregateInput
    storageEditedBy?: StorageOrderByRelationAggregateInput
    inventoryCreatedBy?: InventoryOrderByRelationAggregateInput
    inventoryEditedBy?: InventoryOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    userName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateJoined?: SortOrder
    lastEdited?: SortOrder
    email?: SortOrder
    password?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userName?: StringWithAggregatesFilter | string
    firstName?: StringNullableWithAggregatesFilter | string | null
    lastName?: StringNullableWithAggregatesFilter | string | null
    dateJoined?: DateTimeWithAggregatesFilter | Date | string
    lastEdited?: DateTimeWithAggregatesFilter | Date | string
    email?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
  }

  export type ProfileWhereInput = {
    AND?: Enumerable<ProfileWhereInput>
    OR?: Enumerable<ProfileWhereInput>
    NOT?: Enumerable<ProfileWhereInput>
    id?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: StringFilter | string
    photo?: StringFilter | string
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    user?: UserOrderByWithRelationInput
    userId?: SortOrder
    photo?: SortOrder
  }

  export type ProfileWhereUniqueInput = {
    id?: number
    userId?: string
  }

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    photo?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _avg?: ProfileAvgOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
    _sum?: ProfileSumOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProfileScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProfileScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProfileScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: StringWithAggregatesFilter | string
    photo?: StringWithAggregatesFilter | string
  }

  export type RecipeBookWhereInput = {
    AND?: Enumerable<RecipeBookWhereInput>
    OR?: Enumerable<RecipeBookWhereInput>
    NOT?: Enumerable<RecipeBookWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    editedAt?: DateTimeFilter | Date | string
    createdById?: StringNullableFilter | string | null
    editedById?: StringNullableFilter | string | null
    createdBy?: XOR<UserRelationFilter, UserWhereInput> | null
    editedBy?: XOR<UserRelationFilter, UserWhereInput> | null
    recipeBookBuild?: RecipeBookBuildListRelationFilter
    recipeBookUser?: RecipeBookUserListRelationFilter
  }

  export type RecipeBookOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    editedBy?: UserOrderByWithRelationInput
    recipeBookBuild?: RecipeBookBuildOrderByRelationAggregateInput
    recipeBookUser?: RecipeBookUserOrderByRelationAggregateInput
  }

  export type RecipeBookWhereUniqueInput = {
    id?: number
  }

  export type RecipeBookOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    _count?: RecipeBookCountOrderByAggregateInput
    _avg?: RecipeBookAvgOrderByAggregateInput
    _max?: RecipeBookMaxOrderByAggregateInput
    _min?: RecipeBookMinOrderByAggregateInput
    _sum?: RecipeBookSumOrderByAggregateInput
  }

  export type RecipeBookScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RecipeBookScalarWhereWithAggregatesInput>
    OR?: Enumerable<RecipeBookScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RecipeBookScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    editedAt?: DateTimeWithAggregatesFilter | Date | string
    createdById?: StringNullableWithAggregatesFilter | string | null
    editedById?: StringNullableWithAggregatesFilter | string | null
  }

  export type RecipeBookUserWhereInput = {
    AND?: Enumerable<RecipeBookUserWhereInput>
    OR?: Enumerable<RecipeBookUserWhereInput>
    NOT?: Enumerable<RecipeBookUserWhereInput>
    id?: IntFilter | number
    userId?: StringFilter | string
    recipeBookId?: IntFilter | number
    recipeBook?: XOR<RecipeBookRelationFilter, RecipeBookWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    partner?: BoolFilter | boolean
    manager?: BoolFilter | boolean
  }

  export type RecipeBookUserOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    recipeBookId?: SortOrder
    recipeBook?: RecipeBookOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    partner?: SortOrder
    manager?: SortOrder
  }

  export type RecipeBookUserWhereUniqueInput = {
    id?: number
  }

  export type RecipeBookUserOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    recipeBookId?: SortOrder
    partner?: SortOrder
    manager?: SortOrder
    _count?: RecipeBookUserCountOrderByAggregateInput
    _avg?: RecipeBookUserAvgOrderByAggregateInput
    _max?: RecipeBookUserMaxOrderByAggregateInput
    _min?: RecipeBookUserMinOrderByAggregateInput
    _sum?: RecipeBookUserSumOrderByAggregateInput
  }

  export type RecipeBookUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RecipeBookUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<RecipeBookUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RecipeBookUserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: StringWithAggregatesFilter | string
    recipeBookId?: IntWithAggregatesFilter | number
    partner?: BoolWithAggregatesFilter | boolean
    manager?: BoolWithAggregatesFilter | boolean
  }

  export type BuildWhereInput = {
    AND?: Enumerable<BuildWhereInput>
    OR?: Enumerable<BuildWhereInput>
    NOT?: Enumerable<BuildWhereInput>
    id?: IntFilter | number
    buildName?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    editedAt?: DateTimeFilter | Date | string
    createdById?: StringFilter | string
    editedById?: StringFilter | string
    createdBy?: XOR<UserRelationFilter, UserWhereInput> | null
    editedBy?: XOR<UserRelationFilter, UserWhereInput> | null
    recipe?: XOR<RecipeRelationFilter, RecipeWhereInput> | null
    recipeId?: IntNullableFilter | number | null
    instructions?: StringNullableFilter | string | null
    notes?: StringNullableFilter | string | null
    glassware?: StringNullableFilter | string | null
    ice?: StringNullableFilter | string | null
    touch?: TouchListRelationFilter
    RecipeBookBuild?: RecipeBookBuildListRelationFilter
    userBuild?: UserBuildListRelationFilter
  }

  export type BuildOrderByWithRelationInput = {
    id?: SortOrder
    buildName?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    editedBy?: UserOrderByWithRelationInput
    recipe?: RecipeOrderByWithRelationInput
    recipeId?: SortOrder
    instructions?: SortOrder
    notes?: SortOrder
    glassware?: SortOrder
    ice?: SortOrder
    touch?: TouchOrderByRelationAggregateInput
    RecipeBookBuild?: RecipeBookBuildOrderByRelationAggregateInput
    userBuild?: UserBuildOrderByRelationAggregateInput
  }

  export type BuildWhereUniqueInput = {
    id?: number
  }

  export type BuildOrderByWithAggregationInput = {
    id?: SortOrder
    buildName?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    recipeId?: SortOrder
    instructions?: SortOrder
    notes?: SortOrder
    glassware?: SortOrder
    ice?: SortOrder
    _count?: BuildCountOrderByAggregateInput
    _avg?: BuildAvgOrderByAggregateInput
    _max?: BuildMaxOrderByAggregateInput
    _min?: BuildMinOrderByAggregateInput
    _sum?: BuildSumOrderByAggregateInput
  }

  export type BuildScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BuildScalarWhereWithAggregatesInput>
    OR?: Enumerable<BuildScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BuildScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    buildName?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    editedAt?: DateTimeWithAggregatesFilter | Date | string
    createdById?: StringWithAggregatesFilter | string
    editedById?: StringWithAggregatesFilter | string
    recipeId?: IntNullableWithAggregatesFilter | number | null
    instructions?: StringNullableWithAggregatesFilter | string | null
    notes?: StringNullableWithAggregatesFilter | string | null
    glassware?: StringNullableWithAggregatesFilter | string | null
    ice?: StringNullableWithAggregatesFilter | string | null
  }

  export type UserBuildWhereInput = {
    AND?: Enumerable<UserBuildWhereInput>
    OR?: Enumerable<UserBuildWhereInput>
    NOT?: Enumerable<UserBuildWhereInput>
    id?: IntFilter | number
    userId?: StringFilter | string
    buildId?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    build?: XOR<BuildRelationFilter, BuildWhereInput>
    partner?: BoolFilter | boolean
    manager?: BoolFilter | boolean
  }

  export type UserBuildOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    buildId?: SortOrder
    user?: UserOrderByWithRelationInput
    build?: BuildOrderByWithRelationInput
    partner?: SortOrder
    manager?: SortOrder
  }

  export type UserBuildWhereUniqueInput = {
    id?: number
  }

  export type UserBuildOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    buildId?: SortOrder
    partner?: SortOrder
    manager?: SortOrder
    _count?: UserBuildCountOrderByAggregateInput
    _avg?: UserBuildAvgOrderByAggregateInput
    _max?: UserBuildMaxOrderByAggregateInput
    _min?: UserBuildMinOrderByAggregateInput
    _sum?: UserBuildSumOrderByAggregateInput
  }

  export type UserBuildScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserBuildScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserBuildScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserBuildScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: StringWithAggregatesFilter | string
    buildId?: IntWithAggregatesFilter | number
    partner?: BoolWithAggregatesFilter | boolean
    manager?: BoolWithAggregatesFilter | boolean
  }

  export type RecipeWhereInput = {
    AND?: Enumerable<RecipeWhereInput>
    OR?: Enumerable<RecipeWhereInput>
    NOT?: Enumerable<RecipeWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    name?: StringFilter | string
    origin?: StringNullableFilter | string | null
    history?: StringNullableFilter | string | null
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    createdById?: StringFilter | string
    build?: BuildListRelationFilter
  }

  export type RecipeOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    origin?: SortOrder
    history?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    createdById?: SortOrder
    build?: BuildOrderByRelationAggregateInput
  }

  export type RecipeWhereUniqueInput = {
    id?: number
  }

  export type RecipeOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    origin?: SortOrder
    history?: SortOrder
    createdById?: SortOrder
    _count?: RecipeCountOrderByAggregateInput
    _avg?: RecipeAvgOrderByAggregateInput
    _max?: RecipeMaxOrderByAggregateInput
    _min?: RecipeMinOrderByAggregateInput
    _sum?: RecipeSumOrderByAggregateInput
  }

  export type RecipeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RecipeScalarWhereWithAggregatesInput>
    OR?: Enumerable<RecipeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RecipeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    name?: StringWithAggregatesFilter | string
    origin?: StringNullableWithAggregatesFilter | string | null
    history?: StringNullableWithAggregatesFilter | string | null
    createdById?: StringWithAggregatesFilter | string
  }

  export type RecipeBookBuildWhereInput = {
    AND?: Enumerable<RecipeBookBuildWhereInput>
    OR?: Enumerable<RecipeBookBuildWhereInput>
    NOT?: Enumerable<RecipeBookBuildWhereInput>
    id?: IntFilter | number
    buildId?: IntFilter | number
    recipeBookId?: IntFilter | number
    recipeBook?: XOR<RecipeBookRelationFilter, RecipeBookWhereInput>
    build?: XOR<BuildRelationFilter, BuildWhereInput>
  }

  export type RecipeBookBuildOrderByWithRelationInput = {
    id?: SortOrder
    buildId?: SortOrder
    recipeBookId?: SortOrder
    recipeBook?: RecipeBookOrderByWithRelationInput
    build?: BuildOrderByWithRelationInput
  }

  export type RecipeBookBuildWhereUniqueInput = {
    id?: number
  }

  export type RecipeBookBuildOrderByWithAggregationInput = {
    id?: SortOrder
    buildId?: SortOrder
    recipeBookId?: SortOrder
    _count?: RecipeBookBuildCountOrderByAggregateInput
    _avg?: RecipeBookBuildAvgOrderByAggregateInput
    _max?: RecipeBookBuildMaxOrderByAggregateInput
    _min?: RecipeBookBuildMinOrderByAggregateInput
    _sum?: RecipeBookBuildSumOrderByAggregateInput
  }

  export type RecipeBookBuildScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RecipeBookBuildScalarWhereWithAggregatesInput>
    OR?: Enumerable<RecipeBookBuildScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RecipeBookBuildScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    buildId?: IntWithAggregatesFilter | number
    recipeBookId?: IntWithAggregatesFilter | number
  }

  export type TouchWhereInput = {
    AND?: Enumerable<TouchWhereInput>
    OR?: Enumerable<TouchWhereInput>
    NOT?: Enumerable<TouchWhereInput>
    id?: IntFilter | number
    ingredientName?: StringFilter | string
    ingredientId?: IntNullableFilter | number | null
    ingredient?: XOR<IngredientRelationFilter, IngredientWhereInput> | null
    build?: XOR<BuildRelationFilter, BuildWhereInput> | null
    buildId?: IntNullableFilter | number | null
    order?: IntNullableFilter | number | null
    amount?: FloatNullableFilter | number | null
    unit?: StringNullableFilter | string | null
  }

  export type TouchOrderByWithRelationInput = {
    id?: SortOrder
    ingredientName?: SortOrder
    ingredientId?: SortOrder
    ingredient?: IngredientOrderByWithRelationInput
    build?: BuildOrderByWithRelationInput
    buildId?: SortOrder
    order?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
  }

  export type TouchWhereUniqueInput = {
    id?: number
  }

  export type TouchOrderByWithAggregationInput = {
    id?: SortOrder
    ingredientName?: SortOrder
    ingredientId?: SortOrder
    buildId?: SortOrder
    order?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    _count?: TouchCountOrderByAggregateInput
    _avg?: TouchAvgOrderByAggregateInput
    _max?: TouchMaxOrderByAggregateInput
    _min?: TouchMinOrderByAggregateInput
    _sum?: TouchSumOrderByAggregateInput
  }

  export type TouchScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TouchScalarWhereWithAggregatesInput>
    OR?: Enumerable<TouchScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TouchScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    ingredientName?: StringWithAggregatesFilter | string
    ingredientId?: IntNullableWithAggregatesFilter | number | null
    buildId?: IntNullableWithAggregatesFilter | number | null
    order?: IntNullableWithAggregatesFilter | number | null
    amount?: FloatNullableWithAggregatesFilter | number | null
    unit?: StringNullableWithAggregatesFilter | string | null
  }

  export type IngredientWhereInput = {
    AND?: Enumerable<IngredientWhereInput>
    OR?: Enumerable<IngredientWhereInput>
    NOT?: Enumerable<IngredientWhereInput>
    id?: IntFilter | number
    dateCreated?: DateTimeFilter | Date | string
    createdBy?: XOR<UserRelationFilter, UserWhereInput> | null
    createdById?: StringNullableFilter | string | null
    name?: StringFilter | string
    price?: FloatNullableFilter | number | null
    amount?: FloatNullableFilter | number | null
    unit?: StringNullableFilter | string | null
    touch?: TouchListRelationFilter
    ingredientStorage?: IngredientStorageListRelationFilter
  }

  export type IngredientOrderByWithRelationInput = {
    id?: SortOrder
    dateCreated?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    createdById?: SortOrder
    name?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    touch?: TouchOrderByRelationAggregateInput
    ingredientStorage?: ingredientStorageOrderByRelationAggregateInput
  }

  export type IngredientWhereUniqueInput = {
    id?: number
  }

  export type IngredientOrderByWithAggregationInput = {
    id?: SortOrder
    dateCreated?: SortOrder
    createdById?: SortOrder
    name?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    _count?: IngredientCountOrderByAggregateInput
    _avg?: IngredientAvgOrderByAggregateInput
    _max?: IngredientMaxOrderByAggregateInput
    _min?: IngredientMinOrderByAggregateInput
    _sum?: IngredientSumOrderByAggregateInput
  }

  export type IngredientScalarWhereWithAggregatesInput = {
    AND?: Enumerable<IngredientScalarWhereWithAggregatesInput>
    OR?: Enumerable<IngredientScalarWhereWithAggregatesInput>
    NOT?: Enumerable<IngredientScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    dateCreated?: DateTimeWithAggregatesFilter | Date | string
    createdById?: StringNullableWithAggregatesFilter | string | null
    name?: StringWithAggregatesFilter | string
    price?: FloatNullableWithAggregatesFilter | number | null
    amount?: FloatNullableWithAggregatesFilter | number | null
    unit?: StringNullableWithAggregatesFilter | string | null
  }

  export type InventoryWhereInput = {
    AND?: Enumerable<InventoryWhereInput>
    OR?: Enumerable<InventoryWhereInput>
    NOT?: Enumerable<InventoryWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    editedAt?: DateTimeFilter | Date | string
    createdById?: StringFilter | string
    editedById?: StringFilter | string
    createdBy?: XOR<UserRelationFilter, UserWhereInput> | null
    editedBy?: XOR<UserRelationFilter, UserWhereInput> | null
    InventoryStorage?: InventoryStorageListRelationFilter
  }

  export type InventoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    editedBy?: UserOrderByWithRelationInput
    InventoryStorage?: InventoryStorageOrderByRelationAggregateInput
  }

  export type InventoryWhereUniqueInput = {
    id?: number
  }

  export type InventoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    _count?: InventoryCountOrderByAggregateInput
    _avg?: InventoryAvgOrderByAggregateInput
    _max?: InventoryMaxOrderByAggregateInput
    _min?: InventoryMinOrderByAggregateInput
    _sum?: InventorySumOrderByAggregateInput
  }

  export type InventoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InventoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<InventoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InventoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    editedAt?: DateTimeWithAggregatesFilter | Date | string
    createdById?: StringWithAggregatesFilter | string
    editedById?: StringWithAggregatesFilter | string
  }

  export type InventoryStorageWhereInput = {
    AND?: Enumerable<InventoryStorageWhereInput>
    OR?: Enumerable<InventoryStorageWhereInput>
    NOT?: Enumerable<InventoryStorageWhereInput>
    id?: IntFilter | number
    inventoryId?: IntFilter | number
    storageId?: IntFilter | number
    storage?: XOR<StorageRelationFilter, StorageWhereInput>
    inventory?: XOR<InventoryRelationFilter, InventoryWhereInput>
  }

  export type InventoryStorageOrderByWithRelationInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    storageId?: SortOrder
    storage?: StorageOrderByWithRelationInput
    inventory?: InventoryOrderByWithRelationInput
  }

  export type InventoryStorageWhereUniqueInput = {
    id?: number
  }

  export type InventoryStorageOrderByWithAggregationInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    storageId?: SortOrder
    _count?: InventoryStorageCountOrderByAggregateInput
    _avg?: InventoryStorageAvgOrderByAggregateInput
    _max?: InventoryStorageMaxOrderByAggregateInput
    _min?: InventoryStorageMinOrderByAggregateInput
    _sum?: InventoryStorageSumOrderByAggregateInput
  }

  export type InventoryStorageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InventoryStorageScalarWhereWithAggregatesInput>
    OR?: Enumerable<InventoryStorageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InventoryStorageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    inventoryId?: IntWithAggregatesFilter | number
    storageId?: IntWithAggregatesFilter | number
  }

  export type StorageWhereInput = {
    AND?: Enumerable<StorageWhereInput>
    OR?: Enumerable<StorageWhereInput>
    NOT?: Enumerable<StorageWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    editedAt?: DateTimeFilter | Date | string
    createdById?: StringFilter | string
    editedById?: StringFilter | string
    createdBy?: XOR<UserRelationFilter, UserWhereInput> | null
    editedBy?: XOR<UserRelationFilter, UserWhereInput> | null
    inventoryStorage?: InventoryStorageListRelationFilter
    ingredientStorage?: IngredientStorageListRelationFilter
    userStorage?: UserStorageListRelationFilter
  }

  export type StorageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    editedBy?: UserOrderByWithRelationInput
    inventoryStorage?: InventoryStorageOrderByRelationAggregateInput
    ingredientStorage?: ingredientStorageOrderByRelationAggregateInput
    userStorage?: UserStorageOrderByRelationAggregateInput
  }

  export type StorageWhereUniqueInput = {
    id?: number
  }

  export type StorageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    _count?: StorageCountOrderByAggregateInput
    _avg?: StorageAvgOrderByAggregateInput
    _max?: StorageMaxOrderByAggregateInput
    _min?: StorageMinOrderByAggregateInput
    _sum?: StorageSumOrderByAggregateInput
  }

  export type StorageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StorageScalarWhereWithAggregatesInput>
    OR?: Enumerable<StorageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StorageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    editedAt?: DateTimeWithAggregatesFilter | Date | string
    createdById?: StringWithAggregatesFilter | string
    editedById?: StringWithAggregatesFilter | string
  }

  export type ingredientStorageWhereInput = {
    AND?: Enumerable<ingredientStorageWhereInput>
    OR?: Enumerable<ingredientStorageWhereInput>
    NOT?: Enumerable<ingredientStorageWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    editedAt?: DateTimeFilter | Date | string
    ingredientId?: IntNullableFilter | number | null
    ingredient?: XOR<IngredientRelationFilter, IngredientWhereInput> | null
    quantity?: FloatNullableFilter | number | null
    Storage?: XOR<StorageRelationFilter, StorageWhereInput> | null
    storageId?: IntNullableFilter | number | null
  }

  export type ingredientStorageOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    ingredientId?: SortOrder
    ingredient?: IngredientOrderByWithRelationInput
    quantity?: SortOrder
    Storage?: StorageOrderByWithRelationInput
    storageId?: SortOrder
  }

  export type ingredientStorageWhereUniqueInput = {
    id?: number
  }

  export type ingredientStorageOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    ingredientId?: SortOrder
    quantity?: SortOrder
    storageId?: SortOrder
    _count?: ingredientStorageCountOrderByAggregateInput
    _avg?: ingredientStorageAvgOrderByAggregateInput
    _max?: ingredientStorageMaxOrderByAggregateInput
    _min?: ingredientStorageMinOrderByAggregateInput
    _sum?: ingredientStorageSumOrderByAggregateInput
  }

  export type ingredientStorageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ingredientStorageScalarWhereWithAggregatesInput>
    OR?: Enumerable<ingredientStorageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ingredientStorageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    editedAt?: DateTimeWithAggregatesFilter | Date | string
    ingredientId?: IntNullableWithAggregatesFilter | number | null
    quantity?: FloatNullableWithAggregatesFilter | number | null
    storageId?: IntNullableWithAggregatesFilter | number | null
  }

  export type UserStorageWhereInput = {
    AND?: Enumerable<UserStorageWhereInput>
    OR?: Enumerable<UserStorageWhereInput>
    NOT?: Enumerable<UserStorageWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    editedAt?: DateTimeFilter | Date | string
    userId?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    quantity?: FloatNullableFilter | number | null
    Storage?: XOR<StorageRelationFilter, StorageWhereInput> | null
    storageId?: IntNullableFilter | number | null
    partner?: BoolFilter | boolean
    manager?: BoolFilter | boolean
  }

  export type UserStorageOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    quantity?: SortOrder
    Storage?: StorageOrderByWithRelationInput
    storageId?: SortOrder
    partner?: SortOrder
    manager?: SortOrder
  }

  export type UserStorageWhereUniqueInput = {
    id?: number
  }

  export type UserStorageOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    userId?: SortOrder
    quantity?: SortOrder
    storageId?: SortOrder
    partner?: SortOrder
    manager?: SortOrder
    _count?: UserStorageCountOrderByAggregateInput
    _avg?: UserStorageAvgOrderByAggregateInput
    _max?: UserStorageMaxOrderByAggregateInput
    _min?: UserStorageMinOrderByAggregateInput
    _sum?: UserStorageSumOrderByAggregateInput
  }

  export type UserStorageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserStorageScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserStorageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserStorageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    editedAt?: DateTimeWithAggregatesFilter | Date | string
    userId?: StringWithAggregatesFilter | string
    quantity?: FloatNullableWithAggregatesFilter | number | null
    storageId?: IntNullableWithAggregatesFilter | number | null
    partner?: BoolWithAggregatesFilter | boolean
    manager?: BoolWithAggregatesFilter | boolean
  }

  export type CrewWhereInput = {
    AND?: Enumerable<CrewWhereInput>
    OR?: Enumerable<CrewWhereInput>
    NOT?: Enumerable<CrewWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    editedAt?: DateTimeFilter | Date | string
    createdById?: StringFilter | string
    editedById?: StringFilter | string
    createdBy?: XOR<UserRelationFilter, UserWhereInput> | null
    editedBy?: XOR<UserRelationFilter, UserWhereInput> | null
    userCrew?: UserCrewListRelationFilter
  }

  export type CrewOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    editedBy?: UserOrderByWithRelationInput
    userCrew?: UserCrewOrderByRelationAggregateInput
  }

  export type CrewWhereUniqueInput = {
    id?: number
  }

  export type CrewOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    _count?: CrewCountOrderByAggregateInput
    _avg?: CrewAvgOrderByAggregateInput
    _max?: CrewMaxOrderByAggregateInput
    _min?: CrewMinOrderByAggregateInput
    _sum?: CrewSumOrderByAggregateInput
  }

  export type CrewScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CrewScalarWhereWithAggregatesInput>
    OR?: Enumerable<CrewScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CrewScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    editedAt?: DateTimeWithAggregatesFilter | Date | string
    createdById?: StringWithAggregatesFilter | string
    editedById?: StringWithAggregatesFilter | string
  }

  export type UserCrewWhereInput = {
    AND?: Enumerable<UserCrewWhereInput>
    OR?: Enumerable<UserCrewWhereInput>
    NOT?: Enumerable<UserCrewWhereInput>
    id?: IntFilter | number
    userId?: StringFilter | string
    crewId?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    crew?: XOR<CrewRelationFilter, CrewWhereInput>
    partner?: BoolFilter | boolean
    manager?: BoolFilter | boolean
  }

  export type UserCrewOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    crewId?: SortOrder
    user?: UserOrderByWithRelationInput
    crew?: CrewOrderByWithRelationInput
    partner?: SortOrder
    manager?: SortOrder
  }

  export type UserCrewWhereUniqueInput = {
    id?: number
  }

  export type UserCrewOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    crewId?: SortOrder
    partner?: SortOrder
    manager?: SortOrder
    _count?: UserCrewCountOrderByAggregateInput
    _avg?: UserCrewAvgOrderByAggregateInput
    _max?: UserCrewMaxOrderByAggregateInput
    _min?: UserCrewMinOrderByAggregateInput
    _sum?: UserCrewSumOrderByAggregateInput
  }

  export type UserCrewScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserCrewScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserCrewScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserCrewScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: StringWithAggregatesFilter | string
    crewId?: IntWithAggregatesFilter | number
    partner?: BoolWithAggregatesFilter | boolean
    manager?: BoolWithAggregatesFilter | boolean
  }

  export type UserCreateInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    userBuild?: UserBuildCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    userStorage?: UserStorageCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    userBuild?: UserBuildUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    userStorage?: UserStorageUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    userBuild?: UserBuildUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    userStorage?: UserStorageUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    userBuild?: UserBuildUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    userStorage?: UserStorageUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileCreateInput = {
    user: UserCreateNestedOneWithoutProfileInput
    photo: string
  }

  export type ProfileUncheckedCreateInput = {
    id?: number
    userId: string
    photo: string
  }

  export type ProfileUpdateInput = {
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    photo?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileCreateManyInput = {
    id?: number
    userId: string
    photo: string
  }

  export type ProfileUpdateManyMutationInput = {
    photo?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookCreateInput = {
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutRecipeBookInput
    editedBy?: UserCreateNestedOneWithoutRecipeBookEditedByIdInput
    recipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutRecipeBookInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    editedById?: string | null
    recipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutRecipeBookInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutRecipeBookNestedInput
    editedBy?: UserUpdateOneWithoutRecipeBookEditedByIdNestedInput
    recipeBookBuild?: RecipeBookBuildUpdateManyWithoutRecipeBookNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutRecipeBookNestedInput
  }

  export type RecipeBookUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutRecipeBookNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutRecipeBookNestedInput
  }

  export type RecipeBookCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    editedById?: string | null
  }

  export type RecipeBookUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipeBookUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeBookUserCreateInput = {
    recipeBook: RecipeBookCreateNestedOneWithoutRecipeBookUserInput
    user: UserCreateNestedOneWithoutRecipeBookUserInput
    partner: boolean
    manager: boolean
  }

  export type RecipeBookUserUncheckedCreateInput = {
    id?: number
    userId: string
    recipeBookId: number
    partner: boolean
    manager: boolean
  }

  export type RecipeBookUserUpdateInput = {
    recipeBook?: RecipeBookUpdateOneRequiredWithoutRecipeBookUserNestedInput
    user?: UserUpdateOneRequiredWithoutRecipeBookUserNestedInput
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RecipeBookUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    recipeBookId?: IntFieldUpdateOperationsInput | number
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RecipeBookUserCreateManyInput = {
    id?: number
    userId: string
    recipeBookId: number
    partner: boolean
    manager: boolean
  }

  export type RecipeBookUserUpdateManyMutationInput = {
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RecipeBookUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    recipeBookId?: IntFieldUpdateOperationsInput | number
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BuildCreateInput = {
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutBuildInput
    editedBy?: UserCreateNestedOneWithoutBuildEditedByInput
    recipe?: RecipeCreateNestedOneWithoutBuildInput
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    touch?: TouchCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutBuildInput
    userBuild?: UserBuildCreateNestedManyWithoutBuildInput
  }

  export type BuildUncheckedCreateInput = {
    id?: number
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    recipeId?: number | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutBuildInput
    userBuild?: UserBuildUncheckedCreateNestedManyWithoutBuildInput
  }

  export type BuildUpdateInput = {
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutBuildNestedInput
    editedBy?: UserUpdateOneWithoutBuildEditedByNestedInput
    recipe?: RecipeUpdateOneWithoutBuildNestedInput
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUpdateManyWithoutBuildNestedInput
    userBuild?: UserBuildUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutBuildNestedInput
    userBuild?: UserBuildUncheckedUpdateManyWithoutBuildNestedInput
  }

  export type BuildCreateManyInput = {
    id?: number
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    recipeId?: number | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
  }

  export type BuildUpdateManyMutationInput = {
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BuildUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserBuildCreateInput = {
    user: UserCreateNestedOneWithoutUserBuildInput
    build: BuildCreateNestedOneWithoutUserBuildInput
    partner: boolean
    manager: boolean
  }

  export type UserBuildUncheckedCreateInput = {
    id?: number
    userId: string
    buildId: number
    partner: boolean
    manager: boolean
  }

  export type UserBuildUpdateInput = {
    user?: UserUpdateOneRequiredWithoutUserBuildNestedInput
    build?: BuildUpdateOneRequiredWithoutUserBuildNestedInput
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserBuildUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    buildId?: IntFieldUpdateOperationsInput | number
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserBuildCreateManyInput = {
    id?: number
    userId: string
    buildId: number
    partner: boolean
    manager: boolean
  }

  export type UserBuildUpdateManyMutationInput = {
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserBuildUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    buildId?: IntFieldUpdateOperationsInput | number
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RecipeCreateInput = {
    createdAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    createdBy: UserCreateNestedOneWithoutRecipeInput
    build?: BuildCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    createdById: string
    build?: BuildUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneRequiredWithoutRecipeNestedInput
    build?: BuildUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    build?: BuildUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeCreateManyInput = {
    id?: number
    createdAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    createdById: string
  }

  export type RecipeUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookBuildCreateInput = {
    recipeBook: RecipeBookCreateNestedOneWithoutRecipeBookBuildInput
    build: BuildCreateNestedOneWithoutRecipeBookBuildInput
  }

  export type RecipeBookBuildUncheckedCreateInput = {
    id?: number
    buildId: number
    recipeBookId: number
  }

  export type RecipeBookBuildUpdateInput = {
    recipeBook?: RecipeBookUpdateOneRequiredWithoutRecipeBookBuildNestedInput
    build?: BuildUpdateOneRequiredWithoutRecipeBookBuildNestedInput
  }

  export type RecipeBookBuildUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildId?: IntFieldUpdateOperationsInput | number
    recipeBookId?: IntFieldUpdateOperationsInput | number
  }

  export type RecipeBookBuildCreateManyInput = {
    id?: number
    buildId: number
    recipeBookId: number
  }

  export type RecipeBookBuildUpdateManyMutationInput = {

  }

  export type RecipeBookBuildUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildId?: IntFieldUpdateOperationsInput | number
    recipeBookId?: IntFieldUpdateOperationsInput | number
  }

  export type TouchCreateInput = {
    ingredientName?: string
    ingredient?: IngredientCreateNestedOneWithoutTouchInput
    build?: BuildCreateNestedOneWithoutTouchInput
    order?: number | null
    amount?: number | null
    unit?: string | null
  }

  export type TouchUncheckedCreateInput = {
    id?: number
    ingredientName?: string
    ingredientId?: number | null
    buildId?: number | null
    order?: number | null
    amount?: number | null
    unit?: string | null
  }

  export type TouchUpdateInput = {
    ingredientName?: StringFieldUpdateOperationsInput | string
    ingredient?: IngredientUpdateOneWithoutTouchNestedInput
    build?: BuildUpdateOneWithoutTouchNestedInput
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TouchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ingredientName?: StringFieldUpdateOperationsInput | string
    ingredientId?: NullableIntFieldUpdateOperationsInput | number | null
    buildId?: NullableIntFieldUpdateOperationsInput | number | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TouchCreateManyInput = {
    id?: number
    ingredientName?: string
    ingredientId?: number | null
    buildId?: number | null
    order?: number | null
    amount?: number | null
    unit?: string | null
  }

  export type TouchUpdateManyMutationInput = {
    ingredientName?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TouchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ingredientName?: StringFieldUpdateOperationsInput | string
    ingredientId?: NullableIntFieldUpdateOperationsInput | number | null
    buildId?: NullableIntFieldUpdateOperationsInput | number | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IngredientCreateInput = {
    dateCreated?: Date | string
    createdBy?: UserCreateNestedOneWithoutIngredientInput
    name?: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    touch?: TouchCreateNestedManyWithoutIngredientInput
    ingredientStorage?: ingredientStorageCreateNestedManyWithoutIngredientInput
  }

  export type IngredientUncheckedCreateInput = {
    id?: number
    dateCreated?: Date | string
    createdById?: string | null
    name?: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutIngredientInput
    ingredientStorage?: ingredientStorageUncheckedCreateNestedManyWithoutIngredientInput
  }

  export type IngredientUpdateInput = {
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutIngredientNestedInput
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUpdateManyWithoutIngredientNestedInput
    ingredientStorage?: ingredientStorageUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientStorage?: ingredientStorageUncheckedUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientCreateManyInput = {
    id?: number
    dateCreated?: Date | string
    createdById?: string | null
    name?: string
    price?: number | null
    amount?: number | null
    unit?: string | null
  }

  export type IngredientUpdateManyMutationInput = {
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IngredientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryCreateInput = {
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutInventoryCreatedByInput
    editedBy?: UserCreateNestedOneWithoutInventoryEditedByInput
    InventoryStorage?: InventoryStorageCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    InventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutInventoryCreatedByNestedInput
    editedBy?: UserUpdateOneWithoutInventoryEditedByNestedInput
    InventoryStorage?: InventoryStorageUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    InventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
  }

  export type InventoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryStorageCreateInput = {
    storage: StorageCreateNestedOneWithoutInventoryStorageInput
    inventory: InventoryCreateNestedOneWithoutInventoryStorageInput
  }

  export type InventoryStorageUncheckedCreateInput = {
    id?: number
    inventoryId: number
    storageId: number
  }

  export type InventoryStorageUpdateInput = {
    storage?: StorageUpdateOneRequiredWithoutInventoryStorageNestedInput
    inventory?: InventoryUpdateOneRequiredWithoutInventoryStorageNestedInput
  }

  export type InventoryStorageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
    storageId?: IntFieldUpdateOperationsInput | number
  }

  export type InventoryStorageCreateManyInput = {
    id?: number
    inventoryId: number
    storageId: number
  }

  export type InventoryStorageUpdateManyMutationInput = {

  }

  export type InventoryStorageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
    storageId?: IntFieldUpdateOperationsInput | number
  }

  export type StorageCreateInput = {
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutStorageInput
    editedBy?: UserCreateNestedOneWithoutStorageEditedByInput
    inventoryStorage?: InventoryStorageCreateNestedManyWithoutStorageInput
    ingredientStorage?: ingredientStorageCreateNestedManyWithoutStorageInput
    userStorage?: UserStorageCreateNestedManyWithoutStorageInput
  }

  export type StorageUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    inventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutStorageInput
    ingredientStorage?: ingredientStorageUncheckedCreateNestedManyWithoutStorageInput
    userStorage?: UserStorageUncheckedCreateNestedManyWithoutStorageInput
  }

  export type StorageUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutStorageNestedInput
    editedBy?: UserUpdateOneWithoutStorageEditedByNestedInput
    inventoryStorage?: InventoryStorageUpdateManyWithoutStorageNestedInput
    ingredientStorage?: ingredientStorageUpdateManyWithoutStorageNestedInput
    userStorage?: UserStorageUpdateManyWithoutStorageNestedInput
  }

  export type StorageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    inventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutStorageNestedInput
    ingredientStorage?: ingredientStorageUncheckedUpdateManyWithoutStorageNestedInput
    userStorage?: UserStorageUncheckedUpdateManyWithoutStorageNestedInput
  }

  export type StorageCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
  }

  export type StorageUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
  }

  export type ingredientStorageCreateInput = {
    createdAt?: Date | string
    editedAt?: Date | string
    ingredient?: IngredientCreateNestedOneWithoutIngredientStorageInput
    quantity?: number | null
    Storage?: StorageCreateNestedOneWithoutIngredientStorageInput
  }

  export type ingredientStorageUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    editedAt?: Date | string
    ingredientId?: number | null
    quantity?: number | null
    storageId?: number | null
  }

  export type ingredientStorageUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ingredient?: IngredientUpdateOneWithoutIngredientStorageNestedInput
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    Storage?: StorageUpdateOneWithoutIngredientStorageNestedInput
  }

  export type ingredientStorageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ingredientId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    storageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ingredientStorageCreateManyInput = {
    id?: number
    createdAt?: Date | string
    editedAt?: Date | string
    ingredientId?: number | null
    quantity?: number | null
    storageId?: number | null
  }

  export type ingredientStorageUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ingredientStorageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ingredientId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    storageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserStorageCreateInput = {
    createdAt?: Date | string
    editedAt?: Date | string
    user?: UserCreateNestedOneWithoutUserStorageInput
    quantity?: number | null
    Storage?: StorageCreateNestedOneWithoutUserStorageInput
    partner: boolean
    manager: boolean
  }

  export type UserStorageUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    editedAt?: Date | string
    userId: string
    quantity?: number | null
    storageId?: number | null
    partner: boolean
    manager: boolean
  }

  export type UserStorageUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutUserStorageNestedInput
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    Storage?: StorageUpdateOneWithoutUserStorageNestedInput
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserStorageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    storageId?: NullableIntFieldUpdateOperationsInput | number | null
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserStorageCreateManyInput = {
    id?: number
    createdAt?: Date | string
    editedAt?: Date | string
    userId: string
    quantity?: number | null
    storageId?: number | null
    partner: boolean
    manager: boolean
  }

  export type UserStorageUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserStorageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    storageId?: NullableIntFieldUpdateOperationsInput | number | null
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CrewCreateInput = {
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCrewInput
    editedBy?: UserCreateNestedOneWithoutCrewEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutCrewInput
  }

  export type CrewUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutCrewInput
  }

  export type CrewUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCrewNestedInput
    editedBy?: UserUpdateOneWithoutCrewEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutCrewNestedInput
  }

  export type CrewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    userCrew?: UserCrewUncheckedUpdateManyWithoutCrewNestedInput
  }

  export type CrewCreateManyInput = {
    id?: number
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
  }

  export type CrewUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
  }

  export type UserCrewCreateInput = {
    user: UserCreateNestedOneWithoutUserCrewInput
    crew: CrewCreateNestedOneWithoutUserCrewInput
    partner: boolean
    manager: boolean
  }

  export type UserCrewUncheckedCreateInput = {
    id?: number
    userId: string
    crewId: number
    partner: boolean
    manager: boolean
  }

  export type UserCrewUpdateInput = {
    user?: UserUpdateOneRequiredWithoutUserCrewNestedInput
    crew?: CrewUpdateOneRequiredWithoutUserCrewNestedInput
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCrewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    crewId?: IntFieldUpdateOperationsInput | number
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCrewCreateManyInput = {
    id?: number
    userId: string
    crewId: number
    partner: boolean
    manager: boolean
  }

  export type UserCrewUpdateManyMutationInput = {
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCrewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    crewId?: IntFieldUpdateOperationsInput | number
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type ProfileRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type RecipeBookUserListRelationFilter = {
    every?: RecipeBookUserWhereInput
    some?: RecipeBookUserWhereInput
    none?: RecipeBookUserWhereInput
  }

  export type RecipeBookListRelationFilter = {
    every?: RecipeBookWhereInput
    some?: RecipeBookWhereInput
    none?: RecipeBookWhereInput
  }

  export type UserCrewListRelationFilter = {
    every?: UserCrewWhereInput
    some?: UserCrewWhereInput
    none?: UserCrewWhereInput
  }

  export type CrewListRelationFilter = {
    every?: CrewWhereInput
    some?: CrewWhereInput
    none?: CrewWhereInput
  }

  export type UserBuildListRelationFilter = {
    every?: UserBuildWhereInput
    some?: UserBuildWhereInput
    none?: UserBuildWhereInput
  }

  export type BuildListRelationFilter = {
    every?: BuildWhereInput
    some?: BuildWhereInput
    none?: BuildWhereInput
  }

  export type RecipeListRelationFilter = {
    every?: RecipeWhereInput
    some?: RecipeWhereInput
    none?: RecipeWhereInput
  }

  export type IngredientListRelationFilter = {
    every?: IngredientWhereInput
    some?: IngredientWhereInput
    none?: IngredientWhereInput
  }

  export type UserStorageListRelationFilter = {
    every?: UserStorageWhereInput
    some?: UserStorageWhereInput
    none?: UserStorageWhereInput
  }

  export type StorageListRelationFilter = {
    every?: StorageWhereInput
    some?: StorageWhereInput
    none?: StorageWhereInput
  }

  export type InventoryListRelationFilter = {
    every?: InventoryWhereInput
    some?: InventoryWhereInput
    none?: InventoryWhereInput
  }

  export type RecipeBookUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipeBookOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCrewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CrewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserBuildOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BuildOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IngredientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserStorageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StorageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    userName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateJoined?: SortOrder
    lastEdited?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    userName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateJoined?: SortOrder
    lastEdited?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    userName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateJoined?: SortOrder
    lastEdited?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    photo?: SortOrder
  }

  export type ProfileAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    photo?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    photo?: SortOrder
  }

  export type ProfileSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type RecipeBookBuildListRelationFilter = {
    every?: RecipeBookBuildWhereInput
    some?: RecipeBookBuildWhereInput
    none?: RecipeBookBuildWhereInput
  }

  export type RecipeBookBuildOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipeBookCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type RecipeBookAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RecipeBookMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type RecipeBookMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type RecipeBookSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RecipeBookRelationFilter = {
    is?: RecipeBookWhereInput
    isNot?: RecipeBookWhereInput
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type RecipeBookUserCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    recipeBookId?: SortOrder
    partner?: SortOrder
    manager?: SortOrder
  }

  export type RecipeBookUserAvgOrderByAggregateInput = {
    id?: SortOrder
    recipeBookId?: SortOrder
  }

  export type RecipeBookUserMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    recipeBookId?: SortOrder
    partner?: SortOrder
    manager?: SortOrder
  }

  export type RecipeBookUserMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    recipeBookId?: SortOrder
    partner?: SortOrder
    manager?: SortOrder
  }

  export type RecipeBookUserSumOrderByAggregateInput = {
    id?: SortOrder
    recipeBookId?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type RecipeRelationFilter = {
    is?: RecipeWhereInput | null
    isNot?: RecipeWhereInput | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type TouchListRelationFilter = {
    every?: TouchWhereInput
    some?: TouchWhereInput
    none?: TouchWhereInput
  }

  export type TouchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BuildCountOrderByAggregateInput = {
    id?: SortOrder
    buildName?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    recipeId?: SortOrder
    instructions?: SortOrder
    notes?: SortOrder
    glassware?: SortOrder
    ice?: SortOrder
  }

  export type BuildAvgOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
  }

  export type BuildMaxOrderByAggregateInput = {
    id?: SortOrder
    buildName?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    recipeId?: SortOrder
    instructions?: SortOrder
    notes?: SortOrder
    glassware?: SortOrder
    ice?: SortOrder
  }

  export type BuildMinOrderByAggregateInput = {
    id?: SortOrder
    buildName?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    recipeId?: SortOrder
    instructions?: SortOrder
    notes?: SortOrder
    glassware?: SortOrder
    ice?: SortOrder
  }

  export type BuildSumOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type BuildRelationFilter = {
    is?: BuildWhereInput | null
    isNot?: BuildWhereInput | null
  }

  export type UserBuildCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    buildId?: SortOrder
    partner?: SortOrder
    manager?: SortOrder
  }

  export type UserBuildAvgOrderByAggregateInput = {
    id?: SortOrder
    buildId?: SortOrder
  }

  export type UserBuildMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    buildId?: SortOrder
    partner?: SortOrder
    manager?: SortOrder
  }

  export type UserBuildMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    buildId?: SortOrder
    partner?: SortOrder
    manager?: SortOrder
  }

  export type UserBuildSumOrderByAggregateInput = {
    id?: SortOrder
    buildId?: SortOrder
  }

  export type RecipeCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    origin?: SortOrder
    history?: SortOrder
    createdById?: SortOrder
  }

  export type RecipeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RecipeMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    origin?: SortOrder
    history?: SortOrder
    createdById?: SortOrder
  }

  export type RecipeMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    origin?: SortOrder
    history?: SortOrder
    createdById?: SortOrder
  }

  export type RecipeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RecipeBookBuildCountOrderByAggregateInput = {
    id?: SortOrder
    buildId?: SortOrder
    recipeBookId?: SortOrder
  }

  export type RecipeBookBuildAvgOrderByAggregateInput = {
    id?: SortOrder
    buildId?: SortOrder
    recipeBookId?: SortOrder
  }

  export type RecipeBookBuildMaxOrderByAggregateInput = {
    id?: SortOrder
    buildId?: SortOrder
    recipeBookId?: SortOrder
  }

  export type RecipeBookBuildMinOrderByAggregateInput = {
    id?: SortOrder
    buildId?: SortOrder
    recipeBookId?: SortOrder
  }

  export type RecipeBookBuildSumOrderByAggregateInput = {
    id?: SortOrder
    buildId?: SortOrder
    recipeBookId?: SortOrder
  }

  export type IngredientRelationFilter = {
    is?: IngredientWhereInput | null
    isNot?: IngredientWhereInput | null
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type TouchCountOrderByAggregateInput = {
    id?: SortOrder
    ingredientName?: SortOrder
    ingredientId?: SortOrder
    buildId?: SortOrder
    order?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
  }

  export type TouchAvgOrderByAggregateInput = {
    id?: SortOrder
    ingredientId?: SortOrder
    buildId?: SortOrder
    order?: SortOrder
    amount?: SortOrder
  }

  export type TouchMaxOrderByAggregateInput = {
    id?: SortOrder
    ingredientName?: SortOrder
    ingredientId?: SortOrder
    buildId?: SortOrder
    order?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
  }

  export type TouchMinOrderByAggregateInput = {
    id?: SortOrder
    ingredientName?: SortOrder
    ingredientId?: SortOrder
    buildId?: SortOrder
    order?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
  }

  export type TouchSumOrderByAggregateInput = {
    id?: SortOrder
    ingredientId?: SortOrder
    buildId?: SortOrder
    order?: SortOrder
    amount?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type IngredientStorageListRelationFilter = {
    every?: ingredientStorageWhereInput
    some?: ingredientStorageWhereInput
    none?: ingredientStorageWhereInput
  }

  export type ingredientStorageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IngredientCountOrderByAggregateInput = {
    id?: SortOrder
    dateCreated?: SortOrder
    createdById?: SortOrder
    name?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
  }

  export type IngredientAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    amount?: SortOrder
  }

  export type IngredientMaxOrderByAggregateInput = {
    id?: SortOrder
    dateCreated?: SortOrder
    createdById?: SortOrder
    name?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
  }

  export type IngredientMinOrderByAggregateInput = {
    id?: SortOrder
    dateCreated?: SortOrder
    createdById?: SortOrder
    name?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
  }

  export type IngredientSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    amount?: SortOrder
  }

  export type InventoryStorageListRelationFilter = {
    every?: InventoryStorageWhereInput
    some?: InventoryStorageWhereInput
    none?: InventoryStorageWhereInput
  }

  export type InventoryStorageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type InventoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type InventoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type InventoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type InventorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StorageRelationFilter = {
    is?: StorageWhereInput
    isNot?: StorageWhereInput
  }

  export type InventoryRelationFilter = {
    is?: InventoryWhereInput
    isNot?: InventoryWhereInput
  }

  export type InventoryStorageCountOrderByAggregateInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    storageId?: SortOrder
  }

  export type InventoryStorageAvgOrderByAggregateInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    storageId?: SortOrder
  }

  export type InventoryStorageMaxOrderByAggregateInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    storageId?: SortOrder
  }

  export type InventoryStorageMinOrderByAggregateInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    storageId?: SortOrder
  }

  export type InventoryStorageSumOrderByAggregateInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    storageId?: SortOrder
  }

  export type StorageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type StorageAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StorageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type StorageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type StorageSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ingredientStorageCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    ingredientId?: SortOrder
    quantity?: SortOrder
    storageId?: SortOrder
  }

  export type ingredientStorageAvgOrderByAggregateInput = {
    id?: SortOrder
    ingredientId?: SortOrder
    quantity?: SortOrder
    storageId?: SortOrder
  }

  export type ingredientStorageMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    ingredientId?: SortOrder
    quantity?: SortOrder
    storageId?: SortOrder
  }

  export type ingredientStorageMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    ingredientId?: SortOrder
    quantity?: SortOrder
    storageId?: SortOrder
  }

  export type ingredientStorageSumOrderByAggregateInput = {
    id?: SortOrder
    ingredientId?: SortOrder
    quantity?: SortOrder
    storageId?: SortOrder
  }

  export type UserStorageCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    userId?: SortOrder
    quantity?: SortOrder
    storageId?: SortOrder
    partner?: SortOrder
    manager?: SortOrder
  }

  export type UserStorageAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    storageId?: SortOrder
  }

  export type UserStorageMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    userId?: SortOrder
    quantity?: SortOrder
    storageId?: SortOrder
    partner?: SortOrder
    manager?: SortOrder
  }

  export type UserStorageMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    userId?: SortOrder
    quantity?: SortOrder
    storageId?: SortOrder
    partner?: SortOrder
    manager?: SortOrder
  }

  export type UserStorageSumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    storageId?: SortOrder
  }

  export type CrewCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type CrewAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CrewMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type CrewMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type CrewSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CrewRelationFilter = {
    is?: CrewWhereInput
    isNot?: CrewWhereInput
  }

  export type UserCrewCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    crewId?: SortOrder
    partner?: SortOrder
    manager?: SortOrder
  }

  export type UserCrewAvgOrderByAggregateInput = {
    id?: SortOrder
    crewId?: SortOrder
  }

  export type UserCrewMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    crewId?: SortOrder
    partner?: SortOrder
    manager?: SortOrder
  }

  export type UserCrewMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    crewId?: SortOrder
    partner?: SortOrder
    manager?: SortOrder
  }

  export type UserCrewSumOrderByAggregateInput = {
    id?: SortOrder
    crewId?: SortOrder
  }

  export type ProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type RecipeBookUserCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<RecipeBookUserCreateWithoutUserInput>, Enumerable<RecipeBookUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RecipeBookUserCreateOrConnectWithoutUserInput>
    createMany?: RecipeBookUserCreateManyUserInputEnvelope
    connect?: Enumerable<RecipeBookUserWhereUniqueInput>
  }

  export type RecipeBookCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<RecipeBookCreateWithoutCreatedByInput>, Enumerable<RecipeBookUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<RecipeBookCreateOrConnectWithoutCreatedByInput>
    createMany?: RecipeBookCreateManyCreatedByInputEnvelope
    connect?: Enumerable<RecipeBookWhereUniqueInput>
  }

  export type RecipeBookCreateNestedManyWithoutEditedByInput = {
    create?: XOR<Enumerable<RecipeBookCreateWithoutEditedByInput>, Enumerable<RecipeBookUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<RecipeBookCreateOrConnectWithoutEditedByInput>
    createMany?: RecipeBookCreateManyEditedByInputEnvelope
    connect?: Enumerable<RecipeBookWhereUniqueInput>
  }

  export type UserCrewCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserCrewCreateWithoutUserInput>, Enumerable<UserCrewUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserCrewCreateOrConnectWithoutUserInput>
    createMany?: UserCrewCreateManyUserInputEnvelope
    connect?: Enumerable<UserCrewWhereUniqueInput>
  }

  export type CrewCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<CrewCreateWithoutCreatedByInput>, Enumerable<CrewUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<CrewCreateOrConnectWithoutCreatedByInput>
    createMany?: CrewCreateManyCreatedByInputEnvelope
    connect?: Enumerable<CrewWhereUniqueInput>
  }

  export type CrewCreateNestedManyWithoutEditedByInput = {
    create?: XOR<Enumerable<CrewCreateWithoutEditedByInput>, Enumerable<CrewUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<CrewCreateOrConnectWithoutEditedByInput>
    createMany?: CrewCreateManyEditedByInputEnvelope
    connect?: Enumerable<CrewWhereUniqueInput>
  }

  export type UserBuildCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserBuildCreateWithoutUserInput>, Enumerable<UserBuildUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserBuildCreateOrConnectWithoutUserInput>
    createMany?: UserBuildCreateManyUserInputEnvelope
    connect?: Enumerable<UserBuildWhereUniqueInput>
  }

  export type BuildCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<BuildCreateWithoutCreatedByInput>, Enumerable<BuildUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutCreatedByInput>
    createMany?: BuildCreateManyCreatedByInputEnvelope
    connect?: Enumerable<BuildWhereUniqueInput>
  }

  export type BuildCreateNestedManyWithoutEditedByInput = {
    create?: XOR<Enumerable<BuildCreateWithoutEditedByInput>, Enumerable<BuildUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutEditedByInput>
    createMany?: BuildCreateManyEditedByInputEnvelope
    connect?: Enumerable<BuildWhereUniqueInput>
  }

  export type RecipeCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<RecipeCreateWithoutCreatedByInput>, Enumerable<RecipeUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<RecipeCreateOrConnectWithoutCreatedByInput>
    createMany?: RecipeCreateManyCreatedByInputEnvelope
    connect?: Enumerable<RecipeWhereUniqueInput>
  }

  export type IngredientCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<IngredientCreateWithoutCreatedByInput>, Enumerable<IngredientUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<IngredientCreateOrConnectWithoutCreatedByInput>
    createMany?: IngredientCreateManyCreatedByInputEnvelope
    connect?: Enumerable<IngredientWhereUniqueInput>
  }

  export type UserStorageCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserStorageCreateWithoutUserInput>, Enumerable<UserStorageUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserStorageCreateOrConnectWithoutUserInput>
    createMany?: UserStorageCreateManyUserInputEnvelope
    connect?: Enumerable<UserStorageWhereUniqueInput>
  }

  export type StorageCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<StorageCreateWithoutCreatedByInput>, Enumerable<StorageUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<StorageCreateOrConnectWithoutCreatedByInput>
    createMany?: StorageCreateManyCreatedByInputEnvelope
    connect?: Enumerable<StorageWhereUniqueInput>
  }

  export type StorageCreateNestedManyWithoutEditedByInput = {
    create?: XOR<Enumerable<StorageCreateWithoutEditedByInput>, Enumerable<StorageUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<StorageCreateOrConnectWithoutEditedByInput>
    createMany?: StorageCreateManyEditedByInputEnvelope
    connect?: Enumerable<StorageWhereUniqueInput>
  }

  export type InventoryCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<InventoryCreateWithoutCreatedByInput>, Enumerable<InventoryUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<InventoryCreateOrConnectWithoutCreatedByInput>
    createMany?: InventoryCreateManyCreatedByInputEnvelope
    connect?: Enumerable<InventoryWhereUniqueInput>
  }

  export type InventoryCreateNestedManyWithoutEditedByInput = {
    create?: XOR<Enumerable<InventoryCreateWithoutEditedByInput>, Enumerable<InventoryUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<InventoryCreateOrConnectWithoutEditedByInput>
    createMany?: InventoryCreateManyEditedByInputEnvelope
    connect?: Enumerable<InventoryWhereUniqueInput>
  }

  export type ProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type RecipeBookUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<RecipeBookUserCreateWithoutUserInput>, Enumerable<RecipeBookUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RecipeBookUserCreateOrConnectWithoutUserInput>
    createMany?: RecipeBookUserCreateManyUserInputEnvelope
    connect?: Enumerable<RecipeBookUserWhereUniqueInput>
  }

  export type RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<RecipeBookCreateWithoutCreatedByInput>, Enumerable<RecipeBookUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<RecipeBookCreateOrConnectWithoutCreatedByInput>
    createMany?: RecipeBookCreateManyCreatedByInputEnvelope
    connect?: Enumerable<RecipeBookWhereUniqueInput>
  }

  export type RecipeBookUncheckedCreateNestedManyWithoutEditedByInput = {
    create?: XOR<Enumerable<RecipeBookCreateWithoutEditedByInput>, Enumerable<RecipeBookUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<RecipeBookCreateOrConnectWithoutEditedByInput>
    createMany?: RecipeBookCreateManyEditedByInputEnvelope
    connect?: Enumerable<RecipeBookWhereUniqueInput>
  }

  export type UserCrewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserCrewCreateWithoutUserInput>, Enumerable<UserCrewUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserCrewCreateOrConnectWithoutUserInput>
    createMany?: UserCrewCreateManyUserInputEnvelope
    connect?: Enumerable<UserCrewWhereUniqueInput>
  }

  export type CrewUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<CrewCreateWithoutCreatedByInput>, Enumerable<CrewUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<CrewCreateOrConnectWithoutCreatedByInput>
    createMany?: CrewCreateManyCreatedByInputEnvelope
    connect?: Enumerable<CrewWhereUniqueInput>
  }

  export type CrewUncheckedCreateNestedManyWithoutEditedByInput = {
    create?: XOR<Enumerable<CrewCreateWithoutEditedByInput>, Enumerable<CrewUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<CrewCreateOrConnectWithoutEditedByInput>
    createMany?: CrewCreateManyEditedByInputEnvelope
    connect?: Enumerable<CrewWhereUniqueInput>
  }

  export type UserBuildUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserBuildCreateWithoutUserInput>, Enumerable<UserBuildUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserBuildCreateOrConnectWithoutUserInput>
    createMany?: UserBuildCreateManyUserInputEnvelope
    connect?: Enumerable<UserBuildWhereUniqueInput>
  }

  export type BuildUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<BuildCreateWithoutCreatedByInput>, Enumerable<BuildUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutCreatedByInput>
    createMany?: BuildCreateManyCreatedByInputEnvelope
    connect?: Enumerable<BuildWhereUniqueInput>
  }

  export type BuildUncheckedCreateNestedManyWithoutEditedByInput = {
    create?: XOR<Enumerable<BuildCreateWithoutEditedByInput>, Enumerable<BuildUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutEditedByInput>
    createMany?: BuildCreateManyEditedByInputEnvelope
    connect?: Enumerable<BuildWhereUniqueInput>
  }

  export type RecipeUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<RecipeCreateWithoutCreatedByInput>, Enumerable<RecipeUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<RecipeCreateOrConnectWithoutCreatedByInput>
    createMany?: RecipeCreateManyCreatedByInputEnvelope
    connect?: Enumerable<RecipeWhereUniqueInput>
  }

  export type IngredientUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<IngredientCreateWithoutCreatedByInput>, Enumerable<IngredientUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<IngredientCreateOrConnectWithoutCreatedByInput>
    createMany?: IngredientCreateManyCreatedByInputEnvelope
    connect?: Enumerable<IngredientWhereUniqueInput>
  }

  export type UserStorageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserStorageCreateWithoutUserInput>, Enumerable<UserStorageUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserStorageCreateOrConnectWithoutUserInput>
    createMany?: UserStorageCreateManyUserInputEnvelope
    connect?: Enumerable<UserStorageWhereUniqueInput>
  }

  export type StorageUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<StorageCreateWithoutCreatedByInput>, Enumerable<StorageUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<StorageCreateOrConnectWithoutCreatedByInput>
    createMany?: StorageCreateManyCreatedByInputEnvelope
    connect?: Enumerable<StorageWhereUniqueInput>
  }

  export type StorageUncheckedCreateNestedManyWithoutEditedByInput = {
    create?: XOR<Enumerable<StorageCreateWithoutEditedByInput>, Enumerable<StorageUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<StorageCreateOrConnectWithoutEditedByInput>
    createMany?: StorageCreateManyEditedByInputEnvelope
    connect?: Enumerable<StorageWhereUniqueInput>
  }

  export type InventoryUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<InventoryCreateWithoutCreatedByInput>, Enumerable<InventoryUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<InventoryCreateOrConnectWithoutCreatedByInput>
    createMany?: InventoryCreateManyCreatedByInputEnvelope
    connect?: Enumerable<InventoryWhereUniqueInput>
  }

  export type InventoryUncheckedCreateNestedManyWithoutEditedByInput = {
    create?: XOR<Enumerable<InventoryCreateWithoutEditedByInput>, Enumerable<InventoryUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<InventoryCreateOrConnectWithoutEditedByInput>
    createMany?: InventoryCreateManyEditedByInputEnvelope
    connect?: Enumerable<InventoryWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type RecipeBookUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<RecipeBookUserCreateWithoutUserInput>, Enumerable<RecipeBookUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RecipeBookUserCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<RecipeBookUserUpsertWithWhereUniqueWithoutUserInput>
    createMany?: RecipeBookUserCreateManyUserInputEnvelope
    set?: Enumerable<RecipeBookUserWhereUniqueInput>
    disconnect?: Enumerable<RecipeBookUserWhereUniqueInput>
    delete?: Enumerable<RecipeBookUserWhereUniqueInput>
    connect?: Enumerable<RecipeBookUserWhereUniqueInput>
    update?: Enumerable<RecipeBookUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<RecipeBookUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<RecipeBookUserScalarWhereInput>
  }

  export type RecipeBookUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<RecipeBookCreateWithoutCreatedByInput>, Enumerable<RecipeBookUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<RecipeBookCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<RecipeBookUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: RecipeBookCreateManyCreatedByInputEnvelope
    set?: Enumerable<RecipeBookWhereUniqueInput>
    disconnect?: Enumerable<RecipeBookWhereUniqueInput>
    delete?: Enumerable<RecipeBookWhereUniqueInput>
    connect?: Enumerable<RecipeBookWhereUniqueInput>
    update?: Enumerable<RecipeBookUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<RecipeBookUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<RecipeBookScalarWhereInput>
  }

  export type RecipeBookUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<Enumerable<RecipeBookCreateWithoutEditedByInput>, Enumerable<RecipeBookUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<RecipeBookCreateOrConnectWithoutEditedByInput>
    upsert?: Enumerable<RecipeBookUpsertWithWhereUniqueWithoutEditedByInput>
    createMany?: RecipeBookCreateManyEditedByInputEnvelope
    set?: Enumerable<RecipeBookWhereUniqueInput>
    disconnect?: Enumerable<RecipeBookWhereUniqueInput>
    delete?: Enumerable<RecipeBookWhereUniqueInput>
    connect?: Enumerable<RecipeBookWhereUniqueInput>
    update?: Enumerable<RecipeBookUpdateWithWhereUniqueWithoutEditedByInput>
    updateMany?: Enumerable<RecipeBookUpdateManyWithWhereWithoutEditedByInput>
    deleteMany?: Enumerable<RecipeBookScalarWhereInput>
  }

  export type UserCrewUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserCrewCreateWithoutUserInput>, Enumerable<UserCrewUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserCrewCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserCrewUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserCrewCreateManyUserInputEnvelope
    set?: Enumerable<UserCrewWhereUniqueInput>
    disconnect?: Enumerable<UserCrewWhereUniqueInput>
    delete?: Enumerable<UserCrewWhereUniqueInput>
    connect?: Enumerable<UserCrewWhereUniqueInput>
    update?: Enumerable<UserCrewUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserCrewUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserCrewScalarWhereInput>
  }

  export type CrewUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<CrewCreateWithoutCreatedByInput>, Enumerable<CrewUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<CrewCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<CrewUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: CrewCreateManyCreatedByInputEnvelope
    set?: Enumerable<CrewWhereUniqueInput>
    disconnect?: Enumerable<CrewWhereUniqueInput>
    delete?: Enumerable<CrewWhereUniqueInput>
    connect?: Enumerable<CrewWhereUniqueInput>
    update?: Enumerable<CrewUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<CrewUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<CrewScalarWhereInput>
  }

  export type CrewUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<Enumerable<CrewCreateWithoutEditedByInput>, Enumerable<CrewUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<CrewCreateOrConnectWithoutEditedByInput>
    upsert?: Enumerable<CrewUpsertWithWhereUniqueWithoutEditedByInput>
    createMany?: CrewCreateManyEditedByInputEnvelope
    set?: Enumerable<CrewWhereUniqueInput>
    disconnect?: Enumerable<CrewWhereUniqueInput>
    delete?: Enumerable<CrewWhereUniqueInput>
    connect?: Enumerable<CrewWhereUniqueInput>
    update?: Enumerable<CrewUpdateWithWhereUniqueWithoutEditedByInput>
    updateMany?: Enumerable<CrewUpdateManyWithWhereWithoutEditedByInput>
    deleteMany?: Enumerable<CrewScalarWhereInput>
  }

  export type UserBuildUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserBuildCreateWithoutUserInput>, Enumerable<UserBuildUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserBuildCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserBuildUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserBuildCreateManyUserInputEnvelope
    set?: Enumerable<UserBuildWhereUniqueInput>
    disconnect?: Enumerable<UserBuildWhereUniqueInput>
    delete?: Enumerable<UserBuildWhereUniqueInput>
    connect?: Enumerable<UserBuildWhereUniqueInput>
    update?: Enumerable<UserBuildUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserBuildUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserBuildScalarWhereInput>
  }

  export type BuildUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<BuildCreateWithoutCreatedByInput>, Enumerable<BuildUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<BuildUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: BuildCreateManyCreatedByInputEnvelope
    set?: Enumerable<BuildWhereUniqueInput>
    disconnect?: Enumerable<BuildWhereUniqueInput>
    delete?: Enumerable<BuildWhereUniqueInput>
    connect?: Enumerable<BuildWhereUniqueInput>
    update?: Enumerable<BuildUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<BuildUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<BuildScalarWhereInput>
  }

  export type BuildUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<Enumerable<BuildCreateWithoutEditedByInput>, Enumerable<BuildUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutEditedByInput>
    upsert?: Enumerable<BuildUpsertWithWhereUniqueWithoutEditedByInput>
    createMany?: BuildCreateManyEditedByInputEnvelope
    set?: Enumerable<BuildWhereUniqueInput>
    disconnect?: Enumerable<BuildWhereUniqueInput>
    delete?: Enumerable<BuildWhereUniqueInput>
    connect?: Enumerable<BuildWhereUniqueInput>
    update?: Enumerable<BuildUpdateWithWhereUniqueWithoutEditedByInput>
    updateMany?: Enumerable<BuildUpdateManyWithWhereWithoutEditedByInput>
    deleteMany?: Enumerable<BuildScalarWhereInput>
  }

  export type RecipeUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<RecipeCreateWithoutCreatedByInput>, Enumerable<RecipeUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<RecipeCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<RecipeUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: RecipeCreateManyCreatedByInputEnvelope
    set?: Enumerable<RecipeWhereUniqueInput>
    disconnect?: Enumerable<RecipeWhereUniqueInput>
    delete?: Enumerable<RecipeWhereUniqueInput>
    connect?: Enumerable<RecipeWhereUniqueInput>
    update?: Enumerable<RecipeUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<RecipeUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<RecipeScalarWhereInput>
  }

  export type IngredientUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<IngredientCreateWithoutCreatedByInput>, Enumerable<IngredientUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<IngredientCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<IngredientUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: IngredientCreateManyCreatedByInputEnvelope
    set?: Enumerable<IngredientWhereUniqueInput>
    disconnect?: Enumerable<IngredientWhereUniqueInput>
    delete?: Enumerable<IngredientWhereUniqueInput>
    connect?: Enumerable<IngredientWhereUniqueInput>
    update?: Enumerable<IngredientUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<IngredientUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<IngredientScalarWhereInput>
  }

  export type UserStorageUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserStorageCreateWithoutUserInput>, Enumerable<UserStorageUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserStorageCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserStorageUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserStorageCreateManyUserInputEnvelope
    set?: Enumerable<UserStorageWhereUniqueInput>
    disconnect?: Enumerable<UserStorageWhereUniqueInput>
    delete?: Enumerable<UserStorageWhereUniqueInput>
    connect?: Enumerable<UserStorageWhereUniqueInput>
    update?: Enumerable<UserStorageUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserStorageUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserStorageScalarWhereInput>
  }

  export type StorageUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<StorageCreateWithoutCreatedByInput>, Enumerable<StorageUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<StorageCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<StorageUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: StorageCreateManyCreatedByInputEnvelope
    set?: Enumerable<StorageWhereUniqueInput>
    disconnect?: Enumerable<StorageWhereUniqueInput>
    delete?: Enumerable<StorageWhereUniqueInput>
    connect?: Enumerable<StorageWhereUniqueInput>
    update?: Enumerable<StorageUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<StorageUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<StorageScalarWhereInput>
  }

  export type StorageUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<Enumerable<StorageCreateWithoutEditedByInput>, Enumerable<StorageUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<StorageCreateOrConnectWithoutEditedByInput>
    upsert?: Enumerable<StorageUpsertWithWhereUniqueWithoutEditedByInput>
    createMany?: StorageCreateManyEditedByInputEnvelope
    set?: Enumerable<StorageWhereUniqueInput>
    disconnect?: Enumerable<StorageWhereUniqueInput>
    delete?: Enumerable<StorageWhereUniqueInput>
    connect?: Enumerable<StorageWhereUniqueInput>
    update?: Enumerable<StorageUpdateWithWhereUniqueWithoutEditedByInput>
    updateMany?: Enumerable<StorageUpdateManyWithWhereWithoutEditedByInput>
    deleteMany?: Enumerable<StorageScalarWhereInput>
  }

  export type InventoryUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<InventoryCreateWithoutCreatedByInput>, Enumerable<InventoryUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<InventoryCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<InventoryUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: InventoryCreateManyCreatedByInputEnvelope
    set?: Enumerable<InventoryWhereUniqueInput>
    disconnect?: Enumerable<InventoryWhereUniqueInput>
    delete?: Enumerable<InventoryWhereUniqueInput>
    connect?: Enumerable<InventoryWhereUniqueInput>
    update?: Enumerable<InventoryUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<InventoryUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<InventoryScalarWhereInput>
  }

  export type InventoryUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<Enumerable<InventoryCreateWithoutEditedByInput>, Enumerable<InventoryUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<InventoryCreateOrConnectWithoutEditedByInput>
    upsert?: Enumerable<InventoryUpsertWithWhereUniqueWithoutEditedByInput>
    createMany?: InventoryCreateManyEditedByInputEnvelope
    set?: Enumerable<InventoryWhereUniqueInput>
    disconnect?: Enumerable<InventoryWhereUniqueInput>
    delete?: Enumerable<InventoryWhereUniqueInput>
    connect?: Enumerable<InventoryWhereUniqueInput>
    update?: Enumerable<InventoryUpdateWithWhereUniqueWithoutEditedByInput>
    updateMany?: Enumerable<InventoryUpdateManyWithWhereWithoutEditedByInput>
    deleteMany?: Enumerable<InventoryScalarWhereInput>
  }

  export type ProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<RecipeBookUserCreateWithoutUserInput>, Enumerable<RecipeBookUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RecipeBookUserCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<RecipeBookUserUpsertWithWhereUniqueWithoutUserInput>
    createMany?: RecipeBookUserCreateManyUserInputEnvelope
    set?: Enumerable<RecipeBookUserWhereUniqueInput>
    disconnect?: Enumerable<RecipeBookUserWhereUniqueInput>
    delete?: Enumerable<RecipeBookUserWhereUniqueInput>
    connect?: Enumerable<RecipeBookUserWhereUniqueInput>
    update?: Enumerable<RecipeBookUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<RecipeBookUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<RecipeBookUserScalarWhereInput>
  }

  export type RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<RecipeBookCreateWithoutCreatedByInput>, Enumerable<RecipeBookUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<RecipeBookCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<RecipeBookUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: RecipeBookCreateManyCreatedByInputEnvelope
    set?: Enumerable<RecipeBookWhereUniqueInput>
    disconnect?: Enumerable<RecipeBookWhereUniqueInput>
    delete?: Enumerable<RecipeBookWhereUniqueInput>
    connect?: Enumerable<RecipeBookWhereUniqueInput>
    update?: Enumerable<RecipeBookUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<RecipeBookUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<RecipeBookScalarWhereInput>
  }

  export type RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<Enumerable<RecipeBookCreateWithoutEditedByInput>, Enumerable<RecipeBookUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<RecipeBookCreateOrConnectWithoutEditedByInput>
    upsert?: Enumerable<RecipeBookUpsertWithWhereUniqueWithoutEditedByInput>
    createMany?: RecipeBookCreateManyEditedByInputEnvelope
    set?: Enumerable<RecipeBookWhereUniqueInput>
    disconnect?: Enumerable<RecipeBookWhereUniqueInput>
    delete?: Enumerable<RecipeBookWhereUniqueInput>
    connect?: Enumerable<RecipeBookWhereUniqueInput>
    update?: Enumerable<RecipeBookUpdateWithWhereUniqueWithoutEditedByInput>
    updateMany?: Enumerable<RecipeBookUpdateManyWithWhereWithoutEditedByInput>
    deleteMany?: Enumerable<RecipeBookScalarWhereInput>
  }

  export type UserCrewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserCrewCreateWithoutUserInput>, Enumerable<UserCrewUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserCrewCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserCrewUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserCrewCreateManyUserInputEnvelope
    set?: Enumerable<UserCrewWhereUniqueInput>
    disconnect?: Enumerable<UserCrewWhereUniqueInput>
    delete?: Enumerable<UserCrewWhereUniqueInput>
    connect?: Enumerable<UserCrewWhereUniqueInput>
    update?: Enumerable<UserCrewUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserCrewUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserCrewScalarWhereInput>
  }

  export type CrewUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<CrewCreateWithoutCreatedByInput>, Enumerable<CrewUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<CrewCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<CrewUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: CrewCreateManyCreatedByInputEnvelope
    set?: Enumerable<CrewWhereUniqueInput>
    disconnect?: Enumerable<CrewWhereUniqueInput>
    delete?: Enumerable<CrewWhereUniqueInput>
    connect?: Enumerable<CrewWhereUniqueInput>
    update?: Enumerable<CrewUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<CrewUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<CrewScalarWhereInput>
  }

  export type CrewUncheckedUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<Enumerable<CrewCreateWithoutEditedByInput>, Enumerable<CrewUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<CrewCreateOrConnectWithoutEditedByInput>
    upsert?: Enumerable<CrewUpsertWithWhereUniqueWithoutEditedByInput>
    createMany?: CrewCreateManyEditedByInputEnvelope
    set?: Enumerable<CrewWhereUniqueInput>
    disconnect?: Enumerable<CrewWhereUniqueInput>
    delete?: Enumerable<CrewWhereUniqueInput>
    connect?: Enumerable<CrewWhereUniqueInput>
    update?: Enumerable<CrewUpdateWithWhereUniqueWithoutEditedByInput>
    updateMany?: Enumerable<CrewUpdateManyWithWhereWithoutEditedByInput>
    deleteMany?: Enumerable<CrewScalarWhereInput>
  }

  export type UserBuildUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserBuildCreateWithoutUserInput>, Enumerable<UserBuildUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserBuildCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserBuildUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserBuildCreateManyUserInputEnvelope
    set?: Enumerable<UserBuildWhereUniqueInput>
    disconnect?: Enumerable<UserBuildWhereUniqueInput>
    delete?: Enumerable<UserBuildWhereUniqueInput>
    connect?: Enumerable<UserBuildWhereUniqueInput>
    update?: Enumerable<UserBuildUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserBuildUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserBuildScalarWhereInput>
  }

  export type BuildUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<BuildCreateWithoutCreatedByInput>, Enumerable<BuildUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<BuildUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: BuildCreateManyCreatedByInputEnvelope
    set?: Enumerable<BuildWhereUniqueInput>
    disconnect?: Enumerable<BuildWhereUniqueInput>
    delete?: Enumerable<BuildWhereUniqueInput>
    connect?: Enumerable<BuildWhereUniqueInput>
    update?: Enumerable<BuildUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<BuildUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<BuildScalarWhereInput>
  }

  export type BuildUncheckedUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<Enumerable<BuildCreateWithoutEditedByInput>, Enumerable<BuildUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutEditedByInput>
    upsert?: Enumerable<BuildUpsertWithWhereUniqueWithoutEditedByInput>
    createMany?: BuildCreateManyEditedByInputEnvelope
    set?: Enumerable<BuildWhereUniqueInput>
    disconnect?: Enumerable<BuildWhereUniqueInput>
    delete?: Enumerable<BuildWhereUniqueInput>
    connect?: Enumerable<BuildWhereUniqueInput>
    update?: Enumerable<BuildUpdateWithWhereUniqueWithoutEditedByInput>
    updateMany?: Enumerable<BuildUpdateManyWithWhereWithoutEditedByInput>
    deleteMany?: Enumerable<BuildScalarWhereInput>
  }

  export type RecipeUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<RecipeCreateWithoutCreatedByInput>, Enumerable<RecipeUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<RecipeCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<RecipeUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: RecipeCreateManyCreatedByInputEnvelope
    set?: Enumerable<RecipeWhereUniqueInput>
    disconnect?: Enumerable<RecipeWhereUniqueInput>
    delete?: Enumerable<RecipeWhereUniqueInput>
    connect?: Enumerable<RecipeWhereUniqueInput>
    update?: Enumerable<RecipeUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<RecipeUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<RecipeScalarWhereInput>
  }

  export type IngredientUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<IngredientCreateWithoutCreatedByInput>, Enumerable<IngredientUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<IngredientCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<IngredientUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: IngredientCreateManyCreatedByInputEnvelope
    set?: Enumerable<IngredientWhereUniqueInput>
    disconnect?: Enumerable<IngredientWhereUniqueInput>
    delete?: Enumerable<IngredientWhereUniqueInput>
    connect?: Enumerable<IngredientWhereUniqueInput>
    update?: Enumerable<IngredientUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<IngredientUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<IngredientScalarWhereInput>
  }

  export type UserStorageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserStorageCreateWithoutUserInput>, Enumerable<UserStorageUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserStorageCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserStorageUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserStorageCreateManyUserInputEnvelope
    set?: Enumerable<UserStorageWhereUniqueInput>
    disconnect?: Enumerable<UserStorageWhereUniqueInput>
    delete?: Enumerable<UserStorageWhereUniqueInput>
    connect?: Enumerable<UserStorageWhereUniqueInput>
    update?: Enumerable<UserStorageUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserStorageUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserStorageScalarWhereInput>
  }

  export type StorageUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<StorageCreateWithoutCreatedByInput>, Enumerable<StorageUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<StorageCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<StorageUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: StorageCreateManyCreatedByInputEnvelope
    set?: Enumerable<StorageWhereUniqueInput>
    disconnect?: Enumerable<StorageWhereUniqueInput>
    delete?: Enumerable<StorageWhereUniqueInput>
    connect?: Enumerable<StorageWhereUniqueInput>
    update?: Enumerable<StorageUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<StorageUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<StorageScalarWhereInput>
  }

  export type StorageUncheckedUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<Enumerable<StorageCreateWithoutEditedByInput>, Enumerable<StorageUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<StorageCreateOrConnectWithoutEditedByInput>
    upsert?: Enumerable<StorageUpsertWithWhereUniqueWithoutEditedByInput>
    createMany?: StorageCreateManyEditedByInputEnvelope
    set?: Enumerable<StorageWhereUniqueInput>
    disconnect?: Enumerable<StorageWhereUniqueInput>
    delete?: Enumerable<StorageWhereUniqueInput>
    connect?: Enumerable<StorageWhereUniqueInput>
    update?: Enumerable<StorageUpdateWithWhereUniqueWithoutEditedByInput>
    updateMany?: Enumerable<StorageUpdateManyWithWhereWithoutEditedByInput>
    deleteMany?: Enumerable<StorageScalarWhereInput>
  }

  export type InventoryUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<InventoryCreateWithoutCreatedByInput>, Enumerable<InventoryUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<InventoryCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<InventoryUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: InventoryCreateManyCreatedByInputEnvelope
    set?: Enumerable<InventoryWhereUniqueInput>
    disconnect?: Enumerable<InventoryWhereUniqueInput>
    delete?: Enumerable<InventoryWhereUniqueInput>
    connect?: Enumerable<InventoryWhereUniqueInput>
    update?: Enumerable<InventoryUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<InventoryUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<InventoryScalarWhereInput>
  }

  export type InventoryUncheckedUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<Enumerable<InventoryCreateWithoutEditedByInput>, Enumerable<InventoryUncheckedCreateWithoutEditedByInput>>
    connectOrCreate?: Enumerable<InventoryCreateOrConnectWithoutEditedByInput>
    upsert?: Enumerable<InventoryUpsertWithWhereUniqueWithoutEditedByInput>
    createMany?: InventoryCreateManyEditedByInputEnvelope
    set?: Enumerable<InventoryWhereUniqueInput>
    disconnect?: Enumerable<InventoryWhereUniqueInput>
    delete?: Enumerable<InventoryWhereUniqueInput>
    connect?: Enumerable<InventoryWhereUniqueInput>
    update?: Enumerable<InventoryUpdateWithWhereUniqueWithoutEditedByInput>
    updateMany?: Enumerable<InventoryUpdateManyWithWhereWithoutEditedByInput>
    deleteMany?: Enumerable<InventoryScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserCreateNestedOneWithoutRecipeBookInput = {
    create?: XOR<UserCreateWithoutRecipeBookInput, UserUncheckedCreateWithoutRecipeBookInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeBookInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRecipeBookEditedByIdInput = {
    create?: XOR<UserCreateWithoutRecipeBookEditedByIdInput, UserUncheckedCreateWithoutRecipeBookEditedByIdInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeBookEditedByIdInput
    connect?: UserWhereUniqueInput
  }

  export type RecipeBookBuildCreateNestedManyWithoutRecipeBookInput = {
    create?: XOR<Enumerable<RecipeBookBuildCreateWithoutRecipeBookInput>, Enumerable<RecipeBookBuildUncheckedCreateWithoutRecipeBookInput>>
    connectOrCreate?: Enumerable<RecipeBookBuildCreateOrConnectWithoutRecipeBookInput>
    createMany?: RecipeBookBuildCreateManyRecipeBookInputEnvelope
    connect?: Enumerable<RecipeBookBuildWhereUniqueInput>
  }

  export type RecipeBookUserCreateNestedManyWithoutRecipeBookInput = {
    create?: XOR<Enumerable<RecipeBookUserCreateWithoutRecipeBookInput>, Enumerable<RecipeBookUserUncheckedCreateWithoutRecipeBookInput>>
    connectOrCreate?: Enumerable<RecipeBookUserCreateOrConnectWithoutRecipeBookInput>
    createMany?: RecipeBookUserCreateManyRecipeBookInputEnvelope
    connect?: Enumerable<RecipeBookUserWhereUniqueInput>
  }

  export type RecipeBookBuildUncheckedCreateNestedManyWithoutRecipeBookInput = {
    create?: XOR<Enumerable<RecipeBookBuildCreateWithoutRecipeBookInput>, Enumerable<RecipeBookBuildUncheckedCreateWithoutRecipeBookInput>>
    connectOrCreate?: Enumerable<RecipeBookBuildCreateOrConnectWithoutRecipeBookInput>
    createMany?: RecipeBookBuildCreateManyRecipeBookInputEnvelope
    connect?: Enumerable<RecipeBookBuildWhereUniqueInput>
  }

  export type RecipeBookUserUncheckedCreateNestedManyWithoutRecipeBookInput = {
    create?: XOR<Enumerable<RecipeBookUserCreateWithoutRecipeBookInput>, Enumerable<RecipeBookUserUncheckedCreateWithoutRecipeBookInput>>
    connectOrCreate?: Enumerable<RecipeBookUserCreateOrConnectWithoutRecipeBookInput>
    createMany?: RecipeBookUserCreateManyRecipeBookInputEnvelope
    connect?: Enumerable<RecipeBookUserWhereUniqueInput>
  }

  export type UserUpdateOneWithoutRecipeBookNestedInput = {
    create?: XOR<UserCreateWithoutRecipeBookInput, UserUncheckedCreateWithoutRecipeBookInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeBookInput
    upsert?: UserUpsertWithoutRecipeBookInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutRecipeBookInput, UserUncheckedUpdateWithoutRecipeBookInput>
  }

  export type UserUpdateOneWithoutRecipeBookEditedByIdNestedInput = {
    create?: XOR<UserCreateWithoutRecipeBookEditedByIdInput, UserUncheckedCreateWithoutRecipeBookEditedByIdInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeBookEditedByIdInput
    upsert?: UserUpsertWithoutRecipeBookEditedByIdInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutRecipeBookEditedByIdInput, UserUncheckedUpdateWithoutRecipeBookEditedByIdInput>
  }

  export type RecipeBookBuildUpdateManyWithoutRecipeBookNestedInput = {
    create?: XOR<Enumerable<RecipeBookBuildCreateWithoutRecipeBookInput>, Enumerable<RecipeBookBuildUncheckedCreateWithoutRecipeBookInput>>
    connectOrCreate?: Enumerable<RecipeBookBuildCreateOrConnectWithoutRecipeBookInput>
    upsert?: Enumerable<RecipeBookBuildUpsertWithWhereUniqueWithoutRecipeBookInput>
    createMany?: RecipeBookBuildCreateManyRecipeBookInputEnvelope
    set?: Enumerable<RecipeBookBuildWhereUniqueInput>
    disconnect?: Enumerable<RecipeBookBuildWhereUniqueInput>
    delete?: Enumerable<RecipeBookBuildWhereUniqueInput>
    connect?: Enumerable<RecipeBookBuildWhereUniqueInput>
    update?: Enumerable<RecipeBookBuildUpdateWithWhereUniqueWithoutRecipeBookInput>
    updateMany?: Enumerable<RecipeBookBuildUpdateManyWithWhereWithoutRecipeBookInput>
    deleteMany?: Enumerable<RecipeBookBuildScalarWhereInput>
  }

  export type RecipeBookUserUpdateManyWithoutRecipeBookNestedInput = {
    create?: XOR<Enumerable<RecipeBookUserCreateWithoutRecipeBookInput>, Enumerable<RecipeBookUserUncheckedCreateWithoutRecipeBookInput>>
    connectOrCreate?: Enumerable<RecipeBookUserCreateOrConnectWithoutRecipeBookInput>
    upsert?: Enumerable<RecipeBookUserUpsertWithWhereUniqueWithoutRecipeBookInput>
    createMany?: RecipeBookUserCreateManyRecipeBookInputEnvelope
    set?: Enumerable<RecipeBookUserWhereUniqueInput>
    disconnect?: Enumerable<RecipeBookUserWhereUniqueInput>
    delete?: Enumerable<RecipeBookUserWhereUniqueInput>
    connect?: Enumerable<RecipeBookUserWhereUniqueInput>
    update?: Enumerable<RecipeBookUserUpdateWithWhereUniqueWithoutRecipeBookInput>
    updateMany?: Enumerable<RecipeBookUserUpdateManyWithWhereWithoutRecipeBookInput>
    deleteMany?: Enumerable<RecipeBookUserScalarWhereInput>
  }

  export type RecipeBookBuildUncheckedUpdateManyWithoutRecipeBookNestedInput = {
    create?: XOR<Enumerable<RecipeBookBuildCreateWithoutRecipeBookInput>, Enumerable<RecipeBookBuildUncheckedCreateWithoutRecipeBookInput>>
    connectOrCreate?: Enumerable<RecipeBookBuildCreateOrConnectWithoutRecipeBookInput>
    upsert?: Enumerable<RecipeBookBuildUpsertWithWhereUniqueWithoutRecipeBookInput>
    createMany?: RecipeBookBuildCreateManyRecipeBookInputEnvelope
    set?: Enumerable<RecipeBookBuildWhereUniqueInput>
    disconnect?: Enumerable<RecipeBookBuildWhereUniqueInput>
    delete?: Enumerable<RecipeBookBuildWhereUniqueInput>
    connect?: Enumerable<RecipeBookBuildWhereUniqueInput>
    update?: Enumerable<RecipeBookBuildUpdateWithWhereUniqueWithoutRecipeBookInput>
    updateMany?: Enumerable<RecipeBookBuildUpdateManyWithWhereWithoutRecipeBookInput>
    deleteMany?: Enumerable<RecipeBookBuildScalarWhereInput>
  }

  export type RecipeBookUserUncheckedUpdateManyWithoutRecipeBookNestedInput = {
    create?: XOR<Enumerable<RecipeBookUserCreateWithoutRecipeBookInput>, Enumerable<RecipeBookUserUncheckedCreateWithoutRecipeBookInput>>
    connectOrCreate?: Enumerable<RecipeBookUserCreateOrConnectWithoutRecipeBookInput>
    upsert?: Enumerable<RecipeBookUserUpsertWithWhereUniqueWithoutRecipeBookInput>
    createMany?: RecipeBookUserCreateManyRecipeBookInputEnvelope
    set?: Enumerable<RecipeBookUserWhereUniqueInput>
    disconnect?: Enumerable<RecipeBookUserWhereUniqueInput>
    delete?: Enumerable<RecipeBookUserWhereUniqueInput>
    connect?: Enumerable<RecipeBookUserWhereUniqueInput>
    update?: Enumerable<RecipeBookUserUpdateWithWhereUniqueWithoutRecipeBookInput>
    updateMany?: Enumerable<RecipeBookUserUpdateManyWithWhereWithoutRecipeBookInput>
    deleteMany?: Enumerable<RecipeBookUserScalarWhereInput>
  }

  export type RecipeBookCreateNestedOneWithoutRecipeBookUserInput = {
    create?: XOR<RecipeBookCreateWithoutRecipeBookUserInput, RecipeBookUncheckedCreateWithoutRecipeBookUserInput>
    connectOrCreate?: RecipeBookCreateOrConnectWithoutRecipeBookUserInput
    connect?: RecipeBookWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRecipeBookUserInput = {
    create?: XOR<UserCreateWithoutRecipeBookUserInput, UserUncheckedCreateWithoutRecipeBookUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeBookUserInput
    connect?: UserWhereUniqueInput
  }

  export type RecipeBookUpdateOneRequiredWithoutRecipeBookUserNestedInput = {
    create?: XOR<RecipeBookCreateWithoutRecipeBookUserInput, RecipeBookUncheckedCreateWithoutRecipeBookUserInput>
    connectOrCreate?: RecipeBookCreateOrConnectWithoutRecipeBookUserInput
    upsert?: RecipeBookUpsertWithoutRecipeBookUserInput
    connect?: RecipeBookWhereUniqueInput
    update?: XOR<RecipeBookUpdateWithoutRecipeBookUserInput, RecipeBookUncheckedUpdateWithoutRecipeBookUserInput>
  }

  export type UserUpdateOneRequiredWithoutRecipeBookUserNestedInput = {
    create?: XOR<UserCreateWithoutRecipeBookUserInput, UserUncheckedCreateWithoutRecipeBookUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeBookUserInput
    upsert?: UserUpsertWithoutRecipeBookUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutRecipeBookUserInput, UserUncheckedUpdateWithoutRecipeBookUserInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserCreateNestedOneWithoutBuildInput = {
    create?: XOR<UserCreateWithoutBuildInput, UserUncheckedCreateWithoutBuildInput>
    connectOrCreate?: UserCreateOrConnectWithoutBuildInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBuildEditedByInput = {
    create?: XOR<UserCreateWithoutBuildEditedByInput, UserUncheckedCreateWithoutBuildEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutBuildEditedByInput
    connect?: UserWhereUniqueInput
  }

  export type RecipeCreateNestedOneWithoutBuildInput = {
    create?: XOR<RecipeCreateWithoutBuildInput, RecipeUncheckedCreateWithoutBuildInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutBuildInput
    connect?: RecipeWhereUniqueInput
  }

  export type TouchCreateNestedManyWithoutBuildInput = {
    create?: XOR<Enumerable<TouchCreateWithoutBuildInput>, Enumerable<TouchUncheckedCreateWithoutBuildInput>>
    connectOrCreate?: Enumerable<TouchCreateOrConnectWithoutBuildInput>
    createMany?: TouchCreateManyBuildInputEnvelope
    connect?: Enumerable<TouchWhereUniqueInput>
  }

  export type RecipeBookBuildCreateNestedManyWithoutBuildInput = {
    create?: XOR<Enumerable<RecipeBookBuildCreateWithoutBuildInput>, Enumerable<RecipeBookBuildUncheckedCreateWithoutBuildInput>>
    connectOrCreate?: Enumerable<RecipeBookBuildCreateOrConnectWithoutBuildInput>
    createMany?: RecipeBookBuildCreateManyBuildInputEnvelope
    connect?: Enumerable<RecipeBookBuildWhereUniqueInput>
  }

  export type UserBuildCreateNestedManyWithoutBuildInput = {
    create?: XOR<Enumerable<UserBuildCreateWithoutBuildInput>, Enumerable<UserBuildUncheckedCreateWithoutBuildInput>>
    connectOrCreate?: Enumerable<UserBuildCreateOrConnectWithoutBuildInput>
    createMany?: UserBuildCreateManyBuildInputEnvelope
    connect?: Enumerable<UserBuildWhereUniqueInput>
  }

  export type TouchUncheckedCreateNestedManyWithoutBuildInput = {
    create?: XOR<Enumerable<TouchCreateWithoutBuildInput>, Enumerable<TouchUncheckedCreateWithoutBuildInput>>
    connectOrCreate?: Enumerable<TouchCreateOrConnectWithoutBuildInput>
    createMany?: TouchCreateManyBuildInputEnvelope
    connect?: Enumerable<TouchWhereUniqueInput>
  }

  export type RecipeBookBuildUncheckedCreateNestedManyWithoutBuildInput = {
    create?: XOR<Enumerable<RecipeBookBuildCreateWithoutBuildInput>, Enumerable<RecipeBookBuildUncheckedCreateWithoutBuildInput>>
    connectOrCreate?: Enumerable<RecipeBookBuildCreateOrConnectWithoutBuildInput>
    createMany?: RecipeBookBuildCreateManyBuildInputEnvelope
    connect?: Enumerable<RecipeBookBuildWhereUniqueInput>
  }

  export type UserBuildUncheckedCreateNestedManyWithoutBuildInput = {
    create?: XOR<Enumerable<UserBuildCreateWithoutBuildInput>, Enumerable<UserBuildUncheckedCreateWithoutBuildInput>>
    connectOrCreate?: Enumerable<UserBuildCreateOrConnectWithoutBuildInput>
    createMany?: UserBuildCreateManyBuildInputEnvelope
    connect?: Enumerable<UserBuildWhereUniqueInput>
  }

  export type UserUpdateOneWithoutBuildNestedInput = {
    create?: XOR<UserCreateWithoutBuildInput, UserUncheckedCreateWithoutBuildInput>
    connectOrCreate?: UserCreateOrConnectWithoutBuildInput
    upsert?: UserUpsertWithoutBuildInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutBuildInput, UserUncheckedUpdateWithoutBuildInput>
  }

  export type UserUpdateOneWithoutBuildEditedByNestedInput = {
    create?: XOR<UserCreateWithoutBuildEditedByInput, UserUncheckedCreateWithoutBuildEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutBuildEditedByInput
    upsert?: UserUpsertWithoutBuildEditedByInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutBuildEditedByInput, UserUncheckedUpdateWithoutBuildEditedByInput>
  }

  export type RecipeUpdateOneWithoutBuildNestedInput = {
    create?: XOR<RecipeCreateWithoutBuildInput, RecipeUncheckedCreateWithoutBuildInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutBuildInput
    upsert?: RecipeUpsertWithoutBuildInput
    disconnect?: boolean
    delete?: boolean
    connect?: RecipeWhereUniqueInput
    update?: XOR<RecipeUpdateWithoutBuildInput, RecipeUncheckedUpdateWithoutBuildInput>
  }

  export type TouchUpdateManyWithoutBuildNestedInput = {
    create?: XOR<Enumerable<TouchCreateWithoutBuildInput>, Enumerable<TouchUncheckedCreateWithoutBuildInput>>
    connectOrCreate?: Enumerable<TouchCreateOrConnectWithoutBuildInput>
    upsert?: Enumerable<TouchUpsertWithWhereUniqueWithoutBuildInput>
    createMany?: TouchCreateManyBuildInputEnvelope
    set?: Enumerable<TouchWhereUniqueInput>
    disconnect?: Enumerable<TouchWhereUniqueInput>
    delete?: Enumerable<TouchWhereUniqueInput>
    connect?: Enumerable<TouchWhereUniqueInput>
    update?: Enumerable<TouchUpdateWithWhereUniqueWithoutBuildInput>
    updateMany?: Enumerable<TouchUpdateManyWithWhereWithoutBuildInput>
    deleteMany?: Enumerable<TouchScalarWhereInput>
  }

  export type RecipeBookBuildUpdateManyWithoutBuildNestedInput = {
    create?: XOR<Enumerable<RecipeBookBuildCreateWithoutBuildInput>, Enumerable<RecipeBookBuildUncheckedCreateWithoutBuildInput>>
    connectOrCreate?: Enumerable<RecipeBookBuildCreateOrConnectWithoutBuildInput>
    upsert?: Enumerable<RecipeBookBuildUpsertWithWhereUniqueWithoutBuildInput>
    createMany?: RecipeBookBuildCreateManyBuildInputEnvelope
    set?: Enumerable<RecipeBookBuildWhereUniqueInput>
    disconnect?: Enumerable<RecipeBookBuildWhereUniqueInput>
    delete?: Enumerable<RecipeBookBuildWhereUniqueInput>
    connect?: Enumerable<RecipeBookBuildWhereUniqueInput>
    update?: Enumerable<RecipeBookBuildUpdateWithWhereUniqueWithoutBuildInput>
    updateMany?: Enumerable<RecipeBookBuildUpdateManyWithWhereWithoutBuildInput>
    deleteMany?: Enumerable<RecipeBookBuildScalarWhereInput>
  }

  export type UserBuildUpdateManyWithoutBuildNestedInput = {
    create?: XOR<Enumerable<UserBuildCreateWithoutBuildInput>, Enumerable<UserBuildUncheckedCreateWithoutBuildInput>>
    connectOrCreate?: Enumerable<UserBuildCreateOrConnectWithoutBuildInput>
    upsert?: Enumerable<UserBuildUpsertWithWhereUniqueWithoutBuildInput>
    createMany?: UserBuildCreateManyBuildInputEnvelope
    set?: Enumerable<UserBuildWhereUniqueInput>
    disconnect?: Enumerable<UserBuildWhereUniqueInput>
    delete?: Enumerable<UserBuildWhereUniqueInput>
    connect?: Enumerable<UserBuildWhereUniqueInput>
    update?: Enumerable<UserBuildUpdateWithWhereUniqueWithoutBuildInput>
    updateMany?: Enumerable<UserBuildUpdateManyWithWhereWithoutBuildInput>
    deleteMany?: Enumerable<UserBuildScalarWhereInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TouchUncheckedUpdateManyWithoutBuildNestedInput = {
    create?: XOR<Enumerable<TouchCreateWithoutBuildInput>, Enumerable<TouchUncheckedCreateWithoutBuildInput>>
    connectOrCreate?: Enumerable<TouchCreateOrConnectWithoutBuildInput>
    upsert?: Enumerable<TouchUpsertWithWhereUniqueWithoutBuildInput>
    createMany?: TouchCreateManyBuildInputEnvelope
    set?: Enumerable<TouchWhereUniqueInput>
    disconnect?: Enumerable<TouchWhereUniqueInput>
    delete?: Enumerable<TouchWhereUniqueInput>
    connect?: Enumerable<TouchWhereUniqueInput>
    update?: Enumerable<TouchUpdateWithWhereUniqueWithoutBuildInput>
    updateMany?: Enumerable<TouchUpdateManyWithWhereWithoutBuildInput>
    deleteMany?: Enumerable<TouchScalarWhereInput>
  }

  export type RecipeBookBuildUncheckedUpdateManyWithoutBuildNestedInput = {
    create?: XOR<Enumerable<RecipeBookBuildCreateWithoutBuildInput>, Enumerable<RecipeBookBuildUncheckedCreateWithoutBuildInput>>
    connectOrCreate?: Enumerable<RecipeBookBuildCreateOrConnectWithoutBuildInput>
    upsert?: Enumerable<RecipeBookBuildUpsertWithWhereUniqueWithoutBuildInput>
    createMany?: RecipeBookBuildCreateManyBuildInputEnvelope
    set?: Enumerable<RecipeBookBuildWhereUniqueInput>
    disconnect?: Enumerable<RecipeBookBuildWhereUniqueInput>
    delete?: Enumerable<RecipeBookBuildWhereUniqueInput>
    connect?: Enumerable<RecipeBookBuildWhereUniqueInput>
    update?: Enumerable<RecipeBookBuildUpdateWithWhereUniqueWithoutBuildInput>
    updateMany?: Enumerable<RecipeBookBuildUpdateManyWithWhereWithoutBuildInput>
    deleteMany?: Enumerable<RecipeBookBuildScalarWhereInput>
  }

  export type UserBuildUncheckedUpdateManyWithoutBuildNestedInput = {
    create?: XOR<Enumerable<UserBuildCreateWithoutBuildInput>, Enumerable<UserBuildUncheckedCreateWithoutBuildInput>>
    connectOrCreate?: Enumerable<UserBuildCreateOrConnectWithoutBuildInput>
    upsert?: Enumerable<UserBuildUpsertWithWhereUniqueWithoutBuildInput>
    createMany?: UserBuildCreateManyBuildInputEnvelope
    set?: Enumerable<UserBuildWhereUniqueInput>
    disconnect?: Enumerable<UserBuildWhereUniqueInput>
    delete?: Enumerable<UserBuildWhereUniqueInput>
    connect?: Enumerable<UserBuildWhereUniqueInput>
    update?: Enumerable<UserBuildUpdateWithWhereUniqueWithoutBuildInput>
    updateMany?: Enumerable<UserBuildUpdateManyWithWhereWithoutBuildInput>
    deleteMany?: Enumerable<UserBuildScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutUserBuildInput = {
    create?: XOR<UserCreateWithoutUserBuildInput, UserUncheckedCreateWithoutUserBuildInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserBuildInput
    connect?: UserWhereUniqueInput
  }

  export type BuildCreateNestedOneWithoutUserBuildInput = {
    create?: XOR<BuildCreateWithoutUserBuildInput, BuildUncheckedCreateWithoutUserBuildInput>
    connectOrCreate?: BuildCreateOrConnectWithoutUserBuildInput
    connect?: BuildWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserBuildNestedInput = {
    create?: XOR<UserCreateWithoutUserBuildInput, UserUncheckedCreateWithoutUserBuildInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserBuildInput
    upsert?: UserUpsertWithoutUserBuildInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserBuildInput, UserUncheckedUpdateWithoutUserBuildInput>
  }

  export type BuildUpdateOneRequiredWithoutUserBuildNestedInput = {
    create?: XOR<BuildCreateWithoutUserBuildInput, BuildUncheckedCreateWithoutUserBuildInput>
    connectOrCreate?: BuildCreateOrConnectWithoutUserBuildInput
    upsert?: BuildUpsertWithoutUserBuildInput
    connect?: BuildWhereUniqueInput
    update?: XOR<BuildUpdateWithoutUserBuildInput, BuildUncheckedUpdateWithoutUserBuildInput>
  }

  export type UserCreateNestedOneWithoutRecipeInput = {
    create?: XOR<UserCreateWithoutRecipeInput, UserUncheckedCreateWithoutRecipeInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeInput
    connect?: UserWhereUniqueInput
  }

  export type BuildCreateNestedManyWithoutRecipeInput = {
    create?: XOR<Enumerable<BuildCreateWithoutRecipeInput>, Enumerable<BuildUncheckedCreateWithoutRecipeInput>>
    connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutRecipeInput>
    createMany?: BuildCreateManyRecipeInputEnvelope
    connect?: Enumerable<BuildWhereUniqueInput>
  }

  export type BuildUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<Enumerable<BuildCreateWithoutRecipeInput>, Enumerable<BuildUncheckedCreateWithoutRecipeInput>>
    connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutRecipeInput>
    createMany?: BuildCreateManyRecipeInputEnvelope
    connect?: Enumerable<BuildWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutRecipeNestedInput = {
    create?: XOR<UserCreateWithoutRecipeInput, UserUncheckedCreateWithoutRecipeInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeInput
    upsert?: UserUpsertWithoutRecipeInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutRecipeInput, UserUncheckedUpdateWithoutRecipeInput>
  }

  export type BuildUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<Enumerable<BuildCreateWithoutRecipeInput>, Enumerable<BuildUncheckedCreateWithoutRecipeInput>>
    connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutRecipeInput>
    upsert?: Enumerable<BuildUpsertWithWhereUniqueWithoutRecipeInput>
    createMany?: BuildCreateManyRecipeInputEnvelope
    set?: Enumerable<BuildWhereUniqueInput>
    disconnect?: Enumerable<BuildWhereUniqueInput>
    delete?: Enumerable<BuildWhereUniqueInput>
    connect?: Enumerable<BuildWhereUniqueInput>
    update?: Enumerable<BuildUpdateWithWhereUniqueWithoutRecipeInput>
    updateMany?: Enumerable<BuildUpdateManyWithWhereWithoutRecipeInput>
    deleteMany?: Enumerable<BuildScalarWhereInput>
  }

  export type BuildUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<Enumerable<BuildCreateWithoutRecipeInput>, Enumerable<BuildUncheckedCreateWithoutRecipeInput>>
    connectOrCreate?: Enumerable<BuildCreateOrConnectWithoutRecipeInput>
    upsert?: Enumerable<BuildUpsertWithWhereUniqueWithoutRecipeInput>
    createMany?: BuildCreateManyRecipeInputEnvelope
    set?: Enumerable<BuildWhereUniqueInput>
    disconnect?: Enumerable<BuildWhereUniqueInput>
    delete?: Enumerable<BuildWhereUniqueInput>
    connect?: Enumerable<BuildWhereUniqueInput>
    update?: Enumerable<BuildUpdateWithWhereUniqueWithoutRecipeInput>
    updateMany?: Enumerable<BuildUpdateManyWithWhereWithoutRecipeInput>
    deleteMany?: Enumerable<BuildScalarWhereInput>
  }

  export type RecipeBookCreateNestedOneWithoutRecipeBookBuildInput = {
    create?: XOR<RecipeBookCreateWithoutRecipeBookBuildInput, RecipeBookUncheckedCreateWithoutRecipeBookBuildInput>
    connectOrCreate?: RecipeBookCreateOrConnectWithoutRecipeBookBuildInput
    connect?: RecipeBookWhereUniqueInput
  }

  export type BuildCreateNestedOneWithoutRecipeBookBuildInput = {
    create?: XOR<BuildCreateWithoutRecipeBookBuildInput, BuildUncheckedCreateWithoutRecipeBookBuildInput>
    connectOrCreate?: BuildCreateOrConnectWithoutRecipeBookBuildInput
    connect?: BuildWhereUniqueInput
  }

  export type RecipeBookUpdateOneRequiredWithoutRecipeBookBuildNestedInput = {
    create?: XOR<RecipeBookCreateWithoutRecipeBookBuildInput, RecipeBookUncheckedCreateWithoutRecipeBookBuildInput>
    connectOrCreate?: RecipeBookCreateOrConnectWithoutRecipeBookBuildInput
    upsert?: RecipeBookUpsertWithoutRecipeBookBuildInput
    connect?: RecipeBookWhereUniqueInput
    update?: XOR<RecipeBookUpdateWithoutRecipeBookBuildInput, RecipeBookUncheckedUpdateWithoutRecipeBookBuildInput>
  }

  export type BuildUpdateOneRequiredWithoutRecipeBookBuildNestedInput = {
    create?: XOR<BuildCreateWithoutRecipeBookBuildInput, BuildUncheckedCreateWithoutRecipeBookBuildInput>
    connectOrCreate?: BuildCreateOrConnectWithoutRecipeBookBuildInput
    upsert?: BuildUpsertWithoutRecipeBookBuildInput
    connect?: BuildWhereUniqueInput
    update?: XOR<BuildUpdateWithoutRecipeBookBuildInput, BuildUncheckedUpdateWithoutRecipeBookBuildInput>
  }

  export type IngredientCreateNestedOneWithoutTouchInput = {
    create?: XOR<IngredientCreateWithoutTouchInput, IngredientUncheckedCreateWithoutTouchInput>
    connectOrCreate?: IngredientCreateOrConnectWithoutTouchInput
    connect?: IngredientWhereUniqueInput
  }

  export type BuildCreateNestedOneWithoutTouchInput = {
    create?: XOR<BuildCreateWithoutTouchInput, BuildUncheckedCreateWithoutTouchInput>
    connectOrCreate?: BuildCreateOrConnectWithoutTouchInput
    connect?: BuildWhereUniqueInput
  }

  export type IngredientUpdateOneWithoutTouchNestedInput = {
    create?: XOR<IngredientCreateWithoutTouchInput, IngredientUncheckedCreateWithoutTouchInput>
    connectOrCreate?: IngredientCreateOrConnectWithoutTouchInput
    upsert?: IngredientUpsertWithoutTouchInput
    disconnect?: boolean
    delete?: boolean
    connect?: IngredientWhereUniqueInput
    update?: XOR<IngredientUpdateWithoutTouchInput, IngredientUncheckedUpdateWithoutTouchInput>
  }

  export type BuildUpdateOneWithoutTouchNestedInput = {
    create?: XOR<BuildCreateWithoutTouchInput, BuildUncheckedCreateWithoutTouchInput>
    connectOrCreate?: BuildCreateOrConnectWithoutTouchInput
    upsert?: BuildUpsertWithoutTouchInput
    disconnect?: boolean
    delete?: boolean
    connect?: BuildWhereUniqueInput
    update?: XOR<BuildUpdateWithoutTouchInput, BuildUncheckedUpdateWithoutTouchInput>
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserCreateNestedOneWithoutIngredientInput = {
    create?: XOR<UserCreateWithoutIngredientInput, UserUncheckedCreateWithoutIngredientInput>
    connectOrCreate?: UserCreateOrConnectWithoutIngredientInput
    connect?: UserWhereUniqueInput
  }

  export type TouchCreateNestedManyWithoutIngredientInput = {
    create?: XOR<Enumerable<TouchCreateWithoutIngredientInput>, Enumerable<TouchUncheckedCreateWithoutIngredientInput>>
    connectOrCreate?: Enumerable<TouchCreateOrConnectWithoutIngredientInput>
    createMany?: TouchCreateManyIngredientInputEnvelope
    connect?: Enumerable<TouchWhereUniqueInput>
  }

  export type ingredientStorageCreateNestedManyWithoutIngredientInput = {
    create?: XOR<Enumerable<ingredientStorageCreateWithoutIngredientInput>, Enumerable<ingredientStorageUncheckedCreateWithoutIngredientInput>>
    connectOrCreate?: Enumerable<ingredientStorageCreateOrConnectWithoutIngredientInput>
    createMany?: ingredientStorageCreateManyIngredientInputEnvelope
    connect?: Enumerable<ingredientStorageWhereUniqueInput>
  }

  export type TouchUncheckedCreateNestedManyWithoutIngredientInput = {
    create?: XOR<Enumerable<TouchCreateWithoutIngredientInput>, Enumerable<TouchUncheckedCreateWithoutIngredientInput>>
    connectOrCreate?: Enumerable<TouchCreateOrConnectWithoutIngredientInput>
    createMany?: TouchCreateManyIngredientInputEnvelope
    connect?: Enumerable<TouchWhereUniqueInput>
  }

  export type ingredientStorageUncheckedCreateNestedManyWithoutIngredientInput = {
    create?: XOR<Enumerable<ingredientStorageCreateWithoutIngredientInput>, Enumerable<ingredientStorageUncheckedCreateWithoutIngredientInput>>
    connectOrCreate?: Enumerable<ingredientStorageCreateOrConnectWithoutIngredientInput>
    createMany?: ingredientStorageCreateManyIngredientInputEnvelope
    connect?: Enumerable<ingredientStorageWhereUniqueInput>
  }

  export type UserUpdateOneWithoutIngredientNestedInput = {
    create?: XOR<UserCreateWithoutIngredientInput, UserUncheckedCreateWithoutIngredientInput>
    connectOrCreate?: UserCreateOrConnectWithoutIngredientInput
    upsert?: UserUpsertWithoutIngredientInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutIngredientInput, UserUncheckedUpdateWithoutIngredientInput>
  }

  export type TouchUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<Enumerable<TouchCreateWithoutIngredientInput>, Enumerable<TouchUncheckedCreateWithoutIngredientInput>>
    connectOrCreate?: Enumerable<TouchCreateOrConnectWithoutIngredientInput>
    upsert?: Enumerable<TouchUpsertWithWhereUniqueWithoutIngredientInput>
    createMany?: TouchCreateManyIngredientInputEnvelope
    set?: Enumerable<TouchWhereUniqueInput>
    disconnect?: Enumerable<TouchWhereUniqueInput>
    delete?: Enumerable<TouchWhereUniqueInput>
    connect?: Enumerable<TouchWhereUniqueInput>
    update?: Enumerable<TouchUpdateWithWhereUniqueWithoutIngredientInput>
    updateMany?: Enumerable<TouchUpdateManyWithWhereWithoutIngredientInput>
    deleteMany?: Enumerable<TouchScalarWhereInput>
  }

  export type ingredientStorageUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<Enumerable<ingredientStorageCreateWithoutIngredientInput>, Enumerable<ingredientStorageUncheckedCreateWithoutIngredientInput>>
    connectOrCreate?: Enumerable<ingredientStorageCreateOrConnectWithoutIngredientInput>
    upsert?: Enumerable<ingredientStorageUpsertWithWhereUniqueWithoutIngredientInput>
    createMany?: ingredientStorageCreateManyIngredientInputEnvelope
    set?: Enumerable<ingredientStorageWhereUniqueInput>
    disconnect?: Enumerable<ingredientStorageWhereUniqueInput>
    delete?: Enumerable<ingredientStorageWhereUniqueInput>
    connect?: Enumerable<ingredientStorageWhereUniqueInput>
    update?: Enumerable<ingredientStorageUpdateWithWhereUniqueWithoutIngredientInput>
    updateMany?: Enumerable<ingredientStorageUpdateManyWithWhereWithoutIngredientInput>
    deleteMany?: Enumerable<ingredientStorageScalarWhereInput>
  }

  export type TouchUncheckedUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<Enumerable<TouchCreateWithoutIngredientInput>, Enumerable<TouchUncheckedCreateWithoutIngredientInput>>
    connectOrCreate?: Enumerable<TouchCreateOrConnectWithoutIngredientInput>
    upsert?: Enumerable<TouchUpsertWithWhereUniqueWithoutIngredientInput>
    createMany?: TouchCreateManyIngredientInputEnvelope
    set?: Enumerable<TouchWhereUniqueInput>
    disconnect?: Enumerable<TouchWhereUniqueInput>
    delete?: Enumerable<TouchWhereUniqueInput>
    connect?: Enumerable<TouchWhereUniqueInput>
    update?: Enumerable<TouchUpdateWithWhereUniqueWithoutIngredientInput>
    updateMany?: Enumerable<TouchUpdateManyWithWhereWithoutIngredientInput>
    deleteMany?: Enumerable<TouchScalarWhereInput>
  }

  export type ingredientStorageUncheckedUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<Enumerable<ingredientStorageCreateWithoutIngredientInput>, Enumerable<ingredientStorageUncheckedCreateWithoutIngredientInput>>
    connectOrCreate?: Enumerable<ingredientStorageCreateOrConnectWithoutIngredientInput>
    upsert?: Enumerable<ingredientStorageUpsertWithWhereUniqueWithoutIngredientInput>
    createMany?: ingredientStorageCreateManyIngredientInputEnvelope
    set?: Enumerable<ingredientStorageWhereUniqueInput>
    disconnect?: Enumerable<ingredientStorageWhereUniqueInput>
    delete?: Enumerable<ingredientStorageWhereUniqueInput>
    connect?: Enumerable<ingredientStorageWhereUniqueInput>
    update?: Enumerable<ingredientStorageUpdateWithWhereUniqueWithoutIngredientInput>
    updateMany?: Enumerable<ingredientStorageUpdateManyWithWhereWithoutIngredientInput>
    deleteMany?: Enumerable<ingredientStorageScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutInventoryCreatedByInput = {
    create?: XOR<UserCreateWithoutInventoryCreatedByInput, UserUncheckedCreateWithoutInventoryCreatedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryCreatedByInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInventoryEditedByInput = {
    create?: XOR<UserCreateWithoutInventoryEditedByInput, UserUncheckedCreateWithoutInventoryEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryEditedByInput
    connect?: UserWhereUniqueInput
  }

  export type InventoryStorageCreateNestedManyWithoutInventoryInput = {
    create?: XOR<Enumerable<InventoryStorageCreateWithoutInventoryInput>, Enumerable<InventoryStorageUncheckedCreateWithoutInventoryInput>>
    connectOrCreate?: Enumerable<InventoryStorageCreateOrConnectWithoutInventoryInput>
    createMany?: InventoryStorageCreateManyInventoryInputEnvelope
    connect?: Enumerable<InventoryStorageWhereUniqueInput>
  }

  export type InventoryStorageUncheckedCreateNestedManyWithoutInventoryInput = {
    create?: XOR<Enumerable<InventoryStorageCreateWithoutInventoryInput>, Enumerable<InventoryStorageUncheckedCreateWithoutInventoryInput>>
    connectOrCreate?: Enumerable<InventoryStorageCreateOrConnectWithoutInventoryInput>
    createMany?: InventoryStorageCreateManyInventoryInputEnvelope
    connect?: Enumerable<InventoryStorageWhereUniqueInput>
  }

  export type UserUpdateOneWithoutInventoryCreatedByNestedInput = {
    create?: XOR<UserCreateWithoutInventoryCreatedByInput, UserUncheckedCreateWithoutInventoryCreatedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryCreatedByInput
    upsert?: UserUpsertWithoutInventoryCreatedByInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutInventoryCreatedByInput, UserUncheckedUpdateWithoutInventoryCreatedByInput>
  }

  export type UserUpdateOneWithoutInventoryEditedByNestedInput = {
    create?: XOR<UserCreateWithoutInventoryEditedByInput, UserUncheckedCreateWithoutInventoryEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryEditedByInput
    upsert?: UserUpsertWithoutInventoryEditedByInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutInventoryEditedByInput, UserUncheckedUpdateWithoutInventoryEditedByInput>
  }

  export type InventoryStorageUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<Enumerable<InventoryStorageCreateWithoutInventoryInput>, Enumerable<InventoryStorageUncheckedCreateWithoutInventoryInput>>
    connectOrCreate?: Enumerable<InventoryStorageCreateOrConnectWithoutInventoryInput>
    upsert?: Enumerable<InventoryStorageUpsertWithWhereUniqueWithoutInventoryInput>
    createMany?: InventoryStorageCreateManyInventoryInputEnvelope
    set?: Enumerable<InventoryStorageWhereUniqueInput>
    disconnect?: Enumerable<InventoryStorageWhereUniqueInput>
    delete?: Enumerable<InventoryStorageWhereUniqueInput>
    connect?: Enumerable<InventoryStorageWhereUniqueInput>
    update?: Enumerable<InventoryStorageUpdateWithWhereUniqueWithoutInventoryInput>
    updateMany?: Enumerable<InventoryStorageUpdateManyWithWhereWithoutInventoryInput>
    deleteMany?: Enumerable<InventoryStorageScalarWhereInput>
  }

  export type InventoryStorageUncheckedUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<Enumerable<InventoryStorageCreateWithoutInventoryInput>, Enumerable<InventoryStorageUncheckedCreateWithoutInventoryInput>>
    connectOrCreate?: Enumerable<InventoryStorageCreateOrConnectWithoutInventoryInput>
    upsert?: Enumerable<InventoryStorageUpsertWithWhereUniqueWithoutInventoryInput>
    createMany?: InventoryStorageCreateManyInventoryInputEnvelope
    set?: Enumerable<InventoryStorageWhereUniqueInput>
    disconnect?: Enumerable<InventoryStorageWhereUniqueInput>
    delete?: Enumerable<InventoryStorageWhereUniqueInput>
    connect?: Enumerable<InventoryStorageWhereUniqueInput>
    update?: Enumerable<InventoryStorageUpdateWithWhereUniqueWithoutInventoryInput>
    updateMany?: Enumerable<InventoryStorageUpdateManyWithWhereWithoutInventoryInput>
    deleteMany?: Enumerable<InventoryStorageScalarWhereInput>
  }

  export type StorageCreateNestedOneWithoutInventoryStorageInput = {
    create?: XOR<StorageCreateWithoutInventoryStorageInput, StorageUncheckedCreateWithoutInventoryStorageInput>
    connectOrCreate?: StorageCreateOrConnectWithoutInventoryStorageInput
    connect?: StorageWhereUniqueInput
  }

  export type InventoryCreateNestedOneWithoutInventoryStorageInput = {
    create?: XOR<InventoryCreateWithoutInventoryStorageInput, InventoryUncheckedCreateWithoutInventoryStorageInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutInventoryStorageInput
    connect?: InventoryWhereUniqueInput
  }

  export type StorageUpdateOneRequiredWithoutInventoryStorageNestedInput = {
    create?: XOR<StorageCreateWithoutInventoryStorageInput, StorageUncheckedCreateWithoutInventoryStorageInput>
    connectOrCreate?: StorageCreateOrConnectWithoutInventoryStorageInput
    upsert?: StorageUpsertWithoutInventoryStorageInput
    connect?: StorageWhereUniqueInput
    update?: XOR<StorageUpdateWithoutInventoryStorageInput, StorageUncheckedUpdateWithoutInventoryStorageInput>
  }

  export type InventoryUpdateOneRequiredWithoutInventoryStorageNestedInput = {
    create?: XOR<InventoryCreateWithoutInventoryStorageInput, InventoryUncheckedCreateWithoutInventoryStorageInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutInventoryStorageInput
    upsert?: InventoryUpsertWithoutInventoryStorageInput
    connect?: InventoryWhereUniqueInput
    update?: XOR<InventoryUpdateWithoutInventoryStorageInput, InventoryUncheckedUpdateWithoutInventoryStorageInput>
  }

  export type UserCreateNestedOneWithoutStorageInput = {
    create?: XOR<UserCreateWithoutStorageInput, UserUncheckedCreateWithoutStorageInput>
    connectOrCreate?: UserCreateOrConnectWithoutStorageInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStorageEditedByInput = {
    create?: XOR<UserCreateWithoutStorageEditedByInput, UserUncheckedCreateWithoutStorageEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutStorageEditedByInput
    connect?: UserWhereUniqueInput
  }

  export type InventoryStorageCreateNestedManyWithoutStorageInput = {
    create?: XOR<Enumerable<InventoryStorageCreateWithoutStorageInput>, Enumerable<InventoryStorageUncheckedCreateWithoutStorageInput>>
    connectOrCreate?: Enumerable<InventoryStorageCreateOrConnectWithoutStorageInput>
    createMany?: InventoryStorageCreateManyStorageInputEnvelope
    connect?: Enumerable<InventoryStorageWhereUniqueInput>
  }

  export type ingredientStorageCreateNestedManyWithoutStorageInput = {
    create?: XOR<Enumerable<ingredientStorageCreateWithoutStorageInput>, Enumerable<ingredientStorageUncheckedCreateWithoutStorageInput>>
    connectOrCreate?: Enumerable<ingredientStorageCreateOrConnectWithoutStorageInput>
    createMany?: ingredientStorageCreateManyStorageInputEnvelope
    connect?: Enumerable<ingredientStorageWhereUniqueInput>
  }

  export type UserStorageCreateNestedManyWithoutStorageInput = {
    create?: XOR<Enumerable<UserStorageCreateWithoutStorageInput>, Enumerable<UserStorageUncheckedCreateWithoutStorageInput>>
    connectOrCreate?: Enumerable<UserStorageCreateOrConnectWithoutStorageInput>
    createMany?: UserStorageCreateManyStorageInputEnvelope
    connect?: Enumerable<UserStorageWhereUniqueInput>
  }

  export type InventoryStorageUncheckedCreateNestedManyWithoutStorageInput = {
    create?: XOR<Enumerable<InventoryStorageCreateWithoutStorageInput>, Enumerable<InventoryStorageUncheckedCreateWithoutStorageInput>>
    connectOrCreate?: Enumerable<InventoryStorageCreateOrConnectWithoutStorageInput>
    createMany?: InventoryStorageCreateManyStorageInputEnvelope
    connect?: Enumerable<InventoryStorageWhereUniqueInput>
  }

  export type ingredientStorageUncheckedCreateNestedManyWithoutStorageInput = {
    create?: XOR<Enumerable<ingredientStorageCreateWithoutStorageInput>, Enumerable<ingredientStorageUncheckedCreateWithoutStorageInput>>
    connectOrCreate?: Enumerable<ingredientStorageCreateOrConnectWithoutStorageInput>
    createMany?: ingredientStorageCreateManyStorageInputEnvelope
    connect?: Enumerable<ingredientStorageWhereUniqueInput>
  }

  export type UserStorageUncheckedCreateNestedManyWithoutStorageInput = {
    create?: XOR<Enumerable<UserStorageCreateWithoutStorageInput>, Enumerable<UserStorageUncheckedCreateWithoutStorageInput>>
    connectOrCreate?: Enumerable<UserStorageCreateOrConnectWithoutStorageInput>
    createMany?: UserStorageCreateManyStorageInputEnvelope
    connect?: Enumerable<UserStorageWhereUniqueInput>
  }

  export type UserUpdateOneWithoutStorageNestedInput = {
    create?: XOR<UserCreateWithoutStorageInput, UserUncheckedCreateWithoutStorageInput>
    connectOrCreate?: UserCreateOrConnectWithoutStorageInput
    upsert?: UserUpsertWithoutStorageInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutStorageInput, UserUncheckedUpdateWithoutStorageInput>
  }

  export type UserUpdateOneWithoutStorageEditedByNestedInput = {
    create?: XOR<UserCreateWithoutStorageEditedByInput, UserUncheckedCreateWithoutStorageEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutStorageEditedByInput
    upsert?: UserUpsertWithoutStorageEditedByInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutStorageEditedByInput, UserUncheckedUpdateWithoutStorageEditedByInput>
  }

  export type InventoryStorageUpdateManyWithoutStorageNestedInput = {
    create?: XOR<Enumerable<InventoryStorageCreateWithoutStorageInput>, Enumerable<InventoryStorageUncheckedCreateWithoutStorageInput>>
    connectOrCreate?: Enumerable<InventoryStorageCreateOrConnectWithoutStorageInput>
    upsert?: Enumerable<InventoryStorageUpsertWithWhereUniqueWithoutStorageInput>
    createMany?: InventoryStorageCreateManyStorageInputEnvelope
    set?: Enumerable<InventoryStorageWhereUniqueInput>
    disconnect?: Enumerable<InventoryStorageWhereUniqueInput>
    delete?: Enumerable<InventoryStorageWhereUniqueInput>
    connect?: Enumerable<InventoryStorageWhereUniqueInput>
    update?: Enumerable<InventoryStorageUpdateWithWhereUniqueWithoutStorageInput>
    updateMany?: Enumerable<InventoryStorageUpdateManyWithWhereWithoutStorageInput>
    deleteMany?: Enumerable<InventoryStorageScalarWhereInput>
  }

  export type ingredientStorageUpdateManyWithoutStorageNestedInput = {
    create?: XOR<Enumerable<ingredientStorageCreateWithoutStorageInput>, Enumerable<ingredientStorageUncheckedCreateWithoutStorageInput>>
    connectOrCreate?: Enumerable<ingredientStorageCreateOrConnectWithoutStorageInput>
    upsert?: Enumerable<ingredientStorageUpsertWithWhereUniqueWithoutStorageInput>
    createMany?: ingredientStorageCreateManyStorageInputEnvelope
    set?: Enumerable<ingredientStorageWhereUniqueInput>
    disconnect?: Enumerable<ingredientStorageWhereUniqueInput>
    delete?: Enumerable<ingredientStorageWhereUniqueInput>
    connect?: Enumerable<ingredientStorageWhereUniqueInput>
    update?: Enumerable<ingredientStorageUpdateWithWhereUniqueWithoutStorageInput>
    updateMany?: Enumerable<ingredientStorageUpdateManyWithWhereWithoutStorageInput>
    deleteMany?: Enumerable<ingredientStorageScalarWhereInput>
  }

  export type UserStorageUpdateManyWithoutStorageNestedInput = {
    create?: XOR<Enumerable<UserStorageCreateWithoutStorageInput>, Enumerable<UserStorageUncheckedCreateWithoutStorageInput>>
    connectOrCreate?: Enumerable<UserStorageCreateOrConnectWithoutStorageInput>
    upsert?: Enumerable<UserStorageUpsertWithWhereUniqueWithoutStorageInput>
    createMany?: UserStorageCreateManyStorageInputEnvelope
    set?: Enumerable<UserStorageWhereUniqueInput>
    disconnect?: Enumerable<UserStorageWhereUniqueInput>
    delete?: Enumerable<UserStorageWhereUniqueInput>
    connect?: Enumerable<UserStorageWhereUniqueInput>
    update?: Enumerable<UserStorageUpdateWithWhereUniqueWithoutStorageInput>
    updateMany?: Enumerable<UserStorageUpdateManyWithWhereWithoutStorageInput>
    deleteMany?: Enumerable<UserStorageScalarWhereInput>
  }

  export type InventoryStorageUncheckedUpdateManyWithoutStorageNestedInput = {
    create?: XOR<Enumerable<InventoryStorageCreateWithoutStorageInput>, Enumerable<InventoryStorageUncheckedCreateWithoutStorageInput>>
    connectOrCreate?: Enumerable<InventoryStorageCreateOrConnectWithoutStorageInput>
    upsert?: Enumerable<InventoryStorageUpsertWithWhereUniqueWithoutStorageInput>
    createMany?: InventoryStorageCreateManyStorageInputEnvelope
    set?: Enumerable<InventoryStorageWhereUniqueInput>
    disconnect?: Enumerable<InventoryStorageWhereUniqueInput>
    delete?: Enumerable<InventoryStorageWhereUniqueInput>
    connect?: Enumerable<InventoryStorageWhereUniqueInput>
    update?: Enumerable<InventoryStorageUpdateWithWhereUniqueWithoutStorageInput>
    updateMany?: Enumerable<InventoryStorageUpdateManyWithWhereWithoutStorageInput>
    deleteMany?: Enumerable<InventoryStorageScalarWhereInput>
  }

  export type ingredientStorageUncheckedUpdateManyWithoutStorageNestedInput = {
    create?: XOR<Enumerable<ingredientStorageCreateWithoutStorageInput>, Enumerable<ingredientStorageUncheckedCreateWithoutStorageInput>>
    connectOrCreate?: Enumerable<ingredientStorageCreateOrConnectWithoutStorageInput>
    upsert?: Enumerable<ingredientStorageUpsertWithWhereUniqueWithoutStorageInput>
    createMany?: ingredientStorageCreateManyStorageInputEnvelope
    set?: Enumerable<ingredientStorageWhereUniqueInput>
    disconnect?: Enumerable<ingredientStorageWhereUniqueInput>
    delete?: Enumerable<ingredientStorageWhereUniqueInput>
    connect?: Enumerable<ingredientStorageWhereUniqueInput>
    update?: Enumerable<ingredientStorageUpdateWithWhereUniqueWithoutStorageInput>
    updateMany?: Enumerable<ingredientStorageUpdateManyWithWhereWithoutStorageInput>
    deleteMany?: Enumerable<ingredientStorageScalarWhereInput>
  }

  export type UserStorageUncheckedUpdateManyWithoutStorageNestedInput = {
    create?: XOR<Enumerable<UserStorageCreateWithoutStorageInput>, Enumerable<UserStorageUncheckedCreateWithoutStorageInput>>
    connectOrCreate?: Enumerable<UserStorageCreateOrConnectWithoutStorageInput>
    upsert?: Enumerable<UserStorageUpsertWithWhereUniqueWithoutStorageInput>
    createMany?: UserStorageCreateManyStorageInputEnvelope
    set?: Enumerable<UserStorageWhereUniqueInput>
    disconnect?: Enumerable<UserStorageWhereUniqueInput>
    delete?: Enumerable<UserStorageWhereUniqueInput>
    connect?: Enumerable<UserStorageWhereUniqueInput>
    update?: Enumerable<UserStorageUpdateWithWhereUniqueWithoutStorageInput>
    updateMany?: Enumerable<UserStorageUpdateManyWithWhereWithoutStorageInput>
    deleteMany?: Enumerable<UserStorageScalarWhereInput>
  }

  export type IngredientCreateNestedOneWithoutIngredientStorageInput = {
    create?: XOR<IngredientCreateWithoutIngredientStorageInput, IngredientUncheckedCreateWithoutIngredientStorageInput>
    connectOrCreate?: IngredientCreateOrConnectWithoutIngredientStorageInput
    connect?: IngredientWhereUniqueInput
  }

  export type StorageCreateNestedOneWithoutIngredientStorageInput = {
    create?: XOR<StorageCreateWithoutIngredientStorageInput, StorageUncheckedCreateWithoutIngredientStorageInput>
    connectOrCreate?: StorageCreateOrConnectWithoutIngredientStorageInput
    connect?: StorageWhereUniqueInput
  }

  export type IngredientUpdateOneWithoutIngredientStorageNestedInput = {
    create?: XOR<IngredientCreateWithoutIngredientStorageInput, IngredientUncheckedCreateWithoutIngredientStorageInput>
    connectOrCreate?: IngredientCreateOrConnectWithoutIngredientStorageInput
    upsert?: IngredientUpsertWithoutIngredientStorageInput
    disconnect?: boolean
    delete?: boolean
    connect?: IngredientWhereUniqueInput
    update?: XOR<IngredientUpdateWithoutIngredientStorageInput, IngredientUncheckedUpdateWithoutIngredientStorageInput>
  }

  export type StorageUpdateOneWithoutIngredientStorageNestedInput = {
    create?: XOR<StorageCreateWithoutIngredientStorageInput, StorageUncheckedCreateWithoutIngredientStorageInput>
    connectOrCreate?: StorageCreateOrConnectWithoutIngredientStorageInput
    upsert?: StorageUpsertWithoutIngredientStorageInput
    disconnect?: boolean
    delete?: boolean
    connect?: StorageWhereUniqueInput
    update?: XOR<StorageUpdateWithoutIngredientStorageInput, StorageUncheckedUpdateWithoutIngredientStorageInput>
  }

  export type UserCreateNestedOneWithoutUserStorageInput = {
    create?: XOR<UserCreateWithoutUserStorageInput, UserUncheckedCreateWithoutUserStorageInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserStorageInput
    connect?: UserWhereUniqueInput
  }

  export type StorageCreateNestedOneWithoutUserStorageInput = {
    create?: XOR<StorageCreateWithoutUserStorageInput, StorageUncheckedCreateWithoutUserStorageInput>
    connectOrCreate?: StorageCreateOrConnectWithoutUserStorageInput
    connect?: StorageWhereUniqueInput
  }

  export type UserUpdateOneWithoutUserStorageNestedInput = {
    create?: XOR<UserCreateWithoutUserStorageInput, UserUncheckedCreateWithoutUserStorageInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserStorageInput
    upsert?: UserUpsertWithoutUserStorageInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserStorageInput, UserUncheckedUpdateWithoutUserStorageInput>
  }

  export type StorageUpdateOneWithoutUserStorageNestedInput = {
    create?: XOR<StorageCreateWithoutUserStorageInput, StorageUncheckedCreateWithoutUserStorageInput>
    connectOrCreate?: StorageCreateOrConnectWithoutUserStorageInput
    upsert?: StorageUpsertWithoutUserStorageInput
    disconnect?: boolean
    delete?: boolean
    connect?: StorageWhereUniqueInput
    update?: XOR<StorageUpdateWithoutUserStorageInput, StorageUncheckedUpdateWithoutUserStorageInput>
  }

  export type UserCreateNestedOneWithoutCrewInput = {
    create?: XOR<UserCreateWithoutCrewInput, UserUncheckedCreateWithoutCrewInput>
    connectOrCreate?: UserCreateOrConnectWithoutCrewInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCrewEditedByInput = {
    create?: XOR<UserCreateWithoutCrewEditedByInput, UserUncheckedCreateWithoutCrewEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutCrewEditedByInput
    connect?: UserWhereUniqueInput
  }

  export type UserCrewCreateNestedManyWithoutCrewInput = {
    create?: XOR<Enumerable<UserCrewCreateWithoutCrewInput>, Enumerable<UserCrewUncheckedCreateWithoutCrewInput>>
    connectOrCreate?: Enumerable<UserCrewCreateOrConnectWithoutCrewInput>
    createMany?: UserCrewCreateManyCrewInputEnvelope
    connect?: Enumerable<UserCrewWhereUniqueInput>
  }

  export type UserCrewUncheckedCreateNestedManyWithoutCrewInput = {
    create?: XOR<Enumerable<UserCrewCreateWithoutCrewInput>, Enumerable<UserCrewUncheckedCreateWithoutCrewInput>>
    connectOrCreate?: Enumerable<UserCrewCreateOrConnectWithoutCrewInput>
    createMany?: UserCrewCreateManyCrewInputEnvelope
    connect?: Enumerable<UserCrewWhereUniqueInput>
  }

  export type UserUpdateOneWithoutCrewNestedInput = {
    create?: XOR<UserCreateWithoutCrewInput, UserUncheckedCreateWithoutCrewInput>
    connectOrCreate?: UserCreateOrConnectWithoutCrewInput
    upsert?: UserUpsertWithoutCrewInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCrewInput, UserUncheckedUpdateWithoutCrewInput>
  }

  export type UserUpdateOneWithoutCrewEditedByNestedInput = {
    create?: XOR<UserCreateWithoutCrewEditedByInput, UserUncheckedCreateWithoutCrewEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutCrewEditedByInput
    upsert?: UserUpsertWithoutCrewEditedByInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCrewEditedByInput, UserUncheckedUpdateWithoutCrewEditedByInput>
  }

  export type UserCrewUpdateManyWithoutCrewNestedInput = {
    create?: XOR<Enumerable<UserCrewCreateWithoutCrewInput>, Enumerable<UserCrewUncheckedCreateWithoutCrewInput>>
    connectOrCreate?: Enumerable<UserCrewCreateOrConnectWithoutCrewInput>
    upsert?: Enumerable<UserCrewUpsertWithWhereUniqueWithoutCrewInput>
    createMany?: UserCrewCreateManyCrewInputEnvelope
    set?: Enumerable<UserCrewWhereUniqueInput>
    disconnect?: Enumerable<UserCrewWhereUniqueInput>
    delete?: Enumerable<UserCrewWhereUniqueInput>
    connect?: Enumerable<UserCrewWhereUniqueInput>
    update?: Enumerable<UserCrewUpdateWithWhereUniqueWithoutCrewInput>
    updateMany?: Enumerable<UserCrewUpdateManyWithWhereWithoutCrewInput>
    deleteMany?: Enumerable<UserCrewScalarWhereInput>
  }

  export type UserCrewUncheckedUpdateManyWithoutCrewNestedInput = {
    create?: XOR<Enumerable<UserCrewCreateWithoutCrewInput>, Enumerable<UserCrewUncheckedCreateWithoutCrewInput>>
    connectOrCreate?: Enumerable<UserCrewCreateOrConnectWithoutCrewInput>
    upsert?: Enumerable<UserCrewUpsertWithWhereUniqueWithoutCrewInput>
    createMany?: UserCrewCreateManyCrewInputEnvelope
    set?: Enumerable<UserCrewWhereUniqueInput>
    disconnect?: Enumerable<UserCrewWhereUniqueInput>
    delete?: Enumerable<UserCrewWhereUniqueInput>
    connect?: Enumerable<UserCrewWhereUniqueInput>
    update?: Enumerable<UserCrewUpdateWithWhereUniqueWithoutCrewInput>
    updateMany?: Enumerable<UserCrewUpdateManyWithWhereWithoutCrewInput>
    deleteMany?: Enumerable<UserCrewScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutUserCrewInput = {
    create?: XOR<UserCreateWithoutUserCrewInput, UserUncheckedCreateWithoutUserCrewInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserCrewInput
    connect?: UserWhereUniqueInput
  }

  export type CrewCreateNestedOneWithoutUserCrewInput = {
    create?: XOR<CrewCreateWithoutUserCrewInput, CrewUncheckedCreateWithoutUserCrewInput>
    connectOrCreate?: CrewCreateOrConnectWithoutUserCrewInput
    connect?: CrewWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserCrewNestedInput = {
    create?: XOR<UserCreateWithoutUserCrewInput, UserUncheckedCreateWithoutUserCrewInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserCrewInput
    upsert?: UserUpsertWithoutUserCrewInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserCrewInput, UserUncheckedUpdateWithoutUserCrewInput>
  }

  export type CrewUpdateOneRequiredWithoutUserCrewNestedInput = {
    create?: XOR<CrewCreateWithoutUserCrewInput, CrewUncheckedCreateWithoutUserCrewInput>
    connectOrCreate?: CrewCreateOrConnectWithoutUserCrewInput
    upsert?: CrewUpsertWithoutUserCrewInput
    connect?: CrewWhereUniqueInput
    update?: XOR<CrewUpdateWithoutUserCrewInput, CrewUncheckedUpdateWithoutUserCrewInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type ProfileCreateWithoutUserInput = {
    photo: string
  }

  export type ProfileUncheckedCreateWithoutUserInput = {
    id?: number
    photo: string
  }

  export type ProfileCreateOrConnectWithoutUserInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type RecipeBookUserCreateWithoutUserInput = {
    recipeBook: RecipeBookCreateNestedOneWithoutRecipeBookUserInput
    partner: boolean
    manager: boolean
  }

  export type RecipeBookUserUncheckedCreateWithoutUserInput = {
    id?: number
    recipeBookId: number
    partner: boolean
    manager: boolean
  }

  export type RecipeBookUserCreateOrConnectWithoutUserInput = {
    where: RecipeBookUserWhereUniqueInput
    create: XOR<RecipeBookUserCreateWithoutUserInput, RecipeBookUserUncheckedCreateWithoutUserInput>
  }

  export type RecipeBookUserCreateManyUserInputEnvelope = {
    data: Enumerable<RecipeBookUserCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type RecipeBookCreateWithoutCreatedByInput = {
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedBy?: UserCreateNestedOneWithoutRecipeBookEditedByIdInput
    recipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutRecipeBookInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookUncheckedCreateWithoutCreatedByInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedById?: string | null
    recipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutRecipeBookInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookCreateOrConnectWithoutCreatedByInput = {
    where: RecipeBookWhereUniqueInput
    create: XOR<RecipeBookCreateWithoutCreatedByInput, RecipeBookUncheckedCreateWithoutCreatedByInput>
  }

  export type RecipeBookCreateManyCreatedByInputEnvelope = {
    data: Enumerable<RecipeBookCreateManyCreatedByInput>
    skipDuplicates?: boolean
  }

  export type RecipeBookCreateWithoutEditedByInput = {
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutRecipeBookInput
    recipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutRecipeBookInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookUncheckedCreateWithoutEditedByInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    recipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutRecipeBookInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookCreateOrConnectWithoutEditedByInput = {
    where: RecipeBookWhereUniqueInput
    create: XOR<RecipeBookCreateWithoutEditedByInput, RecipeBookUncheckedCreateWithoutEditedByInput>
  }

  export type RecipeBookCreateManyEditedByInputEnvelope = {
    data: Enumerable<RecipeBookCreateManyEditedByInput>
    skipDuplicates?: boolean
  }

  export type UserCrewCreateWithoutUserInput = {
    crew: CrewCreateNestedOneWithoutUserCrewInput
    partner: boolean
    manager: boolean
  }

  export type UserCrewUncheckedCreateWithoutUserInput = {
    id?: number
    crewId: number
    partner: boolean
    manager: boolean
  }

  export type UserCrewCreateOrConnectWithoutUserInput = {
    where: UserCrewWhereUniqueInput
    create: XOR<UserCrewCreateWithoutUserInput, UserCrewUncheckedCreateWithoutUserInput>
  }

  export type UserCrewCreateManyUserInputEnvelope = {
    data: Enumerable<UserCrewCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type CrewCreateWithoutCreatedByInput = {
    createdAt?: Date | string
    editedAt?: Date | string
    editedBy?: UserCreateNestedOneWithoutCrewEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutCrewInput
  }

  export type CrewUncheckedCreateWithoutCreatedByInput = {
    id?: number
    createdAt?: Date | string
    editedAt?: Date | string
    editedById: string
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutCrewInput
  }

  export type CrewCreateOrConnectWithoutCreatedByInput = {
    where: CrewWhereUniqueInput
    create: XOR<CrewCreateWithoutCreatedByInput, CrewUncheckedCreateWithoutCreatedByInput>
  }

  export type CrewCreateManyCreatedByInputEnvelope = {
    data: Enumerable<CrewCreateManyCreatedByInput>
    skipDuplicates?: boolean
  }

  export type CrewCreateWithoutEditedByInput = {
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCrewInput
    userCrew?: UserCrewCreateNestedManyWithoutCrewInput
  }

  export type CrewUncheckedCreateWithoutEditedByInput = {
    id?: number
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutCrewInput
  }

  export type CrewCreateOrConnectWithoutEditedByInput = {
    where: CrewWhereUniqueInput
    create: XOR<CrewCreateWithoutEditedByInput, CrewUncheckedCreateWithoutEditedByInput>
  }

  export type CrewCreateManyEditedByInputEnvelope = {
    data: Enumerable<CrewCreateManyEditedByInput>
    skipDuplicates?: boolean
  }

  export type UserBuildCreateWithoutUserInput = {
    build: BuildCreateNestedOneWithoutUserBuildInput
    partner: boolean
    manager: boolean
  }

  export type UserBuildUncheckedCreateWithoutUserInput = {
    id?: number
    buildId: number
    partner: boolean
    manager: boolean
  }

  export type UserBuildCreateOrConnectWithoutUserInput = {
    where: UserBuildWhereUniqueInput
    create: XOR<UserBuildCreateWithoutUserInput, UserBuildUncheckedCreateWithoutUserInput>
  }

  export type UserBuildCreateManyUserInputEnvelope = {
    data: Enumerable<UserBuildCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type BuildCreateWithoutCreatedByInput = {
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedBy?: UserCreateNestedOneWithoutBuildEditedByInput
    recipe?: RecipeCreateNestedOneWithoutBuildInput
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    touch?: TouchCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutBuildInput
    userBuild?: UserBuildCreateNestedManyWithoutBuildInput
  }

  export type BuildUncheckedCreateWithoutCreatedByInput = {
    id?: number
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedById: string
    recipeId?: number | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutBuildInput
    userBuild?: UserBuildUncheckedCreateNestedManyWithoutBuildInput
  }

  export type BuildCreateOrConnectWithoutCreatedByInput = {
    where: BuildWhereUniqueInput
    create: XOR<BuildCreateWithoutCreatedByInput, BuildUncheckedCreateWithoutCreatedByInput>
  }

  export type BuildCreateManyCreatedByInputEnvelope = {
    data: Enumerable<BuildCreateManyCreatedByInput>
    skipDuplicates?: boolean
  }

  export type BuildCreateWithoutEditedByInput = {
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutBuildInput
    recipe?: RecipeCreateNestedOneWithoutBuildInput
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    touch?: TouchCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutBuildInput
    userBuild?: UserBuildCreateNestedManyWithoutBuildInput
  }

  export type BuildUncheckedCreateWithoutEditedByInput = {
    id?: number
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    recipeId?: number | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutBuildInput
    userBuild?: UserBuildUncheckedCreateNestedManyWithoutBuildInput
  }

  export type BuildCreateOrConnectWithoutEditedByInput = {
    where: BuildWhereUniqueInput
    create: XOR<BuildCreateWithoutEditedByInput, BuildUncheckedCreateWithoutEditedByInput>
  }

  export type BuildCreateManyEditedByInputEnvelope = {
    data: Enumerable<BuildCreateManyEditedByInput>
    skipDuplicates?: boolean
  }

  export type RecipeCreateWithoutCreatedByInput = {
    createdAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    build?: BuildCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutCreatedByInput = {
    id?: number
    createdAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    build?: BuildUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutCreatedByInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutCreatedByInput, RecipeUncheckedCreateWithoutCreatedByInput>
  }

  export type RecipeCreateManyCreatedByInputEnvelope = {
    data: Enumerable<RecipeCreateManyCreatedByInput>
    skipDuplicates?: boolean
  }

  export type IngredientCreateWithoutCreatedByInput = {
    dateCreated?: Date | string
    name?: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    touch?: TouchCreateNestedManyWithoutIngredientInput
    ingredientStorage?: ingredientStorageCreateNestedManyWithoutIngredientInput
  }

  export type IngredientUncheckedCreateWithoutCreatedByInput = {
    id?: number
    dateCreated?: Date | string
    name?: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutIngredientInput
    ingredientStorage?: ingredientStorageUncheckedCreateNestedManyWithoutIngredientInput
  }

  export type IngredientCreateOrConnectWithoutCreatedByInput = {
    where: IngredientWhereUniqueInput
    create: XOR<IngredientCreateWithoutCreatedByInput, IngredientUncheckedCreateWithoutCreatedByInput>
  }

  export type IngredientCreateManyCreatedByInputEnvelope = {
    data: Enumerable<IngredientCreateManyCreatedByInput>
    skipDuplicates?: boolean
  }

  export type UserStorageCreateWithoutUserInput = {
    createdAt?: Date | string
    editedAt?: Date | string
    quantity?: number | null
    Storage?: StorageCreateNestedOneWithoutUserStorageInput
    partner: boolean
    manager: boolean
  }

  export type UserStorageUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    editedAt?: Date | string
    quantity?: number | null
    storageId?: number | null
    partner: boolean
    manager: boolean
  }

  export type UserStorageCreateOrConnectWithoutUserInput = {
    where: UserStorageWhereUniqueInput
    create: XOR<UserStorageCreateWithoutUserInput, UserStorageUncheckedCreateWithoutUserInput>
  }

  export type UserStorageCreateManyUserInputEnvelope = {
    data: Enumerable<UserStorageCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type StorageCreateWithoutCreatedByInput = {
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedBy?: UserCreateNestedOneWithoutStorageEditedByInput
    inventoryStorage?: InventoryStorageCreateNestedManyWithoutStorageInput
    ingredientStorage?: ingredientStorageCreateNestedManyWithoutStorageInput
    userStorage?: UserStorageCreateNestedManyWithoutStorageInput
  }

  export type StorageUncheckedCreateWithoutCreatedByInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedById: string
    inventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutStorageInput
    ingredientStorage?: ingredientStorageUncheckedCreateNestedManyWithoutStorageInput
    userStorage?: UserStorageUncheckedCreateNestedManyWithoutStorageInput
  }

  export type StorageCreateOrConnectWithoutCreatedByInput = {
    where: StorageWhereUniqueInput
    create: XOR<StorageCreateWithoutCreatedByInput, StorageUncheckedCreateWithoutCreatedByInput>
  }

  export type StorageCreateManyCreatedByInputEnvelope = {
    data: Enumerable<StorageCreateManyCreatedByInput>
    skipDuplicates?: boolean
  }

  export type StorageCreateWithoutEditedByInput = {
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutStorageInput
    inventoryStorage?: InventoryStorageCreateNestedManyWithoutStorageInput
    ingredientStorage?: ingredientStorageCreateNestedManyWithoutStorageInput
    userStorage?: UserStorageCreateNestedManyWithoutStorageInput
  }

  export type StorageUncheckedCreateWithoutEditedByInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    inventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutStorageInput
    ingredientStorage?: ingredientStorageUncheckedCreateNestedManyWithoutStorageInput
    userStorage?: UserStorageUncheckedCreateNestedManyWithoutStorageInput
  }

  export type StorageCreateOrConnectWithoutEditedByInput = {
    where: StorageWhereUniqueInput
    create: XOR<StorageCreateWithoutEditedByInput, StorageUncheckedCreateWithoutEditedByInput>
  }

  export type StorageCreateManyEditedByInputEnvelope = {
    data: Enumerable<StorageCreateManyEditedByInput>
    skipDuplicates?: boolean
  }

  export type InventoryCreateWithoutCreatedByInput = {
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedBy?: UserCreateNestedOneWithoutInventoryEditedByInput
    InventoryStorage?: InventoryStorageCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutCreatedByInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedById: string
    InventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryCreateOrConnectWithoutCreatedByInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutCreatedByInput, InventoryUncheckedCreateWithoutCreatedByInput>
  }

  export type InventoryCreateManyCreatedByInputEnvelope = {
    data: Enumerable<InventoryCreateManyCreatedByInput>
    skipDuplicates?: boolean
  }

  export type InventoryCreateWithoutEditedByInput = {
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutInventoryCreatedByInput
    InventoryStorage?: InventoryStorageCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutEditedByInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    InventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryCreateOrConnectWithoutEditedByInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutEditedByInput, InventoryUncheckedCreateWithoutEditedByInput>
  }

  export type InventoryCreateManyEditedByInputEnvelope = {
    data: Enumerable<InventoryCreateManyEditedByInput>
    skipDuplicates?: boolean
  }

  export type ProfileUpsertWithoutUserInput = {
    update: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type ProfileUpdateWithoutUserInput = {
    photo?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    photo?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookUserUpsertWithWhereUniqueWithoutUserInput = {
    where: RecipeBookUserWhereUniqueInput
    update: XOR<RecipeBookUserUpdateWithoutUserInput, RecipeBookUserUncheckedUpdateWithoutUserInput>
    create: XOR<RecipeBookUserCreateWithoutUserInput, RecipeBookUserUncheckedCreateWithoutUserInput>
  }

  export type RecipeBookUserUpdateWithWhereUniqueWithoutUserInput = {
    where: RecipeBookUserWhereUniqueInput
    data: XOR<RecipeBookUserUpdateWithoutUserInput, RecipeBookUserUncheckedUpdateWithoutUserInput>
  }

  export type RecipeBookUserUpdateManyWithWhereWithoutUserInput = {
    where: RecipeBookUserScalarWhereInput
    data: XOR<RecipeBookUserUpdateManyMutationInput, RecipeBookUserUncheckedUpdateManyWithoutRecipeBookUserInput>
  }

  export type RecipeBookUserScalarWhereInput = {
    AND?: Enumerable<RecipeBookUserScalarWhereInput>
    OR?: Enumerable<RecipeBookUserScalarWhereInput>
    NOT?: Enumerable<RecipeBookUserScalarWhereInput>
    id?: IntFilter | number
    userId?: StringFilter | string
    recipeBookId?: IntFilter | number
    partner?: BoolFilter | boolean
    manager?: BoolFilter | boolean
  }

  export type RecipeBookUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: RecipeBookWhereUniqueInput
    update: XOR<RecipeBookUpdateWithoutCreatedByInput, RecipeBookUncheckedUpdateWithoutCreatedByInput>
    create: XOR<RecipeBookCreateWithoutCreatedByInput, RecipeBookUncheckedCreateWithoutCreatedByInput>
  }

  export type RecipeBookUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: RecipeBookWhereUniqueInput
    data: XOR<RecipeBookUpdateWithoutCreatedByInput, RecipeBookUncheckedUpdateWithoutCreatedByInput>
  }

  export type RecipeBookUpdateManyWithWhereWithoutCreatedByInput = {
    where: RecipeBookScalarWhereInput
    data: XOR<RecipeBookUpdateManyMutationInput, RecipeBookUncheckedUpdateManyWithoutRecipeBookInput>
  }

  export type RecipeBookScalarWhereInput = {
    AND?: Enumerable<RecipeBookScalarWhereInput>
    OR?: Enumerable<RecipeBookScalarWhereInput>
    NOT?: Enumerable<RecipeBookScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    editedAt?: DateTimeFilter | Date | string
    createdById?: StringNullableFilter | string | null
    editedById?: StringNullableFilter | string | null
  }

  export type RecipeBookUpsertWithWhereUniqueWithoutEditedByInput = {
    where: RecipeBookWhereUniqueInput
    update: XOR<RecipeBookUpdateWithoutEditedByInput, RecipeBookUncheckedUpdateWithoutEditedByInput>
    create: XOR<RecipeBookCreateWithoutEditedByInput, RecipeBookUncheckedCreateWithoutEditedByInput>
  }

  export type RecipeBookUpdateWithWhereUniqueWithoutEditedByInput = {
    where: RecipeBookWhereUniqueInput
    data: XOR<RecipeBookUpdateWithoutEditedByInput, RecipeBookUncheckedUpdateWithoutEditedByInput>
  }

  export type RecipeBookUpdateManyWithWhereWithoutEditedByInput = {
    where: RecipeBookScalarWhereInput
    data: XOR<RecipeBookUpdateManyMutationInput, RecipeBookUncheckedUpdateManyWithoutRecipeBookEditedByIdInput>
  }

  export type UserCrewUpsertWithWhereUniqueWithoutUserInput = {
    where: UserCrewWhereUniqueInput
    update: XOR<UserCrewUpdateWithoutUserInput, UserCrewUncheckedUpdateWithoutUserInput>
    create: XOR<UserCrewCreateWithoutUserInput, UserCrewUncheckedCreateWithoutUserInput>
  }

  export type UserCrewUpdateWithWhereUniqueWithoutUserInput = {
    where: UserCrewWhereUniqueInput
    data: XOR<UserCrewUpdateWithoutUserInput, UserCrewUncheckedUpdateWithoutUserInput>
  }

  export type UserCrewUpdateManyWithWhereWithoutUserInput = {
    where: UserCrewScalarWhereInput
    data: XOR<UserCrewUpdateManyMutationInput, UserCrewUncheckedUpdateManyWithoutUserCrewInput>
  }

  export type UserCrewScalarWhereInput = {
    AND?: Enumerable<UserCrewScalarWhereInput>
    OR?: Enumerable<UserCrewScalarWhereInput>
    NOT?: Enumerable<UserCrewScalarWhereInput>
    id?: IntFilter | number
    userId?: StringFilter | string
    crewId?: IntFilter | number
    partner?: BoolFilter | boolean
    manager?: BoolFilter | boolean
  }

  export type CrewUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: CrewWhereUniqueInput
    update: XOR<CrewUpdateWithoutCreatedByInput, CrewUncheckedUpdateWithoutCreatedByInput>
    create: XOR<CrewCreateWithoutCreatedByInput, CrewUncheckedCreateWithoutCreatedByInput>
  }

  export type CrewUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: CrewWhereUniqueInput
    data: XOR<CrewUpdateWithoutCreatedByInput, CrewUncheckedUpdateWithoutCreatedByInput>
  }

  export type CrewUpdateManyWithWhereWithoutCreatedByInput = {
    where: CrewScalarWhereInput
    data: XOR<CrewUpdateManyMutationInput, CrewUncheckedUpdateManyWithoutCrewInput>
  }

  export type CrewScalarWhereInput = {
    AND?: Enumerable<CrewScalarWhereInput>
    OR?: Enumerable<CrewScalarWhereInput>
    NOT?: Enumerable<CrewScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    editedAt?: DateTimeFilter | Date | string
    createdById?: StringFilter | string
    editedById?: StringFilter | string
  }

  export type CrewUpsertWithWhereUniqueWithoutEditedByInput = {
    where: CrewWhereUniqueInput
    update: XOR<CrewUpdateWithoutEditedByInput, CrewUncheckedUpdateWithoutEditedByInput>
    create: XOR<CrewCreateWithoutEditedByInput, CrewUncheckedCreateWithoutEditedByInput>
  }

  export type CrewUpdateWithWhereUniqueWithoutEditedByInput = {
    where: CrewWhereUniqueInput
    data: XOR<CrewUpdateWithoutEditedByInput, CrewUncheckedUpdateWithoutEditedByInput>
  }

  export type CrewUpdateManyWithWhereWithoutEditedByInput = {
    where: CrewScalarWhereInput
    data: XOR<CrewUpdateManyMutationInput, CrewUncheckedUpdateManyWithoutCrewEditedByInput>
  }

  export type UserBuildUpsertWithWhereUniqueWithoutUserInput = {
    where: UserBuildWhereUniqueInput
    update: XOR<UserBuildUpdateWithoutUserInput, UserBuildUncheckedUpdateWithoutUserInput>
    create: XOR<UserBuildCreateWithoutUserInput, UserBuildUncheckedCreateWithoutUserInput>
  }

  export type UserBuildUpdateWithWhereUniqueWithoutUserInput = {
    where: UserBuildWhereUniqueInput
    data: XOR<UserBuildUpdateWithoutUserInput, UserBuildUncheckedUpdateWithoutUserInput>
  }

  export type UserBuildUpdateManyWithWhereWithoutUserInput = {
    where: UserBuildScalarWhereInput
    data: XOR<UserBuildUpdateManyMutationInput, UserBuildUncheckedUpdateManyWithoutUserBuildInput>
  }

  export type UserBuildScalarWhereInput = {
    AND?: Enumerable<UserBuildScalarWhereInput>
    OR?: Enumerable<UserBuildScalarWhereInput>
    NOT?: Enumerable<UserBuildScalarWhereInput>
    id?: IntFilter | number
    userId?: StringFilter | string
    buildId?: IntFilter | number
    partner?: BoolFilter | boolean
    manager?: BoolFilter | boolean
  }

  export type BuildUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: BuildWhereUniqueInput
    update: XOR<BuildUpdateWithoutCreatedByInput, BuildUncheckedUpdateWithoutCreatedByInput>
    create: XOR<BuildCreateWithoutCreatedByInput, BuildUncheckedCreateWithoutCreatedByInput>
  }

  export type BuildUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: BuildWhereUniqueInput
    data: XOR<BuildUpdateWithoutCreatedByInput, BuildUncheckedUpdateWithoutCreatedByInput>
  }

  export type BuildUpdateManyWithWhereWithoutCreatedByInput = {
    where: BuildScalarWhereInput
    data: XOR<BuildUpdateManyMutationInput, BuildUncheckedUpdateManyWithoutBuildInput>
  }

  export type BuildScalarWhereInput = {
    AND?: Enumerable<BuildScalarWhereInput>
    OR?: Enumerable<BuildScalarWhereInput>
    NOT?: Enumerable<BuildScalarWhereInput>
    id?: IntFilter | number
    buildName?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    editedAt?: DateTimeFilter | Date | string
    createdById?: StringFilter | string
    editedById?: StringFilter | string
    recipeId?: IntNullableFilter | number | null
    instructions?: StringNullableFilter | string | null
    notes?: StringNullableFilter | string | null
    glassware?: StringNullableFilter | string | null
    ice?: StringNullableFilter | string | null
  }

  export type BuildUpsertWithWhereUniqueWithoutEditedByInput = {
    where: BuildWhereUniqueInput
    update: XOR<BuildUpdateWithoutEditedByInput, BuildUncheckedUpdateWithoutEditedByInput>
    create: XOR<BuildCreateWithoutEditedByInput, BuildUncheckedCreateWithoutEditedByInput>
  }

  export type BuildUpdateWithWhereUniqueWithoutEditedByInput = {
    where: BuildWhereUniqueInput
    data: XOR<BuildUpdateWithoutEditedByInput, BuildUncheckedUpdateWithoutEditedByInput>
  }

  export type BuildUpdateManyWithWhereWithoutEditedByInput = {
    where: BuildScalarWhereInput
    data: XOR<BuildUpdateManyMutationInput, BuildUncheckedUpdateManyWithoutBuildEditedByInput>
  }

  export type RecipeUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: RecipeWhereUniqueInput
    update: XOR<RecipeUpdateWithoutCreatedByInput, RecipeUncheckedUpdateWithoutCreatedByInput>
    create: XOR<RecipeCreateWithoutCreatedByInput, RecipeUncheckedCreateWithoutCreatedByInput>
  }

  export type RecipeUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: RecipeWhereUniqueInput
    data: XOR<RecipeUpdateWithoutCreatedByInput, RecipeUncheckedUpdateWithoutCreatedByInput>
  }

  export type RecipeUpdateManyWithWhereWithoutCreatedByInput = {
    where: RecipeScalarWhereInput
    data: XOR<RecipeUpdateManyMutationInput, RecipeUncheckedUpdateManyWithoutRecipeInput>
  }

  export type RecipeScalarWhereInput = {
    AND?: Enumerable<RecipeScalarWhereInput>
    OR?: Enumerable<RecipeScalarWhereInput>
    NOT?: Enumerable<RecipeScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    name?: StringFilter | string
    origin?: StringNullableFilter | string | null
    history?: StringNullableFilter | string | null
    createdById?: StringFilter | string
  }

  export type IngredientUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: IngredientWhereUniqueInput
    update: XOR<IngredientUpdateWithoutCreatedByInput, IngredientUncheckedUpdateWithoutCreatedByInput>
    create: XOR<IngredientCreateWithoutCreatedByInput, IngredientUncheckedCreateWithoutCreatedByInput>
  }

  export type IngredientUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: IngredientWhereUniqueInput
    data: XOR<IngredientUpdateWithoutCreatedByInput, IngredientUncheckedUpdateWithoutCreatedByInput>
  }

  export type IngredientUpdateManyWithWhereWithoutCreatedByInput = {
    where: IngredientScalarWhereInput
    data: XOR<IngredientUpdateManyMutationInput, IngredientUncheckedUpdateManyWithoutIngredientInput>
  }

  export type IngredientScalarWhereInput = {
    AND?: Enumerable<IngredientScalarWhereInput>
    OR?: Enumerable<IngredientScalarWhereInput>
    NOT?: Enumerable<IngredientScalarWhereInput>
    id?: IntFilter | number
    dateCreated?: DateTimeFilter | Date | string
    createdById?: StringNullableFilter | string | null
    name?: StringFilter | string
    price?: FloatNullableFilter | number | null
    amount?: FloatNullableFilter | number | null
    unit?: StringNullableFilter | string | null
  }

  export type UserStorageUpsertWithWhereUniqueWithoutUserInput = {
    where: UserStorageWhereUniqueInput
    update: XOR<UserStorageUpdateWithoutUserInput, UserStorageUncheckedUpdateWithoutUserInput>
    create: XOR<UserStorageCreateWithoutUserInput, UserStorageUncheckedCreateWithoutUserInput>
  }

  export type UserStorageUpdateWithWhereUniqueWithoutUserInput = {
    where: UserStorageWhereUniqueInput
    data: XOR<UserStorageUpdateWithoutUserInput, UserStorageUncheckedUpdateWithoutUserInput>
  }

  export type UserStorageUpdateManyWithWhereWithoutUserInput = {
    where: UserStorageScalarWhereInput
    data: XOR<UserStorageUpdateManyMutationInput, UserStorageUncheckedUpdateManyWithoutUserStorageInput>
  }

  export type UserStorageScalarWhereInput = {
    AND?: Enumerable<UserStorageScalarWhereInput>
    OR?: Enumerable<UserStorageScalarWhereInput>
    NOT?: Enumerable<UserStorageScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    editedAt?: DateTimeFilter | Date | string
    userId?: StringFilter | string
    quantity?: FloatNullableFilter | number | null
    storageId?: IntNullableFilter | number | null
    partner?: BoolFilter | boolean
    manager?: BoolFilter | boolean
  }

  export type StorageUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: StorageWhereUniqueInput
    update: XOR<StorageUpdateWithoutCreatedByInput, StorageUncheckedUpdateWithoutCreatedByInput>
    create: XOR<StorageCreateWithoutCreatedByInput, StorageUncheckedCreateWithoutCreatedByInput>
  }

  export type StorageUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: StorageWhereUniqueInput
    data: XOR<StorageUpdateWithoutCreatedByInput, StorageUncheckedUpdateWithoutCreatedByInput>
  }

  export type StorageUpdateManyWithWhereWithoutCreatedByInput = {
    where: StorageScalarWhereInput
    data: XOR<StorageUpdateManyMutationInput, StorageUncheckedUpdateManyWithoutStorageInput>
  }

  export type StorageScalarWhereInput = {
    AND?: Enumerable<StorageScalarWhereInput>
    OR?: Enumerable<StorageScalarWhereInput>
    NOT?: Enumerable<StorageScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    editedAt?: DateTimeFilter | Date | string
    createdById?: StringFilter | string
    editedById?: StringFilter | string
  }

  export type StorageUpsertWithWhereUniqueWithoutEditedByInput = {
    where: StorageWhereUniqueInput
    update: XOR<StorageUpdateWithoutEditedByInput, StorageUncheckedUpdateWithoutEditedByInput>
    create: XOR<StorageCreateWithoutEditedByInput, StorageUncheckedCreateWithoutEditedByInput>
  }

  export type StorageUpdateWithWhereUniqueWithoutEditedByInput = {
    where: StorageWhereUniqueInput
    data: XOR<StorageUpdateWithoutEditedByInput, StorageUncheckedUpdateWithoutEditedByInput>
  }

  export type StorageUpdateManyWithWhereWithoutEditedByInput = {
    where: StorageScalarWhereInput
    data: XOR<StorageUpdateManyMutationInput, StorageUncheckedUpdateManyWithoutStorageEditedByInput>
  }

  export type InventoryUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: InventoryWhereUniqueInput
    update: XOR<InventoryUpdateWithoutCreatedByInput, InventoryUncheckedUpdateWithoutCreatedByInput>
    create: XOR<InventoryCreateWithoutCreatedByInput, InventoryUncheckedCreateWithoutCreatedByInput>
  }

  export type InventoryUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: InventoryWhereUniqueInput
    data: XOR<InventoryUpdateWithoutCreatedByInput, InventoryUncheckedUpdateWithoutCreatedByInput>
  }

  export type InventoryUpdateManyWithWhereWithoutCreatedByInput = {
    where: InventoryScalarWhereInput
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyWithoutInventoryCreatedByInput>
  }

  export type InventoryScalarWhereInput = {
    AND?: Enumerable<InventoryScalarWhereInput>
    OR?: Enumerable<InventoryScalarWhereInput>
    NOT?: Enumerable<InventoryScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    editedAt?: DateTimeFilter | Date | string
    createdById?: StringFilter | string
    editedById?: StringFilter | string
  }

  export type InventoryUpsertWithWhereUniqueWithoutEditedByInput = {
    where: InventoryWhereUniqueInput
    update: XOR<InventoryUpdateWithoutEditedByInput, InventoryUncheckedUpdateWithoutEditedByInput>
    create: XOR<InventoryCreateWithoutEditedByInput, InventoryUncheckedCreateWithoutEditedByInput>
  }

  export type InventoryUpdateWithWhereUniqueWithoutEditedByInput = {
    where: InventoryWhereUniqueInput
    data: XOR<InventoryUpdateWithoutEditedByInput, InventoryUncheckedUpdateWithoutEditedByInput>
  }

  export type InventoryUpdateManyWithWhereWithoutEditedByInput = {
    where: InventoryScalarWhereInput
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyWithoutInventoryEditedByInput>
  }

  export type UserCreateWithoutProfileInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    userBuild?: UserBuildCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    userStorage?: UserStorageCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    userBuild?: UserBuildUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    userStorage?: UserStorageUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    userBuild?: UserBuildUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    userStorage?: UserStorageUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    userBuild?: UserBuildUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    userStorage?: UserStorageUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
  }

  export type UserCreateWithoutRecipeBookInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    userBuild?: UserBuildCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    userStorage?: UserStorageCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
  }

  export type UserUncheckedCreateWithoutRecipeBookInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    userBuild?: UserBuildUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    userStorage?: UserStorageUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
  }

  export type UserCreateOrConnectWithoutRecipeBookInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecipeBookInput, UserUncheckedCreateWithoutRecipeBookInput>
  }

  export type UserCreateWithoutRecipeBookEditedByIdInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    userBuild?: UserBuildCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    userStorage?: UserStorageCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
  }

  export type UserUncheckedCreateWithoutRecipeBookEditedByIdInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    userBuild?: UserBuildUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    userStorage?: UserStorageUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
  }

  export type UserCreateOrConnectWithoutRecipeBookEditedByIdInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecipeBookEditedByIdInput, UserUncheckedCreateWithoutRecipeBookEditedByIdInput>
  }

  export type RecipeBookBuildCreateWithoutRecipeBookInput = {
    build: BuildCreateNestedOneWithoutRecipeBookBuildInput
  }

  export type RecipeBookBuildUncheckedCreateWithoutRecipeBookInput = {
    id?: number
    buildId: number
  }

  export type RecipeBookBuildCreateOrConnectWithoutRecipeBookInput = {
    where: RecipeBookBuildWhereUniqueInput
    create: XOR<RecipeBookBuildCreateWithoutRecipeBookInput, RecipeBookBuildUncheckedCreateWithoutRecipeBookInput>
  }

  export type RecipeBookBuildCreateManyRecipeBookInputEnvelope = {
    data: Enumerable<RecipeBookBuildCreateManyRecipeBookInput>
    skipDuplicates?: boolean
  }

  export type RecipeBookUserCreateWithoutRecipeBookInput = {
    user: UserCreateNestedOneWithoutRecipeBookUserInput
    partner: boolean
    manager: boolean
  }

  export type RecipeBookUserUncheckedCreateWithoutRecipeBookInput = {
    id?: number
    userId: string
    partner: boolean
    manager: boolean
  }

  export type RecipeBookUserCreateOrConnectWithoutRecipeBookInput = {
    where: RecipeBookUserWhereUniqueInput
    create: XOR<RecipeBookUserCreateWithoutRecipeBookInput, RecipeBookUserUncheckedCreateWithoutRecipeBookInput>
  }

  export type RecipeBookUserCreateManyRecipeBookInputEnvelope = {
    data: Enumerable<RecipeBookUserCreateManyRecipeBookInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutRecipeBookInput = {
    update: XOR<UserUpdateWithoutRecipeBookInput, UserUncheckedUpdateWithoutRecipeBookInput>
    create: XOR<UserCreateWithoutRecipeBookInput, UserUncheckedCreateWithoutRecipeBookInput>
  }

  export type UserUpdateWithoutRecipeBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    userBuild?: UserBuildUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    userStorage?: UserStorageUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
  }

  export type UserUncheckedUpdateWithoutRecipeBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    userBuild?: UserBuildUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    userStorage?: UserStorageUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
  }

  export type UserUpsertWithoutRecipeBookEditedByIdInput = {
    update: XOR<UserUpdateWithoutRecipeBookEditedByIdInput, UserUncheckedUpdateWithoutRecipeBookEditedByIdInput>
    create: XOR<UserCreateWithoutRecipeBookEditedByIdInput, UserUncheckedCreateWithoutRecipeBookEditedByIdInput>
  }

  export type UserUpdateWithoutRecipeBookEditedByIdInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    userBuild?: UserBuildUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    userStorage?: UserStorageUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
  }

  export type UserUncheckedUpdateWithoutRecipeBookEditedByIdInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    userBuild?: UserBuildUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    userStorage?: UserStorageUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
  }

  export type RecipeBookBuildUpsertWithWhereUniqueWithoutRecipeBookInput = {
    where: RecipeBookBuildWhereUniqueInput
    update: XOR<RecipeBookBuildUpdateWithoutRecipeBookInput, RecipeBookBuildUncheckedUpdateWithoutRecipeBookInput>
    create: XOR<RecipeBookBuildCreateWithoutRecipeBookInput, RecipeBookBuildUncheckedCreateWithoutRecipeBookInput>
  }

  export type RecipeBookBuildUpdateWithWhereUniqueWithoutRecipeBookInput = {
    where: RecipeBookBuildWhereUniqueInput
    data: XOR<RecipeBookBuildUpdateWithoutRecipeBookInput, RecipeBookBuildUncheckedUpdateWithoutRecipeBookInput>
  }

  export type RecipeBookBuildUpdateManyWithWhereWithoutRecipeBookInput = {
    where: RecipeBookBuildScalarWhereInput
    data: XOR<RecipeBookBuildUpdateManyMutationInput, RecipeBookBuildUncheckedUpdateManyWithoutRecipeBookBuildInput>
  }

  export type RecipeBookBuildScalarWhereInput = {
    AND?: Enumerable<RecipeBookBuildScalarWhereInput>
    OR?: Enumerable<RecipeBookBuildScalarWhereInput>
    NOT?: Enumerable<RecipeBookBuildScalarWhereInput>
    id?: IntFilter | number
    buildId?: IntFilter | number
    recipeBookId?: IntFilter | number
  }

  export type RecipeBookUserUpsertWithWhereUniqueWithoutRecipeBookInput = {
    where: RecipeBookUserWhereUniqueInput
    update: XOR<RecipeBookUserUpdateWithoutRecipeBookInput, RecipeBookUserUncheckedUpdateWithoutRecipeBookInput>
    create: XOR<RecipeBookUserCreateWithoutRecipeBookInput, RecipeBookUserUncheckedCreateWithoutRecipeBookInput>
  }

  export type RecipeBookUserUpdateWithWhereUniqueWithoutRecipeBookInput = {
    where: RecipeBookUserWhereUniqueInput
    data: XOR<RecipeBookUserUpdateWithoutRecipeBookInput, RecipeBookUserUncheckedUpdateWithoutRecipeBookInput>
  }

  export type RecipeBookUserUpdateManyWithWhereWithoutRecipeBookInput = {
    where: RecipeBookUserScalarWhereInput
    data: XOR<RecipeBookUserUpdateManyMutationInput, RecipeBookUserUncheckedUpdateManyWithoutRecipeBookUserInput>
  }

  export type RecipeBookCreateWithoutRecipeBookUserInput = {
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutRecipeBookInput
    editedBy?: UserCreateNestedOneWithoutRecipeBookEditedByIdInput
    recipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookUncheckedCreateWithoutRecipeBookUserInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    editedById?: string | null
    recipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookCreateOrConnectWithoutRecipeBookUserInput = {
    where: RecipeBookWhereUniqueInput
    create: XOR<RecipeBookCreateWithoutRecipeBookUserInput, RecipeBookUncheckedCreateWithoutRecipeBookUserInput>
  }

  export type UserCreateWithoutRecipeBookUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    userBuild?: UserBuildCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    userStorage?: UserStorageCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
  }

  export type UserUncheckedCreateWithoutRecipeBookUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    userBuild?: UserBuildUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    userStorage?: UserStorageUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
  }

  export type UserCreateOrConnectWithoutRecipeBookUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecipeBookUserInput, UserUncheckedCreateWithoutRecipeBookUserInput>
  }

  export type RecipeBookUpsertWithoutRecipeBookUserInput = {
    update: XOR<RecipeBookUpdateWithoutRecipeBookUserInput, RecipeBookUncheckedUpdateWithoutRecipeBookUserInput>
    create: XOR<RecipeBookCreateWithoutRecipeBookUserInput, RecipeBookUncheckedCreateWithoutRecipeBookUserInput>
  }

  export type RecipeBookUpdateWithoutRecipeBookUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutRecipeBookNestedInput
    editedBy?: UserUpdateOneWithoutRecipeBookEditedByIdNestedInput
    recipeBookBuild?: RecipeBookBuildUpdateManyWithoutRecipeBookNestedInput
  }

  export type RecipeBookUncheckedUpdateWithoutRecipeBookUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutRecipeBookNestedInput
  }

  export type UserUpsertWithoutRecipeBookUserInput = {
    update: XOR<UserUpdateWithoutRecipeBookUserInput, UserUncheckedUpdateWithoutRecipeBookUserInput>
    create: XOR<UserCreateWithoutRecipeBookUserInput, UserUncheckedCreateWithoutRecipeBookUserInput>
  }

  export type UserUpdateWithoutRecipeBookUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    userBuild?: UserBuildUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    userStorage?: UserStorageUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
  }

  export type UserUncheckedUpdateWithoutRecipeBookUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    userBuild?: UserBuildUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    userStorage?: UserStorageUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
  }

  export type UserCreateWithoutBuildInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    userBuild?: UserBuildCreateNestedManyWithoutUserInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    userStorage?: UserStorageCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
  }

  export type UserUncheckedCreateWithoutBuildInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    userBuild?: UserBuildUncheckedCreateNestedManyWithoutUserInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    userStorage?: UserStorageUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
  }

  export type UserCreateOrConnectWithoutBuildInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBuildInput, UserUncheckedCreateWithoutBuildInput>
  }

  export type UserCreateWithoutBuildEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    userBuild?: UserBuildCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    userStorage?: UserStorageCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
  }

  export type UserUncheckedCreateWithoutBuildEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    userBuild?: UserBuildUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    userStorage?: UserStorageUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
  }

  export type UserCreateOrConnectWithoutBuildEditedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBuildEditedByInput, UserUncheckedCreateWithoutBuildEditedByInput>
  }

  export type RecipeCreateWithoutBuildInput = {
    createdAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    createdBy: UserCreateNestedOneWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutBuildInput = {
    id?: number
    createdAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    createdById: string
  }

  export type RecipeCreateOrConnectWithoutBuildInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutBuildInput, RecipeUncheckedCreateWithoutBuildInput>
  }

  export type TouchCreateWithoutBuildInput = {
    ingredientName?: string
    ingredient?: IngredientCreateNestedOneWithoutTouchInput
    order?: number | null
    amount?: number | null
    unit?: string | null
  }

  export type TouchUncheckedCreateWithoutBuildInput = {
    id?: number
    ingredientName?: string
    ingredientId?: number | null
    order?: number | null
    amount?: number | null
    unit?: string | null
  }

  export type TouchCreateOrConnectWithoutBuildInput = {
    where: TouchWhereUniqueInput
    create: XOR<TouchCreateWithoutBuildInput, TouchUncheckedCreateWithoutBuildInput>
  }

  export type TouchCreateManyBuildInputEnvelope = {
    data: Enumerable<TouchCreateManyBuildInput>
    skipDuplicates?: boolean
  }

  export type RecipeBookBuildCreateWithoutBuildInput = {
    recipeBook: RecipeBookCreateNestedOneWithoutRecipeBookBuildInput
  }

  export type RecipeBookBuildUncheckedCreateWithoutBuildInput = {
    id?: number
    recipeBookId: number
  }

  export type RecipeBookBuildCreateOrConnectWithoutBuildInput = {
    where: RecipeBookBuildWhereUniqueInput
    create: XOR<RecipeBookBuildCreateWithoutBuildInput, RecipeBookBuildUncheckedCreateWithoutBuildInput>
  }

  export type RecipeBookBuildCreateManyBuildInputEnvelope = {
    data: Enumerable<RecipeBookBuildCreateManyBuildInput>
    skipDuplicates?: boolean
  }

  export type UserBuildCreateWithoutBuildInput = {
    user: UserCreateNestedOneWithoutUserBuildInput
    partner: boolean
    manager: boolean
  }

  export type UserBuildUncheckedCreateWithoutBuildInput = {
    id?: number
    userId: string
    partner: boolean
    manager: boolean
  }

  export type UserBuildCreateOrConnectWithoutBuildInput = {
    where: UserBuildWhereUniqueInput
    create: XOR<UserBuildCreateWithoutBuildInput, UserBuildUncheckedCreateWithoutBuildInput>
  }

  export type UserBuildCreateManyBuildInputEnvelope = {
    data: Enumerable<UserBuildCreateManyBuildInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBuildInput = {
    update: XOR<UserUpdateWithoutBuildInput, UserUncheckedUpdateWithoutBuildInput>
    create: XOR<UserCreateWithoutBuildInput, UserUncheckedCreateWithoutBuildInput>
  }

  export type UserUpdateWithoutBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    userBuild?: UserBuildUpdateManyWithoutUserNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    userStorage?: UserStorageUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
  }

  export type UserUncheckedUpdateWithoutBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    userBuild?: UserBuildUncheckedUpdateManyWithoutUserNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    userStorage?: UserStorageUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
  }

  export type UserUpsertWithoutBuildEditedByInput = {
    update: XOR<UserUpdateWithoutBuildEditedByInput, UserUncheckedUpdateWithoutBuildEditedByInput>
    create: XOR<UserCreateWithoutBuildEditedByInput, UserUncheckedCreateWithoutBuildEditedByInput>
  }

  export type UserUpdateWithoutBuildEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    userBuild?: UserBuildUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    userStorage?: UserStorageUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
  }

  export type UserUncheckedUpdateWithoutBuildEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    userBuild?: UserBuildUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    userStorage?: UserStorageUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
  }

  export type RecipeUpsertWithoutBuildInput = {
    update: XOR<RecipeUpdateWithoutBuildInput, RecipeUncheckedUpdateWithoutBuildInput>
    create: XOR<RecipeCreateWithoutBuildInput, RecipeUncheckedCreateWithoutBuildInput>
  }

  export type RecipeUpdateWithoutBuildInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneRequiredWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutBuildInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type TouchUpsertWithWhereUniqueWithoutBuildInput = {
    where: TouchWhereUniqueInput
    update: XOR<TouchUpdateWithoutBuildInput, TouchUncheckedUpdateWithoutBuildInput>
    create: XOR<TouchCreateWithoutBuildInput, TouchUncheckedCreateWithoutBuildInput>
  }

  export type TouchUpdateWithWhereUniqueWithoutBuildInput = {
    where: TouchWhereUniqueInput
    data: XOR<TouchUpdateWithoutBuildInput, TouchUncheckedUpdateWithoutBuildInput>
  }

  export type TouchUpdateManyWithWhereWithoutBuildInput = {
    where: TouchScalarWhereInput
    data: XOR<TouchUpdateManyMutationInput, TouchUncheckedUpdateManyWithoutTouchInput>
  }

  export type TouchScalarWhereInput = {
    AND?: Enumerable<TouchScalarWhereInput>
    OR?: Enumerable<TouchScalarWhereInput>
    NOT?: Enumerable<TouchScalarWhereInput>
    id?: IntFilter | number
    ingredientName?: StringFilter | string
    ingredientId?: IntNullableFilter | number | null
    buildId?: IntNullableFilter | number | null
    order?: IntNullableFilter | number | null
    amount?: FloatNullableFilter | number | null
    unit?: StringNullableFilter | string | null
  }

  export type RecipeBookBuildUpsertWithWhereUniqueWithoutBuildInput = {
    where: RecipeBookBuildWhereUniqueInput
    update: XOR<RecipeBookBuildUpdateWithoutBuildInput, RecipeBookBuildUncheckedUpdateWithoutBuildInput>
    create: XOR<RecipeBookBuildCreateWithoutBuildInput, RecipeBookBuildUncheckedCreateWithoutBuildInput>
  }

  export type RecipeBookBuildUpdateWithWhereUniqueWithoutBuildInput = {
    where: RecipeBookBuildWhereUniqueInput
    data: XOR<RecipeBookBuildUpdateWithoutBuildInput, RecipeBookBuildUncheckedUpdateWithoutBuildInput>
  }

  export type RecipeBookBuildUpdateManyWithWhereWithoutBuildInput = {
    where: RecipeBookBuildScalarWhereInput
    data: XOR<RecipeBookBuildUpdateManyMutationInput, RecipeBookBuildUncheckedUpdateManyWithoutRecipeBookBuildInput>
  }

  export type UserBuildUpsertWithWhereUniqueWithoutBuildInput = {
    where: UserBuildWhereUniqueInput
    update: XOR<UserBuildUpdateWithoutBuildInput, UserBuildUncheckedUpdateWithoutBuildInput>
    create: XOR<UserBuildCreateWithoutBuildInput, UserBuildUncheckedCreateWithoutBuildInput>
  }

  export type UserBuildUpdateWithWhereUniqueWithoutBuildInput = {
    where: UserBuildWhereUniqueInput
    data: XOR<UserBuildUpdateWithoutBuildInput, UserBuildUncheckedUpdateWithoutBuildInput>
  }

  export type UserBuildUpdateManyWithWhereWithoutBuildInput = {
    where: UserBuildScalarWhereInput
    data: XOR<UserBuildUpdateManyMutationInput, UserBuildUncheckedUpdateManyWithoutUserBuildInput>
  }

  export type UserCreateWithoutUserBuildInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    userStorage?: UserStorageCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
  }

  export type UserUncheckedCreateWithoutUserBuildInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    userStorage?: UserStorageUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
  }

  export type UserCreateOrConnectWithoutUserBuildInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserBuildInput, UserUncheckedCreateWithoutUserBuildInput>
  }

  export type BuildCreateWithoutUserBuildInput = {
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutBuildInput
    editedBy?: UserCreateNestedOneWithoutBuildEditedByInput
    recipe?: RecipeCreateNestedOneWithoutBuildInput
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    touch?: TouchCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutBuildInput
  }

  export type BuildUncheckedCreateWithoutUserBuildInput = {
    id?: number
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    recipeId?: number | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutBuildInput
  }

  export type BuildCreateOrConnectWithoutUserBuildInput = {
    where: BuildWhereUniqueInput
    create: XOR<BuildCreateWithoutUserBuildInput, BuildUncheckedCreateWithoutUserBuildInput>
  }

  export type UserUpsertWithoutUserBuildInput = {
    update: XOR<UserUpdateWithoutUserBuildInput, UserUncheckedUpdateWithoutUserBuildInput>
    create: XOR<UserCreateWithoutUserBuildInput, UserUncheckedCreateWithoutUserBuildInput>
  }

  export type UserUpdateWithoutUserBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    userStorage?: UserStorageUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUserBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    userStorage?: UserStorageUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
  }

  export type BuildUpsertWithoutUserBuildInput = {
    update: XOR<BuildUpdateWithoutUserBuildInput, BuildUncheckedUpdateWithoutUserBuildInput>
    create: XOR<BuildCreateWithoutUserBuildInput, BuildUncheckedCreateWithoutUserBuildInput>
  }

  export type BuildUpdateWithoutUserBuildInput = {
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutBuildNestedInput
    editedBy?: UserUpdateOneWithoutBuildEditedByNestedInput
    recipe?: RecipeUpdateOneWithoutBuildNestedInput
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateWithoutUserBuildInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutBuildNestedInput
  }

  export type UserCreateWithoutRecipeInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    userBuild?: UserBuildCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    userStorage?: UserStorageCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
  }

  export type UserUncheckedCreateWithoutRecipeInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    userBuild?: UserBuildUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    userStorage?: UserStorageUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
  }

  export type UserCreateOrConnectWithoutRecipeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecipeInput, UserUncheckedCreateWithoutRecipeInput>
  }

  export type BuildCreateWithoutRecipeInput = {
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutBuildInput
    editedBy?: UserCreateNestedOneWithoutBuildEditedByInput
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    touch?: TouchCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutBuildInput
    userBuild?: UserBuildCreateNestedManyWithoutBuildInput
  }

  export type BuildUncheckedCreateWithoutRecipeInput = {
    id?: number
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutBuildInput
    userBuild?: UserBuildUncheckedCreateNestedManyWithoutBuildInput
  }

  export type BuildCreateOrConnectWithoutRecipeInput = {
    where: BuildWhereUniqueInput
    create: XOR<BuildCreateWithoutRecipeInput, BuildUncheckedCreateWithoutRecipeInput>
  }

  export type BuildCreateManyRecipeInputEnvelope = {
    data: Enumerable<BuildCreateManyRecipeInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutRecipeInput = {
    update: XOR<UserUpdateWithoutRecipeInput, UserUncheckedUpdateWithoutRecipeInput>
    create: XOR<UserCreateWithoutRecipeInput, UserUncheckedCreateWithoutRecipeInput>
  }

  export type UserUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    userBuild?: UserBuildUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    userStorage?: UserStorageUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
  }

  export type UserUncheckedUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    userBuild?: UserBuildUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    userStorage?: UserStorageUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
  }

  export type BuildUpsertWithWhereUniqueWithoutRecipeInput = {
    where: BuildWhereUniqueInput
    update: XOR<BuildUpdateWithoutRecipeInput, BuildUncheckedUpdateWithoutRecipeInput>
    create: XOR<BuildCreateWithoutRecipeInput, BuildUncheckedCreateWithoutRecipeInput>
  }

  export type BuildUpdateWithWhereUniqueWithoutRecipeInput = {
    where: BuildWhereUniqueInput
    data: XOR<BuildUpdateWithoutRecipeInput, BuildUncheckedUpdateWithoutRecipeInput>
  }

  export type BuildUpdateManyWithWhereWithoutRecipeInput = {
    where: BuildScalarWhereInput
    data: XOR<BuildUpdateManyMutationInput, BuildUncheckedUpdateManyWithoutBuildInput>
  }

  export type RecipeBookCreateWithoutRecipeBookBuildInput = {
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutRecipeBookInput
    editedBy?: UserCreateNestedOneWithoutRecipeBookEditedByIdInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookUncheckedCreateWithoutRecipeBookBuildInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    editedById?: string | null
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookCreateOrConnectWithoutRecipeBookBuildInput = {
    where: RecipeBookWhereUniqueInput
    create: XOR<RecipeBookCreateWithoutRecipeBookBuildInput, RecipeBookUncheckedCreateWithoutRecipeBookBuildInput>
  }

  export type BuildCreateWithoutRecipeBookBuildInput = {
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutBuildInput
    editedBy?: UserCreateNestedOneWithoutBuildEditedByInput
    recipe?: RecipeCreateNestedOneWithoutBuildInput
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    touch?: TouchCreateNestedManyWithoutBuildInput
    userBuild?: UserBuildCreateNestedManyWithoutBuildInput
  }

  export type BuildUncheckedCreateWithoutRecipeBookBuildInput = {
    id?: number
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    recipeId?: number | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutBuildInput
    userBuild?: UserBuildUncheckedCreateNestedManyWithoutBuildInput
  }

  export type BuildCreateOrConnectWithoutRecipeBookBuildInput = {
    where: BuildWhereUniqueInput
    create: XOR<BuildCreateWithoutRecipeBookBuildInput, BuildUncheckedCreateWithoutRecipeBookBuildInput>
  }

  export type RecipeBookUpsertWithoutRecipeBookBuildInput = {
    update: XOR<RecipeBookUpdateWithoutRecipeBookBuildInput, RecipeBookUncheckedUpdateWithoutRecipeBookBuildInput>
    create: XOR<RecipeBookCreateWithoutRecipeBookBuildInput, RecipeBookUncheckedCreateWithoutRecipeBookBuildInput>
  }

  export type RecipeBookUpdateWithoutRecipeBookBuildInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutRecipeBookNestedInput
    editedBy?: UserUpdateOneWithoutRecipeBookEditedByIdNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutRecipeBookNestedInput
  }

  export type RecipeBookUncheckedUpdateWithoutRecipeBookBuildInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutRecipeBookNestedInput
  }

  export type BuildUpsertWithoutRecipeBookBuildInput = {
    update: XOR<BuildUpdateWithoutRecipeBookBuildInput, BuildUncheckedUpdateWithoutRecipeBookBuildInput>
    create: XOR<BuildCreateWithoutRecipeBookBuildInput, BuildUncheckedCreateWithoutRecipeBookBuildInput>
  }

  export type BuildUpdateWithoutRecipeBookBuildInput = {
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutBuildNestedInput
    editedBy?: UserUpdateOneWithoutBuildEditedByNestedInput
    recipe?: RecipeUpdateOneWithoutBuildNestedInput
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUpdateManyWithoutBuildNestedInput
    userBuild?: UserBuildUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateWithoutRecipeBookBuildInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutBuildNestedInput
    userBuild?: UserBuildUncheckedUpdateManyWithoutBuildNestedInput
  }

  export type IngredientCreateWithoutTouchInput = {
    dateCreated?: Date | string
    createdBy?: UserCreateNestedOneWithoutIngredientInput
    name?: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    ingredientStorage?: ingredientStorageCreateNestedManyWithoutIngredientInput
  }

  export type IngredientUncheckedCreateWithoutTouchInput = {
    id?: number
    dateCreated?: Date | string
    createdById?: string | null
    name?: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    ingredientStorage?: ingredientStorageUncheckedCreateNestedManyWithoutIngredientInput
  }

  export type IngredientCreateOrConnectWithoutTouchInput = {
    where: IngredientWhereUniqueInput
    create: XOR<IngredientCreateWithoutTouchInput, IngredientUncheckedCreateWithoutTouchInput>
  }

  export type BuildCreateWithoutTouchInput = {
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutBuildInput
    editedBy?: UserCreateNestedOneWithoutBuildEditedByInput
    recipe?: RecipeCreateNestedOneWithoutBuildInput
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    RecipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutBuildInput
    userBuild?: UserBuildCreateNestedManyWithoutBuildInput
  }

  export type BuildUncheckedCreateWithoutTouchInput = {
    id?: number
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    recipeId?: number | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    RecipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutBuildInput
    userBuild?: UserBuildUncheckedCreateNestedManyWithoutBuildInput
  }

  export type BuildCreateOrConnectWithoutTouchInput = {
    where: BuildWhereUniqueInput
    create: XOR<BuildCreateWithoutTouchInput, BuildUncheckedCreateWithoutTouchInput>
  }

  export type IngredientUpsertWithoutTouchInput = {
    update: XOR<IngredientUpdateWithoutTouchInput, IngredientUncheckedUpdateWithoutTouchInput>
    create: XOR<IngredientCreateWithoutTouchInput, IngredientUncheckedCreateWithoutTouchInput>
  }

  export type IngredientUpdateWithoutTouchInput = {
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutIngredientNestedInput
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientStorage?: ingredientStorageUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientUncheckedUpdateWithoutTouchInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientStorage?: ingredientStorageUncheckedUpdateManyWithoutIngredientNestedInput
  }

  export type BuildUpsertWithoutTouchInput = {
    update: XOR<BuildUpdateWithoutTouchInput, BuildUncheckedUpdateWithoutTouchInput>
    create: XOR<BuildCreateWithoutTouchInput, BuildUncheckedCreateWithoutTouchInput>
  }

  export type BuildUpdateWithoutTouchInput = {
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutBuildNestedInput
    editedBy?: UserUpdateOneWithoutBuildEditedByNestedInput
    recipe?: RecipeUpdateOneWithoutBuildNestedInput
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    RecipeBookBuild?: RecipeBookBuildUpdateManyWithoutBuildNestedInput
    userBuild?: UserBuildUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateWithoutTouchInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    RecipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutBuildNestedInput
    userBuild?: UserBuildUncheckedUpdateManyWithoutBuildNestedInput
  }

  export type UserCreateWithoutIngredientInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    userBuild?: UserBuildCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    userStorage?: UserStorageCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
  }

  export type UserUncheckedCreateWithoutIngredientInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    userBuild?: UserBuildUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    userStorage?: UserStorageUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
  }

  export type UserCreateOrConnectWithoutIngredientInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIngredientInput, UserUncheckedCreateWithoutIngredientInput>
  }

  export type TouchCreateWithoutIngredientInput = {
    ingredientName?: string
    build?: BuildCreateNestedOneWithoutTouchInput
    order?: number | null
    amount?: number | null
    unit?: string | null
  }

  export type TouchUncheckedCreateWithoutIngredientInput = {
    id?: number
    ingredientName?: string
    buildId?: number | null
    order?: number | null
    amount?: number | null
    unit?: string | null
  }

  export type TouchCreateOrConnectWithoutIngredientInput = {
    where: TouchWhereUniqueInput
    create: XOR<TouchCreateWithoutIngredientInput, TouchUncheckedCreateWithoutIngredientInput>
  }

  export type TouchCreateManyIngredientInputEnvelope = {
    data: Enumerable<TouchCreateManyIngredientInput>
    skipDuplicates?: boolean
  }

  export type ingredientStorageCreateWithoutIngredientInput = {
    createdAt?: Date | string
    editedAt?: Date | string
    quantity?: number | null
    Storage?: StorageCreateNestedOneWithoutIngredientStorageInput
  }

  export type ingredientStorageUncheckedCreateWithoutIngredientInput = {
    id?: number
    createdAt?: Date | string
    editedAt?: Date | string
    quantity?: number | null
    storageId?: number | null
  }

  export type ingredientStorageCreateOrConnectWithoutIngredientInput = {
    where: ingredientStorageWhereUniqueInput
    create: XOR<ingredientStorageCreateWithoutIngredientInput, ingredientStorageUncheckedCreateWithoutIngredientInput>
  }

  export type ingredientStorageCreateManyIngredientInputEnvelope = {
    data: Enumerable<ingredientStorageCreateManyIngredientInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutIngredientInput = {
    update: XOR<UserUpdateWithoutIngredientInput, UserUncheckedUpdateWithoutIngredientInput>
    create: XOR<UserCreateWithoutIngredientInput, UserUncheckedCreateWithoutIngredientInput>
  }

  export type UserUpdateWithoutIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    userBuild?: UserBuildUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    userStorage?: UserStorageUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
  }

  export type UserUncheckedUpdateWithoutIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    userBuild?: UserBuildUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    userStorage?: UserStorageUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
  }

  export type TouchUpsertWithWhereUniqueWithoutIngredientInput = {
    where: TouchWhereUniqueInput
    update: XOR<TouchUpdateWithoutIngredientInput, TouchUncheckedUpdateWithoutIngredientInput>
    create: XOR<TouchCreateWithoutIngredientInput, TouchUncheckedCreateWithoutIngredientInput>
  }

  export type TouchUpdateWithWhereUniqueWithoutIngredientInput = {
    where: TouchWhereUniqueInput
    data: XOR<TouchUpdateWithoutIngredientInput, TouchUncheckedUpdateWithoutIngredientInput>
  }

  export type TouchUpdateManyWithWhereWithoutIngredientInput = {
    where: TouchScalarWhereInput
    data: XOR<TouchUpdateManyMutationInput, TouchUncheckedUpdateManyWithoutTouchInput>
  }

  export type ingredientStorageUpsertWithWhereUniqueWithoutIngredientInput = {
    where: ingredientStorageWhereUniqueInput
    update: XOR<ingredientStorageUpdateWithoutIngredientInput, ingredientStorageUncheckedUpdateWithoutIngredientInput>
    create: XOR<ingredientStorageCreateWithoutIngredientInput, ingredientStorageUncheckedCreateWithoutIngredientInput>
  }

  export type ingredientStorageUpdateWithWhereUniqueWithoutIngredientInput = {
    where: ingredientStorageWhereUniqueInput
    data: XOR<ingredientStorageUpdateWithoutIngredientInput, ingredientStorageUncheckedUpdateWithoutIngredientInput>
  }

  export type ingredientStorageUpdateManyWithWhereWithoutIngredientInput = {
    where: ingredientStorageScalarWhereInput
    data: XOR<ingredientStorageUpdateManyMutationInput, ingredientStorageUncheckedUpdateManyWithoutIngredientStorageInput>
  }

  export type ingredientStorageScalarWhereInput = {
    AND?: Enumerable<ingredientStorageScalarWhereInput>
    OR?: Enumerable<ingredientStorageScalarWhereInput>
    NOT?: Enumerable<ingredientStorageScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    editedAt?: DateTimeFilter | Date | string
    ingredientId?: IntNullableFilter | number | null
    quantity?: FloatNullableFilter | number | null
    storageId?: IntNullableFilter | number | null
  }

  export type UserCreateWithoutInventoryCreatedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    userBuild?: UserBuildCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    userStorage?: UserStorageCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
  }

  export type UserUncheckedCreateWithoutInventoryCreatedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    userBuild?: UserBuildUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    userStorage?: UserStorageUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
  }

  export type UserCreateOrConnectWithoutInventoryCreatedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInventoryCreatedByInput, UserUncheckedCreateWithoutInventoryCreatedByInput>
  }

  export type UserCreateWithoutInventoryEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    userBuild?: UserBuildCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    userStorage?: UserStorageCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutInventoryEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    userBuild?: UserBuildUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    userStorage?: UserStorageUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutInventoryEditedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInventoryEditedByInput, UserUncheckedCreateWithoutInventoryEditedByInput>
  }

  export type InventoryStorageCreateWithoutInventoryInput = {
    storage: StorageCreateNestedOneWithoutInventoryStorageInput
  }

  export type InventoryStorageUncheckedCreateWithoutInventoryInput = {
    id?: number
    storageId: number
  }

  export type InventoryStorageCreateOrConnectWithoutInventoryInput = {
    where: InventoryStorageWhereUniqueInput
    create: XOR<InventoryStorageCreateWithoutInventoryInput, InventoryStorageUncheckedCreateWithoutInventoryInput>
  }

  export type InventoryStorageCreateManyInventoryInputEnvelope = {
    data: Enumerable<InventoryStorageCreateManyInventoryInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutInventoryCreatedByInput = {
    update: XOR<UserUpdateWithoutInventoryCreatedByInput, UserUncheckedUpdateWithoutInventoryCreatedByInput>
    create: XOR<UserCreateWithoutInventoryCreatedByInput, UserUncheckedCreateWithoutInventoryCreatedByInput>
  }

  export type UserUpdateWithoutInventoryCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    userBuild?: UserBuildUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    userStorage?: UserStorageUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
  }

  export type UserUncheckedUpdateWithoutInventoryCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    userBuild?: UserBuildUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    userStorage?: UserStorageUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
  }

  export type UserUpsertWithoutInventoryEditedByInput = {
    update: XOR<UserUpdateWithoutInventoryEditedByInput, UserUncheckedUpdateWithoutInventoryEditedByInput>
    create: XOR<UserCreateWithoutInventoryEditedByInput, UserUncheckedCreateWithoutInventoryEditedByInput>
  }

  export type UserUpdateWithoutInventoryEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    userBuild?: UserBuildUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    userStorage?: UserStorageUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutInventoryEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    userBuild?: UserBuildUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    userStorage?: UserStorageUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type InventoryStorageUpsertWithWhereUniqueWithoutInventoryInput = {
    where: InventoryStorageWhereUniqueInput
    update: XOR<InventoryStorageUpdateWithoutInventoryInput, InventoryStorageUncheckedUpdateWithoutInventoryInput>
    create: XOR<InventoryStorageCreateWithoutInventoryInput, InventoryStorageUncheckedCreateWithoutInventoryInput>
  }

  export type InventoryStorageUpdateWithWhereUniqueWithoutInventoryInput = {
    where: InventoryStorageWhereUniqueInput
    data: XOR<InventoryStorageUpdateWithoutInventoryInput, InventoryStorageUncheckedUpdateWithoutInventoryInput>
  }

  export type InventoryStorageUpdateManyWithWhereWithoutInventoryInput = {
    where: InventoryStorageScalarWhereInput
    data: XOR<InventoryStorageUpdateManyMutationInput, InventoryStorageUncheckedUpdateManyWithoutInventoryStorageInput>
  }

  export type InventoryStorageScalarWhereInput = {
    AND?: Enumerable<InventoryStorageScalarWhereInput>
    OR?: Enumerable<InventoryStorageScalarWhereInput>
    NOT?: Enumerable<InventoryStorageScalarWhereInput>
    id?: IntFilter | number
    inventoryId?: IntFilter | number
    storageId?: IntFilter | number
  }

  export type StorageCreateWithoutInventoryStorageInput = {
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutStorageInput
    editedBy?: UserCreateNestedOneWithoutStorageEditedByInput
    ingredientStorage?: ingredientStorageCreateNestedManyWithoutStorageInput
    userStorage?: UserStorageCreateNestedManyWithoutStorageInput
  }

  export type StorageUncheckedCreateWithoutInventoryStorageInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    ingredientStorage?: ingredientStorageUncheckedCreateNestedManyWithoutStorageInput
    userStorage?: UserStorageUncheckedCreateNestedManyWithoutStorageInput
  }

  export type StorageCreateOrConnectWithoutInventoryStorageInput = {
    where: StorageWhereUniqueInput
    create: XOR<StorageCreateWithoutInventoryStorageInput, StorageUncheckedCreateWithoutInventoryStorageInput>
  }

  export type InventoryCreateWithoutInventoryStorageInput = {
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutInventoryCreatedByInput
    editedBy?: UserCreateNestedOneWithoutInventoryEditedByInput
  }

  export type InventoryUncheckedCreateWithoutInventoryStorageInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
  }

  export type InventoryCreateOrConnectWithoutInventoryStorageInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutInventoryStorageInput, InventoryUncheckedCreateWithoutInventoryStorageInput>
  }

  export type StorageUpsertWithoutInventoryStorageInput = {
    update: XOR<StorageUpdateWithoutInventoryStorageInput, StorageUncheckedUpdateWithoutInventoryStorageInput>
    create: XOR<StorageCreateWithoutInventoryStorageInput, StorageUncheckedCreateWithoutInventoryStorageInput>
  }

  export type StorageUpdateWithoutInventoryStorageInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutStorageNestedInput
    editedBy?: UserUpdateOneWithoutStorageEditedByNestedInput
    ingredientStorage?: ingredientStorageUpdateManyWithoutStorageNestedInput
    userStorage?: UserStorageUpdateManyWithoutStorageNestedInput
  }

  export type StorageUncheckedUpdateWithoutInventoryStorageInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    ingredientStorage?: ingredientStorageUncheckedUpdateManyWithoutStorageNestedInput
    userStorage?: UserStorageUncheckedUpdateManyWithoutStorageNestedInput
  }

  export type InventoryUpsertWithoutInventoryStorageInput = {
    update: XOR<InventoryUpdateWithoutInventoryStorageInput, InventoryUncheckedUpdateWithoutInventoryStorageInput>
    create: XOR<InventoryCreateWithoutInventoryStorageInput, InventoryUncheckedCreateWithoutInventoryStorageInput>
  }

  export type InventoryUpdateWithoutInventoryStorageInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutInventoryCreatedByNestedInput
    editedBy?: UserUpdateOneWithoutInventoryEditedByNestedInput
  }

  export type InventoryUncheckedUpdateWithoutInventoryStorageInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateWithoutStorageInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    userBuild?: UserBuildCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    userStorage?: UserStorageCreateNestedManyWithoutUserInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
  }

  export type UserUncheckedCreateWithoutStorageInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    userBuild?: UserBuildUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    userStorage?: UserStorageUncheckedCreateNestedManyWithoutUserInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
  }

  export type UserCreateOrConnectWithoutStorageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStorageInput, UserUncheckedCreateWithoutStorageInput>
  }

  export type UserCreateWithoutStorageEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    userBuild?: UserBuildCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    userStorage?: UserStorageCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
  }

  export type UserUncheckedCreateWithoutStorageEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    userBuild?: UserBuildUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    userStorage?: UserStorageUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
  }

  export type UserCreateOrConnectWithoutStorageEditedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStorageEditedByInput, UserUncheckedCreateWithoutStorageEditedByInput>
  }

  export type InventoryStorageCreateWithoutStorageInput = {
    inventory: InventoryCreateNestedOneWithoutInventoryStorageInput
  }

  export type InventoryStorageUncheckedCreateWithoutStorageInput = {
    id?: number
    inventoryId: number
  }

  export type InventoryStorageCreateOrConnectWithoutStorageInput = {
    where: InventoryStorageWhereUniqueInput
    create: XOR<InventoryStorageCreateWithoutStorageInput, InventoryStorageUncheckedCreateWithoutStorageInput>
  }

  export type InventoryStorageCreateManyStorageInputEnvelope = {
    data: Enumerable<InventoryStorageCreateManyStorageInput>
    skipDuplicates?: boolean
  }

  export type ingredientStorageCreateWithoutStorageInput = {
    createdAt?: Date | string
    editedAt?: Date | string
    ingredient?: IngredientCreateNestedOneWithoutIngredientStorageInput
    quantity?: number | null
  }

  export type ingredientStorageUncheckedCreateWithoutStorageInput = {
    id?: number
    createdAt?: Date | string
    editedAt?: Date | string
    ingredientId?: number | null
    quantity?: number | null
  }

  export type ingredientStorageCreateOrConnectWithoutStorageInput = {
    where: ingredientStorageWhereUniqueInput
    create: XOR<ingredientStorageCreateWithoutStorageInput, ingredientStorageUncheckedCreateWithoutStorageInput>
  }

  export type ingredientStorageCreateManyStorageInputEnvelope = {
    data: Enumerable<ingredientStorageCreateManyStorageInput>
    skipDuplicates?: boolean
  }

  export type UserStorageCreateWithoutStorageInput = {
    createdAt?: Date | string
    editedAt?: Date | string
    user?: UserCreateNestedOneWithoutUserStorageInput
    quantity?: number | null
    partner: boolean
    manager: boolean
  }

  export type UserStorageUncheckedCreateWithoutStorageInput = {
    id?: number
    createdAt?: Date | string
    editedAt?: Date | string
    userId: string
    quantity?: number | null
    partner: boolean
    manager: boolean
  }

  export type UserStorageCreateOrConnectWithoutStorageInput = {
    where: UserStorageWhereUniqueInput
    create: XOR<UserStorageCreateWithoutStorageInput, UserStorageUncheckedCreateWithoutStorageInput>
  }

  export type UserStorageCreateManyStorageInputEnvelope = {
    data: Enumerable<UserStorageCreateManyStorageInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutStorageInput = {
    update: XOR<UserUpdateWithoutStorageInput, UserUncheckedUpdateWithoutStorageInput>
    create: XOR<UserCreateWithoutStorageInput, UserUncheckedCreateWithoutStorageInput>
  }

  export type UserUpdateWithoutStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    userBuild?: UserBuildUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    userStorage?: UserStorageUpdateManyWithoutUserNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
  }

  export type UserUncheckedUpdateWithoutStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    userBuild?: UserBuildUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    userStorage?: UserStorageUncheckedUpdateManyWithoutUserNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
  }

  export type UserUpsertWithoutStorageEditedByInput = {
    update: XOR<UserUpdateWithoutStorageEditedByInput, UserUncheckedUpdateWithoutStorageEditedByInput>
    create: XOR<UserCreateWithoutStorageEditedByInput, UserUncheckedCreateWithoutStorageEditedByInput>
  }

  export type UserUpdateWithoutStorageEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    userBuild?: UserBuildUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    userStorage?: UserStorageUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
  }

  export type UserUncheckedUpdateWithoutStorageEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    userBuild?: UserBuildUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    userStorage?: UserStorageUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
  }

  export type InventoryStorageUpsertWithWhereUniqueWithoutStorageInput = {
    where: InventoryStorageWhereUniqueInput
    update: XOR<InventoryStorageUpdateWithoutStorageInput, InventoryStorageUncheckedUpdateWithoutStorageInput>
    create: XOR<InventoryStorageCreateWithoutStorageInput, InventoryStorageUncheckedCreateWithoutStorageInput>
  }

  export type InventoryStorageUpdateWithWhereUniqueWithoutStorageInput = {
    where: InventoryStorageWhereUniqueInput
    data: XOR<InventoryStorageUpdateWithoutStorageInput, InventoryStorageUncheckedUpdateWithoutStorageInput>
  }

  export type InventoryStorageUpdateManyWithWhereWithoutStorageInput = {
    where: InventoryStorageScalarWhereInput
    data: XOR<InventoryStorageUpdateManyMutationInput, InventoryStorageUncheckedUpdateManyWithoutInventoryStorageInput>
  }

  export type ingredientStorageUpsertWithWhereUniqueWithoutStorageInput = {
    where: ingredientStorageWhereUniqueInput
    update: XOR<ingredientStorageUpdateWithoutStorageInput, ingredientStorageUncheckedUpdateWithoutStorageInput>
    create: XOR<ingredientStorageCreateWithoutStorageInput, ingredientStorageUncheckedCreateWithoutStorageInput>
  }

  export type ingredientStorageUpdateWithWhereUniqueWithoutStorageInput = {
    where: ingredientStorageWhereUniqueInput
    data: XOR<ingredientStorageUpdateWithoutStorageInput, ingredientStorageUncheckedUpdateWithoutStorageInput>
  }

  export type ingredientStorageUpdateManyWithWhereWithoutStorageInput = {
    where: ingredientStorageScalarWhereInput
    data: XOR<ingredientStorageUpdateManyMutationInput, ingredientStorageUncheckedUpdateManyWithoutIngredientStorageInput>
  }

  export type UserStorageUpsertWithWhereUniqueWithoutStorageInput = {
    where: UserStorageWhereUniqueInput
    update: XOR<UserStorageUpdateWithoutStorageInput, UserStorageUncheckedUpdateWithoutStorageInput>
    create: XOR<UserStorageCreateWithoutStorageInput, UserStorageUncheckedCreateWithoutStorageInput>
  }

  export type UserStorageUpdateWithWhereUniqueWithoutStorageInput = {
    where: UserStorageWhereUniqueInput
    data: XOR<UserStorageUpdateWithoutStorageInput, UserStorageUncheckedUpdateWithoutStorageInput>
  }

  export type UserStorageUpdateManyWithWhereWithoutStorageInput = {
    where: UserStorageScalarWhereInput
    data: XOR<UserStorageUpdateManyMutationInput, UserStorageUncheckedUpdateManyWithoutUserStorageInput>
  }

  export type IngredientCreateWithoutIngredientStorageInput = {
    dateCreated?: Date | string
    createdBy?: UserCreateNestedOneWithoutIngredientInput
    name?: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    touch?: TouchCreateNestedManyWithoutIngredientInput
  }

  export type IngredientUncheckedCreateWithoutIngredientStorageInput = {
    id?: number
    dateCreated?: Date | string
    createdById?: string | null
    name?: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutIngredientInput
  }

  export type IngredientCreateOrConnectWithoutIngredientStorageInput = {
    where: IngredientWhereUniqueInput
    create: XOR<IngredientCreateWithoutIngredientStorageInput, IngredientUncheckedCreateWithoutIngredientStorageInput>
  }

  export type StorageCreateWithoutIngredientStorageInput = {
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutStorageInput
    editedBy?: UserCreateNestedOneWithoutStorageEditedByInput
    inventoryStorage?: InventoryStorageCreateNestedManyWithoutStorageInput
    userStorage?: UserStorageCreateNestedManyWithoutStorageInput
  }

  export type StorageUncheckedCreateWithoutIngredientStorageInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    inventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutStorageInput
    userStorage?: UserStorageUncheckedCreateNestedManyWithoutStorageInput
  }

  export type StorageCreateOrConnectWithoutIngredientStorageInput = {
    where: StorageWhereUniqueInput
    create: XOR<StorageCreateWithoutIngredientStorageInput, StorageUncheckedCreateWithoutIngredientStorageInput>
  }

  export type IngredientUpsertWithoutIngredientStorageInput = {
    update: XOR<IngredientUpdateWithoutIngredientStorageInput, IngredientUncheckedUpdateWithoutIngredientStorageInput>
    create: XOR<IngredientCreateWithoutIngredientStorageInput, IngredientUncheckedCreateWithoutIngredientStorageInput>
  }

  export type IngredientUpdateWithoutIngredientStorageInput = {
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutIngredientNestedInput
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientUncheckedUpdateWithoutIngredientStorageInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutIngredientNestedInput
  }

  export type StorageUpsertWithoutIngredientStorageInput = {
    update: XOR<StorageUpdateWithoutIngredientStorageInput, StorageUncheckedUpdateWithoutIngredientStorageInput>
    create: XOR<StorageCreateWithoutIngredientStorageInput, StorageUncheckedCreateWithoutIngredientStorageInput>
  }

  export type StorageUpdateWithoutIngredientStorageInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutStorageNestedInput
    editedBy?: UserUpdateOneWithoutStorageEditedByNestedInput
    inventoryStorage?: InventoryStorageUpdateManyWithoutStorageNestedInput
    userStorage?: UserStorageUpdateManyWithoutStorageNestedInput
  }

  export type StorageUncheckedUpdateWithoutIngredientStorageInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    inventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutStorageNestedInput
    userStorage?: UserStorageUncheckedUpdateManyWithoutStorageNestedInput
  }

  export type UserCreateWithoutUserStorageInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    userBuild?: UserBuildCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
  }

  export type UserUncheckedCreateWithoutUserStorageInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    userBuild?: UserBuildUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
  }

  export type UserCreateOrConnectWithoutUserStorageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserStorageInput, UserUncheckedCreateWithoutUserStorageInput>
  }

  export type StorageCreateWithoutUserStorageInput = {
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutStorageInput
    editedBy?: UserCreateNestedOneWithoutStorageEditedByInput
    inventoryStorage?: InventoryStorageCreateNestedManyWithoutStorageInput
    ingredientStorage?: ingredientStorageCreateNestedManyWithoutStorageInput
  }

  export type StorageUncheckedCreateWithoutUserStorageInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    inventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutStorageInput
    ingredientStorage?: ingredientStorageUncheckedCreateNestedManyWithoutStorageInput
  }

  export type StorageCreateOrConnectWithoutUserStorageInput = {
    where: StorageWhereUniqueInput
    create: XOR<StorageCreateWithoutUserStorageInput, StorageUncheckedCreateWithoutUserStorageInput>
  }

  export type UserUpsertWithoutUserStorageInput = {
    update: XOR<UserUpdateWithoutUserStorageInput, UserUncheckedUpdateWithoutUserStorageInput>
    create: XOR<UserCreateWithoutUserStorageInput, UserUncheckedCreateWithoutUserStorageInput>
  }

  export type UserUpdateWithoutUserStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    userBuild?: UserBuildUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUserStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    userBuild?: UserBuildUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
  }

  export type StorageUpsertWithoutUserStorageInput = {
    update: XOR<StorageUpdateWithoutUserStorageInput, StorageUncheckedUpdateWithoutUserStorageInput>
    create: XOR<StorageCreateWithoutUserStorageInput, StorageUncheckedCreateWithoutUserStorageInput>
  }

  export type StorageUpdateWithoutUserStorageInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutStorageNestedInput
    editedBy?: UserUpdateOneWithoutStorageEditedByNestedInput
    inventoryStorage?: InventoryStorageUpdateManyWithoutStorageNestedInput
    ingredientStorage?: ingredientStorageUpdateManyWithoutStorageNestedInput
  }

  export type StorageUncheckedUpdateWithoutUserStorageInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    inventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutStorageNestedInput
    ingredientStorage?: ingredientStorageUncheckedUpdateManyWithoutStorageNestedInput
  }

  export type UserCreateWithoutCrewInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    userBuild?: UserBuildCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    userStorage?: UserStorageCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
  }

  export type UserUncheckedCreateWithoutCrewInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    userBuild?: UserBuildUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    userStorage?: UserStorageUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
  }

  export type UserCreateOrConnectWithoutCrewInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCrewInput, UserUncheckedCreateWithoutCrewInput>
  }

  export type UserCreateWithoutCrewEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    userBuild?: UserBuildCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    userStorage?: UserStorageCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
  }

  export type UserUncheckedCreateWithoutCrewEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    userCrew?: UserCrewUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    userBuild?: UserBuildUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    userStorage?: UserStorageUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
  }

  export type UserCreateOrConnectWithoutCrewEditedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCrewEditedByInput, UserUncheckedCreateWithoutCrewEditedByInput>
  }

  export type UserCrewCreateWithoutCrewInput = {
    user: UserCreateNestedOneWithoutUserCrewInput
    partner: boolean
    manager: boolean
  }

  export type UserCrewUncheckedCreateWithoutCrewInput = {
    id?: number
    userId: string
    partner: boolean
    manager: boolean
  }

  export type UserCrewCreateOrConnectWithoutCrewInput = {
    where: UserCrewWhereUniqueInput
    create: XOR<UserCrewCreateWithoutCrewInput, UserCrewUncheckedCreateWithoutCrewInput>
  }

  export type UserCrewCreateManyCrewInputEnvelope = {
    data: Enumerable<UserCrewCreateManyCrewInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCrewInput = {
    update: XOR<UserUpdateWithoutCrewInput, UserUncheckedUpdateWithoutCrewInput>
    create: XOR<UserCreateWithoutCrewInput, UserUncheckedCreateWithoutCrewInput>
  }

  export type UserUpdateWithoutCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    userBuild?: UserBuildUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    userStorage?: UserStorageUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    userBuild?: UserBuildUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    userStorage?: UserStorageUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
  }

  export type UserUpsertWithoutCrewEditedByInput = {
    update: XOR<UserUpdateWithoutCrewEditedByInput, UserUncheckedUpdateWithoutCrewEditedByInput>
    create: XOR<UserCreateWithoutCrewEditedByInput, UserUncheckedCreateWithoutCrewEditedByInput>
  }

  export type UserUpdateWithoutCrewEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    userBuild?: UserBuildUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    userStorage?: UserStorageUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCrewEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    userCrew?: UserCrewUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    userBuild?: UserBuildUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    userStorage?: UserStorageUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
  }

  export type UserCrewUpsertWithWhereUniqueWithoutCrewInput = {
    where: UserCrewWhereUniqueInput
    update: XOR<UserCrewUpdateWithoutCrewInput, UserCrewUncheckedUpdateWithoutCrewInput>
    create: XOR<UserCrewCreateWithoutCrewInput, UserCrewUncheckedCreateWithoutCrewInput>
  }

  export type UserCrewUpdateWithWhereUniqueWithoutCrewInput = {
    where: UserCrewWhereUniqueInput
    data: XOR<UserCrewUpdateWithoutCrewInput, UserCrewUncheckedUpdateWithoutCrewInput>
  }

  export type UserCrewUpdateManyWithWhereWithoutCrewInput = {
    where: UserCrewScalarWhereInput
    data: XOR<UserCrewUpdateManyMutationInput, UserCrewUncheckedUpdateManyWithoutUserCrewInput>
  }

  export type UserCreateWithoutUserCrewInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookCreateNestedManyWithoutEditedByInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    userBuild?: UserBuildCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    userStorage?: UserStorageCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
  }

  export type UserUncheckedCreateWithoutUserCrewInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedById?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    userBuild?: UserBuildUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    userStorage?: UserStorageUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryCreatedBy?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
  }

  export type UserCreateOrConnectWithoutUserCrewInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserCrewInput, UserUncheckedCreateWithoutUserCrewInput>
  }

  export type CrewCreateWithoutUserCrewInput = {
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCrewInput
    editedBy?: UserCreateNestedOneWithoutCrewEditedByInput
  }

  export type CrewUncheckedCreateWithoutUserCrewInput = {
    id?: number
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
  }

  export type CrewCreateOrConnectWithoutUserCrewInput = {
    where: CrewWhereUniqueInput
    create: XOR<CrewCreateWithoutUserCrewInput, CrewUncheckedCreateWithoutUserCrewInput>
  }

  export type UserUpsertWithoutUserCrewInput = {
    update: XOR<UserUpdateWithoutUserCrewInput, UserUncheckedUpdateWithoutUserCrewInput>
    create: XOR<UserCreateWithoutUserCrewInput, UserUncheckedCreateWithoutUserCrewInput>
  }

  export type UserUpdateWithoutUserCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUpdateManyWithoutEditedByNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    userBuild?: UserBuildUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    userStorage?: UserStorageUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUserCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedById?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    userBuild?: UserBuildUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    userStorage?: UserStorageUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryCreatedBy?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
  }

  export type CrewUpsertWithoutUserCrewInput = {
    update: XOR<CrewUpdateWithoutUserCrewInput, CrewUncheckedUpdateWithoutUserCrewInput>
    create: XOR<CrewCreateWithoutUserCrewInput, CrewUncheckedCreateWithoutUserCrewInput>
  }

  export type CrewUpdateWithoutUserCrewInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCrewNestedInput
    editedBy?: UserUpdateOneWithoutCrewEditedByNestedInput
  }

  export type CrewUncheckedUpdateWithoutUserCrewInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookUserCreateManyUserInput = {
    id?: number
    recipeBookId: number
    partner: boolean
    manager: boolean
  }

  export type RecipeBookCreateManyCreatedByInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedById?: string | null
  }

  export type RecipeBookCreateManyEditedByInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
  }

  export type UserCrewCreateManyUserInput = {
    id?: number
    crewId: number
    partner: boolean
    manager: boolean
  }

  export type CrewCreateManyCreatedByInput = {
    id?: number
    createdAt?: Date | string
    editedAt?: Date | string
    editedById: string
  }

  export type CrewCreateManyEditedByInput = {
    id?: number
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
  }

  export type UserBuildCreateManyUserInput = {
    id?: number
    buildId: number
    partner: boolean
    manager: boolean
  }

  export type BuildCreateManyCreatedByInput = {
    id?: number
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedById: string
    recipeId?: number | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
  }

  export type BuildCreateManyEditedByInput = {
    id?: number
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    recipeId?: number | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
  }

  export type RecipeCreateManyCreatedByInput = {
    id?: number
    createdAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
  }

  export type IngredientCreateManyCreatedByInput = {
    id?: number
    dateCreated?: Date | string
    name?: string
    price?: number | null
    amount?: number | null
    unit?: string | null
  }

  export type UserStorageCreateManyUserInput = {
    id?: number
    createdAt?: Date | string
    editedAt?: Date | string
    quantity?: number | null
    storageId?: number | null
    partner: boolean
    manager: boolean
  }

  export type StorageCreateManyCreatedByInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedById: string
  }

  export type StorageCreateManyEditedByInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
  }

  export type InventoryCreateManyCreatedByInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedById: string
  }

  export type InventoryCreateManyEditedByInput = {
    id?: number
    name: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
  }

  export type RecipeBookUserUpdateWithoutUserInput = {
    recipeBook?: RecipeBookUpdateOneRequiredWithoutRecipeBookUserNestedInput
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RecipeBookUserUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    recipeBookId?: IntFieldUpdateOperationsInput | number
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RecipeBookUserUncheckedUpdateManyWithoutRecipeBookUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    recipeBookId?: IntFieldUpdateOperationsInput | number
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RecipeBookUpdateWithoutCreatedByInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedBy?: UserUpdateOneWithoutRecipeBookEditedByIdNestedInput
    recipeBookBuild?: RecipeBookBuildUpdateManyWithoutRecipeBookNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutRecipeBookNestedInput
  }

  export type RecipeBookUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutRecipeBookNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutRecipeBookNestedInput
  }

  export type RecipeBookUncheckedUpdateManyWithoutRecipeBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeBookUpdateWithoutEditedByInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutRecipeBookNestedInput
    recipeBookBuild?: RecipeBookBuildUpdateManyWithoutRecipeBookNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutRecipeBookNestedInput
  }

  export type RecipeBookUncheckedUpdateWithoutEditedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutRecipeBookNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutRecipeBookNestedInput
  }

  export type RecipeBookUncheckedUpdateManyWithoutRecipeBookEditedByIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCrewUpdateWithoutUserInput = {
    crew?: CrewUpdateOneRequiredWithoutUserCrewNestedInput
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCrewUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    crewId?: IntFieldUpdateOperationsInput | number
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCrewUncheckedUpdateManyWithoutUserCrewInput = {
    id?: IntFieldUpdateOperationsInput | number
    crewId?: IntFieldUpdateOperationsInput | number
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CrewUpdateWithoutCreatedByInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedBy?: UserUpdateOneWithoutCrewEditedByNestedInput
    userCrew?: UserCrewUpdateManyWithoutCrewNestedInput
  }

  export type CrewUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: StringFieldUpdateOperationsInput | string
    userCrew?: UserCrewUncheckedUpdateManyWithoutCrewNestedInput
  }

  export type CrewUncheckedUpdateManyWithoutCrewInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: StringFieldUpdateOperationsInput | string
  }

  export type CrewUpdateWithoutEditedByInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCrewNestedInput
    userCrew?: UserCrewUpdateManyWithoutCrewNestedInput
  }

  export type CrewUncheckedUpdateWithoutEditedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    userCrew?: UserCrewUncheckedUpdateManyWithoutCrewNestedInput
  }

  export type CrewUncheckedUpdateManyWithoutCrewEditedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type UserBuildUpdateWithoutUserInput = {
    build?: BuildUpdateOneRequiredWithoutUserBuildNestedInput
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserBuildUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildId?: IntFieldUpdateOperationsInput | number
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserBuildUncheckedUpdateManyWithoutUserBuildInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildId?: IntFieldUpdateOperationsInput | number
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BuildUpdateWithoutCreatedByInput = {
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedBy?: UserUpdateOneWithoutBuildEditedByNestedInput
    recipe?: RecipeUpdateOneWithoutBuildNestedInput
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUpdateManyWithoutBuildNestedInput
    userBuild?: UserBuildUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: StringFieldUpdateOperationsInput | string
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutBuildNestedInput
    userBuild?: UserBuildUncheckedUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateManyWithoutBuildInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: StringFieldUpdateOperationsInput | string
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BuildUpdateWithoutEditedByInput = {
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutBuildNestedInput
    recipe?: RecipeUpdateOneWithoutBuildNestedInput
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUpdateManyWithoutBuildNestedInput
    userBuild?: UserBuildUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateWithoutEditedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutBuildNestedInput
    userBuild?: UserBuildUncheckedUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateManyWithoutBuildEditedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeUpdateWithoutCreatedByInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    build?: BuildUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    build?: BuildUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateManyWithoutRecipeInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IngredientUpdateWithoutCreatedByInput = {
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUpdateManyWithoutIngredientNestedInput
    ingredientStorage?: ingredientStorageUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientStorage?: ingredientStorageUncheckedUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientUncheckedUpdateManyWithoutIngredientInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserStorageUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    Storage?: StorageUpdateOneWithoutUserStorageNestedInput
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserStorageUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    storageId?: NullableIntFieldUpdateOperationsInput | number | null
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserStorageUncheckedUpdateManyWithoutUserStorageInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    storageId?: NullableIntFieldUpdateOperationsInput | number | null
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StorageUpdateWithoutCreatedByInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedBy?: UserUpdateOneWithoutStorageEditedByNestedInput
    inventoryStorage?: InventoryStorageUpdateManyWithoutStorageNestedInput
    ingredientStorage?: ingredientStorageUpdateManyWithoutStorageNestedInput
    userStorage?: UserStorageUpdateManyWithoutStorageNestedInput
  }

  export type StorageUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: StringFieldUpdateOperationsInput | string
    inventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutStorageNestedInput
    ingredientStorage?: ingredientStorageUncheckedUpdateManyWithoutStorageNestedInput
    userStorage?: UserStorageUncheckedUpdateManyWithoutStorageNestedInput
  }

  export type StorageUncheckedUpdateManyWithoutStorageInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: StringFieldUpdateOperationsInput | string
  }

  export type StorageUpdateWithoutEditedByInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutStorageNestedInput
    inventoryStorage?: InventoryStorageUpdateManyWithoutStorageNestedInput
    ingredientStorage?: ingredientStorageUpdateManyWithoutStorageNestedInput
    userStorage?: UserStorageUpdateManyWithoutStorageNestedInput
  }

  export type StorageUncheckedUpdateWithoutEditedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    inventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutStorageNestedInput
    ingredientStorage?: ingredientStorageUncheckedUpdateManyWithoutStorageNestedInput
    userStorage?: UserStorageUncheckedUpdateManyWithoutStorageNestedInput
  }

  export type StorageUncheckedUpdateManyWithoutStorageEditedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryUpdateWithoutCreatedByInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedBy?: UserUpdateOneWithoutInventoryEditedByNestedInput
    InventoryStorage?: InventoryStorageUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: StringFieldUpdateOperationsInput | string
    InventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateManyWithoutInventoryCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryUpdateWithoutEditedByInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutInventoryCreatedByNestedInput
    InventoryStorage?: InventoryStorageUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutEditedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    InventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateManyWithoutInventoryEditedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookBuildCreateManyRecipeBookInput = {
    id?: number
    buildId: number
  }

  export type RecipeBookUserCreateManyRecipeBookInput = {
    id?: number
    userId: string
    partner: boolean
    manager: boolean
  }

  export type RecipeBookBuildUpdateWithoutRecipeBookInput = {
    build?: BuildUpdateOneRequiredWithoutRecipeBookBuildNestedInput
  }

  export type RecipeBookBuildUncheckedUpdateWithoutRecipeBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildId?: IntFieldUpdateOperationsInput | number
  }

  export type RecipeBookBuildUncheckedUpdateManyWithoutRecipeBookBuildInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildId?: IntFieldUpdateOperationsInput | number
  }

  export type RecipeBookUserUpdateWithoutRecipeBookInput = {
    user?: UserUpdateOneRequiredWithoutRecipeBookUserNestedInput
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RecipeBookUserUncheckedUpdateWithoutRecipeBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TouchCreateManyBuildInput = {
    id?: number
    ingredientName?: string
    ingredientId?: number | null
    order?: number | null
    amount?: number | null
    unit?: string | null
  }

  export type RecipeBookBuildCreateManyBuildInput = {
    id?: number
    recipeBookId: number
  }

  export type UserBuildCreateManyBuildInput = {
    id?: number
    userId: string
    partner: boolean
    manager: boolean
  }

  export type TouchUpdateWithoutBuildInput = {
    ingredientName?: StringFieldUpdateOperationsInput | string
    ingredient?: IngredientUpdateOneWithoutTouchNestedInput
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TouchUncheckedUpdateWithoutBuildInput = {
    id?: IntFieldUpdateOperationsInput | number
    ingredientName?: StringFieldUpdateOperationsInput | string
    ingredientId?: NullableIntFieldUpdateOperationsInput | number | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TouchUncheckedUpdateManyWithoutTouchInput = {
    id?: IntFieldUpdateOperationsInput | number
    ingredientName?: StringFieldUpdateOperationsInput | string
    ingredientId?: NullableIntFieldUpdateOperationsInput | number | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeBookBuildUpdateWithoutBuildInput = {
    recipeBook?: RecipeBookUpdateOneRequiredWithoutRecipeBookBuildNestedInput
  }

  export type RecipeBookBuildUncheckedUpdateWithoutBuildInput = {
    id?: IntFieldUpdateOperationsInput | number
    recipeBookId?: IntFieldUpdateOperationsInput | number
  }

  export type UserBuildUpdateWithoutBuildInput = {
    user?: UserUpdateOneRequiredWithoutUserBuildNestedInput
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserBuildUncheckedUpdateWithoutBuildInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BuildCreateManyRecipeInput = {
    id?: number
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
  }

  export type BuildUpdateWithoutRecipeInput = {
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutBuildNestedInput
    editedBy?: UserUpdateOneWithoutBuildEditedByNestedInput
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUpdateManyWithoutBuildNestedInput
    userBuild?: UserBuildUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateWithoutRecipeInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutBuildNestedInput
    userBuild?: UserBuildUncheckedUpdateManyWithoutBuildNestedInput
  }

  export type TouchCreateManyIngredientInput = {
    id?: number
    ingredientName?: string
    buildId?: number | null
    order?: number | null
    amount?: number | null
    unit?: string | null
  }

  export type ingredientStorageCreateManyIngredientInput = {
    id?: number
    createdAt?: Date | string
    editedAt?: Date | string
    quantity?: number | null
    storageId?: number | null
  }

  export type TouchUpdateWithoutIngredientInput = {
    ingredientName?: StringFieldUpdateOperationsInput | string
    build?: BuildUpdateOneWithoutTouchNestedInput
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TouchUncheckedUpdateWithoutIngredientInput = {
    id?: IntFieldUpdateOperationsInput | number
    ingredientName?: StringFieldUpdateOperationsInput | string
    buildId?: NullableIntFieldUpdateOperationsInput | number | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ingredientStorageUpdateWithoutIngredientInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    Storage?: StorageUpdateOneWithoutIngredientStorageNestedInput
  }

  export type ingredientStorageUncheckedUpdateWithoutIngredientInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    storageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ingredientStorageUncheckedUpdateManyWithoutIngredientStorageInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    storageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InventoryStorageCreateManyInventoryInput = {
    id?: number
    storageId: number
  }

  export type InventoryStorageUpdateWithoutInventoryInput = {
    storage?: StorageUpdateOneRequiredWithoutInventoryStorageNestedInput
  }

  export type InventoryStorageUncheckedUpdateWithoutInventoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    storageId?: IntFieldUpdateOperationsInput | number
  }

  export type InventoryStorageUncheckedUpdateManyWithoutInventoryStorageInput = {
    id?: IntFieldUpdateOperationsInput | number
    storageId?: IntFieldUpdateOperationsInput | number
  }

  export type InventoryStorageCreateManyStorageInput = {
    id?: number
    inventoryId: number
  }

  export type ingredientStorageCreateManyStorageInput = {
    id?: number
    createdAt?: Date | string
    editedAt?: Date | string
    ingredientId?: number | null
    quantity?: number | null
  }

  export type UserStorageCreateManyStorageInput = {
    id?: number
    createdAt?: Date | string
    editedAt?: Date | string
    userId: string
    quantity?: number | null
    partner: boolean
    manager: boolean
  }

  export type InventoryStorageUpdateWithoutStorageInput = {
    inventory?: InventoryUpdateOneRequiredWithoutInventoryStorageNestedInput
  }

  export type InventoryStorageUncheckedUpdateWithoutStorageInput = {
    id?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
  }

  export type ingredientStorageUpdateWithoutStorageInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ingredient?: IngredientUpdateOneWithoutIngredientStorageNestedInput
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ingredientStorageUncheckedUpdateWithoutStorageInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ingredientId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type UserStorageUpdateWithoutStorageInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutUserStorageNestedInput
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserStorageUncheckedUpdateWithoutStorageInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCrewCreateManyCrewInput = {
    id?: number
    userId: string
    partner: boolean
    manager: boolean
  }

  export type UserCrewUpdateWithoutCrewInput = {
    user?: UserUpdateOneRequiredWithoutUserCrewNestedInput
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCrewUncheckedUpdateWithoutCrewInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    partner?: BoolFieldUpdateOperationsInput | boolean
    manager?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}