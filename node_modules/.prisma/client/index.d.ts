
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Follow
 * 
 */
export type Follow = $Result.DefaultSelection<Prisma.$FollowPayload>
/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model RecipeBook
 * 
 */
export type RecipeBook = $Result.DefaultSelection<Prisma.$RecipeBookPayload>
/**
 * Model RecipeBookUser
 * 
 */
export type RecipeBookUser = $Result.DefaultSelection<Prisma.$RecipeBookUserPayload>
/**
 * Model Build
 * 
 */
export type Build = $Result.DefaultSelection<Prisma.$BuildPayload>
/**
 * Model ArchivedBuild
 * 
 */
export type ArchivedBuild = $Result.DefaultSelection<Prisma.$ArchivedBuildPayload>
/**
 * Model BuildUser
 * 
 */
export type BuildUser = $Result.DefaultSelection<Prisma.$BuildUserPayload>
/**
 * Model Recipe
 * 
 */
export type Recipe = $Result.DefaultSelection<Prisma.$RecipePayload>
/**
 * Model RecipeBookBuild
 * 
 */
export type RecipeBookBuild = $Result.DefaultSelection<Prisma.$RecipeBookBuildPayload>
/**
 * Model Touch
 * 
 */
export type Touch = $Result.DefaultSelection<Prisma.$TouchPayload>
/**
 * Model ArchivedTouch
 * 
 */
export type ArchivedTouch = $Result.DefaultSelection<Prisma.$ArchivedTouchPayload>
/**
 * Model IngredientType
 * 
 */
export type IngredientType = $Result.DefaultSelection<Prisma.$IngredientTypePayload>
/**
 * Model Ingredient
 * 
 */
export type Ingredient = $Result.DefaultSelection<Prisma.$IngredientPayload>
/**
 * Model IngredientUser
 * 
 */
export type IngredientUser = $Result.DefaultSelection<Prisma.$IngredientUserPayload>
/**
 * Model IngredientPreference
 * 
 */
export type IngredientPreference = $Result.DefaultSelection<Prisma.$IngredientPreferencePayload>
/**
 * Model Inventory
 * 
 */
export type Inventory = $Result.DefaultSelection<Prisma.$InventoryPayload>
/**
 * Model InventoryUser
 * 
 */
export type InventoryUser = $Result.DefaultSelection<Prisma.$InventoryUserPayload>
/**
 * Model Storage
 * 
 */
export type Storage = $Result.DefaultSelection<Prisma.$StoragePayload>
/**
 * Model InventoryStorage
 * 
 */
export type InventoryStorage = $Result.DefaultSelection<Prisma.$InventoryStoragePayload>
/**
 * Model IngredientStorage
 * 
 */
export type IngredientStorage = $Result.DefaultSelection<Prisma.$IngredientStoragePayload>
/**
 * Model StorageUser
 * 
 */
export type StorageUser = $Result.DefaultSelection<Prisma.$StorageUserPayload>
/**
 * Model Crew
 * 
 */
export type Crew = $Result.DefaultSelection<Prisma.$CrewPayload>
/**
 * Model CrewUser
 * 
 */
export type CrewUser = $Result.DefaultSelection<Prisma.$CrewUserPayload>
/**
 * Model CrewInventory
 * 
 */
export type CrewInventory = $Result.DefaultSelection<Prisma.$CrewInventoryPayload>
/**
 * Model CrewStorage
 * 
 */
export type CrewStorage = $Result.DefaultSelection<Prisma.$CrewStoragePayload>
/**
 * Model CrewIngredient
 * 
 */
export type CrewIngredient = $Result.DefaultSelection<Prisma.$CrewIngredientPayload>
/**
 * Model CrewRecipeBook
 * 
 */
export type CrewRecipeBook = $Result.DefaultSelection<Prisma.$CrewRecipeBookPayload>
/**
 * Model CrewBuild
 * 
 */
export type CrewBuild = $Result.DefaultSelection<Prisma.$CrewBuildPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.follow`: Exposes CRUD operations for the **Follow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Follows
    * const follows = await prisma.follow.findMany()
    * ```
    */
  get follow(): Prisma.FollowDelegate<ExtArgs>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs>;

  /**
   * `prisma.recipeBook`: Exposes CRUD operations for the **RecipeBook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecipeBooks
    * const recipeBooks = await prisma.recipeBook.findMany()
    * ```
    */
  get recipeBook(): Prisma.RecipeBookDelegate<ExtArgs>;

  /**
   * `prisma.recipeBookUser`: Exposes CRUD operations for the **RecipeBookUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecipeBookUsers
    * const recipeBookUsers = await prisma.recipeBookUser.findMany()
    * ```
    */
  get recipeBookUser(): Prisma.RecipeBookUserDelegate<ExtArgs>;

  /**
   * `prisma.build`: Exposes CRUD operations for the **Build** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Builds
    * const builds = await prisma.build.findMany()
    * ```
    */
  get build(): Prisma.BuildDelegate<ExtArgs>;

  /**
   * `prisma.archivedBuild`: Exposes CRUD operations for the **ArchivedBuild** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ArchivedBuilds
    * const archivedBuilds = await prisma.archivedBuild.findMany()
    * ```
    */
  get archivedBuild(): Prisma.ArchivedBuildDelegate<ExtArgs>;

  /**
   * `prisma.buildUser`: Exposes CRUD operations for the **BuildUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BuildUsers
    * const buildUsers = await prisma.buildUser.findMany()
    * ```
    */
  get buildUser(): Prisma.BuildUserDelegate<ExtArgs>;

  /**
   * `prisma.recipe`: Exposes CRUD operations for the **Recipe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recipes
    * const recipes = await prisma.recipe.findMany()
    * ```
    */
  get recipe(): Prisma.RecipeDelegate<ExtArgs>;

  /**
   * `prisma.recipeBookBuild`: Exposes CRUD operations for the **RecipeBookBuild** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecipeBookBuilds
    * const recipeBookBuilds = await prisma.recipeBookBuild.findMany()
    * ```
    */
  get recipeBookBuild(): Prisma.RecipeBookBuildDelegate<ExtArgs>;

  /**
   * `prisma.touch`: Exposes CRUD operations for the **Touch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Touches
    * const touches = await prisma.touch.findMany()
    * ```
    */
  get touch(): Prisma.TouchDelegate<ExtArgs>;

  /**
   * `prisma.archivedTouch`: Exposes CRUD operations for the **ArchivedTouch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ArchivedTouches
    * const archivedTouches = await prisma.archivedTouch.findMany()
    * ```
    */
  get archivedTouch(): Prisma.ArchivedTouchDelegate<ExtArgs>;

  /**
   * `prisma.ingredientType`: Exposes CRUD operations for the **IngredientType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IngredientTypes
    * const ingredientTypes = await prisma.ingredientType.findMany()
    * ```
    */
  get ingredientType(): Prisma.IngredientTypeDelegate<ExtArgs>;

  /**
   * `prisma.ingredient`: Exposes CRUD operations for the **Ingredient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ingredients
    * const ingredients = await prisma.ingredient.findMany()
    * ```
    */
  get ingredient(): Prisma.IngredientDelegate<ExtArgs>;

  /**
   * `prisma.ingredientUser`: Exposes CRUD operations for the **IngredientUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IngredientUsers
    * const ingredientUsers = await prisma.ingredientUser.findMany()
    * ```
    */
  get ingredientUser(): Prisma.IngredientUserDelegate<ExtArgs>;

  /**
   * `prisma.ingredientPreference`: Exposes CRUD operations for the **IngredientPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IngredientPreferences
    * const ingredientPreferences = await prisma.ingredientPreference.findMany()
    * ```
    */
  get ingredientPreference(): Prisma.IngredientPreferenceDelegate<ExtArgs>;

  /**
   * `prisma.inventory`: Exposes CRUD operations for the **Inventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventories
    * const inventories = await prisma.inventory.findMany()
    * ```
    */
  get inventory(): Prisma.InventoryDelegate<ExtArgs>;

  /**
   * `prisma.inventoryUser`: Exposes CRUD operations for the **InventoryUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryUsers
    * const inventoryUsers = await prisma.inventoryUser.findMany()
    * ```
    */
  get inventoryUser(): Prisma.InventoryUserDelegate<ExtArgs>;

  /**
   * `prisma.storage`: Exposes CRUD operations for the **Storage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Storages
    * const storages = await prisma.storage.findMany()
    * ```
    */
  get storage(): Prisma.StorageDelegate<ExtArgs>;

  /**
   * `prisma.inventoryStorage`: Exposes CRUD operations for the **InventoryStorage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryStorages
    * const inventoryStorages = await prisma.inventoryStorage.findMany()
    * ```
    */
  get inventoryStorage(): Prisma.InventoryStorageDelegate<ExtArgs>;

  /**
   * `prisma.ingredientStorage`: Exposes CRUD operations for the **IngredientStorage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IngredientStorages
    * const ingredientStorages = await prisma.ingredientStorage.findMany()
    * ```
    */
  get ingredientStorage(): Prisma.IngredientStorageDelegate<ExtArgs>;

  /**
   * `prisma.storageUser`: Exposes CRUD operations for the **StorageUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StorageUsers
    * const storageUsers = await prisma.storageUser.findMany()
    * ```
    */
  get storageUser(): Prisma.StorageUserDelegate<ExtArgs>;

  /**
   * `prisma.crew`: Exposes CRUD operations for the **Crew** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Crews
    * const crews = await prisma.crew.findMany()
    * ```
    */
  get crew(): Prisma.CrewDelegate<ExtArgs>;

  /**
   * `prisma.crewUser`: Exposes CRUD operations for the **CrewUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrewUsers
    * const crewUsers = await prisma.crewUser.findMany()
    * ```
    */
  get crewUser(): Prisma.CrewUserDelegate<ExtArgs>;

  /**
   * `prisma.crewInventory`: Exposes CRUD operations for the **CrewInventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrewInventories
    * const crewInventories = await prisma.crewInventory.findMany()
    * ```
    */
  get crewInventory(): Prisma.CrewInventoryDelegate<ExtArgs>;

  /**
   * `prisma.crewStorage`: Exposes CRUD operations for the **CrewStorage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrewStorages
    * const crewStorages = await prisma.crewStorage.findMany()
    * ```
    */
  get crewStorage(): Prisma.CrewStorageDelegate<ExtArgs>;

  /**
   * `prisma.crewIngredient`: Exposes CRUD operations for the **CrewIngredient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrewIngredients
    * const crewIngredients = await prisma.crewIngredient.findMany()
    * ```
    */
  get crewIngredient(): Prisma.CrewIngredientDelegate<ExtArgs>;

  /**
   * `prisma.crewRecipeBook`: Exposes CRUD operations for the **CrewRecipeBook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrewRecipeBooks
    * const crewRecipeBooks = await prisma.crewRecipeBook.findMany()
    * ```
    */
  get crewRecipeBook(): Prisma.CrewRecipeBookDelegate<ExtArgs>;

  /**
   * `prisma.crewBuild`: Exposes CRUD operations for the **CrewBuild** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrewBuilds
    * const crewBuilds = await prisma.crewBuild.findMany()
    * ```
    */
  get crewBuild(): Prisma.CrewBuildDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.6.0
   * Query Engine version: e95e739751f42d8ca026f6b910f5a2dc5adeaeee
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Follow: 'Follow',
    Profile: 'Profile',
    RecipeBook: 'RecipeBook',
    RecipeBookUser: 'RecipeBookUser',
    Build: 'Build',
    ArchivedBuild: 'ArchivedBuild',
    BuildUser: 'BuildUser',
    Recipe: 'Recipe',
    RecipeBookBuild: 'RecipeBookBuild',
    Touch: 'Touch',
    ArchivedTouch: 'ArchivedTouch',
    IngredientType: 'IngredientType',
    Ingredient: 'Ingredient',
    IngredientUser: 'IngredientUser',
    IngredientPreference: 'IngredientPreference',
    Inventory: 'Inventory',
    InventoryUser: 'InventoryUser',
    Storage: 'Storage',
    InventoryStorage: 'InventoryStorage',
    IngredientStorage: 'IngredientStorage',
    StorageUser: 'StorageUser',
    Crew: 'Crew',
    CrewUser: 'CrewUser',
    CrewInventory: 'CrewInventory',
    CrewStorage: 'CrewStorage',
    CrewIngredient: 'CrewIngredient',
    CrewRecipeBook: 'CrewRecipeBook',
    CrewBuild: 'CrewBuild'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'follow' | 'profile' | 'recipeBook' | 'recipeBookUser' | 'build' | 'archivedBuild' | 'buildUser' | 'recipe' | 'recipeBookBuild' | 'touch' | 'archivedTouch' | 'ingredientType' | 'ingredient' | 'ingredientUser' | 'ingredientPreference' | 'inventory' | 'inventoryUser' | 'storage' | 'inventoryStorage' | 'ingredientStorage' | 'storageUser' | 'crew' | 'crewUser' | 'crewInventory' | 'crewStorage' | 'crewIngredient' | 'crewRecipeBook' | 'crewBuild'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Follow: {
        payload: Prisma.$FollowPayload<ExtArgs>
        fields: Prisma.FollowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FollowFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FollowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FollowFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          findFirst: {
            args: Prisma.FollowFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FollowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FollowFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          findMany: {
            args: Prisma.FollowFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>[]
          }
          create: {
            args: Prisma.FollowCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          createMany: {
            args: Prisma.FollowCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FollowDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          update: {
            args: Prisma.FollowUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          deleteMany: {
            args: Prisma.FollowDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FollowUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FollowUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          aggregate: {
            args: Prisma.FollowAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFollow>
          }
          groupBy: {
            args: Prisma.FollowGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FollowGroupByOutputType>[]
          }
          count: {
            args: Prisma.FollowCountArgs<ExtArgs>,
            result: $Utils.Optional<FollowCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>,
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      RecipeBook: {
        payload: Prisma.$RecipeBookPayload<ExtArgs>
        fields: Prisma.RecipeBookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeBookFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeBookFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookPayload>
          }
          findFirst: {
            args: Prisma.RecipeBookFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeBookFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookPayload>
          }
          findMany: {
            args: Prisma.RecipeBookFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookPayload>[]
          }
          create: {
            args: Prisma.RecipeBookCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookPayload>
          }
          createMany: {
            args: Prisma.RecipeBookCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RecipeBookDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookPayload>
          }
          update: {
            args: Prisma.RecipeBookUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookPayload>
          }
          deleteMany: {
            args: Prisma.RecipeBookDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeBookUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RecipeBookUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookPayload>
          }
          aggregate: {
            args: Prisma.RecipeBookAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRecipeBook>
          }
          groupBy: {
            args: Prisma.RecipeBookGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RecipeBookGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeBookCountArgs<ExtArgs>,
            result: $Utils.Optional<RecipeBookCountAggregateOutputType> | number
          }
        }
      }
      RecipeBookUser: {
        payload: Prisma.$RecipeBookUserPayload<ExtArgs>
        fields: Prisma.RecipeBookUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeBookUserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeBookUserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookUserPayload>
          }
          findFirst: {
            args: Prisma.RecipeBookUserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeBookUserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookUserPayload>
          }
          findMany: {
            args: Prisma.RecipeBookUserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookUserPayload>[]
          }
          create: {
            args: Prisma.RecipeBookUserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookUserPayload>
          }
          createMany: {
            args: Prisma.RecipeBookUserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RecipeBookUserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookUserPayload>
          }
          update: {
            args: Prisma.RecipeBookUserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookUserPayload>
          }
          deleteMany: {
            args: Prisma.RecipeBookUserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeBookUserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RecipeBookUserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookUserPayload>
          }
          aggregate: {
            args: Prisma.RecipeBookUserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRecipeBookUser>
          }
          groupBy: {
            args: Prisma.RecipeBookUserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RecipeBookUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeBookUserCountArgs<ExtArgs>,
            result: $Utils.Optional<RecipeBookUserCountAggregateOutputType> | number
          }
        }
      }
      Build: {
        payload: Prisma.$BuildPayload<ExtArgs>
        fields: Prisma.BuildFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuildFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuildFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPayload>
          }
          findFirst: {
            args: Prisma.BuildFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuildFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPayload>
          }
          findMany: {
            args: Prisma.BuildFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPayload>[]
          }
          create: {
            args: Prisma.BuildCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPayload>
          }
          createMany: {
            args: Prisma.BuildCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BuildDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPayload>
          }
          update: {
            args: Prisma.BuildUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPayload>
          }
          deleteMany: {
            args: Prisma.BuildDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BuildUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BuildUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPayload>
          }
          aggregate: {
            args: Prisma.BuildAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBuild>
          }
          groupBy: {
            args: Prisma.BuildGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BuildGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuildCountArgs<ExtArgs>,
            result: $Utils.Optional<BuildCountAggregateOutputType> | number
          }
        }
      }
      ArchivedBuild: {
        payload: Prisma.$ArchivedBuildPayload<ExtArgs>
        fields: Prisma.ArchivedBuildFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArchivedBuildFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArchivedBuildPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArchivedBuildFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArchivedBuildPayload>
          }
          findFirst: {
            args: Prisma.ArchivedBuildFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArchivedBuildPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArchivedBuildFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArchivedBuildPayload>
          }
          findMany: {
            args: Prisma.ArchivedBuildFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArchivedBuildPayload>[]
          }
          create: {
            args: Prisma.ArchivedBuildCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArchivedBuildPayload>
          }
          createMany: {
            args: Prisma.ArchivedBuildCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ArchivedBuildDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArchivedBuildPayload>
          }
          update: {
            args: Prisma.ArchivedBuildUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArchivedBuildPayload>
          }
          deleteMany: {
            args: Prisma.ArchivedBuildDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ArchivedBuildUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ArchivedBuildUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArchivedBuildPayload>
          }
          aggregate: {
            args: Prisma.ArchivedBuildAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateArchivedBuild>
          }
          groupBy: {
            args: Prisma.ArchivedBuildGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ArchivedBuildGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArchivedBuildCountArgs<ExtArgs>,
            result: $Utils.Optional<ArchivedBuildCountAggregateOutputType> | number
          }
        }
      }
      BuildUser: {
        payload: Prisma.$BuildUserPayload<ExtArgs>
        fields: Prisma.BuildUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuildUserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuildUserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildUserPayload>
          }
          findFirst: {
            args: Prisma.BuildUserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuildUserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildUserPayload>
          }
          findMany: {
            args: Prisma.BuildUserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildUserPayload>[]
          }
          create: {
            args: Prisma.BuildUserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildUserPayload>
          }
          createMany: {
            args: Prisma.BuildUserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BuildUserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildUserPayload>
          }
          update: {
            args: Prisma.BuildUserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildUserPayload>
          }
          deleteMany: {
            args: Prisma.BuildUserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BuildUserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BuildUserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildUserPayload>
          }
          aggregate: {
            args: Prisma.BuildUserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBuildUser>
          }
          groupBy: {
            args: Prisma.BuildUserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BuildUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuildUserCountArgs<ExtArgs>,
            result: $Utils.Optional<BuildUserCountAggregateOutputType> | number
          }
        }
      }
      Recipe: {
        payload: Prisma.$RecipePayload<ExtArgs>
        fields: Prisma.RecipeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          findFirst: {
            args: Prisma.RecipeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          findMany: {
            args: Prisma.RecipeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>[]
          }
          create: {
            args: Prisma.RecipeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          createMany: {
            args: Prisma.RecipeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RecipeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          update: {
            args: Prisma.RecipeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          deleteMany: {
            args: Prisma.RecipeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RecipeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          aggregate: {
            args: Prisma.RecipeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRecipe>
          }
          groupBy: {
            args: Prisma.RecipeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RecipeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeCountArgs<ExtArgs>,
            result: $Utils.Optional<RecipeCountAggregateOutputType> | number
          }
        }
      }
      RecipeBookBuild: {
        payload: Prisma.$RecipeBookBuildPayload<ExtArgs>
        fields: Prisma.RecipeBookBuildFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeBookBuildFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookBuildPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeBookBuildFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookBuildPayload>
          }
          findFirst: {
            args: Prisma.RecipeBookBuildFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookBuildPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeBookBuildFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookBuildPayload>
          }
          findMany: {
            args: Prisma.RecipeBookBuildFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookBuildPayload>[]
          }
          create: {
            args: Prisma.RecipeBookBuildCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookBuildPayload>
          }
          createMany: {
            args: Prisma.RecipeBookBuildCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RecipeBookBuildDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookBuildPayload>
          }
          update: {
            args: Prisma.RecipeBookBuildUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookBuildPayload>
          }
          deleteMany: {
            args: Prisma.RecipeBookBuildDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeBookBuildUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RecipeBookBuildUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeBookBuildPayload>
          }
          aggregate: {
            args: Prisma.RecipeBookBuildAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRecipeBookBuild>
          }
          groupBy: {
            args: Prisma.RecipeBookBuildGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RecipeBookBuildGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeBookBuildCountArgs<ExtArgs>,
            result: $Utils.Optional<RecipeBookBuildCountAggregateOutputType> | number
          }
        }
      }
      Touch: {
        payload: Prisma.$TouchPayload<ExtArgs>
        fields: Prisma.TouchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TouchFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TouchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TouchFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TouchPayload>
          }
          findFirst: {
            args: Prisma.TouchFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TouchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TouchFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TouchPayload>
          }
          findMany: {
            args: Prisma.TouchFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TouchPayload>[]
          }
          create: {
            args: Prisma.TouchCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TouchPayload>
          }
          createMany: {
            args: Prisma.TouchCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TouchDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TouchPayload>
          }
          update: {
            args: Prisma.TouchUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TouchPayload>
          }
          deleteMany: {
            args: Prisma.TouchDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TouchUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TouchUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TouchPayload>
          }
          aggregate: {
            args: Prisma.TouchAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTouch>
          }
          groupBy: {
            args: Prisma.TouchGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TouchGroupByOutputType>[]
          }
          count: {
            args: Prisma.TouchCountArgs<ExtArgs>,
            result: $Utils.Optional<TouchCountAggregateOutputType> | number
          }
        }
      }
      ArchivedTouch: {
        payload: Prisma.$ArchivedTouchPayload<ExtArgs>
        fields: Prisma.ArchivedTouchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArchivedTouchFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArchivedTouchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArchivedTouchFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArchivedTouchPayload>
          }
          findFirst: {
            args: Prisma.ArchivedTouchFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArchivedTouchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArchivedTouchFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArchivedTouchPayload>
          }
          findMany: {
            args: Prisma.ArchivedTouchFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArchivedTouchPayload>[]
          }
          create: {
            args: Prisma.ArchivedTouchCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArchivedTouchPayload>
          }
          createMany: {
            args: Prisma.ArchivedTouchCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ArchivedTouchDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArchivedTouchPayload>
          }
          update: {
            args: Prisma.ArchivedTouchUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArchivedTouchPayload>
          }
          deleteMany: {
            args: Prisma.ArchivedTouchDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ArchivedTouchUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ArchivedTouchUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArchivedTouchPayload>
          }
          aggregate: {
            args: Prisma.ArchivedTouchAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateArchivedTouch>
          }
          groupBy: {
            args: Prisma.ArchivedTouchGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ArchivedTouchGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArchivedTouchCountArgs<ExtArgs>,
            result: $Utils.Optional<ArchivedTouchCountAggregateOutputType> | number
          }
        }
      }
      IngredientType: {
        payload: Prisma.$IngredientTypePayload<ExtArgs>
        fields: Prisma.IngredientTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IngredientTypeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IngredientTypeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientTypePayload>
          }
          findFirst: {
            args: Prisma.IngredientTypeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IngredientTypeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientTypePayload>
          }
          findMany: {
            args: Prisma.IngredientTypeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientTypePayload>[]
          }
          create: {
            args: Prisma.IngredientTypeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientTypePayload>
          }
          createMany: {
            args: Prisma.IngredientTypeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.IngredientTypeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientTypePayload>
          }
          update: {
            args: Prisma.IngredientTypeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientTypePayload>
          }
          deleteMany: {
            args: Prisma.IngredientTypeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.IngredientTypeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.IngredientTypeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientTypePayload>
          }
          aggregate: {
            args: Prisma.IngredientTypeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIngredientType>
          }
          groupBy: {
            args: Prisma.IngredientTypeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<IngredientTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.IngredientTypeCountArgs<ExtArgs>,
            result: $Utils.Optional<IngredientTypeCountAggregateOutputType> | number
          }
        }
      }
      Ingredient: {
        payload: Prisma.$IngredientPayload<ExtArgs>
        fields: Prisma.IngredientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IngredientFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IngredientFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload>
          }
          findFirst: {
            args: Prisma.IngredientFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IngredientFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload>
          }
          findMany: {
            args: Prisma.IngredientFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload>[]
          }
          create: {
            args: Prisma.IngredientCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload>
          }
          createMany: {
            args: Prisma.IngredientCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.IngredientDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload>
          }
          update: {
            args: Prisma.IngredientUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload>
          }
          deleteMany: {
            args: Prisma.IngredientDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.IngredientUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.IngredientUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload>
          }
          aggregate: {
            args: Prisma.IngredientAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIngredient>
          }
          groupBy: {
            args: Prisma.IngredientGroupByArgs<ExtArgs>,
            result: $Utils.Optional<IngredientGroupByOutputType>[]
          }
          count: {
            args: Prisma.IngredientCountArgs<ExtArgs>,
            result: $Utils.Optional<IngredientCountAggregateOutputType> | number
          }
        }
      }
      IngredientUser: {
        payload: Prisma.$IngredientUserPayload<ExtArgs>
        fields: Prisma.IngredientUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IngredientUserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IngredientUserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientUserPayload>
          }
          findFirst: {
            args: Prisma.IngredientUserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IngredientUserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientUserPayload>
          }
          findMany: {
            args: Prisma.IngredientUserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientUserPayload>[]
          }
          create: {
            args: Prisma.IngredientUserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientUserPayload>
          }
          createMany: {
            args: Prisma.IngredientUserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.IngredientUserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientUserPayload>
          }
          update: {
            args: Prisma.IngredientUserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientUserPayload>
          }
          deleteMany: {
            args: Prisma.IngredientUserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.IngredientUserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.IngredientUserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientUserPayload>
          }
          aggregate: {
            args: Prisma.IngredientUserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIngredientUser>
          }
          groupBy: {
            args: Prisma.IngredientUserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<IngredientUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.IngredientUserCountArgs<ExtArgs>,
            result: $Utils.Optional<IngredientUserCountAggregateOutputType> | number
          }
        }
      }
      IngredientPreference: {
        payload: Prisma.$IngredientPreferencePayload<ExtArgs>
        fields: Prisma.IngredientPreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IngredientPreferenceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IngredientPreferenceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPreferencePayload>
          }
          findFirst: {
            args: Prisma.IngredientPreferenceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IngredientPreferenceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPreferencePayload>
          }
          findMany: {
            args: Prisma.IngredientPreferenceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPreferencePayload>[]
          }
          create: {
            args: Prisma.IngredientPreferenceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPreferencePayload>
          }
          createMany: {
            args: Prisma.IngredientPreferenceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.IngredientPreferenceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPreferencePayload>
          }
          update: {
            args: Prisma.IngredientPreferenceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPreferencePayload>
          }
          deleteMany: {
            args: Prisma.IngredientPreferenceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.IngredientPreferenceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.IngredientPreferenceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPreferencePayload>
          }
          aggregate: {
            args: Prisma.IngredientPreferenceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIngredientPreference>
          }
          groupBy: {
            args: Prisma.IngredientPreferenceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<IngredientPreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.IngredientPreferenceCountArgs<ExtArgs>,
            result: $Utils.Optional<IngredientPreferenceCountAggregateOutputType> | number
          }
        }
      }
      Inventory: {
        payload: Prisma.$InventoryPayload<ExtArgs>
        fields: Prisma.InventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findFirst: {
            args: Prisma.InventoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findMany: {
            args: Prisma.InventoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          create: {
            args: Prisma.InventoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          createMany: {
            args: Prisma.InventoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InventoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          update: {
            args: Prisma.InventoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          deleteMany: {
            args: Prisma.InventoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InventoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          aggregate: {
            args: Prisma.InventoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInventory>
          }
          groupBy: {
            args: Prisma.InventoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryCountArgs<ExtArgs>,
            result: $Utils.Optional<InventoryCountAggregateOutputType> | number
          }
        }
      }
      InventoryUser: {
        payload: Prisma.$InventoryUserPayload<ExtArgs>
        fields: Prisma.InventoryUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryUserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryUserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryUserPayload>
          }
          findFirst: {
            args: Prisma.InventoryUserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryUserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryUserPayload>
          }
          findMany: {
            args: Prisma.InventoryUserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryUserPayload>[]
          }
          create: {
            args: Prisma.InventoryUserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryUserPayload>
          }
          createMany: {
            args: Prisma.InventoryUserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InventoryUserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryUserPayload>
          }
          update: {
            args: Prisma.InventoryUserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryUserPayload>
          }
          deleteMany: {
            args: Prisma.InventoryUserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryUserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InventoryUserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryUserPayload>
          }
          aggregate: {
            args: Prisma.InventoryUserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInventoryUser>
          }
          groupBy: {
            args: Prisma.InventoryUserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InventoryUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryUserCountArgs<ExtArgs>,
            result: $Utils.Optional<InventoryUserCountAggregateOutputType> | number
          }
        }
      }
      Storage: {
        payload: Prisma.$StoragePayload<ExtArgs>
        fields: Prisma.StorageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StorageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StoragePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StorageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StoragePayload>
          }
          findFirst: {
            args: Prisma.StorageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StoragePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StorageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StoragePayload>
          }
          findMany: {
            args: Prisma.StorageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StoragePayload>[]
          }
          create: {
            args: Prisma.StorageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StoragePayload>
          }
          createMany: {
            args: Prisma.StorageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StorageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StoragePayload>
          }
          update: {
            args: Prisma.StorageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StoragePayload>
          }
          deleteMany: {
            args: Prisma.StorageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StorageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StorageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StoragePayload>
          }
          aggregate: {
            args: Prisma.StorageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStorage>
          }
          groupBy: {
            args: Prisma.StorageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StorageGroupByOutputType>[]
          }
          count: {
            args: Prisma.StorageCountArgs<ExtArgs>,
            result: $Utils.Optional<StorageCountAggregateOutputType> | number
          }
        }
      }
      InventoryStorage: {
        payload: Prisma.$InventoryStoragePayload<ExtArgs>
        fields: Prisma.InventoryStorageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryStorageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryStoragePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryStorageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryStoragePayload>
          }
          findFirst: {
            args: Prisma.InventoryStorageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryStoragePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryStorageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryStoragePayload>
          }
          findMany: {
            args: Prisma.InventoryStorageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryStoragePayload>[]
          }
          create: {
            args: Prisma.InventoryStorageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryStoragePayload>
          }
          createMany: {
            args: Prisma.InventoryStorageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InventoryStorageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryStoragePayload>
          }
          update: {
            args: Prisma.InventoryStorageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryStoragePayload>
          }
          deleteMany: {
            args: Prisma.InventoryStorageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryStorageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InventoryStorageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryStoragePayload>
          }
          aggregate: {
            args: Prisma.InventoryStorageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInventoryStorage>
          }
          groupBy: {
            args: Prisma.InventoryStorageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InventoryStorageGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryStorageCountArgs<ExtArgs>,
            result: $Utils.Optional<InventoryStorageCountAggregateOutputType> | number
          }
        }
      }
      IngredientStorage: {
        payload: Prisma.$IngredientStoragePayload<ExtArgs>
        fields: Prisma.IngredientStorageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IngredientStorageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientStoragePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IngredientStorageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientStoragePayload>
          }
          findFirst: {
            args: Prisma.IngredientStorageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientStoragePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IngredientStorageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientStoragePayload>
          }
          findMany: {
            args: Prisma.IngredientStorageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientStoragePayload>[]
          }
          create: {
            args: Prisma.IngredientStorageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientStoragePayload>
          }
          createMany: {
            args: Prisma.IngredientStorageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.IngredientStorageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientStoragePayload>
          }
          update: {
            args: Prisma.IngredientStorageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientStoragePayload>
          }
          deleteMany: {
            args: Prisma.IngredientStorageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.IngredientStorageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.IngredientStorageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientStoragePayload>
          }
          aggregate: {
            args: Prisma.IngredientStorageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIngredientStorage>
          }
          groupBy: {
            args: Prisma.IngredientStorageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<IngredientStorageGroupByOutputType>[]
          }
          count: {
            args: Prisma.IngredientStorageCountArgs<ExtArgs>,
            result: $Utils.Optional<IngredientStorageCountAggregateOutputType> | number
          }
        }
      }
      StorageUser: {
        payload: Prisma.$StorageUserPayload<ExtArgs>
        fields: Prisma.StorageUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StorageUserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StorageUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StorageUserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StorageUserPayload>
          }
          findFirst: {
            args: Prisma.StorageUserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StorageUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StorageUserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StorageUserPayload>
          }
          findMany: {
            args: Prisma.StorageUserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StorageUserPayload>[]
          }
          create: {
            args: Prisma.StorageUserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StorageUserPayload>
          }
          createMany: {
            args: Prisma.StorageUserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StorageUserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StorageUserPayload>
          }
          update: {
            args: Prisma.StorageUserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StorageUserPayload>
          }
          deleteMany: {
            args: Prisma.StorageUserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StorageUserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StorageUserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StorageUserPayload>
          }
          aggregate: {
            args: Prisma.StorageUserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStorageUser>
          }
          groupBy: {
            args: Prisma.StorageUserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StorageUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.StorageUserCountArgs<ExtArgs>,
            result: $Utils.Optional<StorageUserCountAggregateOutputType> | number
          }
        }
      }
      Crew: {
        payload: Prisma.$CrewPayload<ExtArgs>
        fields: Prisma.CrewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CrewFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CrewFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>
          }
          findFirst: {
            args: Prisma.CrewFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CrewFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>
          }
          findMany: {
            args: Prisma.CrewFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>[]
          }
          create: {
            args: Prisma.CrewCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>
          }
          createMany: {
            args: Prisma.CrewCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CrewDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>
          }
          update: {
            args: Prisma.CrewUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>
          }
          deleteMany: {
            args: Prisma.CrewDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CrewUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CrewUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>
          }
          aggregate: {
            args: Prisma.CrewAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCrew>
          }
          groupBy: {
            args: Prisma.CrewGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CrewGroupByOutputType>[]
          }
          count: {
            args: Prisma.CrewCountArgs<ExtArgs>,
            result: $Utils.Optional<CrewCountAggregateOutputType> | number
          }
        }
      }
      CrewUser: {
        payload: Prisma.$CrewUserPayload<ExtArgs>
        fields: Prisma.CrewUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CrewUserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CrewUserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewUserPayload>
          }
          findFirst: {
            args: Prisma.CrewUserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CrewUserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewUserPayload>
          }
          findMany: {
            args: Prisma.CrewUserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewUserPayload>[]
          }
          create: {
            args: Prisma.CrewUserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewUserPayload>
          }
          createMany: {
            args: Prisma.CrewUserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CrewUserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewUserPayload>
          }
          update: {
            args: Prisma.CrewUserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewUserPayload>
          }
          deleteMany: {
            args: Prisma.CrewUserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CrewUserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CrewUserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewUserPayload>
          }
          aggregate: {
            args: Prisma.CrewUserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCrewUser>
          }
          groupBy: {
            args: Prisma.CrewUserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CrewUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.CrewUserCountArgs<ExtArgs>,
            result: $Utils.Optional<CrewUserCountAggregateOutputType> | number
          }
        }
      }
      CrewInventory: {
        payload: Prisma.$CrewInventoryPayload<ExtArgs>
        fields: Prisma.CrewInventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CrewInventoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewInventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CrewInventoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewInventoryPayload>
          }
          findFirst: {
            args: Prisma.CrewInventoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewInventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CrewInventoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewInventoryPayload>
          }
          findMany: {
            args: Prisma.CrewInventoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewInventoryPayload>[]
          }
          create: {
            args: Prisma.CrewInventoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewInventoryPayload>
          }
          createMany: {
            args: Prisma.CrewInventoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CrewInventoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewInventoryPayload>
          }
          update: {
            args: Prisma.CrewInventoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewInventoryPayload>
          }
          deleteMany: {
            args: Prisma.CrewInventoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CrewInventoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CrewInventoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewInventoryPayload>
          }
          aggregate: {
            args: Prisma.CrewInventoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCrewInventory>
          }
          groupBy: {
            args: Prisma.CrewInventoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CrewInventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CrewInventoryCountArgs<ExtArgs>,
            result: $Utils.Optional<CrewInventoryCountAggregateOutputType> | number
          }
        }
      }
      CrewStorage: {
        payload: Prisma.$CrewStoragePayload<ExtArgs>
        fields: Prisma.CrewStorageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CrewStorageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewStoragePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CrewStorageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewStoragePayload>
          }
          findFirst: {
            args: Prisma.CrewStorageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewStoragePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CrewStorageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewStoragePayload>
          }
          findMany: {
            args: Prisma.CrewStorageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewStoragePayload>[]
          }
          create: {
            args: Prisma.CrewStorageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewStoragePayload>
          }
          createMany: {
            args: Prisma.CrewStorageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CrewStorageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewStoragePayload>
          }
          update: {
            args: Prisma.CrewStorageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewStoragePayload>
          }
          deleteMany: {
            args: Prisma.CrewStorageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CrewStorageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CrewStorageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewStoragePayload>
          }
          aggregate: {
            args: Prisma.CrewStorageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCrewStorage>
          }
          groupBy: {
            args: Prisma.CrewStorageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CrewStorageGroupByOutputType>[]
          }
          count: {
            args: Prisma.CrewStorageCountArgs<ExtArgs>,
            result: $Utils.Optional<CrewStorageCountAggregateOutputType> | number
          }
        }
      }
      CrewIngredient: {
        payload: Prisma.$CrewIngredientPayload<ExtArgs>
        fields: Prisma.CrewIngredientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CrewIngredientFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewIngredientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CrewIngredientFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewIngredientPayload>
          }
          findFirst: {
            args: Prisma.CrewIngredientFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewIngredientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CrewIngredientFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewIngredientPayload>
          }
          findMany: {
            args: Prisma.CrewIngredientFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewIngredientPayload>[]
          }
          create: {
            args: Prisma.CrewIngredientCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewIngredientPayload>
          }
          createMany: {
            args: Prisma.CrewIngredientCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CrewIngredientDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewIngredientPayload>
          }
          update: {
            args: Prisma.CrewIngredientUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewIngredientPayload>
          }
          deleteMany: {
            args: Prisma.CrewIngredientDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CrewIngredientUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CrewIngredientUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewIngredientPayload>
          }
          aggregate: {
            args: Prisma.CrewIngredientAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCrewIngredient>
          }
          groupBy: {
            args: Prisma.CrewIngredientGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CrewIngredientGroupByOutputType>[]
          }
          count: {
            args: Prisma.CrewIngredientCountArgs<ExtArgs>,
            result: $Utils.Optional<CrewIngredientCountAggregateOutputType> | number
          }
        }
      }
      CrewRecipeBook: {
        payload: Prisma.$CrewRecipeBookPayload<ExtArgs>
        fields: Prisma.CrewRecipeBookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CrewRecipeBookFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewRecipeBookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CrewRecipeBookFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewRecipeBookPayload>
          }
          findFirst: {
            args: Prisma.CrewRecipeBookFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewRecipeBookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CrewRecipeBookFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewRecipeBookPayload>
          }
          findMany: {
            args: Prisma.CrewRecipeBookFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewRecipeBookPayload>[]
          }
          create: {
            args: Prisma.CrewRecipeBookCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewRecipeBookPayload>
          }
          createMany: {
            args: Prisma.CrewRecipeBookCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CrewRecipeBookDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewRecipeBookPayload>
          }
          update: {
            args: Prisma.CrewRecipeBookUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewRecipeBookPayload>
          }
          deleteMany: {
            args: Prisma.CrewRecipeBookDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CrewRecipeBookUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CrewRecipeBookUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewRecipeBookPayload>
          }
          aggregate: {
            args: Prisma.CrewRecipeBookAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCrewRecipeBook>
          }
          groupBy: {
            args: Prisma.CrewRecipeBookGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CrewRecipeBookGroupByOutputType>[]
          }
          count: {
            args: Prisma.CrewRecipeBookCountArgs<ExtArgs>,
            result: $Utils.Optional<CrewRecipeBookCountAggregateOutputType> | number
          }
        }
      }
      CrewBuild: {
        payload: Prisma.$CrewBuildPayload<ExtArgs>
        fields: Prisma.CrewBuildFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CrewBuildFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewBuildPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CrewBuildFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewBuildPayload>
          }
          findFirst: {
            args: Prisma.CrewBuildFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewBuildPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CrewBuildFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewBuildPayload>
          }
          findMany: {
            args: Prisma.CrewBuildFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewBuildPayload>[]
          }
          create: {
            args: Prisma.CrewBuildCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewBuildPayload>
          }
          createMany: {
            args: Prisma.CrewBuildCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CrewBuildDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewBuildPayload>
          }
          update: {
            args: Prisma.CrewBuildUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewBuildPayload>
          }
          deleteMany: {
            args: Prisma.CrewBuildDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CrewBuildUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CrewBuildUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CrewBuildPayload>
          }
          aggregate: {
            args: Prisma.CrewBuildAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCrewBuild>
          }
          groupBy: {
            args: Prisma.CrewBuildGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CrewBuildGroupByOutputType>[]
          }
          count: {
            args: Prisma.CrewBuildCountArgs<ExtArgs>,
            result: $Utils.Optional<CrewBuildCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    recipeBookUser: number
    recipeBook: number
    recipeBookEditedBy: number
    recipe: number
    recipeEditedBy: number
    buildUser: number
    build: number
    buildEditedBy: number
    archivedBuild: number
    crewUser: number
    crew: number
    crewEditedBy: number
    ingredient: number
    ingredientPreference: number
    ingredientUser: number
    storageUser: number
    storage: number
    storageEditedBy: number
    inventory: number
    inventoryEditedBy: number
    inventoryUser: number
    followedBy: number
    following: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipeBookUser?: boolean | UserCountOutputTypeCountRecipeBookUserArgs
    recipeBook?: boolean | UserCountOutputTypeCountRecipeBookArgs
    recipeBookEditedBy?: boolean | UserCountOutputTypeCountRecipeBookEditedByArgs
    recipe?: boolean | UserCountOutputTypeCountRecipeArgs
    recipeEditedBy?: boolean | UserCountOutputTypeCountRecipeEditedByArgs
    buildUser?: boolean | UserCountOutputTypeCountBuildUserArgs
    build?: boolean | UserCountOutputTypeCountBuildArgs
    buildEditedBy?: boolean | UserCountOutputTypeCountBuildEditedByArgs
    archivedBuild?: boolean | UserCountOutputTypeCountArchivedBuildArgs
    crewUser?: boolean | UserCountOutputTypeCountCrewUserArgs
    crew?: boolean | UserCountOutputTypeCountCrewArgs
    crewEditedBy?: boolean | UserCountOutputTypeCountCrewEditedByArgs
    ingredient?: boolean | UserCountOutputTypeCountIngredientArgs
    ingredientPreference?: boolean | UserCountOutputTypeCountIngredientPreferenceArgs
    ingredientUser?: boolean | UserCountOutputTypeCountIngredientUserArgs
    storageUser?: boolean | UserCountOutputTypeCountStorageUserArgs
    storage?: boolean | UserCountOutputTypeCountStorageArgs
    storageEditedBy?: boolean | UserCountOutputTypeCountStorageEditedByArgs
    inventory?: boolean | UserCountOutputTypeCountInventoryArgs
    inventoryEditedBy?: boolean | UserCountOutputTypeCountInventoryEditedByArgs
    inventoryUser?: boolean | UserCountOutputTypeCountInventoryUserArgs
    followedBy?: boolean | UserCountOutputTypeCountFollowedByArgs
    following?: boolean | UserCountOutputTypeCountFollowingArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRecipeBookUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeBookUserWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRecipeBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeBookWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRecipeBookEditedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeBookWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRecipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRecipeEditedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBuildUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildUserWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBuildEditedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountArchivedBuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArchivedBuildWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCrewUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewUserWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCrewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCrewEditedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIngredientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngredientWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIngredientPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngredientPreferenceWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIngredientUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngredientUserWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStorageUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorageUserWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStorageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorageWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStorageEditedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorageWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInventoryEditedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInventoryUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryUserWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
  }



  /**
   * Count Type RecipeBookCountOutputType
   */

  export type RecipeBookCountOutputType = {
    recipeBookBuild: number
    recipeBookUser: number
    crewRecipeBook: number
  }

  export type RecipeBookCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipeBookBuild?: boolean | RecipeBookCountOutputTypeCountRecipeBookBuildArgs
    recipeBookUser?: boolean | RecipeBookCountOutputTypeCountRecipeBookUserArgs
    crewRecipeBook?: boolean | RecipeBookCountOutputTypeCountCrewRecipeBookArgs
  }

  // Custom InputTypes

  /**
   * RecipeBookCountOutputType without action
   */
  export type RecipeBookCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookCountOutputType
     */
    select?: RecipeBookCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RecipeBookCountOutputType without action
   */
  export type RecipeBookCountOutputTypeCountRecipeBookBuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeBookBuildWhereInput
  }


  /**
   * RecipeBookCountOutputType without action
   */
  export type RecipeBookCountOutputTypeCountRecipeBookUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeBookUserWhereInput
  }


  /**
   * RecipeBookCountOutputType without action
   */
  export type RecipeBookCountOutputTypeCountCrewRecipeBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewRecipeBookWhereInput
  }



  /**
   * Count Type BuildCountOutputType
   */

  export type BuildCountOutputType = {
    touch: number
    archivedBuild: number
    RecipeBookBuild: number
    buildUser: number
    crewBuild: number
  }

  export type BuildCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    touch?: boolean | BuildCountOutputTypeCountTouchArgs
    archivedBuild?: boolean | BuildCountOutputTypeCountArchivedBuildArgs
    RecipeBookBuild?: boolean | BuildCountOutputTypeCountRecipeBookBuildArgs
    buildUser?: boolean | BuildCountOutputTypeCountBuildUserArgs
    crewBuild?: boolean | BuildCountOutputTypeCountCrewBuildArgs
  }

  // Custom InputTypes

  /**
   * BuildCountOutputType without action
   */
  export type BuildCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildCountOutputType
     */
    select?: BuildCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * BuildCountOutputType without action
   */
  export type BuildCountOutputTypeCountTouchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TouchWhereInput
  }


  /**
   * BuildCountOutputType without action
   */
  export type BuildCountOutputTypeCountArchivedBuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArchivedBuildWhereInput
  }


  /**
   * BuildCountOutputType without action
   */
  export type BuildCountOutputTypeCountRecipeBookBuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeBookBuildWhereInput
  }


  /**
   * BuildCountOutputType without action
   */
  export type BuildCountOutputTypeCountBuildUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildUserWhereInput
  }


  /**
   * BuildCountOutputType without action
   */
  export type BuildCountOutputTypeCountCrewBuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewBuildWhereInput
  }



  /**
   * Count Type ArchivedBuildCountOutputType
   */

  export type ArchivedBuildCountOutputType = {
    archivedTouch: number
  }

  export type ArchivedBuildCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    archivedTouch?: boolean | ArchivedBuildCountOutputTypeCountArchivedTouchArgs
  }

  // Custom InputTypes

  /**
   * ArchivedBuildCountOutputType without action
   */
  export type ArchivedBuildCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedBuildCountOutputType
     */
    select?: ArchivedBuildCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ArchivedBuildCountOutputType without action
   */
  export type ArchivedBuildCountOutputTypeCountArchivedTouchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArchivedTouchWhereInput
  }



  /**
   * Count Type RecipeCountOutputType
   */

  export type RecipeCountOutputType = {
    build: number
    archivedBuild: number
  }

  export type RecipeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    build?: boolean | RecipeCountOutputTypeCountBuildArgs
    archivedBuild?: boolean | RecipeCountOutputTypeCountArchivedBuildArgs
  }

  // Custom InputTypes

  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeCountOutputType
     */
    select?: RecipeCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountBuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildWhereInput
  }


  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountArchivedBuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArchivedBuildWhereInput
  }



  /**
   * Count Type IngredientTypeCountOutputType
   */

  export type IngredientTypeCountOutputType = {
    touch: number
    archivedTouch: number
    ingredient: number
    ingredientPreference: number
  }

  export type IngredientTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    touch?: boolean | IngredientTypeCountOutputTypeCountTouchArgs
    archivedTouch?: boolean | IngredientTypeCountOutputTypeCountArchivedTouchArgs
    ingredient?: boolean | IngredientTypeCountOutputTypeCountIngredientArgs
    ingredientPreference?: boolean | IngredientTypeCountOutputTypeCountIngredientPreferenceArgs
  }

  // Custom InputTypes

  /**
   * IngredientTypeCountOutputType without action
   */
  export type IngredientTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientTypeCountOutputType
     */
    select?: IngredientTypeCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * IngredientTypeCountOutputType without action
   */
  export type IngredientTypeCountOutputTypeCountTouchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TouchWhereInput
  }


  /**
   * IngredientTypeCountOutputType without action
   */
  export type IngredientTypeCountOutputTypeCountArchivedTouchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArchivedTouchWhereInput
  }


  /**
   * IngredientTypeCountOutputType without action
   */
  export type IngredientTypeCountOutputTypeCountIngredientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngredientWhereInput
  }


  /**
   * IngredientTypeCountOutputType without action
   */
  export type IngredientTypeCountOutputTypeCountIngredientPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngredientPreferenceWhereInput
  }



  /**
   * Count Type IngredientCountOutputType
   */

  export type IngredientCountOutputType = {
    touch: number
    archivedTouch: number
    ingredientStorage: number
    ingredientUser: number
    ingredientPreference: number
    crewIngredient: number
  }

  export type IngredientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    touch?: boolean | IngredientCountOutputTypeCountTouchArgs
    archivedTouch?: boolean | IngredientCountOutputTypeCountArchivedTouchArgs
    ingredientStorage?: boolean | IngredientCountOutputTypeCountIngredientStorageArgs
    ingredientUser?: boolean | IngredientCountOutputTypeCountIngredientUserArgs
    ingredientPreference?: boolean | IngredientCountOutputTypeCountIngredientPreferenceArgs
    crewIngredient?: boolean | IngredientCountOutputTypeCountCrewIngredientArgs
  }

  // Custom InputTypes

  /**
   * IngredientCountOutputType without action
   */
  export type IngredientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientCountOutputType
     */
    select?: IngredientCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * IngredientCountOutputType without action
   */
  export type IngredientCountOutputTypeCountTouchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TouchWhereInput
  }


  /**
   * IngredientCountOutputType without action
   */
  export type IngredientCountOutputTypeCountArchivedTouchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArchivedTouchWhereInput
  }


  /**
   * IngredientCountOutputType without action
   */
  export type IngredientCountOutputTypeCountIngredientStorageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngredientStorageWhereInput
  }


  /**
   * IngredientCountOutputType without action
   */
  export type IngredientCountOutputTypeCountIngredientUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngredientUserWhereInput
  }


  /**
   * IngredientCountOutputType without action
   */
  export type IngredientCountOutputTypeCountIngredientPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngredientPreferenceWhereInput
  }


  /**
   * IngredientCountOutputType without action
   */
  export type IngredientCountOutputTypeCountCrewIngredientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewIngredientWhereInput
  }



  /**
   * Count Type InventoryCountOutputType
   */

  export type InventoryCountOutputType = {
    inventoryStorage: number
    inventoryUser: number
    crewInventory: number
  }

  export type InventoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryStorage?: boolean | InventoryCountOutputTypeCountInventoryStorageArgs
    inventoryUser?: boolean | InventoryCountOutputTypeCountInventoryUserArgs
    crewInventory?: boolean | InventoryCountOutputTypeCountCrewInventoryArgs
  }

  // Custom InputTypes

  /**
   * InventoryCountOutputType without action
   */
  export type InventoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryCountOutputType
     */
    select?: InventoryCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * InventoryCountOutputType without action
   */
  export type InventoryCountOutputTypeCountInventoryStorageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryStorageWhereInput
  }


  /**
   * InventoryCountOutputType without action
   */
  export type InventoryCountOutputTypeCountInventoryUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryUserWhereInput
  }


  /**
   * InventoryCountOutputType without action
   */
  export type InventoryCountOutputTypeCountCrewInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewInventoryWhereInput
  }



  /**
   * Count Type StorageCountOutputType
   */

  export type StorageCountOutputType = {
    inventoryStorage: number
    ingredientStorage: number
    storageUser: number
    crewStorage: number
  }

  export type StorageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryStorage?: boolean | StorageCountOutputTypeCountInventoryStorageArgs
    ingredientStorage?: boolean | StorageCountOutputTypeCountIngredientStorageArgs
    storageUser?: boolean | StorageCountOutputTypeCountStorageUserArgs
    crewStorage?: boolean | StorageCountOutputTypeCountCrewStorageArgs
  }

  // Custom InputTypes

  /**
   * StorageCountOutputType without action
   */
  export type StorageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageCountOutputType
     */
    select?: StorageCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * StorageCountOutputType without action
   */
  export type StorageCountOutputTypeCountInventoryStorageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryStorageWhereInput
  }


  /**
   * StorageCountOutputType without action
   */
  export type StorageCountOutputTypeCountIngredientStorageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngredientStorageWhereInput
  }


  /**
   * StorageCountOutputType without action
   */
  export type StorageCountOutputTypeCountStorageUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorageUserWhereInput
  }


  /**
   * StorageCountOutputType without action
   */
  export type StorageCountOutputTypeCountCrewStorageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewStorageWhereInput
  }



  /**
   * Count Type CrewCountOutputType
   */

  export type CrewCountOutputType = {
    crewUser: number
    crewInventory: number
    crewStorage: number
    crewIngredient: number
    crewRecipeBook: number
    crewBuild: number
  }

  export type CrewCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crewUser?: boolean | CrewCountOutputTypeCountCrewUserArgs
    crewInventory?: boolean | CrewCountOutputTypeCountCrewInventoryArgs
    crewStorage?: boolean | CrewCountOutputTypeCountCrewStorageArgs
    crewIngredient?: boolean | CrewCountOutputTypeCountCrewIngredientArgs
    crewRecipeBook?: boolean | CrewCountOutputTypeCountCrewRecipeBookArgs
    crewBuild?: boolean | CrewCountOutputTypeCountCrewBuildArgs
  }

  // Custom InputTypes

  /**
   * CrewCountOutputType without action
   */
  export type CrewCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewCountOutputType
     */
    select?: CrewCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CrewCountOutputType without action
   */
  export type CrewCountOutputTypeCountCrewUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewUserWhereInput
  }


  /**
   * CrewCountOutputType without action
   */
  export type CrewCountOutputTypeCountCrewInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewInventoryWhereInput
  }


  /**
   * CrewCountOutputType without action
   */
  export type CrewCountOutputTypeCountCrewStorageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewStorageWhereInput
  }


  /**
   * CrewCountOutputType without action
   */
  export type CrewCountOutputTypeCountCrewIngredientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewIngredientWhereInput
  }


  /**
   * CrewCountOutputType without action
   */
  export type CrewCountOutputTypeCountCrewRecipeBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewRecipeBookWhereInput
  }


  /**
   * CrewCountOutputType without action
   */
  export type CrewCountOutputTypeCountCrewBuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewBuildWhereInput
  }



  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    userName: string | null
    firstName: string | null
    lastName: string | null
    dateJoined: Date | null
    lastEdited: Date | null
    email: string | null
    password: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    userName: string | null
    firstName: string | null
    lastName: string | null
    dateJoined: Date | null
    lastEdited: Date | null
    email: string | null
    password: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    userName: number
    firstName: number
    lastName: number
    dateJoined: number
    lastEdited: number
    email: number
    password: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    userName?: true
    firstName?: true
    lastName?: true
    dateJoined?: true
    lastEdited?: true
    email?: true
    password?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    userName?: true
    firstName?: true
    lastName?: true
    dateJoined?: true
    lastEdited?: true
    email?: true
    password?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    userName?: true
    firstName?: true
    lastName?: true
    dateJoined?: true
    lastEdited?: true
    email?: true
    password?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    userName: string
    firstName: string | null
    lastName: string | null
    dateJoined: Date
    lastEdited: Date
    email: string
    password: string
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userName?: boolean
    firstName?: boolean
    lastName?: boolean
    dateJoined?: boolean
    lastEdited?: boolean
    email?: boolean
    password?: boolean
    profile?: boolean | User$profileArgs<ExtArgs>
    recipeBookUser?: boolean | User$recipeBookUserArgs<ExtArgs>
    recipeBook?: boolean | User$recipeBookArgs<ExtArgs>
    recipeBookEditedBy?: boolean | User$recipeBookEditedByArgs<ExtArgs>
    recipe?: boolean | User$recipeArgs<ExtArgs>
    recipeEditedBy?: boolean | User$recipeEditedByArgs<ExtArgs>
    buildUser?: boolean | User$buildUserArgs<ExtArgs>
    build?: boolean | User$buildArgs<ExtArgs>
    buildEditedBy?: boolean | User$buildEditedByArgs<ExtArgs>
    archivedBuild?: boolean | User$archivedBuildArgs<ExtArgs>
    crewUser?: boolean | User$crewUserArgs<ExtArgs>
    crew?: boolean | User$crewArgs<ExtArgs>
    crewEditedBy?: boolean | User$crewEditedByArgs<ExtArgs>
    ingredient?: boolean | User$ingredientArgs<ExtArgs>
    ingredientPreference?: boolean | User$ingredientPreferenceArgs<ExtArgs>
    ingredientUser?: boolean | User$ingredientUserArgs<ExtArgs>
    storageUser?: boolean | User$storageUserArgs<ExtArgs>
    storage?: boolean | User$storageArgs<ExtArgs>
    storageEditedBy?: boolean | User$storageEditedByArgs<ExtArgs>
    inventory?: boolean | User$inventoryArgs<ExtArgs>
    inventoryEditedBy?: boolean | User$inventoryEditedByArgs<ExtArgs>
    inventoryUser?: boolean | User$inventoryUserArgs<ExtArgs>
    followedBy?: boolean | User$followedByArgs<ExtArgs>
    following?: boolean | User$followingArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    userName?: boolean
    firstName?: boolean
    lastName?: boolean
    dateJoined?: boolean
    lastEdited?: boolean
    email?: boolean
    password?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | User$profileArgs<ExtArgs>
    recipeBookUser?: boolean | User$recipeBookUserArgs<ExtArgs>
    recipeBook?: boolean | User$recipeBookArgs<ExtArgs>
    recipeBookEditedBy?: boolean | User$recipeBookEditedByArgs<ExtArgs>
    recipe?: boolean | User$recipeArgs<ExtArgs>
    recipeEditedBy?: boolean | User$recipeEditedByArgs<ExtArgs>
    buildUser?: boolean | User$buildUserArgs<ExtArgs>
    build?: boolean | User$buildArgs<ExtArgs>
    buildEditedBy?: boolean | User$buildEditedByArgs<ExtArgs>
    archivedBuild?: boolean | User$archivedBuildArgs<ExtArgs>
    crewUser?: boolean | User$crewUserArgs<ExtArgs>
    crew?: boolean | User$crewArgs<ExtArgs>
    crewEditedBy?: boolean | User$crewEditedByArgs<ExtArgs>
    ingredient?: boolean | User$ingredientArgs<ExtArgs>
    ingredientPreference?: boolean | User$ingredientPreferenceArgs<ExtArgs>
    ingredientUser?: boolean | User$ingredientUserArgs<ExtArgs>
    storageUser?: boolean | User$storageUserArgs<ExtArgs>
    storage?: boolean | User$storageArgs<ExtArgs>
    storageEditedBy?: boolean | User$storageEditedByArgs<ExtArgs>
    inventory?: boolean | User$inventoryArgs<ExtArgs>
    inventoryEditedBy?: boolean | User$inventoryEditedByArgs<ExtArgs>
    inventoryUser?: boolean | User$inventoryUserArgs<ExtArgs>
    followedBy?: boolean | User$followedByArgs<ExtArgs>
    following?: boolean | User$followingArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs> | null
      recipeBookUser: Prisma.$RecipeBookUserPayload<ExtArgs>[]
      recipeBook: Prisma.$RecipeBookPayload<ExtArgs>[]
      recipeBookEditedBy: Prisma.$RecipeBookPayload<ExtArgs>[]
      recipe: Prisma.$RecipePayload<ExtArgs>[]
      recipeEditedBy: Prisma.$RecipePayload<ExtArgs>[]
      buildUser: Prisma.$BuildUserPayload<ExtArgs>[]
      build: Prisma.$BuildPayload<ExtArgs>[]
      buildEditedBy: Prisma.$BuildPayload<ExtArgs>[]
      archivedBuild: Prisma.$ArchivedBuildPayload<ExtArgs>[]
      crewUser: Prisma.$CrewUserPayload<ExtArgs>[]
      crew: Prisma.$CrewPayload<ExtArgs>[]
      crewEditedBy: Prisma.$CrewPayload<ExtArgs>[]
      ingredient: Prisma.$IngredientPayload<ExtArgs>[]
      ingredientPreference: Prisma.$IngredientPreferencePayload<ExtArgs>[]
      ingredientUser: Prisma.$IngredientUserPayload<ExtArgs>[]
      storageUser: Prisma.$StorageUserPayload<ExtArgs>[]
      storage: Prisma.$StoragePayload<ExtArgs>[]
      storageEditedBy: Prisma.$StoragePayload<ExtArgs>[]
      inventory: Prisma.$InventoryPayload<ExtArgs>[]
      inventoryEditedBy: Prisma.$InventoryPayload<ExtArgs>[]
      inventoryUser: Prisma.$InventoryUserPayload<ExtArgs>[]
      followedBy: Prisma.$FollowPayload<ExtArgs>[]
      following: Prisma.$FollowPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userName: string
      firstName: string | null
      lastName: string | null
      dateJoined: Date
      lastEdited: Date
      email: string
      password: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    profile<T extends User$profileArgs<ExtArgs> = {}>(args?: Subset<T, User$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    recipeBookUser<T extends User$recipeBookUserArgs<ExtArgs> = {}>(args?: Subset<T, User$recipeBookUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeBookUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    recipeBook<T extends User$recipeBookArgs<ExtArgs> = {}>(args?: Subset<T, User$recipeBookArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeBookPayload<ExtArgs>, T, 'findMany'> | Null>;

    recipeBookEditedBy<T extends User$recipeBookEditedByArgs<ExtArgs> = {}>(args?: Subset<T, User$recipeBookEditedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeBookPayload<ExtArgs>, T, 'findMany'> | Null>;

    recipe<T extends User$recipeArgs<ExtArgs> = {}>(args?: Subset<T, User$recipeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findMany'> | Null>;

    recipeEditedBy<T extends User$recipeEditedByArgs<ExtArgs> = {}>(args?: Subset<T, User$recipeEditedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findMany'> | Null>;

    buildUser<T extends User$buildUserArgs<ExtArgs> = {}>(args?: Subset<T, User$buildUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    build<T extends User$buildArgs<ExtArgs> = {}>(args?: Subset<T, User$buildArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'findMany'> | Null>;

    buildEditedBy<T extends User$buildEditedByArgs<ExtArgs> = {}>(args?: Subset<T, User$buildEditedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'findMany'> | Null>;

    archivedBuild<T extends User$archivedBuildArgs<ExtArgs> = {}>(args?: Subset<T, User$archivedBuildArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArchivedBuildPayload<ExtArgs>, T, 'findMany'> | Null>;

    crewUser<T extends User$crewUserArgs<ExtArgs> = {}>(args?: Subset<T, User$crewUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    crew<T extends User$crewArgs<ExtArgs> = {}>(args?: Subset<T, User$crewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, 'findMany'> | Null>;

    crewEditedBy<T extends User$crewEditedByArgs<ExtArgs> = {}>(args?: Subset<T, User$crewEditedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, 'findMany'> | Null>;

    ingredient<T extends User$ingredientArgs<ExtArgs> = {}>(args?: Subset<T, User$ingredientArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'findMany'> | Null>;

    ingredientPreference<T extends User$ingredientPreferenceArgs<ExtArgs> = {}>(args?: Subset<T, User$ingredientPreferenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientPreferencePayload<ExtArgs>, T, 'findMany'> | Null>;

    ingredientUser<T extends User$ingredientUserArgs<ExtArgs> = {}>(args?: Subset<T, User$ingredientUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    storageUser<T extends User$storageUserArgs<ExtArgs> = {}>(args?: Subset<T, User$storageUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorageUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    storage<T extends User$storageArgs<ExtArgs> = {}>(args?: Subset<T, User$storageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, 'findMany'> | Null>;

    storageEditedBy<T extends User$storageEditedByArgs<ExtArgs> = {}>(args?: Subset<T, User$storageEditedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, 'findMany'> | Null>;

    inventory<T extends User$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, User$inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    inventoryEditedBy<T extends User$inventoryEditedByArgs<ExtArgs> = {}>(args?: Subset<T, User$inventoryEditedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    inventoryUser<T extends User$inventoryUserArgs<ExtArgs> = {}>(args?: Subset<T, User$inventoryUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    followedBy<T extends User$followedByArgs<ExtArgs> = {}>(args?: Subset<T, User$followedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, 'findMany'> | Null>;

    following<T extends User$followingArgs<ExtArgs> = {}>(args?: Subset<T, User$followingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly userName: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly dateJoined: FieldRef<"User", 'DateTime'>
    readonly lastEdited: FieldRef<"User", 'DateTime'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.profile
   */
  export type User$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }


  /**
   * User.recipeBookUser
   */
  export type User$recipeBookUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     */
    select?: RecipeBookUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookUserInclude<ExtArgs> | null
    where?: RecipeBookUserWhereInput
    orderBy?: RecipeBookUserOrderByWithRelationInput | RecipeBookUserOrderByWithRelationInput[]
    cursor?: RecipeBookUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeBookUserScalarFieldEnum | RecipeBookUserScalarFieldEnum[]
  }


  /**
   * User.recipeBook
   */
  export type User$recipeBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBook
     */
    select?: RecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookInclude<ExtArgs> | null
    where?: RecipeBookWhereInput
    orderBy?: RecipeBookOrderByWithRelationInput | RecipeBookOrderByWithRelationInput[]
    cursor?: RecipeBookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeBookScalarFieldEnum | RecipeBookScalarFieldEnum[]
  }


  /**
   * User.recipeBookEditedBy
   */
  export type User$recipeBookEditedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBook
     */
    select?: RecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookInclude<ExtArgs> | null
    where?: RecipeBookWhereInput
    orderBy?: RecipeBookOrderByWithRelationInput | RecipeBookOrderByWithRelationInput[]
    cursor?: RecipeBookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeBookScalarFieldEnum | RecipeBookScalarFieldEnum[]
  }


  /**
   * User.recipe
   */
  export type User$recipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    where?: RecipeWhereInput
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    cursor?: RecipeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }


  /**
   * User.recipeEditedBy
   */
  export type User$recipeEditedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    where?: RecipeWhereInput
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    cursor?: RecipeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }


  /**
   * User.buildUser
   */
  export type User$buildUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildUser
     */
    select?: BuildUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildUserInclude<ExtArgs> | null
    where?: BuildUserWhereInput
    orderBy?: BuildUserOrderByWithRelationInput | BuildUserOrderByWithRelationInput[]
    cursor?: BuildUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuildUserScalarFieldEnum | BuildUserScalarFieldEnum[]
  }


  /**
   * User.build
   */
  export type User$buildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    where?: BuildWhereInput
    orderBy?: BuildOrderByWithRelationInput | BuildOrderByWithRelationInput[]
    cursor?: BuildWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuildScalarFieldEnum | BuildScalarFieldEnum[]
  }


  /**
   * User.buildEditedBy
   */
  export type User$buildEditedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    where?: BuildWhereInput
    orderBy?: BuildOrderByWithRelationInput | BuildOrderByWithRelationInput[]
    cursor?: BuildWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuildScalarFieldEnum | BuildScalarFieldEnum[]
  }


  /**
   * User.archivedBuild
   */
  export type User$archivedBuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedBuild
     */
    select?: ArchivedBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedBuildInclude<ExtArgs> | null
    where?: ArchivedBuildWhereInput
    orderBy?: ArchivedBuildOrderByWithRelationInput | ArchivedBuildOrderByWithRelationInput[]
    cursor?: ArchivedBuildWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArchivedBuildScalarFieldEnum | ArchivedBuildScalarFieldEnum[]
  }


  /**
   * User.crewUser
   */
  export type User$crewUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewUser
     */
    select?: CrewUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewUserInclude<ExtArgs> | null
    where?: CrewUserWhereInput
    orderBy?: CrewUserOrderByWithRelationInput | CrewUserOrderByWithRelationInput[]
    cursor?: CrewUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrewUserScalarFieldEnum | CrewUserScalarFieldEnum[]
  }


  /**
   * User.crew
   */
  export type User$crewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInclude<ExtArgs> | null
    where?: CrewWhereInput
    orderBy?: CrewOrderByWithRelationInput | CrewOrderByWithRelationInput[]
    cursor?: CrewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrewScalarFieldEnum | CrewScalarFieldEnum[]
  }


  /**
   * User.crewEditedBy
   */
  export type User$crewEditedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInclude<ExtArgs> | null
    where?: CrewWhereInput
    orderBy?: CrewOrderByWithRelationInput | CrewOrderByWithRelationInput[]
    cursor?: CrewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrewScalarFieldEnum | CrewScalarFieldEnum[]
  }


  /**
   * User.ingredient
   */
  export type User$ingredientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientInclude<ExtArgs> | null
    where?: IngredientWhereInput
    orderBy?: IngredientOrderByWithRelationInput | IngredientOrderByWithRelationInput[]
    cursor?: IngredientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IngredientScalarFieldEnum | IngredientScalarFieldEnum[]
  }


  /**
   * User.ingredientPreference
   */
  export type User$ingredientPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientPreference
     */
    select?: IngredientPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientPreferenceInclude<ExtArgs> | null
    where?: IngredientPreferenceWhereInput
    orderBy?: IngredientPreferenceOrderByWithRelationInput | IngredientPreferenceOrderByWithRelationInput[]
    cursor?: IngredientPreferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IngredientPreferenceScalarFieldEnum | IngredientPreferenceScalarFieldEnum[]
  }


  /**
   * User.ingredientUser
   */
  export type User$ingredientUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientUser
     */
    select?: IngredientUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientUserInclude<ExtArgs> | null
    where?: IngredientUserWhereInput
    orderBy?: IngredientUserOrderByWithRelationInput | IngredientUserOrderByWithRelationInput[]
    cursor?: IngredientUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IngredientUserScalarFieldEnum | IngredientUserScalarFieldEnum[]
  }


  /**
   * User.storageUser
   */
  export type User$storageUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageUser
     */
    select?: StorageUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageUserInclude<ExtArgs> | null
    where?: StorageUserWhereInput
    orderBy?: StorageUserOrderByWithRelationInput | StorageUserOrderByWithRelationInput[]
    cursor?: StorageUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StorageUserScalarFieldEnum | StorageUserScalarFieldEnum[]
  }


  /**
   * User.storage
   */
  export type User$storageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageInclude<ExtArgs> | null
    where?: StorageWhereInput
    orderBy?: StorageOrderByWithRelationInput | StorageOrderByWithRelationInput[]
    cursor?: StorageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StorageScalarFieldEnum | StorageScalarFieldEnum[]
  }


  /**
   * User.storageEditedBy
   */
  export type User$storageEditedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageInclude<ExtArgs> | null
    where?: StorageWhereInput
    orderBy?: StorageOrderByWithRelationInput | StorageOrderByWithRelationInput[]
    cursor?: StorageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StorageScalarFieldEnum | StorageScalarFieldEnum[]
  }


  /**
   * User.inventory
   */
  export type User$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    cursor?: InventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }


  /**
   * User.inventoryEditedBy
   */
  export type User$inventoryEditedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    cursor?: InventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }


  /**
   * User.inventoryUser
   */
  export type User$inventoryUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUser
     */
    select?: InventoryUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryUserInclude<ExtArgs> | null
    where?: InventoryUserWhereInput
    orderBy?: InventoryUserOrderByWithRelationInput | InventoryUserOrderByWithRelationInput[]
    cursor?: InventoryUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryUserScalarFieldEnum | InventoryUserScalarFieldEnum[]
  }


  /**
   * User.followedBy
   */
  export type User$followedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowInclude<ExtArgs> | null
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    cursor?: FollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }


  /**
   * User.following
   */
  export type User$followingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowInclude<ExtArgs> | null
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    cursor?: FollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model Follow
   */

  export type AggregateFollow = {
    _count: FollowCountAggregateOutputType | null
    _min: FollowMinAggregateOutputType | null
    _max: FollowMaxAggregateOutputType | null
  }

  export type FollowMinAggregateOutputType = {
    followedById: string | null
    followingId: string | null
    relationship: string | null
  }

  export type FollowMaxAggregateOutputType = {
    followedById: string | null
    followingId: string | null
    relationship: string | null
  }

  export type FollowCountAggregateOutputType = {
    followedById: number
    followingId: number
    relationship: number
    _all: number
  }


  export type FollowMinAggregateInputType = {
    followedById?: true
    followingId?: true
    relationship?: true
  }

  export type FollowMaxAggregateInputType = {
    followedById?: true
    followingId?: true
    relationship?: true
  }

  export type FollowCountAggregateInputType = {
    followedById?: true
    followingId?: true
    relationship?: true
    _all?: true
  }

  export type FollowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Follow to aggregate.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Follows
    **/
    _count?: true | FollowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FollowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FollowMaxAggregateInputType
  }

  export type GetFollowAggregateType<T extends FollowAggregateArgs> = {
        [P in keyof T & keyof AggregateFollow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollow[P]>
      : GetScalarType<T[P], AggregateFollow[P]>
  }




  export type FollowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithAggregationInput | FollowOrderByWithAggregationInput[]
    by: FollowScalarFieldEnum[] | FollowScalarFieldEnum
    having?: FollowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FollowCountAggregateInputType | true
    _min?: FollowMinAggregateInputType
    _max?: FollowMaxAggregateInputType
  }

  export type FollowGroupByOutputType = {
    followedById: string
    followingId: string
    relationship: string
    _count: FollowCountAggregateOutputType | null
    _min: FollowMinAggregateOutputType | null
    _max: FollowMaxAggregateOutputType | null
  }

  type GetFollowGroupByPayload<T extends FollowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FollowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FollowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowGroupByOutputType[P]>
            : GetScalarType<T[P], FollowGroupByOutputType[P]>
        }
      >
    >


  export type FollowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    followedById?: boolean
    followingId?: boolean
    relationship?: boolean
    followedBy?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follow"]>

  export type FollowSelectScalar = {
    followedById?: boolean
    followingId?: boolean
    relationship?: boolean
  }

  export type FollowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    followedBy?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $FollowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Follow"
    objects: {
      followedBy: Prisma.$UserPayload<ExtArgs>
      following: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      followedById: string
      followingId: string
      relationship: string
    }, ExtArgs["result"]["follow"]>
    composites: {}
  }


  type FollowGetPayload<S extends boolean | null | undefined | FollowDefaultArgs> = $Result.GetResult<Prisma.$FollowPayload, S>

  type FollowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FollowFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: FollowCountAggregateInputType | true
    }

  export interface FollowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Follow'], meta: { name: 'Follow' } }
    /**
     * Find zero or one Follow that matches the filter.
     * @param {FollowFindUniqueArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FollowFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FollowFindUniqueArgs<ExtArgs>>
    ): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Follow that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FollowFindUniqueOrThrowArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FollowFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FollowFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Follow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindFirstArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FollowFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FollowFindFirstArgs<ExtArgs>>
    ): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Follow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindFirstOrThrowArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FollowFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FollowFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Follows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Follows
     * const follows = await prisma.follow.findMany()
     * 
     * // Get first 10 Follows
     * const follows = await prisma.follow.findMany({ take: 10 })
     * 
     * // Only select the `followedById`
     * const followWithFollowedByIdOnly = await prisma.follow.findMany({ select: { followedById: true } })
     * 
    **/
    findMany<T extends FollowFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FollowFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Follow.
     * @param {FollowCreateArgs} args - Arguments to create a Follow.
     * @example
     * // Create one Follow
     * const Follow = await prisma.follow.create({
     *   data: {
     *     // ... data to create a Follow
     *   }
     * })
     * 
    **/
    create<T extends FollowCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FollowCreateArgs<ExtArgs>>
    ): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Follows.
     *     @param {FollowCreateManyArgs} args - Arguments to create many Follows.
     *     @example
     *     // Create many Follows
     *     const follow = await prisma.follow.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FollowCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FollowCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Follow.
     * @param {FollowDeleteArgs} args - Arguments to delete one Follow.
     * @example
     * // Delete one Follow
     * const Follow = await prisma.follow.delete({
     *   where: {
     *     // ... filter to delete one Follow
     *   }
     * })
     * 
    **/
    delete<T extends FollowDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FollowDeleteArgs<ExtArgs>>
    ): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Follow.
     * @param {FollowUpdateArgs} args - Arguments to update one Follow.
     * @example
     * // Update one Follow
     * const follow = await prisma.follow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FollowUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FollowUpdateArgs<ExtArgs>>
    ): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Follows.
     * @param {FollowDeleteManyArgs} args - Arguments to filter Follows to delete.
     * @example
     * // Delete a few Follows
     * const { count } = await prisma.follow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FollowDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FollowDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Follows
     * const follow = await prisma.follow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FollowUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FollowUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Follow.
     * @param {FollowUpsertArgs} args - Arguments to update or create a Follow.
     * @example
     * // Update or create a Follow
     * const follow = await prisma.follow.upsert({
     *   create: {
     *     // ... data to create a Follow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Follow we want to update
     *   }
     * })
    **/
    upsert<T extends FollowUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FollowUpsertArgs<ExtArgs>>
    ): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowCountArgs} args - Arguments to filter Follows to count.
     * @example
     * // Count the number of Follows
     * const count = await prisma.follow.count({
     *   where: {
     *     // ... the filter for the Follows we want to count
     *   }
     * })
    **/
    count<T extends FollowCountArgs>(
      args?: Subset<T, FollowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Follow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FollowAggregateArgs>(args: Subset<T, FollowAggregateArgs>): Prisma.PrismaPromise<GetFollowAggregateType<T>>

    /**
     * Group by Follow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FollowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FollowGroupByArgs['orderBy'] }
        : { orderBy?: FollowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FollowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFollowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Follow model
   */
  readonly fields: FollowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Follow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FollowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    followedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    following<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Follow model
   */ 
  interface FollowFieldRefs {
    readonly followedById: FieldRef<"Follow", 'String'>
    readonly followingId: FieldRef<"Follow", 'String'>
    readonly relationship: FieldRef<"Follow", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Follow findUnique
   */
  export type FollowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where: FollowWhereUniqueInput
  }


  /**
   * Follow findUniqueOrThrow
   */
  export type FollowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where: FollowWhereUniqueInput
  }


  /**
   * Follow findFirst
   */
  export type FollowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Follows.
     */
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }


  /**
   * Follow findFirstOrThrow
   */
  export type FollowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Follows.
     */
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }


  /**
   * Follow findMany
   */
  export type FollowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follows to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }


  /**
   * Follow create
   */
  export type FollowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The data needed to create a Follow.
     */
    data: XOR<FollowCreateInput, FollowUncheckedCreateInput>
  }


  /**
   * Follow createMany
   */
  export type FollowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Follows.
     */
    data: FollowCreateManyInput | FollowCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Follow update
   */
  export type FollowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The data needed to update a Follow.
     */
    data: XOR<FollowUpdateInput, FollowUncheckedUpdateInput>
    /**
     * Choose, which Follow to update.
     */
    where: FollowWhereUniqueInput
  }


  /**
   * Follow updateMany
   */
  export type FollowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Follows.
     */
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyInput>
    /**
     * Filter which Follows to update
     */
    where?: FollowWhereInput
  }


  /**
   * Follow upsert
   */
  export type FollowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The filter to search for the Follow to update in case it exists.
     */
    where: FollowWhereUniqueInput
    /**
     * In case the Follow found by the `where` argument doesn't exist, create a new Follow with this data.
     */
    create: XOR<FollowCreateInput, FollowUncheckedCreateInput>
    /**
     * In case the Follow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FollowUpdateInput, FollowUncheckedUpdateInput>
  }


  /**
   * Follow delete
   */
  export type FollowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter which Follow to delete.
     */
    where: FollowWhereUniqueInput
  }


  /**
   * Follow deleteMany
   */
  export type FollowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Follows to delete
     */
    where?: FollowWhereInput
  }


  /**
   * Follow without action
   */
  export type FollowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowInclude<ExtArgs> | null
  }



  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    photo: string | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    photo: string | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    userId: number
    photo: number
    _all: number
  }


  export type ProfileMinAggregateInputType = {
    id?: true
    userId?: true
    photo?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    photo?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    userId?: true
    photo?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    userId: string
    photo: string
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    photo?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    photo?: boolean
  }

  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      photo: string
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }


  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProfileFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>
    ): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Profile that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProfileFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>
    ): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProfileFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
    **/
    create<T extends ProfileCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>
    ): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Profiles.
     *     @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     *     @example
     *     // Create many Profiles
     *     const profile = await prisma.profile.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProfileCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
    **/
    delete<T extends ProfileDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>
    ): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProfileUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>
    ): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProfileDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProfileUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
    **/
    upsert<T extends ProfileUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>
    ): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Profile model
   */ 
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'String'>
    readonly userId: FieldRef<"Profile", 'String'>
    readonly photo: FieldRef<"Profile", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }


  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }


  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }


  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }


  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }


  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }


  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }


  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
  }


  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }


  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }


  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
  }


  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfileInclude<ExtArgs> | null
  }



  /**
   * Model RecipeBook
   */

  export type AggregateRecipeBook = {
    _count: RecipeBookCountAggregateOutputType | null
    _min: RecipeBookMinAggregateOutputType | null
    _max: RecipeBookMaxAggregateOutputType | null
  }

  export type RecipeBookMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
  }

  export type RecipeBookMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
  }

  export type RecipeBookCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    editedAt: number
    createdById: number
    editedById: number
    _all: number
  }


  export type RecipeBookMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
  }

  export type RecipeBookMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
  }

  export type RecipeBookCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
    _all?: true
  }

  export type RecipeBookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeBook to aggregate.
     */
    where?: RecipeBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBooks to fetch.
     */
    orderBy?: RecipeBookOrderByWithRelationInput | RecipeBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecipeBooks
    **/
    _count?: true | RecipeBookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeBookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeBookMaxAggregateInputType
  }

  export type GetRecipeBookAggregateType<T extends RecipeBookAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipeBook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipeBook[P]>
      : GetScalarType<T[P], AggregateRecipeBook[P]>
  }




  export type RecipeBookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeBookWhereInput
    orderBy?: RecipeBookOrderByWithAggregationInput | RecipeBookOrderByWithAggregationInput[]
    by: RecipeBookScalarFieldEnum[] | RecipeBookScalarFieldEnum
    having?: RecipeBookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeBookCountAggregateInputType | true
    _min?: RecipeBookMinAggregateInputType
    _max?: RecipeBookMaxAggregateInputType
  }

  export type RecipeBookGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    editedAt: Date
    createdById: string | null
    editedById: string | null
    _count: RecipeBookCountAggregateOutputType | null
    _min: RecipeBookMinAggregateOutputType | null
    _max: RecipeBookMaxAggregateOutputType | null
  }

  type GetRecipeBookGroupByPayload<T extends RecipeBookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeBookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeBookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeBookGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeBookGroupByOutputType[P]>
        }
      >
    >


  export type RecipeBookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    editedAt?: boolean
    createdById?: boolean
    editedById?: boolean
    createdBy?: boolean | RecipeBook$createdByArgs<ExtArgs>
    editedBy?: boolean | RecipeBook$editedByArgs<ExtArgs>
    recipeBookBuild?: boolean | RecipeBook$recipeBookBuildArgs<ExtArgs>
    recipeBookUser?: boolean | RecipeBook$recipeBookUserArgs<ExtArgs>
    crewRecipeBook?: boolean | RecipeBook$crewRecipeBookArgs<ExtArgs>
    _count?: boolean | RecipeBookCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeBook"]>

  export type RecipeBookSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    editedAt?: boolean
    createdById?: boolean
    editedById?: boolean
  }

  export type RecipeBookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | RecipeBook$createdByArgs<ExtArgs>
    editedBy?: boolean | RecipeBook$editedByArgs<ExtArgs>
    recipeBookBuild?: boolean | RecipeBook$recipeBookBuildArgs<ExtArgs>
    recipeBookUser?: boolean | RecipeBook$recipeBookUserArgs<ExtArgs>
    crewRecipeBook?: boolean | RecipeBook$crewRecipeBookArgs<ExtArgs>
    _count?: boolean | RecipeBookCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $RecipeBookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecipeBook"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      editedBy: Prisma.$UserPayload<ExtArgs> | null
      recipeBookBuild: Prisma.$RecipeBookBuildPayload<ExtArgs>[]
      recipeBookUser: Prisma.$RecipeBookUserPayload<ExtArgs>[]
      crewRecipeBook: Prisma.$CrewRecipeBookPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      editedAt: Date
      createdById: string | null
      editedById: string | null
    }, ExtArgs["result"]["recipeBook"]>
    composites: {}
  }


  type RecipeBookGetPayload<S extends boolean | null | undefined | RecipeBookDefaultArgs> = $Result.GetResult<Prisma.$RecipeBookPayload, S>

  type RecipeBookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RecipeBookFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: RecipeBookCountAggregateInputType | true
    }

  export interface RecipeBookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecipeBook'], meta: { name: 'RecipeBook' } }
    /**
     * Find zero or one RecipeBook that matches the filter.
     * @param {RecipeBookFindUniqueArgs} args - Arguments to find a RecipeBook
     * @example
     * // Get one RecipeBook
     * const recipeBook = await prisma.recipeBook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RecipeBookFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookFindUniqueArgs<ExtArgs>>
    ): Prisma__RecipeBookClient<$Result.GetResult<Prisma.$RecipeBookPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RecipeBook that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RecipeBookFindUniqueOrThrowArgs} args - Arguments to find a RecipeBook
     * @example
     * // Get one RecipeBook
     * const recipeBook = await prisma.recipeBook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RecipeBookFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RecipeBookClient<$Result.GetResult<Prisma.$RecipeBookPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RecipeBook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookFindFirstArgs} args - Arguments to find a RecipeBook
     * @example
     * // Get one RecipeBook
     * const recipeBook = await prisma.recipeBook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RecipeBookFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookFindFirstArgs<ExtArgs>>
    ): Prisma__RecipeBookClient<$Result.GetResult<Prisma.$RecipeBookPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RecipeBook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookFindFirstOrThrowArgs} args - Arguments to find a RecipeBook
     * @example
     * // Get one RecipeBook
     * const recipeBook = await prisma.recipeBook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RecipeBookFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RecipeBookClient<$Result.GetResult<Prisma.$RecipeBookPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RecipeBooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecipeBooks
     * const recipeBooks = await prisma.recipeBook.findMany()
     * 
     * // Get first 10 RecipeBooks
     * const recipeBooks = await prisma.recipeBook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeBookWithIdOnly = await prisma.recipeBook.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RecipeBookFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeBookPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RecipeBook.
     * @param {RecipeBookCreateArgs} args - Arguments to create a RecipeBook.
     * @example
     * // Create one RecipeBook
     * const RecipeBook = await prisma.recipeBook.create({
     *   data: {
     *     // ... data to create a RecipeBook
     *   }
     * })
     * 
    **/
    create<T extends RecipeBookCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookCreateArgs<ExtArgs>>
    ): Prisma__RecipeBookClient<$Result.GetResult<Prisma.$RecipeBookPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RecipeBooks.
     *     @param {RecipeBookCreateManyArgs} args - Arguments to create many RecipeBooks.
     *     @example
     *     // Create many RecipeBooks
     *     const recipeBook = await prisma.recipeBook.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RecipeBookCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RecipeBook.
     * @param {RecipeBookDeleteArgs} args - Arguments to delete one RecipeBook.
     * @example
     * // Delete one RecipeBook
     * const RecipeBook = await prisma.recipeBook.delete({
     *   where: {
     *     // ... filter to delete one RecipeBook
     *   }
     * })
     * 
    **/
    delete<T extends RecipeBookDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookDeleteArgs<ExtArgs>>
    ): Prisma__RecipeBookClient<$Result.GetResult<Prisma.$RecipeBookPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RecipeBook.
     * @param {RecipeBookUpdateArgs} args - Arguments to update one RecipeBook.
     * @example
     * // Update one RecipeBook
     * const recipeBook = await prisma.recipeBook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RecipeBookUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookUpdateArgs<ExtArgs>>
    ): Prisma__RecipeBookClient<$Result.GetResult<Prisma.$RecipeBookPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RecipeBooks.
     * @param {RecipeBookDeleteManyArgs} args - Arguments to filter RecipeBooks to delete.
     * @example
     * // Delete a few RecipeBooks
     * const { count } = await prisma.recipeBook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RecipeBookDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecipeBooks
     * const recipeBook = await prisma.recipeBook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RecipeBookUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RecipeBook.
     * @param {RecipeBookUpsertArgs} args - Arguments to update or create a RecipeBook.
     * @example
     * // Update or create a RecipeBook
     * const recipeBook = await prisma.recipeBook.upsert({
     *   create: {
     *     // ... data to create a RecipeBook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecipeBook we want to update
     *   }
     * })
    **/
    upsert<T extends RecipeBookUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookUpsertArgs<ExtArgs>>
    ): Prisma__RecipeBookClient<$Result.GetResult<Prisma.$RecipeBookPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RecipeBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookCountArgs} args - Arguments to filter RecipeBooks to count.
     * @example
     * // Count the number of RecipeBooks
     * const count = await prisma.recipeBook.count({
     *   where: {
     *     // ... the filter for the RecipeBooks we want to count
     *   }
     * })
    **/
    count<T extends RecipeBookCountArgs>(
      args?: Subset<T, RecipeBookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeBookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecipeBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeBookAggregateArgs>(args: Subset<T, RecipeBookAggregateArgs>): Prisma.PrismaPromise<GetRecipeBookAggregateType<T>>

    /**
     * Group by RecipeBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeBookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeBookGroupByArgs['orderBy'] }
        : { orderBy?: RecipeBookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeBookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeBookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecipeBook model
   */
  readonly fields: RecipeBookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecipeBook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeBookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    createdBy<T extends RecipeBook$createdByArgs<ExtArgs> = {}>(args?: Subset<T, RecipeBook$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    editedBy<T extends RecipeBook$editedByArgs<ExtArgs> = {}>(args?: Subset<T, RecipeBook$editedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    recipeBookBuild<T extends RecipeBook$recipeBookBuildArgs<ExtArgs> = {}>(args?: Subset<T, RecipeBook$recipeBookBuildArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeBookBuildPayload<ExtArgs>, T, 'findMany'> | Null>;

    recipeBookUser<T extends RecipeBook$recipeBookUserArgs<ExtArgs> = {}>(args?: Subset<T, RecipeBook$recipeBookUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeBookUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    crewRecipeBook<T extends RecipeBook$crewRecipeBookArgs<ExtArgs> = {}>(args?: Subset<T, RecipeBook$crewRecipeBookArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewRecipeBookPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RecipeBook model
   */ 
  interface RecipeBookFieldRefs {
    readonly id: FieldRef<"RecipeBook", 'String'>
    readonly name: FieldRef<"RecipeBook", 'String'>
    readonly description: FieldRef<"RecipeBook", 'String'>
    readonly createdAt: FieldRef<"RecipeBook", 'DateTime'>
    readonly editedAt: FieldRef<"RecipeBook", 'DateTime'>
    readonly createdById: FieldRef<"RecipeBook", 'String'>
    readonly editedById: FieldRef<"RecipeBook", 'String'>
  }
    

  // Custom InputTypes

  /**
   * RecipeBook findUnique
   */
  export type RecipeBookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBook
     */
    select?: RecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookInclude<ExtArgs> | null
    /**
     * Filter, which RecipeBook to fetch.
     */
    where: RecipeBookWhereUniqueInput
  }


  /**
   * RecipeBook findUniqueOrThrow
   */
  export type RecipeBookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBook
     */
    select?: RecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookInclude<ExtArgs> | null
    /**
     * Filter, which RecipeBook to fetch.
     */
    where: RecipeBookWhereUniqueInput
  }


  /**
   * RecipeBook findFirst
   */
  export type RecipeBookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBook
     */
    select?: RecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookInclude<ExtArgs> | null
    /**
     * Filter, which RecipeBook to fetch.
     */
    where?: RecipeBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBooks to fetch.
     */
    orderBy?: RecipeBookOrderByWithRelationInput | RecipeBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeBooks.
     */
    cursor?: RecipeBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeBooks.
     */
    distinct?: RecipeBookScalarFieldEnum | RecipeBookScalarFieldEnum[]
  }


  /**
   * RecipeBook findFirstOrThrow
   */
  export type RecipeBookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBook
     */
    select?: RecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookInclude<ExtArgs> | null
    /**
     * Filter, which RecipeBook to fetch.
     */
    where?: RecipeBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBooks to fetch.
     */
    orderBy?: RecipeBookOrderByWithRelationInput | RecipeBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeBooks.
     */
    cursor?: RecipeBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeBooks.
     */
    distinct?: RecipeBookScalarFieldEnum | RecipeBookScalarFieldEnum[]
  }


  /**
   * RecipeBook findMany
   */
  export type RecipeBookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBook
     */
    select?: RecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookInclude<ExtArgs> | null
    /**
     * Filter, which RecipeBooks to fetch.
     */
    where?: RecipeBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBooks to fetch.
     */
    orderBy?: RecipeBookOrderByWithRelationInput | RecipeBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecipeBooks.
     */
    cursor?: RecipeBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBooks.
     */
    skip?: number
    distinct?: RecipeBookScalarFieldEnum | RecipeBookScalarFieldEnum[]
  }


  /**
   * RecipeBook create
   */
  export type RecipeBookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBook
     */
    select?: RecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookInclude<ExtArgs> | null
    /**
     * The data needed to create a RecipeBook.
     */
    data: XOR<RecipeBookCreateInput, RecipeBookUncheckedCreateInput>
  }


  /**
   * RecipeBook createMany
   */
  export type RecipeBookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecipeBooks.
     */
    data: RecipeBookCreateManyInput | RecipeBookCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RecipeBook update
   */
  export type RecipeBookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBook
     */
    select?: RecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookInclude<ExtArgs> | null
    /**
     * The data needed to update a RecipeBook.
     */
    data: XOR<RecipeBookUpdateInput, RecipeBookUncheckedUpdateInput>
    /**
     * Choose, which RecipeBook to update.
     */
    where: RecipeBookWhereUniqueInput
  }


  /**
   * RecipeBook updateMany
   */
  export type RecipeBookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecipeBooks.
     */
    data: XOR<RecipeBookUpdateManyMutationInput, RecipeBookUncheckedUpdateManyInput>
    /**
     * Filter which RecipeBooks to update
     */
    where?: RecipeBookWhereInput
  }


  /**
   * RecipeBook upsert
   */
  export type RecipeBookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBook
     */
    select?: RecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookInclude<ExtArgs> | null
    /**
     * The filter to search for the RecipeBook to update in case it exists.
     */
    where: RecipeBookWhereUniqueInput
    /**
     * In case the RecipeBook found by the `where` argument doesn't exist, create a new RecipeBook with this data.
     */
    create: XOR<RecipeBookCreateInput, RecipeBookUncheckedCreateInput>
    /**
     * In case the RecipeBook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeBookUpdateInput, RecipeBookUncheckedUpdateInput>
  }


  /**
   * RecipeBook delete
   */
  export type RecipeBookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBook
     */
    select?: RecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookInclude<ExtArgs> | null
    /**
     * Filter which RecipeBook to delete.
     */
    where: RecipeBookWhereUniqueInput
  }


  /**
   * RecipeBook deleteMany
   */
  export type RecipeBookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeBooks to delete
     */
    where?: RecipeBookWhereInput
  }


  /**
   * RecipeBook.createdBy
   */
  export type RecipeBook$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * RecipeBook.editedBy
   */
  export type RecipeBook$editedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * RecipeBook.recipeBookBuild
   */
  export type RecipeBook$recipeBookBuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     */
    select?: RecipeBookBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookBuildInclude<ExtArgs> | null
    where?: RecipeBookBuildWhereInput
    orderBy?: RecipeBookBuildOrderByWithRelationInput | RecipeBookBuildOrderByWithRelationInput[]
    cursor?: RecipeBookBuildWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeBookBuildScalarFieldEnum | RecipeBookBuildScalarFieldEnum[]
  }


  /**
   * RecipeBook.recipeBookUser
   */
  export type RecipeBook$recipeBookUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     */
    select?: RecipeBookUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookUserInclude<ExtArgs> | null
    where?: RecipeBookUserWhereInput
    orderBy?: RecipeBookUserOrderByWithRelationInput | RecipeBookUserOrderByWithRelationInput[]
    cursor?: RecipeBookUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeBookUserScalarFieldEnum | RecipeBookUserScalarFieldEnum[]
  }


  /**
   * RecipeBook.crewRecipeBook
   */
  export type RecipeBook$crewRecipeBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewRecipeBook
     */
    select?: CrewRecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewRecipeBookInclude<ExtArgs> | null
    where?: CrewRecipeBookWhereInput
    orderBy?: CrewRecipeBookOrderByWithRelationInput | CrewRecipeBookOrderByWithRelationInput[]
    cursor?: CrewRecipeBookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrewRecipeBookScalarFieldEnum | CrewRecipeBookScalarFieldEnum[]
  }


  /**
   * RecipeBook without action
   */
  export type RecipeBookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBook
     */
    select?: RecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookInclude<ExtArgs> | null
  }



  /**
   * Model RecipeBookUser
   */

  export type AggregateRecipeBookUser = {
    _count: RecipeBookUserCountAggregateOutputType | null
    _min: RecipeBookUserMinAggregateOutputType | null
    _max: RecipeBookUserMaxAggregateOutputType | null
  }

  export type RecipeBookUserMinAggregateOutputType = {
    userId: string | null
    recipeBookId: string | null
    permission: string | null
  }

  export type RecipeBookUserMaxAggregateOutputType = {
    userId: string | null
    recipeBookId: string | null
    permission: string | null
  }

  export type RecipeBookUserCountAggregateOutputType = {
    userId: number
    recipeBookId: number
    permission: number
    _all: number
  }


  export type RecipeBookUserMinAggregateInputType = {
    userId?: true
    recipeBookId?: true
    permission?: true
  }

  export type RecipeBookUserMaxAggregateInputType = {
    userId?: true
    recipeBookId?: true
    permission?: true
  }

  export type RecipeBookUserCountAggregateInputType = {
    userId?: true
    recipeBookId?: true
    permission?: true
    _all?: true
  }

  export type RecipeBookUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeBookUser to aggregate.
     */
    where?: RecipeBookUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBookUsers to fetch.
     */
    orderBy?: RecipeBookUserOrderByWithRelationInput | RecipeBookUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeBookUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBookUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBookUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecipeBookUsers
    **/
    _count?: true | RecipeBookUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeBookUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeBookUserMaxAggregateInputType
  }

  export type GetRecipeBookUserAggregateType<T extends RecipeBookUserAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipeBookUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipeBookUser[P]>
      : GetScalarType<T[P], AggregateRecipeBookUser[P]>
  }




  export type RecipeBookUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeBookUserWhereInput
    orderBy?: RecipeBookUserOrderByWithAggregationInput | RecipeBookUserOrderByWithAggregationInput[]
    by: RecipeBookUserScalarFieldEnum[] | RecipeBookUserScalarFieldEnum
    having?: RecipeBookUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeBookUserCountAggregateInputType | true
    _min?: RecipeBookUserMinAggregateInputType
    _max?: RecipeBookUserMaxAggregateInputType
  }

  export type RecipeBookUserGroupByOutputType = {
    userId: string
    recipeBookId: string
    permission: string
    _count: RecipeBookUserCountAggregateOutputType | null
    _min: RecipeBookUserMinAggregateOutputType | null
    _max: RecipeBookUserMaxAggregateOutputType | null
  }

  type GetRecipeBookUserGroupByPayload<T extends RecipeBookUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeBookUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeBookUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeBookUserGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeBookUserGroupByOutputType[P]>
        }
      >
    >


  export type RecipeBookUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    recipeBookId?: boolean
    permission?: boolean
    recipeBook?: boolean | RecipeBookDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeBookUser"]>

  export type RecipeBookUserSelectScalar = {
    userId?: boolean
    recipeBookId?: boolean
    permission?: boolean
  }

  export type RecipeBookUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipeBook?: boolean | RecipeBookDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $RecipeBookUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecipeBookUser"
    objects: {
      recipeBook: Prisma.$RecipeBookPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      recipeBookId: string
      permission: string
    }, ExtArgs["result"]["recipeBookUser"]>
    composites: {}
  }


  type RecipeBookUserGetPayload<S extends boolean | null | undefined | RecipeBookUserDefaultArgs> = $Result.GetResult<Prisma.$RecipeBookUserPayload, S>

  type RecipeBookUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RecipeBookUserFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: RecipeBookUserCountAggregateInputType | true
    }

  export interface RecipeBookUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecipeBookUser'], meta: { name: 'RecipeBookUser' } }
    /**
     * Find zero or one RecipeBookUser that matches the filter.
     * @param {RecipeBookUserFindUniqueArgs} args - Arguments to find a RecipeBookUser
     * @example
     * // Get one RecipeBookUser
     * const recipeBookUser = await prisma.recipeBookUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RecipeBookUserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookUserFindUniqueArgs<ExtArgs>>
    ): Prisma__RecipeBookUserClient<$Result.GetResult<Prisma.$RecipeBookUserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RecipeBookUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RecipeBookUserFindUniqueOrThrowArgs} args - Arguments to find a RecipeBookUser
     * @example
     * // Get one RecipeBookUser
     * const recipeBookUser = await prisma.recipeBookUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RecipeBookUserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookUserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RecipeBookUserClient<$Result.GetResult<Prisma.$RecipeBookUserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RecipeBookUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookUserFindFirstArgs} args - Arguments to find a RecipeBookUser
     * @example
     * // Get one RecipeBookUser
     * const recipeBookUser = await prisma.recipeBookUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RecipeBookUserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookUserFindFirstArgs<ExtArgs>>
    ): Prisma__RecipeBookUserClient<$Result.GetResult<Prisma.$RecipeBookUserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RecipeBookUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookUserFindFirstOrThrowArgs} args - Arguments to find a RecipeBookUser
     * @example
     * // Get one RecipeBookUser
     * const recipeBookUser = await prisma.recipeBookUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RecipeBookUserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookUserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RecipeBookUserClient<$Result.GetResult<Prisma.$RecipeBookUserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RecipeBookUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecipeBookUsers
     * const recipeBookUsers = await prisma.recipeBookUser.findMany()
     * 
     * // Get first 10 RecipeBookUsers
     * const recipeBookUsers = await prisma.recipeBookUser.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const recipeBookUserWithUserIdOnly = await prisma.recipeBookUser.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends RecipeBookUserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookUserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeBookUserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RecipeBookUser.
     * @param {RecipeBookUserCreateArgs} args - Arguments to create a RecipeBookUser.
     * @example
     * // Create one RecipeBookUser
     * const RecipeBookUser = await prisma.recipeBookUser.create({
     *   data: {
     *     // ... data to create a RecipeBookUser
     *   }
     * })
     * 
    **/
    create<T extends RecipeBookUserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookUserCreateArgs<ExtArgs>>
    ): Prisma__RecipeBookUserClient<$Result.GetResult<Prisma.$RecipeBookUserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RecipeBookUsers.
     *     @param {RecipeBookUserCreateManyArgs} args - Arguments to create many RecipeBookUsers.
     *     @example
     *     // Create many RecipeBookUsers
     *     const recipeBookUser = await prisma.recipeBookUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RecipeBookUserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookUserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RecipeBookUser.
     * @param {RecipeBookUserDeleteArgs} args - Arguments to delete one RecipeBookUser.
     * @example
     * // Delete one RecipeBookUser
     * const RecipeBookUser = await prisma.recipeBookUser.delete({
     *   where: {
     *     // ... filter to delete one RecipeBookUser
     *   }
     * })
     * 
    **/
    delete<T extends RecipeBookUserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookUserDeleteArgs<ExtArgs>>
    ): Prisma__RecipeBookUserClient<$Result.GetResult<Prisma.$RecipeBookUserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RecipeBookUser.
     * @param {RecipeBookUserUpdateArgs} args - Arguments to update one RecipeBookUser.
     * @example
     * // Update one RecipeBookUser
     * const recipeBookUser = await prisma.recipeBookUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RecipeBookUserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookUserUpdateArgs<ExtArgs>>
    ): Prisma__RecipeBookUserClient<$Result.GetResult<Prisma.$RecipeBookUserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RecipeBookUsers.
     * @param {RecipeBookUserDeleteManyArgs} args - Arguments to filter RecipeBookUsers to delete.
     * @example
     * // Delete a few RecipeBookUsers
     * const { count } = await prisma.recipeBookUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RecipeBookUserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookUserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeBookUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecipeBookUsers
     * const recipeBookUser = await prisma.recipeBookUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RecipeBookUserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookUserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RecipeBookUser.
     * @param {RecipeBookUserUpsertArgs} args - Arguments to update or create a RecipeBookUser.
     * @example
     * // Update or create a RecipeBookUser
     * const recipeBookUser = await prisma.recipeBookUser.upsert({
     *   create: {
     *     // ... data to create a RecipeBookUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecipeBookUser we want to update
     *   }
     * })
    **/
    upsert<T extends RecipeBookUserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookUserUpsertArgs<ExtArgs>>
    ): Prisma__RecipeBookUserClient<$Result.GetResult<Prisma.$RecipeBookUserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RecipeBookUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookUserCountArgs} args - Arguments to filter RecipeBookUsers to count.
     * @example
     * // Count the number of RecipeBookUsers
     * const count = await prisma.recipeBookUser.count({
     *   where: {
     *     // ... the filter for the RecipeBookUsers we want to count
     *   }
     * })
    **/
    count<T extends RecipeBookUserCountArgs>(
      args?: Subset<T, RecipeBookUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeBookUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecipeBookUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeBookUserAggregateArgs>(args: Subset<T, RecipeBookUserAggregateArgs>): Prisma.PrismaPromise<GetRecipeBookUserAggregateType<T>>

    /**
     * Group by RecipeBookUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeBookUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeBookUserGroupByArgs['orderBy'] }
        : { orderBy?: RecipeBookUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeBookUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeBookUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecipeBookUser model
   */
  readonly fields: RecipeBookUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecipeBookUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeBookUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    recipeBook<T extends RecipeBookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeBookDefaultArgs<ExtArgs>>): Prisma__RecipeBookClient<$Result.GetResult<Prisma.$RecipeBookPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RecipeBookUser model
   */ 
  interface RecipeBookUserFieldRefs {
    readonly userId: FieldRef<"RecipeBookUser", 'String'>
    readonly recipeBookId: FieldRef<"RecipeBookUser", 'String'>
    readonly permission: FieldRef<"RecipeBookUser", 'String'>
  }
    

  // Custom InputTypes

  /**
   * RecipeBookUser findUnique
   */
  export type RecipeBookUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     */
    select?: RecipeBookUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookUserInclude<ExtArgs> | null
    /**
     * Filter, which RecipeBookUser to fetch.
     */
    where: RecipeBookUserWhereUniqueInput
  }


  /**
   * RecipeBookUser findUniqueOrThrow
   */
  export type RecipeBookUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     */
    select?: RecipeBookUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookUserInclude<ExtArgs> | null
    /**
     * Filter, which RecipeBookUser to fetch.
     */
    where: RecipeBookUserWhereUniqueInput
  }


  /**
   * RecipeBookUser findFirst
   */
  export type RecipeBookUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     */
    select?: RecipeBookUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookUserInclude<ExtArgs> | null
    /**
     * Filter, which RecipeBookUser to fetch.
     */
    where?: RecipeBookUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBookUsers to fetch.
     */
    orderBy?: RecipeBookUserOrderByWithRelationInput | RecipeBookUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeBookUsers.
     */
    cursor?: RecipeBookUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBookUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBookUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeBookUsers.
     */
    distinct?: RecipeBookUserScalarFieldEnum | RecipeBookUserScalarFieldEnum[]
  }


  /**
   * RecipeBookUser findFirstOrThrow
   */
  export type RecipeBookUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     */
    select?: RecipeBookUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookUserInclude<ExtArgs> | null
    /**
     * Filter, which RecipeBookUser to fetch.
     */
    where?: RecipeBookUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBookUsers to fetch.
     */
    orderBy?: RecipeBookUserOrderByWithRelationInput | RecipeBookUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeBookUsers.
     */
    cursor?: RecipeBookUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBookUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBookUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeBookUsers.
     */
    distinct?: RecipeBookUserScalarFieldEnum | RecipeBookUserScalarFieldEnum[]
  }


  /**
   * RecipeBookUser findMany
   */
  export type RecipeBookUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     */
    select?: RecipeBookUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookUserInclude<ExtArgs> | null
    /**
     * Filter, which RecipeBookUsers to fetch.
     */
    where?: RecipeBookUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBookUsers to fetch.
     */
    orderBy?: RecipeBookUserOrderByWithRelationInput | RecipeBookUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecipeBookUsers.
     */
    cursor?: RecipeBookUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBookUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBookUsers.
     */
    skip?: number
    distinct?: RecipeBookUserScalarFieldEnum | RecipeBookUserScalarFieldEnum[]
  }


  /**
   * RecipeBookUser create
   */
  export type RecipeBookUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     */
    select?: RecipeBookUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookUserInclude<ExtArgs> | null
    /**
     * The data needed to create a RecipeBookUser.
     */
    data: XOR<RecipeBookUserCreateInput, RecipeBookUserUncheckedCreateInput>
  }


  /**
   * RecipeBookUser createMany
   */
  export type RecipeBookUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecipeBookUsers.
     */
    data: RecipeBookUserCreateManyInput | RecipeBookUserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RecipeBookUser update
   */
  export type RecipeBookUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     */
    select?: RecipeBookUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookUserInclude<ExtArgs> | null
    /**
     * The data needed to update a RecipeBookUser.
     */
    data: XOR<RecipeBookUserUpdateInput, RecipeBookUserUncheckedUpdateInput>
    /**
     * Choose, which RecipeBookUser to update.
     */
    where: RecipeBookUserWhereUniqueInput
  }


  /**
   * RecipeBookUser updateMany
   */
  export type RecipeBookUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecipeBookUsers.
     */
    data: XOR<RecipeBookUserUpdateManyMutationInput, RecipeBookUserUncheckedUpdateManyInput>
    /**
     * Filter which RecipeBookUsers to update
     */
    where?: RecipeBookUserWhereInput
  }


  /**
   * RecipeBookUser upsert
   */
  export type RecipeBookUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     */
    select?: RecipeBookUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookUserInclude<ExtArgs> | null
    /**
     * The filter to search for the RecipeBookUser to update in case it exists.
     */
    where: RecipeBookUserWhereUniqueInput
    /**
     * In case the RecipeBookUser found by the `where` argument doesn't exist, create a new RecipeBookUser with this data.
     */
    create: XOR<RecipeBookUserCreateInput, RecipeBookUserUncheckedCreateInput>
    /**
     * In case the RecipeBookUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeBookUserUpdateInput, RecipeBookUserUncheckedUpdateInput>
  }


  /**
   * RecipeBookUser delete
   */
  export type RecipeBookUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     */
    select?: RecipeBookUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookUserInclude<ExtArgs> | null
    /**
     * Filter which RecipeBookUser to delete.
     */
    where: RecipeBookUserWhereUniqueInput
  }


  /**
   * RecipeBookUser deleteMany
   */
  export type RecipeBookUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeBookUsers to delete
     */
    where?: RecipeBookUserWhereInput
  }


  /**
   * RecipeBookUser without action
   */
  export type RecipeBookUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookUser
     */
    select?: RecipeBookUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookUserInclude<ExtArgs> | null
  }



  /**
   * Model Build
   */

  export type AggregateBuild = {
    _count: BuildCountAggregateOutputType | null
    _avg: BuildAvgAggregateOutputType | null
    _sum: BuildSumAggregateOutputType | null
    _min: BuildMinAggregateOutputType | null
    _max: BuildMaxAggregateOutputType | null
  }

  export type BuildAvgAggregateOutputType = {
    version: number | null
  }

  export type BuildSumAggregateOutputType = {
    version: number | null
  }

  export type BuildMinAggregateOutputType = {
    id: string | null
    buildName: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
    recipeId: string | null
    instructions: string | null
    notes: string | null
    glassware: string | null
    ice: string | null
    version: number | null
  }

  export type BuildMaxAggregateOutputType = {
    id: string | null
    buildName: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
    recipeId: string | null
    instructions: string | null
    notes: string | null
    glassware: string | null
    ice: string | null
    version: number | null
  }

  export type BuildCountAggregateOutputType = {
    id: number
    buildName: number
    createdAt: number
    editedAt: number
    createdById: number
    editedById: number
    recipeId: number
    instructions: number
    notes: number
    glassware: number
    ice: number
    version: number
    _all: number
  }


  export type BuildAvgAggregateInputType = {
    version?: true
  }

  export type BuildSumAggregateInputType = {
    version?: true
  }

  export type BuildMinAggregateInputType = {
    id?: true
    buildName?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
    recipeId?: true
    instructions?: true
    notes?: true
    glassware?: true
    ice?: true
    version?: true
  }

  export type BuildMaxAggregateInputType = {
    id?: true
    buildName?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
    recipeId?: true
    instructions?: true
    notes?: true
    glassware?: true
    ice?: true
    version?: true
  }

  export type BuildCountAggregateInputType = {
    id?: true
    buildName?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
    recipeId?: true
    instructions?: true
    notes?: true
    glassware?: true
    ice?: true
    version?: true
    _all?: true
  }

  export type BuildAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Build to aggregate.
     */
    where?: BuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Builds to fetch.
     */
    orderBy?: BuildOrderByWithRelationInput | BuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Builds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Builds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Builds
    **/
    _count?: true | BuildCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BuildAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BuildSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuildMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuildMaxAggregateInputType
  }

  export type GetBuildAggregateType<T extends BuildAggregateArgs> = {
        [P in keyof T & keyof AggregateBuild]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuild[P]>
      : GetScalarType<T[P], AggregateBuild[P]>
  }




  export type BuildGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildWhereInput
    orderBy?: BuildOrderByWithAggregationInput | BuildOrderByWithAggregationInput[]
    by: BuildScalarFieldEnum[] | BuildScalarFieldEnum
    having?: BuildScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuildCountAggregateInputType | true
    _avg?: BuildAvgAggregateInputType
    _sum?: BuildSumAggregateInputType
    _min?: BuildMinAggregateInputType
    _max?: BuildMaxAggregateInputType
  }

  export type BuildGroupByOutputType = {
    id: string
    buildName: string
    createdAt: Date
    editedAt: Date
    createdById: string | null
    editedById: string | null
    recipeId: string | null
    instructions: string | null
    notes: string | null
    glassware: string | null
    ice: string | null
    version: number
    _count: BuildCountAggregateOutputType | null
    _avg: BuildAvgAggregateOutputType | null
    _sum: BuildSumAggregateOutputType | null
    _min: BuildMinAggregateOutputType | null
    _max: BuildMaxAggregateOutputType | null
  }

  type GetBuildGroupByPayload<T extends BuildGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuildGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuildGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuildGroupByOutputType[P]>
            : GetScalarType<T[P], BuildGroupByOutputType[P]>
        }
      >
    >


  export type BuildSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    buildName?: boolean
    createdAt?: boolean
    editedAt?: boolean
    createdById?: boolean
    editedById?: boolean
    recipeId?: boolean
    instructions?: boolean
    notes?: boolean
    glassware?: boolean
    ice?: boolean
    version?: boolean
    createdBy?: boolean | Build$createdByArgs<ExtArgs>
    editedBy?: boolean | Build$editedByArgs<ExtArgs>
    recipe?: boolean | Build$recipeArgs<ExtArgs>
    touch?: boolean | Build$touchArgs<ExtArgs>
    archivedBuild?: boolean | Build$archivedBuildArgs<ExtArgs>
    RecipeBookBuild?: boolean | Build$RecipeBookBuildArgs<ExtArgs>
    buildUser?: boolean | Build$buildUserArgs<ExtArgs>
    crewBuild?: boolean | Build$crewBuildArgs<ExtArgs>
    _count?: boolean | BuildCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["build"]>

  export type BuildSelectScalar = {
    id?: boolean
    buildName?: boolean
    createdAt?: boolean
    editedAt?: boolean
    createdById?: boolean
    editedById?: boolean
    recipeId?: boolean
    instructions?: boolean
    notes?: boolean
    glassware?: boolean
    ice?: boolean
    version?: boolean
  }

  export type BuildInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Build$createdByArgs<ExtArgs>
    editedBy?: boolean | Build$editedByArgs<ExtArgs>
    recipe?: boolean | Build$recipeArgs<ExtArgs>
    touch?: boolean | Build$touchArgs<ExtArgs>
    archivedBuild?: boolean | Build$archivedBuildArgs<ExtArgs>
    RecipeBookBuild?: boolean | Build$RecipeBookBuildArgs<ExtArgs>
    buildUser?: boolean | Build$buildUserArgs<ExtArgs>
    crewBuild?: boolean | Build$crewBuildArgs<ExtArgs>
    _count?: boolean | BuildCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $BuildPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Build"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      editedBy: Prisma.$UserPayload<ExtArgs> | null
      recipe: Prisma.$RecipePayload<ExtArgs> | null
      touch: Prisma.$TouchPayload<ExtArgs>[]
      archivedBuild: Prisma.$ArchivedBuildPayload<ExtArgs>[]
      RecipeBookBuild: Prisma.$RecipeBookBuildPayload<ExtArgs>[]
      buildUser: Prisma.$BuildUserPayload<ExtArgs>[]
      crewBuild: Prisma.$CrewBuildPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      buildName: string
      createdAt: Date
      editedAt: Date
      createdById: string | null
      editedById: string | null
      recipeId: string | null
      instructions: string | null
      notes: string | null
      glassware: string | null
      ice: string | null
      version: number
    }, ExtArgs["result"]["build"]>
    composites: {}
  }


  type BuildGetPayload<S extends boolean | null | undefined | BuildDefaultArgs> = $Result.GetResult<Prisma.$BuildPayload, S>

  type BuildCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BuildFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: BuildCountAggregateInputType | true
    }

  export interface BuildDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Build'], meta: { name: 'Build' } }
    /**
     * Find zero or one Build that matches the filter.
     * @param {BuildFindUniqueArgs} args - Arguments to find a Build
     * @example
     * // Get one Build
     * const build = await prisma.build.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BuildFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BuildFindUniqueArgs<ExtArgs>>
    ): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Build that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BuildFindUniqueOrThrowArgs} args - Arguments to find a Build
     * @example
     * // Get one Build
     * const build = await prisma.build.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BuildFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Build that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildFindFirstArgs} args - Arguments to find a Build
     * @example
     * // Get one Build
     * const build = await prisma.build.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BuildFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildFindFirstArgs<ExtArgs>>
    ): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Build that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildFindFirstOrThrowArgs} args - Arguments to find a Build
     * @example
     * // Get one Build
     * const build = await prisma.build.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BuildFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Builds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Builds
     * const builds = await prisma.build.findMany()
     * 
     * // Get first 10 Builds
     * const builds = await prisma.build.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buildWithIdOnly = await prisma.build.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BuildFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Build.
     * @param {BuildCreateArgs} args - Arguments to create a Build.
     * @example
     * // Create one Build
     * const Build = await prisma.build.create({
     *   data: {
     *     // ... data to create a Build
     *   }
     * })
     * 
    **/
    create<T extends BuildCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BuildCreateArgs<ExtArgs>>
    ): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Builds.
     *     @param {BuildCreateManyArgs} args - Arguments to create many Builds.
     *     @example
     *     // Create many Builds
     *     const build = await prisma.build.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BuildCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Build.
     * @param {BuildDeleteArgs} args - Arguments to delete one Build.
     * @example
     * // Delete one Build
     * const Build = await prisma.build.delete({
     *   where: {
     *     // ... filter to delete one Build
     *   }
     * })
     * 
    **/
    delete<T extends BuildDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BuildDeleteArgs<ExtArgs>>
    ): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Build.
     * @param {BuildUpdateArgs} args - Arguments to update one Build.
     * @example
     * // Update one Build
     * const build = await prisma.build.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BuildUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BuildUpdateArgs<ExtArgs>>
    ): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Builds.
     * @param {BuildDeleteManyArgs} args - Arguments to filter Builds to delete.
     * @example
     * // Delete a few Builds
     * const { count } = await prisma.build.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BuildDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Builds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Builds
     * const build = await prisma.build.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BuildUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BuildUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Build.
     * @param {BuildUpsertArgs} args - Arguments to update or create a Build.
     * @example
     * // Update or create a Build
     * const build = await prisma.build.upsert({
     *   create: {
     *     // ... data to create a Build
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Build we want to update
     *   }
     * })
    **/
    upsert<T extends BuildUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BuildUpsertArgs<ExtArgs>>
    ): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Builds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildCountArgs} args - Arguments to filter Builds to count.
     * @example
     * // Count the number of Builds
     * const count = await prisma.build.count({
     *   where: {
     *     // ... the filter for the Builds we want to count
     *   }
     * })
    **/
    count<T extends BuildCountArgs>(
      args?: Subset<T, BuildCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuildCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Build.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuildAggregateArgs>(args: Subset<T, BuildAggregateArgs>): Prisma.PrismaPromise<GetBuildAggregateType<T>>

    /**
     * Group by Build.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuildGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuildGroupByArgs['orderBy'] }
        : { orderBy?: BuildGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuildGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuildGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Build model
   */
  readonly fields: BuildFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Build.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuildClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    createdBy<T extends Build$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Build$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    editedBy<T extends Build$editedByArgs<ExtArgs> = {}>(args?: Subset<T, Build$editedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    recipe<T extends Build$recipeArgs<ExtArgs> = {}>(args?: Subset<T, Build$recipeArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    touch<T extends Build$touchArgs<ExtArgs> = {}>(args?: Subset<T, Build$touchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TouchPayload<ExtArgs>, T, 'findMany'> | Null>;

    archivedBuild<T extends Build$archivedBuildArgs<ExtArgs> = {}>(args?: Subset<T, Build$archivedBuildArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArchivedBuildPayload<ExtArgs>, T, 'findMany'> | Null>;

    RecipeBookBuild<T extends Build$RecipeBookBuildArgs<ExtArgs> = {}>(args?: Subset<T, Build$RecipeBookBuildArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeBookBuildPayload<ExtArgs>, T, 'findMany'> | Null>;

    buildUser<T extends Build$buildUserArgs<ExtArgs> = {}>(args?: Subset<T, Build$buildUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    crewBuild<T extends Build$crewBuildArgs<ExtArgs> = {}>(args?: Subset<T, Build$crewBuildArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewBuildPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Build model
   */ 
  interface BuildFieldRefs {
    readonly id: FieldRef<"Build", 'String'>
    readonly buildName: FieldRef<"Build", 'String'>
    readonly createdAt: FieldRef<"Build", 'DateTime'>
    readonly editedAt: FieldRef<"Build", 'DateTime'>
    readonly createdById: FieldRef<"Build", 'String'>
    readonly editedById: FieldRef<"Build", 'String'>
    readonly recipeId: FieldRef<"Build", 'String'>
    readonly instructions: FieldRef<"Build", 'String'>
    readonly notes: FieldRef<"Build", 'String'>
    readonly glassware: FieldRef<"Build", 'String'>
    readonly ice: FieldRef<"Build", 'String'>
    readonly version: FieldRef<"Build", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Build findUnique
   */
  export type BuildFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * Filter, which Build to fetch.
     */
    where: BuildWhereUniqueInput
  }


  /**
   * Build findUniqueOrThrow
   */
  export type BuildFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * Filter, which Build to fetch.
     */
    where: BuildWhereUniqueInput
  }


  /**
   * Build findFirst
   */
  export type BuildFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * Filter, which Build to fetch.
     */
    where?: BuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Builds to fetch.
     */
    orderBy?: BuildOrderByWithRelationInput | BuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Builds.
     */
    cursor?: BuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Builds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Builds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Builds.
     */
    distinct?: BuildScalarFieldEnum | BuildScalarFieldEnum[]
  }


  /**
   * Build findFirstOrThrow
   */
  export type BuildFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * Filter, which Build to fetch.
     */
    where?: BuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Builds to fetch.
     */
    orderBy?: BuildOrderByWithRelationInput | BuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Builds.
     */
    cursor?: BuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Builds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Builds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Builds.
     */
    distinct?: BuildScalarFieldEnum | BuildScalarFieldEnum[]
  }


  /**
   * Build findMany
   */
  export type BuildFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * Filter, which Builds to fetch.
     */
    where?: BuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Builds to fetch.
     */
    orderBy?: BuildOrderByWithRelationInput | BuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Builds.
     */
    cursor?: BuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Builds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Builds.
     */
    skip?: number
    distinct?: BuildScalarFieldEnum | BuildScalarFieldEnum[]
  }


  /**
   * Build create
   */
  export type BuildCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * The data needed to create a Build.
     */
    data?: XOR<BuildCreateInput, BuildUncheckedCreateInput>
  }


  /**
   * Build createMany
   */
  export type BuildCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Builds.
     */
    data: BuildCreateManyInput | BuildCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Build update
   */
  export type BuildUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * The data needed to update a Build.
     */
    data: XOR<BuildUpdateInput, BuildUncheckedUpdateInput>
    /**
     * Choose, which Build to update.
     */
    where: BuildWhereUniqueInput
  }


  /**
   * Build updateMany
   */
  export type BuildUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Builds.
     */
    data: XOR<BuildUpdateManyMutationInput, BuildUncheckedUpdateManyInput>
    /**
     * Filter which Builds to update
     */
    where?: BuildWhereInput
  }


  /**
   * Build upsert
   */
  export type BuildUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * The filter to search for the Build to update in case it exists.
     */
    where: BuildWhereUniqueInput
    /**
     * In case the Build found by the `where` argument doesn't exist, create a new Build with this data.
     */
    create: XOR<BuildCreateInput, BuildUncheckedCreateInput>
    /**
     * In case the Build was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuildUpdateInput, BuildUncheckedUpdateInput>
  }


  /**
   * Build delete
   */
  export type BuildDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * Filter which Build to delete.
     */
    where: BuildWhereUniqueInput
  }


  /**
   * Build deleteMany
   */
  export type BuildDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Builds to delete
     */
    where?: BuildWhereInput
  }


  /**
   * Build.createdBy
   */
  export type Build$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Build.editedBy
   */
  export type Build$editedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Build.recipe
   */
  export type Build$recipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    where?: RecipeWhereInput
  }


  /**
   * Build.touch
   */
  export type Build$touchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Touch
     */
    select?: TouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TouchInclude<ExtArgs> | null
    where?: TouchWhereInput
    orderBy?: TouchOrderByWithRelationInput | TouchOrderByWithRelationInput[]
    cursor?: TouchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TouchScalarFieldEnum | TouchScalarFieldEnum[]
  }


  /**
   * Build.archivedBuild
   */
  export type Build$archivedBuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedBuild
     */
    select?: ArchivedBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedBuildInclude<ExtArgs> | null
    where?: ArchivedBuildWhereInput
    orderBy?: ArchivedBuildOrderByWithRelationInput | ArchivedBuildOrderByWithRelationInput[]
    cursor?: ArchivedBuildWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArchivedBuildScalarFieldEnum | ArchivedBuildScalarFieldEnum[]
  }


  /**
   * Build.RecipeBookBuild
   */
  export type Build$RecipeBookBuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     */
    select?: RecipeBookBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookBuildInclude<ExtArgs> | null
    where?: RecipeBookBuildWhereInput
    orderBy?: RecipeBookBuildOrderByWithRelationInput | RecipeBookBuildOrderByWithRelationInput[]
    cursor?: RecipeBookBuildWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeBookBuildScalarFieldEnum | RecipeBookBuildScalarFieldEnum[]
  }


  /**
   * Build.buildUser
   */
  export type Build$buildUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildUser
     */
    select?: BuildUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildUserInclude<ExtArgs> | null
    where?: BuildUserWhereInput
    orderBy?: BuildUserOrderByWithRelationInput | BuildUserOrderByWithRelationInput[]
    cursor?: BuildUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuildUserScalarFieldEnum | BuildUserScalarFieldEnum[]
  }


  /**
   * Build.crewBuild
   */
  export type Build$crewBuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewBuild
     */
    select?: CrewBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewBuildInclude<ExtArgs> | null
    where?: CrewBuildWhereInput
    orderBy?: CrewBuildOrderByWithRelationInput | CrewBuildOrderByWithRelationInput[]
    cursor?: CrewBuildWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrewBuildScalarFieldEnum | CrewBuildScalarFieldEnum[]
  }


  /**
   * Build without action
   */
  export type BuildDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
  }



  /**
   * Model ArchivedBuild
   */

  export type AggregateArchivedBuild = {
    _count: ArchivedBuildCountAggregateOutputType | null
    _avg: ArchivedBuildAvgAggregateOutputType | null
    _sum: ArchivedBuildSumAggregateOutputType | null
    _min: ArchivedBuildMinAggregateOutputType | null
    _max: ArchivedBuildMaxAggregateOutputType | null
  }

  export type ArchivedBuildAvgAggregateOutputType = {
    version: number | null
  }

  export type ArchivedBuildSumAggregateOutputType = {
    version: number | null
  }

  export type ArchivedBuildMinAggregateOutputType = {
    id: string | null
    buildName: string | null
    createdAt: Date | null
    createdById: string | null
    buildId: string | null
    recipeId: string | null
    instructions: string | null
    notes: string | null
    glassware: string | null
    ice: string | null
    version: number | null
  }

  export type ArchivedBuildMaxAggregateOutputType = {
    id: string | null
    buildName: string | null
    createdAt: Date | null
    createdById: string | null
    buildId: string | null
    recipeId: string | null
    instructions: string | null
    notes: string | null
    glassware: string | null
    ice: string | null
    version: number | null
  }

  export type ArchivedBuildCountAggregateOutputType = {
    id: number
    buildName: number
    createdAt: number
    createdById: number
    buildId: number
    recipeId: number
    instructions: number
    notes: number
    glassware: number
    ice: number
    version: number
    _all: number
  }


  export type ArchivedBuildAvgAggregateInputType = {
    version?: true
  }

  export type ArchivedBuildSumAggregateInputType = {
    version?: true
  }

  export type ArchivedBuildMinAggregateInputType = {
    id?: true
    buildName?: true
    createdAt?: true
    createdById?: true
    buildId?: true
    recipeId?: true
    instructions?: true
    notes?: true
    glassware?: true
    ice?: true
    version?: true
  }

  export type ArchivedBuildMaxAggregateInputType = {
    id?: true
    buildName?: true
    createdAt?: true
    createdById?: true
    buildId?: true
    recipeId?: true
    instructions?: true
    notes?: true
    glassware?: true
    ice?: true
    version?: true
  }

  export type ArchivedBuildCountAggregateInputType = {
    id?: true
    buildName?: true
    createdAt?: true
    createdById?: true
    buildId?: true
    recipeId?: true
    instructions?: true
    notes?: true
    glassware?: true
    ice?: true
    version?: true
    _all?: true
  }

  export type ArchivedBuildAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArchivedBuild to aggregate.
     */
    where?: ArchivedBuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArchivedBuilds to fetch.
     */
    orderBy?: ArchivedBuildOrderByWithRelationInput | ArchivedBuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArchivedBuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArchivedBuilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArchivedBuilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ArchivedBuilds
    **/
    _count?: true | ArchivedBuildCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArchivedBuildAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArchivedBuildSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArchivedBuildMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArchivedBuildMaxAggregateInputType
  }

  export type GetArchivedBuildAggregateType<T extends ArchivedBuildAggregateArgs> = {
        [P in keyof T & keyof AggregateArchivedBuild]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArchivedBuild[P]>
      : GetScalarType<T[P], AggregateArchivedBuild[P]>
  }




  export type ArchivedBuildGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArchivedBuildWhereInput
    orderBy?: ArchivedBuildOrderByWithAggregationInput | ArchivedBuildOrderByWithAggregationInput[]
    by: ArchivedBuildScalarFieldEnum[] | ArchivedBuildScalarFieldEnum
    having?: ArchivedBuildScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArchivedBuildCountAggregateInputType | true
    _avg?: ArchivedBuildAvgAggregateInputType
    _sum?: ArchivedBuildSumAggregateInputType
    _min?: ArchivedBuildMinAggregateInputType
    _max?: ArchivedBuildMaxAggregateInputType
  }

  export type ArchivedBuildGroupByOutputType = {
    id: string
    buildName: string
    createdAt: Date
    createdById: string | null
    buildId: string
    recipeId: string | null
    instructions: string | null
    notes: string | null
    glassware: string | null
    ice: string | null
    version: number
    _count: ArchivedBuildCountAggregateOutputType | null
    _avg: ArchivedBuildAvgAggregateOutputType | null
    _sum: ArchivedBuildSumAggregateOutputType | null
    _min: ArchivedBuildMinAggregateOutputType | null
    _max: ArchivedBuildMaxAggregateOutputType | null
  }

  type GetArchivedBuildGroupByPayload<T extends ArchivedBuildGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArchivedBuildGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArchivedBuildGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArchivedBuildGroupByOutputType[P]>
            : GetScalarType<T[P], ArchivedBuildGroupByOutputType[P]>
        }
      >
    >


  export type ArchivedBuildSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    buildName?: boolean
    createdAt?: boolean
    createdById?: boolean
    buildId?: boolean
    recipeId?: boolean
    instructions?: boolean
    notes?: boolean
    glassware?: boolean
    ice?: boolean
    version?: boolean
    createdBy?: boolean | ArchivedBuild$createdByArgs<ExtArgs>
    build?: boolean | BuildDefaultArgs<ExtArgs>
    recipe?: boolean | ArchivedBuild$recipeArgs<ExtArgs>
    archivedTouch?: boolean | ArchivedBuild$archivedTouchArgs<ExtArgs>
    _count?: boolean | ArchivedBuildCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["archivedBuild"]>

  export type ArchivedBuildSelectScalar = {
    id?: boolean
    buildName?: boolean
    createdAt?: boolean
    createdById?: boolean
    buildId?: boolean
    recipeId?: boolean
    instructions?: boolean
    notes?: boolean
    glassware?: boolean
    ice?: boolean
    version?: boolean
  }

  export type ArchivedBuildInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | ArchivedBuild$createdByArgs<ExtArgs>
    build?: boolean | BuildDefaultArgs<ExtArgs>
    recipe?: boolean | ArchivedBuild$recipeArgs<ExtArgs>
    archivedTouch?: boolean | ArchivedBuild$archivedTouchArgs<ExtArgs>
    _count?: boolean | ArchivedBuildCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ArchivedBuildPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ArchivedBuild"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      build: Prisma.$BuildPayload<ExtArgs>
      recipe: Prisma.$RecipePayload<ExtArgs> | null
      archivedTouch: Prisma.$ArchivedTouchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      buildName: string
      createdAt: Date
      createdById: string | null
      buildId: string
      recipeId: string | null
      instructions: string | null
      notes: string | null
      glassware: string | null
      ice: string | null
      version: number
    }, ExtArgs["result"]["archivedBuild"]>
    composites: {}
  }


  type ArchivedBuildGetPayload<S extends boolean | null | undefined | ArchivedBuildDefaultArgs> = $Result.GetResult<Prisma.$ArchivedBuildPayload, S>

  type ArchivedBuildCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ArchivedBuildFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ArchivedBuildCountAggregateInputType | true
    }

  export interface ArchivedBuildDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ArchivedBuild'], meta: { name: 'ArchivedBuild' } }
    /**
     * Find zero or one ArchivedBuild that matches the filter.
     * @param {ArchivedBuildFindUniqueArgs} args - Arguments to find a ArchivedBuild
     * @example
     * // Get one ArchivedBuild
     * const archivedBuild = await prisma.archivedBuild.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ArchivedBuildFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ArchivedBuildFindUniqueArgs<ExtArgs>>
    ): Prisma__ArchivedBuildClient<$Result.GetResult<Prisma.$ArchivedBuildPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ArchivedBuild that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ArchivedBuildFindUniqueOrThrowArgs} args - Arguments to find a ArchivedBuild
     * @example
     * // Get one ArchivedBuild
     * const archivedBuild = await prisma.archivedBuild.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ArchivedBuildFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ArchivedBuildFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ArchivedBuildClient<$Result.GetResult<Prisma.$ArchivedBuildPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ArchivedBuild that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArchivedBuildFindFirstArgs} args - Arguments to find a ArchivedBuild
     * @example
     * // Get one ArchivedBuild
     * const archivedBuild = await prisma.archivedBuild.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ArchivedBuildFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ArchivedBuildFindFirstArgs<ExtArgs>>
    ): Prisma__ArchivedBuildClient<$Result.GetResult<Prisma.$ArchivedBuildPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ArchivedBuild that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArchivedBuildFindFirstOrThrowArgs} args - Arguments to find a ArchivedBuild
     * @example
     * // Get one ArchivedBuild
     * const archivedBuild = await prisma.archivedBuild.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ArchivedBuildFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ArchivedBuildFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ArchivedBuildClient<$Result.GetResult<Prisma.$ArchivedBuildPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ArchivedBuilds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArchivedBuildFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ArchivedBuilds
     * const archivedBuilds = await prisma.archivedBuild.findMany()
     * 
     * // Get first 10 ArchivedBuilds
     * const archivedBuilds = await prisma.archivedBuild.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const archivedBuildWithIdOnly = await prisma.archivedBuild.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ArchivedBuildFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ArchivedBuildFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArchivedBuildPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ArchivedBuild.
     * @param {ArchivedBuildCreateArgs} args - Arguments to create a ArchivedBuild.
     * @example
     * // Create one ArchivedBuild
     * const ArchivedBuild = await prisma.archivedBuild.create({
     *   data: {
     *     // ... data to create a ArchivedBuild
     *   }
     * })
     * 
    **/
    create<T extends ArchivedBuildCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ArchivedBuildCreateArgs<ExtArgs>>
    ): Prisma__ArchivedBuildClient<$Result.GetResult<Prisma.$ArchivedBuildPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ArchivedBuilds.
     *     @param {ArchivedBuildCreateManyArgs} args - Arguments to create many ArchivedBuilds.
     *     @example
     *     // Create many ArchivedBuilds
     *     const archivedBuild = await prisma.archivedBuild.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ArchivedBuildCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ArchivedBuildCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ArchivedBuild.
     * @param {ArchivedBuildDeleteArgs} args - Arguments to delete one ArchivedBuild.
     * @example
     * // Delete one ArchivedBuild
     * const ArchivedBuild = await prisma.archivedBuild.delete({
     *   where: {
     *     // ... filter to delete one ArchivedBuild
     *   }
     * })
     * 
    **/
    delete<T extends ArchivedBuildDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ArchivedBuildDeleteArgs<ExtArgs>>
    ): Prisma__ArchivedBuildClient<$Result.GetResult<Prisma.$ArchivedBuildPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ArchivedBuild.
     * @param {ArchivedBuildUpdateArgs} args - Arguments to update one ArchivedBuild.
     * @example
     * // Update one ArchivedBuild
     * const archivedBuild = await prisma.archivedBuild.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ArchivedBuildUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ArchivedBuildUpdateArgs<ExtArgs>>
    ): Prisma__ArchivedBuildClient<$Result.GetResult<Prisma.$ArchivedBuildPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ArchivedBuilds.
     * @param {ArchivedBuildDeleteManyArgs} args - Arguments to filter ArchivedBuilds to delete.
     * @example
     * // Delete a few ArchivedBuilds
     * const { count } = await prisma.archivedBuild.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ArchivedBuildDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ArchivedBuildDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArchivedBuilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArchivedBuildUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ArchivedBuilds
     * const archivedBuild = await prisma.archivedBuild.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ArchivedBuildUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ArchivedBuildUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ArchivedBuild.
     * @param {ArchivedBuildUpsertArgs} args - Arguments to update or create a ArchivedBuild.
     * @example
     * // Update or create a ArchivedBuild
     * const archivedBuild = await prisma.archivedBuild.upsert({
     *   create: {
     *     // ... data to create a ArchivedBuild
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ArchivedBuild we want to update
     *   }
     * })
    **/
    upsert<T extends ArchivedBuildUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ArchivedBuildUpsertArgs<ExtArgs>>
    ): Prisma__ArchivedBuildClient<$Result.GetResult<Prisma.$ArchivedBuildPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ArchivedBuilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArchivedBuildCountArgs} args - Arguments to filter ArchivedBuilds to count.
     * @example
     * // Count the number of ArchivedBuilds
     * const count = await prisma.archivedBuild.count({
     *   where: {
     *     // ... the filter for the ArchivedBuilds we want to count
     *   }
     * })
    **/
    count<T extends ArchivedBuildCountArgs>(
      args?: Subset<T, ArchivedBuildCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArchivedBuildCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ArchivedBuild.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArchivedBuildAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArchivedBuildAggregateArgs>(args: Subset<T, ArchivedBuildAggregateArgs>): Prisma.PrismaPromise<GetArchivedBuildAggregateType<T>>

    /**
     * Group by ArchivedBuild.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArchivedBuildGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArchivedBuildGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArchivedBuildGroupByArgs['orderBy'] }
        : { orderBy?: ArchivedBuildGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArchivedBuildGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArchivedBuildGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ArchivedBuild model
   */
  readonly fields: ArchivedBuildFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ArchivedBuild.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArchivedBuildClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    createdBy<T extends ArchivedBuild$createdByArgs<ExtArgs> = {}>(args?: Subset<T, ArchivedBuild$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    build<T extends BuildDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BuildDefaultArgs<ExtArgs>>): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    recipe<T extends ArchivedBuild$recipeArgs<ExtArgs> = {}>(args?: Subset<T, ArchivedBuild$recipeArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    archivedTouch<T extends ArchivedBuild$archivedTouchArgs<ExtArgs> = {}>(args?: Subset<T, ArchivedBuild$archivedTouchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArchivedTouchPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ArchivedBuild model
   */ 
  interface ArchivedBuildFieldRefs {
    readonly id: FieldRef<"ArchivedBuild", 'String'>
    readonly buildName: FieldRef<"ArchivedBuild", 'String'>
    readonly createdAt: FieldRef<"ArchivedBuild", 'DateTime'>
    readonly createdById: FieldRef<"ArchivedBuild", 'String'>
    readonly buildId: FieldRef<"ArchivedBuild", 'String'>
    readonly recipeId: FieldRef<"ArchivedBuild", 'String'>
    readonly instructions: FieldRef<"ArchivedBuild", 'String'>
    readonly notes: FieldRef<"ArchivedBuild", 'String'>
    readonly glassware: FieldRef<"ArchivedBuild", 'String'>
    readonly ice: FieldRef<"ArchivedBuild", 'String'>
    readonly version: FieldRef<"ArchivedBuild", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * ArchivedBuild findUnique
   */
  export type ArchivedBuildFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedBuild
     */
    select?: ArchivedBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedBuildInclude<ExtArgs> | null
    /**
     * Filter, which ArchivedBuild to fetch.
     */
    where: ArchivedBuildWhereUniqueInput
  }


  /**
   * ArchivedBuild findUniqueOrThrow
   */
  export type ArchivedBuildFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedBuild
     */
    select?: ArchivedBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedBuildInclude<ExtArgs> | null
    /**
     * Filter, which ArchivedBuild to fetch.
     */
    where: ArchivedBuildWhereUniqueInput
  }


  /**
   * ArchivedBuild findFirst
   */
  export type ArchivedBuildFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedBuild
     */
    select?: ArchivedBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedBuildInclude<ExtArgs> | null
    /**
     * Filter, which ArchivedBuild to fetch.
     */
    where?: ArchivedBuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArchivedBuilds to fetch.
     */
    orderBy?: ArchivedBuildOrderByWithRelationInput | ArchivedBuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArchivedBuilds.
     */
    cursor?: ArchivedBuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArchivedBuilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArchivedBuilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArchivedBuilds.
     */
    distinct?: ArchivedBuildScalarFieldEnum | ArchivedBuildScalarFieldEnum[]
  }


  /**
   * ArchivedBuild findFirstOrThrow
   */
  export type ArchivedBuildFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedBuild
     */
    select?: ArchivedBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedBuildInclude<ExtArgs> | null
    /**
     * Filter, which ArchivedBuild to fetch.
     */
    where?: ArchivedBuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArchivedBuilds to fetch.
     */
    orderBy?: ArchivedBuildOrderByWithRelationInput | ArchivedBuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArchivedBuilds.
     */
    cursor?: ArchivedBuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArchivedBuilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArchivedBuilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArchivedBuilds.
     */
    distinct?: ArchivedBuildScalarFieldEnum | ArchivedBuildScalarFieldEnum[]
  }


  /**
   * ArchivedBuild findMany
   */
  export type ArchivedBuildFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedBuild
     */
    select?: ArchivedBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedBuildInclude<ExtArgs> | null
    /**
     * Filter, which ArchivedBuilds to fetch.
     */
    where?: ArchivedBuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArchivedBuilds to fetch.
     */
    orderBy?: ArchivedBuildOrderByWithRelationInput | ArchivedBuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ArchivedBuilds.
     */
    cursor?: ArchivedBuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArchivedBuilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArchivedBuilds.
     */
    skip?: number
    distinct?: ArchivedBuildScalarFieldEnum | ArchivedBuildScalarFieldEnum[]
  }


  /**
   * ArchivedBuild create
   */
  export type ArchivedBuildCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedBuild
     */
    select?: ArchivedBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedBuildInclude<ExtArgs> | null
    /**
     * The data needed to create a ArchivedBuild.
     */
    data: XOR<ArchivedBuildCreateInput, ArchivedBuildUncheckedCreateInput>
  }


  /**
   * ArchivedBuild createMany
   */
  export type ArchivedBuildCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ArchivedBuilds.
     */
    data: ArchivedBuildCreateManyInput | ArchivedBuildCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ArchivedBuild update
   */
  export type ArchivedBuildUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedBuild
     */
    select?: ArchivedBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedBuildInclude<ExtArgs> | null
    /**
     * The data needed to update a ArchivedBuild.
     */
    data: XOR<ArchivedBuildUpdateInput, ArchivedBuildUncheckedUpdateInput>
    /**
     * Choose, which ArchivedBuild to update.
     */
    where: ArchivedBuildWhereUniqueInput
  }


  /**
   * ArchivedBuild updateMany
   */
  export type ArchivedBuildUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ArchivedBuilds.
     */
    data: XOR<ArchivedBuildUpdateManyMutationInput, ArchivedBuildUncheckedUpdateManyInput>
    /**
     * Filter which ArchivedBuilds to update
     */
    where?: ArchivedBuildWhereInput
  }


  /**
   * ArchivedBuild upsert
   */
  export type ArchivedBuildUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedBuild
     */
    select?: ArchivedBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedBuildInclude<ExtArgs> | null
    /**
     * The filter to search for the ArchivedBuild to update in case it exists.
     */
    where: ArchivedBuildWhereUniqueInput
    /**
     * In case the ArchivedBuild found by the `where` argument doesn't exist, create a new ArchivedBuild with this data.
     */
    create: XOR<ArchivedBuildCreateInput, ArchivedBuildUncheckedCreateInput>
    /**
     * In case the ArchivedBuild was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArchivedBuildUpdateInput, ArchivedBuildUncheckedUpdateInput>
  }


  /**
   * ArchivedBuild delete
   */
  export type ArchivedBuildDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedBuild
     */
    select?: ArchivedBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedBuildInclude<ExtArgs> | null
    /**
     * Filter which ArchivedBuild to delete.
     */
    where: ArchivedBuildWhereUniqueInput
  }


  /**
   * ArchivedBuild deleteMany
   */
  export type ArchivedBuildDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArchivedBuilds to delete
     */
    where?: ArchivedBuildWhereInput
  }


  /**
   * ArchivedBuild.createdBy
   */
  export type ArchivedBuild$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * ArchivedBuild.recipe
   */
  export type ArchivedBuild$recipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    where?: RecipeWhereInput
  }


  /**
   * ArchivedBuild.archivedTouch
   */
  export type ArchivedBuild$archivedTouchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedTouch
     */
    select?: ArchivedTouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedTouchInclude<ExtArgs> | null
    where?: ArchivedTouchWhereInput
    orderBy?: ArchivedTouchOrderByWithRelationInput | ArchivedTouchOrderByWithRelationInput[]
    cursor?: ArchivedTouchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArchivedTouchScalarFieldEnum | ArchivedTouchScalarFieldEnum[]
  }


  /**
   * ArchivedBuild without action
   */
  export type ArchivedBuildDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedBuild
     */
    select?: ArchivedBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedBuildInclude<ExtArgs> | null
  }



  /**
   * Model BuildUser
   */

  export type AggregateBuildUser = {
    _count: BuildUserCountAggregateOutputType | null
    _min: BuildUserMinAggregateOutputType | null
    _max: BuildUserMaxAggregateOutputType | null
  }

  export type BuildUserMinAggregateOutputType = {
    userId: string | null
    buildId: string | null
    permission: string | null
  }

  export type BuildUserMaxAggregateOutputType = {
    userId: string | null
    buildId: string | null
    permission: string | null
  }

  export type BuildUserCountAggregateOutputType = {
    userId: number
    buildId: number
    permission: number
    _all: number
  }


  export type BuildUserMinAggregateInputType = {
    userId?: true
    buildId?: true
    permission?: true
  }

  export type BuildUserMaxAggregateInputType = {
    userId?: true
    buildId?: true
    permission?: true
  }

  export type BuildUserCountAggregateInputType = {
    userId?: true
    buildId?: true
    permission?: true
    _all?: true
  }

  export type BuildUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuildUser to aggregate.
     */
    where?: BuildUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildUsers to fetch.
     */
    orderBy?: BuildUserOrderByWithRelationInput | BuildUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuildUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BuildUsers
    **/
    _count?: true | BuildUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuildUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuildUserMaxAggregateInputType
  }

  export type GetBuildUserAggregateType<T extends BuildUserAggregateArgs> = {
        [P in keyof T & keyof AggregateBuildUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuildUser[P]>
      : GetScalarType<T[P], AggregateBuildUser[P]>
  }




  export type BuildUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildUserWhereInput
    orderBy?: BuildUserOrderByWithAggregationInput | BuildUserOrderByWithAggregationInput[]
    by: BuildUserScalarFieldEnum[] | BuildUserScalarFieldEnum
    having?: BuildUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuildUserCountAggregateInputType | true
    _min?: BuildUserMinAggregateInputType
    _max?: BuildUserMaxAggregateInputType
  }

  export type BuildUserGroupByOutputType = {
    userId: string
    buildId: string
    permission: string
    _count: BuildUserCountAggregateOutputType | null
    _min: BuildUserMinAggregateOutputType | null
    _max: BuildUserMaxAggregateOutputType | null
  }

  type GetBuildUserGroupByPayload<T extends BuildUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuildUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuildUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuildUserGroupByOutputType[P]>
            : GetScalarType<T[P], BuildUserGroupByOutputType[P]>
        }
      >
    >


  export type BuildUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    buildId?: boolean
    permission?: boolean
    user?: boolean | BuildUser$userArgs<ExtArgs>
    build?: boolean | BuildUser$buildArgs<ExtArgs>
  }, ExtArgs["result"]["buildUser"]>

  export type BuildUserSelectScalar = {
    userId?: boolean
    buildId?: boolean
    permission?: boolean
  }

  export type BuildUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | BuildUser$userArgs<ExtArgs>
    build?: boolean | BuildUser$buildArgs<ExtArgs>
  }


  export type $BuildUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BuildUser"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      build: Prisma.$BuildPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      buildId: string
      permission: string
    }, ExtArgs["result"]["buildUser"]>
    composites: {}
  }


  type BuildUserGetPayload<S extends boolean | null | undefined | BuildUserDefaultArgs> = $Result.GetResult<Prisma.$BuildUserPayload, S>

  type BuildUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BuildUserFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: BuildUserCountAggregateInputType | true
    }

  export interface BuildUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BuildUser'], meta: { name: 'BuildUser' } }
    /**
     * Find zero or one BuildUser that matches the filter.
     * @param {BuildUserFindUniqueArgs} args - Arguments to find a BuildUser
     * @example
     * // Get one BuildUser
     * const buildUser = await prisma.buildUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BuildUserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BuildUserFindUniqueArgs<ExtArgs>>
    ): Prisma__BuildUserClient<$Result.GetResult<Prisma.$BuildUserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BuildUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BuildUserFindUniqueOrThrowArgs} args - Arguments to find a BuildUser
     * @example
     * // Get one BuildUser
     * const buildUser = await prisma.buildUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BuildUserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildUserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BuildUserClient<$Result.GetResult<Prisma.$BuildUserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BuildUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildUserFindFirstArgs} args - Arguments to find a BuildUser
     * @example
     * // Get one BuildUser
     * const buildUser = await prisma.buildUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BuildUserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildUserFindFirstArgs<ExtArgs>>
    ): Prisma__BuildUserClient<$Result.GetResult<Prisma.$BuildUserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BuildUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildUserFindFirstOrThrowArgs} args - Arguments to find a BuildUser
     * @example
     * // Get one BuildUser
     * const buildUser = await prisma.buildUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BuildUserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildUserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BuildUserClient<$Result.GetResult<Prisma.$BuildUserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BuildUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BuildUsers
     * const buildUsers = await prisma.buildUser.findMany()
     * 
     * // Get first 10 BuildUsers
     * const buildUsers = await prisma.buildUser.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const buildUserWithUserIdOnly = await prisma.buildUser.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends BuildUserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildUserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildUserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BuildUser.
     * @param {BuildUserCreateArgs} args - Arguments to create a BuildUser.
     * @example
     * // Create one BuildUser
     * const BuildUser = await prisma.buildUser.create({
     *   data: {
     *     // ... data to create a BuildUser
     *   }
     * })
     * 
    **/
    create<T extends BuildUserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BuildUserCreateArgs<ExtArgs>>
    ): Prisma__BuildUserClient<$Result.GetResult<Prisma.$BuildUserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BuildUsers.
     *     @param {BuildUserCreateManyArgs} args - Arguments to create many BuildUsers.
     *     @example
     *     // Create many BuildUsers
     *     const buildUser = await prisma.buildUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BuildUserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildUserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BuildUser.
     * @param {BuildUserDeleteArgs} args - Arguments to delete one BuildUser.
     * @example
     * // Delete one BuildUser
     * const BuildUser = await prisma.buildUser.delete({
     *   where: {
     *     // ... filter to delete one BuildUser
     *   }
     * })
     * 
    **/
    delete<T extends BuildUserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BuildUserDeleteArgs<ExtArgs>>
    ): Prisma__BuildUserClient<$Result.GetResult<Prisma.$BuildUserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BuildUser.
     * @param {BuildUserUpdateArgs} args - Arguments to update one BuildUser.
     * @example
     * // Update one BuildUser
     * const buildUser = await prisma.buildUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BuildUserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BuildUserUpdateArgs<ExtArgs>>
    ): Prisma__BuildUserClient<$Result.GetResult<Prisma.$BuildUserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BuildUsers.
     * @param {BuildUserDeleteManyArgs} args - Arguments to filter BuildUsers to delete.
     * @example
     * // Delete a few BuildUsers
     * const { count } = await prisma.buildUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BuildUserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildUserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BuildUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BuildUsers
     * const buildUser = await prisma.buildUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BuildUserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BuildUserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BuildUser.
     * @param {BuildUserUpsertArgs} args - Arguments to update or create a BuildUser.
     * @example
     * // Update or create a BuildUser
     * const buildUser = await prisma.buildUser.upsert({
     *   create: {
     *     // ... data to create a BuildUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BuildUser we want to update
     *   }
     * })
    **/
    upsert<T extends BuildUserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BuildUserUpsertArgs<ExtArgs>>
    ): Prisma__BuildUserClient<$Result.GetResult<Prisma.$BuildUserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BuildUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildUserCountArgs} args - Arguments to filter BuildUsers to count.
     * @example
     * // Count the number of BuildUsers
     * const count = await prisma.buildUser.count({
     *   where: {
     *     // ... the filter for the BuildUsers we want to count
     *   }
     * })
    **/
    count<T extends BuildUserCountArgs>(
      args?: Subset<T, BuildUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuildUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BuildUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuildUserAggregateArgs>(args: Subset<T, BuildUserAggregateArgs>): Prisma.PrismaPromise<GetBuildUserAggregateType<T>>

    /**
     * Group by BuildUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuildUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuildUserGroupByArgs['orderBy'] }
        : { orderBy?: BuildUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuildUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuildUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BuildUser model
   */
  readonly fields: BuildUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BuildUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuildUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends BuildUser$userArgs<ExtArgs> = {}>(args?: Subset<T, BuildUser$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    build<T extends BuildUser$buildArgs<ExtArgs> = {}>(args?: Subset<T, BuildUser$buildArgs<ExtArgs>>): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BuildUser model
   */ 
  interface BuildUserFieldRefs {
    readonly userId: FieldRef<"BuildUser", 'String'>
    readonly buildId: FieldRef<"BuildUser", 'String'>
    readonly permission: FieldRef<"BuildUser", 'String'>
  }
    

  // Custom InputTypes

  /**
   * BuildUser findUnique
   */
  export type BuildUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildUser
     */
    select?: BuildUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildUserInclude<ExtArgs> | null
    /**
     * Filter, which BuildUser to fetch.
     */
    where: BuildUserWhereUniqueInput
  }


  /**
   * BuildUser findUniqueOrThrow
   */
  export type BuildUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildUser
     */
    select?: BuildUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildUserInclude<ExtArgs> | null
    /**
     * Filter, which BuildUser to fetch.
     */
    where: BuildUserWhereUniqueInput
  }


  /**
   * BuildUser findFirst
   */
  export type BuildUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildUser
     */
    select?: BuildUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildUserInclude<ExtArgs> | null
    /**
     * Filter, which BuildUser to fetch.
     */
    where?: BuildUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildUsers to fetch.
     */
    orderBy?: BuildUserOrderByWithRelationInput | BuildUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuildUsers.
     */
    cursor?: BuildUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuildUsers.
     */
    distinct?: BuildUserScalarFieldEnum | BuildUserScalarFieldEnum[]
  }


  /**
   * BuildUser findFirstOrThrow
   */
  export type BuildUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildUser
     */
    select?: BuildUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildUserInclude<ExtArgs> | null
    /**
     * Filter, which BuildUser to fetch.
     */
    where?: BuildUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildUsers to fetch.
     */
    orderBy?: BuildUserOrderByWithRelationInput | BuildUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuildUsers.
     */
    cursor?: BuildUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuildUsers.
     */
    distinct?: BuildUserScalarFieldEnum | BuildUserScalarFieldEnum[]
  }


  /**
   * BuildUser findMany
   */
  export type BuildUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildUser
     */
    select?: BuildUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildUserInclude<ExtArgs> | null
    /**
     * Filter, which BuildUsers to fetch.
     */
    where?: BuildUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildUsers to fetch.
     */
    orderBy?: BuildUserOrderByWithRelationInput | BuildUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BuildUsers.
     */
    cursor?: BuildUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildUsers.
     */
    skip?: number
    distinct?: BuildUserScalarFieldEnum | BuildUserScalarFieldEnum[]
  }


  /**
   * BuildUser create
   */
  export type BuildUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildUser
     */
    select?: BuildUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildUserInclude<ExtArgs> | null
    /**
     * The data needed to create a BuildUser.
     */
    data: XOR<BuildUserCreateInput, BuildUserUncheckedCreateInput>
  }


  /**
   * BuildUser createMany
   */
  export type BuildUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BuildUsers.
     */
    data: BuildUserCreateManyInput | BuildUserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * BuildUser update
   */
  export type BuildUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildUser
     */
    select?: BuildUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildUserInclude<ExtArgs> | null
    /**
     * The data needed to update a BuildUser.
     */
    data: XOR<BuildUserUpdateInput, BuildUserUncheckedUpdateInput>
    /**
     * Choose, which BuildUser to update.
     */
    where: BuildUserWhereUniqueInput
  }


  /**
   * BuildUser updateMany
   */
  export type BuildUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BuildUsers.
     */
    data: XOR<BuildUserUpdateManyMutationInput, BuildUserUncheckedUpdateManyInput>
    /**
     * Filter which BuildUsers to update
     */
    where?: BuildUserWhereInput
  }


  /**
   * BuildUser upsert
   */
  export type BuildUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildUser
     */
    select?: BuildUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildUserInclude<ExtArgs> | null
    /**
     * The filter to search for the BuildUser to update in case it exists.
     */
    where: BuildUserWhereUniqueInput
    /**
     * In case the BuildUser found by the `where` argument doesn't exist, create a new BuildUser with this data.
     */
    create: XOR<BuildUserCreateInput, BuildUserUncheckedCreateInput>
    /**
     * In case the BuildUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuildUserUpdateInput, BuildUserUncheckedUpdateInput>
  }


  /**
   * BuildUser delete
   */
  export type BuildUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildUser
     */
    select?: BuildUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildUserInclude<ExtArgs> | null
    /**
     * Filter which BuildUser to delete.
     */
    where: BuildUserWhereUniqueInput
  }


  /**
   * BuildUser deleteMany
   */
  export type BuildUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuildUsers to delete
     */
    where?: BuildUserWhereInput
  }


  /**
   * BuildUser.user
   */
  export type BuildUser$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * BuildUser.build
   */
  export type BuildUser$buildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    where?: BuildWhereInput
  }


  /**
   * BuildUser without action
   */
  export type BuildUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildUser
     */
    select?: BuildUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildUserInclude<ExtArgs> | null
  }



  /**
   * Model Recipe
   */

  export type AggregateRecipe = {
    _count: RecipeCountAggregateOutputType | null
    _min: RecipeMinAggregateOutputType | null
    _max: RecipeMaxAggregateOutputType | null
  }

  export type RecipeMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    editedAt: Date | null
    name: string | null
    origin: string | null
    history: string | null
    createdById: string | null
    editedById: string | null
  }

  export type RecipeMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    editedAt: Date | null
    name: string | null
    origin: string | null
    history: string | null
    createdById: string | null
    editedById: string | null
  }

  export type RecipeCountAggregateOutputType = {
    id: number
    createdAt: number
    editedAt: number
    name: number
    origin: number
    history: number
    createdById: number
    editedById: number
    _all: number
  }


  export type RecipeMinAggregateInputType = {
    id?: true
    createdAt?: true
    editedAt?: true
    name?: true
    origin?: true
    history?: true
    createdById?: true
    editedById?: true
  }

  export type RecipeMaxAggregateInputType = {
    id?: true
    createdAt?: true
    editedAt?: true
    name?: true
    origin?: true
    history?: true
    createdById?: true
    editedById?: true
  }

  export type RecipeCountAggregateInputType = {
    id?: true
    createdAt?: true
    editedAt?: true
    name?: true
    origin?: true
    history?: true
    createdById?: true
    editedById?: true
    _all?: true
  }

  export type RecipeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recipe to aggregate.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Recipes
    **/
    _count?: true | RecipeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeMaxAggregateInputType
  }

  export type GetRecipeAggregateType<T extends RecipeAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipe[P]>
      : GetScalarType<T[P], AggregateRecipe[P]>
  }




  export type RecipeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeWhereInput
    orderBy?: RecipeOrderByWithAggregationInput | RecipeOrderByWithAggregationInput[]
    by: RecipeScalarFieldEnum[] | RecipeScalarFieldEnum
    having?: RecipeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeCountAggregateInputType | true
    _min?: RecipeMinAggregateInputType
    _max?: RecipeMaxAggregateInputType
  }

  export type RecipeGroupByOutputType = {
    id: string
    createdAt: Date
    editedAt: Date
    name: string
    origin: string | null
    history: string | null
    createdById: string | null
    editedById: string | null
    _count: RecipeCountAggregateOutputType | null
    _min: RecipeMinAggregateOutputType | null
    _max: RecipeMaxAggregateOutputType | null
  }

  type GetRecipeGroupByPayload<T extends RecipeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeGroupByOutputType[P]>
        }
      >
    >


  export type RecipeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    editedAt?: boolean
    name?: boolean
    origin?: boolean
    history?: boolean
    createdById?: boolean
    editedById?: boolean
    createdBy?: boolean | Recipe$createdByArgs<ExtArgs>
    editedBy?: boolean | Recipe$editedByArgs<ExtArgs>
    build?: boolean | Recipe$buildArgs<ExtArgs>
    archivedBuild?: boolean | Recipe$archivedBuildArgs<ExtArgs>
    _count?: boolean | RecipeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipe"]>

  export type RecipeSelectScalar = {
    id?: boolean
    createdAt?: boolean
    editedAt?: boolean
    name?: boolean
    origin?: boolean
    history?: boolean
    createdById?: boolean
    editedById?: boolean
  }

  export type RecipeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Recipe$createdByArgs<ExtArgs>
    editedBy?: boolean | Recipe$editedByArgs<ExtArgs>
    build?: boolean | Recipe$buildArgs<ExtArgs>
    archivedBuild?: boolean | Recipe$archivedBuildArgs<ExtArgs>
    _count?: boolean | RecipeCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $RecipePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Recipe"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      editedBy: Prisma.$UserPayload<ExtArgs> | null
      build: Prisma.$BuildPayload<ExtArgs>[]
      archivedBuild: Prisma.$ArchivedBuildPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      editedAt: Date
      name: string
      origin: string | null
      history: string | null
      createdById: string | null
      editedById: string | null
    }, ExtArgs["result"]["recipe"]>
    composites: {}
  }


  type RecipeGetPayload<S extends boolean | null | undefined | RecipeDefaultArgs> = $Result.GetResult<Prisma.$RecipePayload, S>

  type RecipeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RecipeFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: RecipeCountAggregateInputType | true
    }

  export interface RecipeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Recipe'], meta: { name: 'Recipe' } }
    /**
     * Find zero or one Recipe that matches the filter.
     * @param {RecipeFindUniqueArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RecipeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeFindUniqueArgs<ExtArgs>>
    ): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Recipe that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RecipeFindUniqueOrThrowArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RecipeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Recipe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindFirstArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RecipeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeFindFirstArgs<ExtArgs>>
    ): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Recipe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindFirstOrThrowArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RecipeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Recipes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recipes
     * const recipes = await prisma.recipe.findMany()
     * 
     * // Get first 10 Recipes
     * const recipes = await prisma.recipe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeWithIdOnly = await prisma.recipe.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RecipeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Recipe.
     * @param {RecipeCreateArgs} args - Arguments to create a Recipe.
     * @example
     * // Create one Recipe
     * const Recipe = await prisma.recipe.create({
     *   data: {
     *     // ... data to create a Recipe
     *   }
     * })
     * 
    **/
    create<T extends RecipeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeCreateArgs<ExtArgs>>
    ): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Recipes.
     *     @param {RecipeCreateManyArgs} args - Arguments to create many Recipes.
     *     @example
     *     // Create many Recipes
     *     const recipe = await prisma.recipe.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RecipeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Recipe.
     * @param {RecipeDeleteArgs} args - Arguments to delete one Recipe.
     * @example
     * // Delete one Recipe
     * const Recipe = await prisma.recipe.delete({
     *   where: {
     *     // ... filter to delete one Recipe
     *   }
     * })
     * 
    **/
    delete<T extends RecipeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeDeleteArgs<ExtArgs>>
    ): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Recipe.
     * @param {RecipeUpdateArgs} args - Arguments to update one Recipe.
     * @example
     * // Update one Recipe
     * const recipe = await prisma.recipe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RecipeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeUpdateArgs<ExtArgs>>
    ): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Recipes.
     * @param {RecipeDeleteManyArgs} args - Arguments to filter Recipes to delete.
     * @example
     * // Delete a few Recipes
     * const { count } = await prisma.recipe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RecipeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recipes
     * const recipe = await prisma.recipe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RecipeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Recipe.
     * @param {RecipeUpsertArgs} args - Arguments to update or create a Recipe.
     * @example
     * // Update or create a Recipe
     * const recipe = await prisma.recipe.upsert({
     *   create: {
     *     // ... data to create a Recipe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recipe we want to update
     *   }
     * })
    **/
    upsert<T extends RecipeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeUpsertArgs<ExtArgs>>
    ): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeCountArgs} args - Arguments to filter Recipes to count.
     * @example
     * // Count the number of Recipes
     * const count = await prisma.recipe.count({
     *   where: {
     *     // ... the filter for the Recipes we want to count
     *   }
     * })
    **/
    count<T extends RecipeCountArgs>(
      args?: Subset<T, RecipeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeAggregateArgs>(args: Subset<T, RecipeAggregateArgs>): Prisma.PrismaPromise<GetRecipeAggregateType<T>>

    /**
     * Group by Recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeGroupByArgs['orderBy'] }
        : { orderBy?: RecipeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Recipe model
   */
  readonly fields: RecipeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Recipe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    createdBy<T extends Recipe$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    editedBy<T extends Recipe$editedByArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$editedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    build<T extends Recipe$buildArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$buildArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'findMany'> | Null>;

    archivedBuild<T extends Recipe$archivedBuildArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$archivedBuildArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArchivedBuildPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Recipe model
   */ 
  interface RecipeFieldRefs {
    readonly id: FieldRef<"Recipe", 'String'>
    readonly createdAt: FieldRef<"Recipe", 'DateTime'>
    readonly editedAt: FieldRef<"Recipe", 'DateTime'>
    readonly name: FieldRef<"Recipe", 'String'>
    readonly origin: FieldRef<"Recipe", 'String'>
    readonly history: FieldRef<"Recipe", 'String'>
    readonly createdById: FieldRef<"Recipe", 'String'>
    readonly editedById: FieldRef<"Recipe", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Recipe findUnique
   */
  export type RecipeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where: RecipeWhereUniqueInput
  }


  /**
   * Recipe findUniqueOrThrow
   */
  export type RecipeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where: RecipeWhereUniqueInput
  }


  /**
   * Recipe findFirst
   */
  export type RecipeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recipes.
     */
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }


  /**
   * Recipe findFirstOrThrow
   */
  export type RecipeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recipes.
     */
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }


  /**
   * Recipe findMany
   */
  export type RecipeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipes to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }


  /**
   * Recipe create
   */
  export type RecipeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The data needed to create a Recipe.
     */
    data: XOR<RecipeCreateInput, RecipeUncheckedCreateInput>
  }


  /**
   * Recipe createMany
   */
  export type RecipeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Recipes.
     */
    data: RecipeCreateManyInput | RecipeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Recipe update
   */
  export type RecipeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The data needed to update a Recipe.
     */
    data: XOR<RecipeUpdateInput, RecipeUncheckedUpdateInput>
    /**
     * Choose, which Recipe to update.
     */
    where: RecipeWhereUniqueInput
  }


  /**
   * Recipe updateMany
   */
  export type RecipeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Recipes.
     */
    data: XOR<RecipeUpdateManyMutationInput, RecipeUncheckedUpdateManyInput>
    /**
     * Filter which Recipes to update
     */
    where?: RecipeWhereInput
  }


  /**
   * Recipe upsert
   */
  export type RecipeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The filter to search for the Recipe to update in case it exists.
     */
    where: RecipeWhereUniqueInput
    /**
     * In case the Recipe found by the `where` argument doesn't exist, create a new Recipe with this data.
     */
    create: XOR<RecipeCreateInput, RecipeUncheckedCreateInput>
    /**
     * In case the Recipe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeUpdateInput, RecipeUncheckedUpdateInput>
  }


  /**
   * Recipe delete
   */
  export type RecipeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter which Recipe to delete.
     */
    where: RecipeWhereUniqueInput
  }


  /**
   * Recipe deleteMany
   */
  export type RecipeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recipes to delete
     */
    where?: RecipeWhereInput
  }


  /**
   * Recipe.createdBy
   */
  export type Recipe$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Recipe.editedBy
   */
  export type Recipe$editedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Recipe.build
   */
  export type Recipe$buildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    where?: BuildWhereInput
    orderBy?: BuildOrderByWithRelationInput | BuildOrderByWithRelationInput[]
    cursor?: BuildWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuildScalarFieldEnum | BuildScalarFieldEnum[]
  }


  /**
   * Recipe.archivedBuild
   */
  export type Recipe$archivedBuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedBuild
     */
    select?: ArchivedBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedBuildInclude<ExtArgs> | null
    where?: ArchivedBuildWhereInput
    orderBy?: ArchivedBuildOrderByWithRelationInput | ArchivedBuildOrderByWithRelationInput[]
    cursor?: ArchivedBuildWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArchivedBuildScalarFieldEnum | ArchivedBuildScalarFieldEnum[]
  }


  /**
   * Recipe without action
   */
  export type RecipeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
  }



  /**
   * Model RecipeBookBuild
   */

  export type AggregateRecipeBookBuild = {
    _count: RecipeBookBuildCountAggregateOutputType | null
    _min: RecipeBookBuildMinAggregateOutputType | null
    _max: RecipeBookBuildMaxAggregateOutputType | null
  }

  export type RecipeBookBuildMinAggregateOutputType = {
    buildId: string | null
    recipeBookId: string | null
  }

  export type RecipeBookBuildMaxAggregateOutputType = {
    buildId: string | null
    recipeBookId: string | null
  }

  export type RecipeBookBuildCountAggregateOutputType = {
    buildId: number
    recipeBookId: number
    _all: number
  }


  export type RecipeBookBuildMinAggregateInputType = {
    buildId?: true
    recipeBookId?: true
  }

  export type RecipeBookBuildMaxAggregateInputType = {
    buildId?: true
    recipeBookId?: true
  }

  export type RecipeBookBuildCountAggregateInputType = {
    buildId?: true
    recipeBookId?: true
    _all?: true
  }

  export type RecipeBookBuildAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeBookBuild to aggregate.
     */
    where?: RecipeBookBuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBookBuilds to fetch.
     */
    orderBy?: RecipeBookBuildOrderByWithRelationInput | RecipeBookBuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeBookBuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBookBuilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBookBuilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecipeBookBuilds
    **/
    _count?: true | RecipeBookBuildCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeBookBuildMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeBookBuildMaxAggregateInputType
  }

  export type GetRecipeBookBuildAggregateType<T extends RecipeBookBuildAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipeBookBuild]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipeBookBuild[P]>
      : GetScalarType<T[P], AggregateRecipeBookBuild[P]>
  }




  export type RecipeBookBuildGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeBookBuildWhereInput
    orderBy?: RecipeBookBuildOrderByWithAggregationInput | RecipeBookBuildOrderByWithAggregationInput[]
    by: RecipeBookBuildScalarFieldEnum[] | RecipeBookBuildScalarFieldEnum
    having?: RecipeBookBuildScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeBookBuildCountAggregateInputType | true
    _min?: RecipeBookBuildMinAggregateInputType
    _max?: RecipeBookBuildMaxAggregateInputType
  }

  export type RecipeBookBuildGroupByOutputType = {
    buildId: string
    recipeBookId: string
    _count: RecipeBookBuildCountAggregateOutputType | null
    _min: RecipeBookBuildMinAggregateOutputType | null
    _max: RecipeBookBuildMaxAggregateOutputType | null
  }

  type GetRecipeBookBuildGroupByPayload<T extends RecipeBookBuildGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeBookBuildGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeBookBuildGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeBookBuildGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeBookBuildGroupByOutputType[P]>
        }
      >
    >


  export type RecipeBookBuildSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    buildId?: boolean
    recipeBookId?: boolean
    recipeBook?: boolean | RecipeBookDefaultArgs<ExtArgs>
    build?: boolean | BuildDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeBookBuild"]>

  export type RecipeBookBuildSelectScalar = {
    buildId?: boolean
    recipeBookId?: boolean
  }

  export type RecipeBookBuildInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipeBook?: boolean | RecipeBookDefaultArgs<ExtArgs>
    build?: boolean | BuildDefaultArgs<ExtArgs>
  }


  export type $RecipeBookBuildPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecipeBookBuild"
    objects: {
      recipeBook: Prisma.$RecipeBookPayload<ExtArgs>
      build: Prisma.$BuildPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      buildId: string
      recipeBookId: string
    }, ExtArgs["result"]["recipeBookBuild"]>
    composites: {}
  }


  type RecipeBookBuildGetPayload<S extends boolean | null | undefined | RecipeBookBuildDefaultArgs> = $Result.GetResult<Prisma.$RecipeBookBuildPayload, S>

  type RecipeBookBuildCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RecipeBookBuildFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: RecipeBookBuildCountAggregateInputType | true
    }

  export interface RecipeBookBuildDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecipeBookBuild'], meta: { name: 'RecipeBookBuild' } }
    /**
     * Find zero or one RecipeBookBuild that matches the filter.
     * @param {RecipeBookBuildFindUniqueArgs} args - Arguments to find a RecipeBookBuild
     * @example
     * // Get one RecipeBookBuild
     * const recipeBookBuild = await prisma.recipeBookBuild.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RecipeBookBuildFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookBuildFindUniqueArgs<ExtArgs>>
    ): Prisma__RecipeBookBuildClient<$Result.GetResult<Prisma.$RecipeBookBuildPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RecipeBookBuild that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RecipeBookBuildFindUniqueOrThrowArgs} args - Arguments to find a RecipeBookBuild
     * @example
     * // Get one RecipeBookBuild
     * const recipeBookBuild = await prisma.recipeBookBuild.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RecipeBookBuildFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookBuildFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RecipeBookBuildClient<$Result.GetResult<Prisma.$RecipeBookBuildPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RecipeBookBuild that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookBuildFindFirstArgs} args - Arguments to find a RecipeBookBuild
     * @example
     * // Get one RecipeBookBuild
     * const recipeBookBuild = await prisma.recipeBookBuild.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RecipeBookBuildFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookBuildFindFirstArgs<ExtArgs>>
    ): Prisma__RecipeBookBuildClient<$Result.GetResult<Prisma.$RecipeBookBuildPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RecipeBookBuild that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookBuildFindFirstOrThrowArgs} args - Arguments to find a RecipeBookBuild
     * @example
     * // Get one RecipeBookBuild
     * const recipeBookBuild = await prisma.recipeBookBuild.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RecipeBookBuildFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookBuildFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RecipeBookBuildClient<$Result.GetResult<Prisma.$RecipeBookBuildPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RecipeBookBuilds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookBuildFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecipeBookBuilds
     * const recipeBookBuilds = await prisma.recipeBookBuild.findMany()
     * 
     * // Get first 10 RecipeBookBuilds
     * const recipeBookBuilds = await prisma.recipeBookBuild.findMany({ take: 10 })
     * 
     * // Only select the `buildId`
     * const recipeBookBuildWithBuildIdOnly = await prisma.recipeBookBuild.findMany({ select: { buildId: true } })
     * 
    **/
    findMany<T extends RecipeBookBuildFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookBuildFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeBookBuildPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RecipeBookBuild.
     * @param {RecipeBookBuildCreateArgs} args - Arguments to create a RecipeBookBuild.
     * @example
     * // Create one RecipeBookBuild
     * const RecipeBookBuild = await prisma.recipeBookBuild.create({
     *   data: {
     *     // ... data to create a RecipeBookBuild
     *   }
     * })
     * 
    **/
    create<T extends RecipeBookBuildCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookBuildCreateArgs<ExtArgs>>
    ): Prisma__RecipeBookBuildClient<$Result.GetResult<Prisma.$RecipeBookBuildPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RecipeBookBuilds.
     *     @param {RecipeBookBuildCreateManyArgs} args - Arguments to create many RecipeBookBuilds.
     *     @example
     *     // Create many RecipeBookBuilds
     *     const recipeBookBuild = await prisma.recipeBookBuild.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RecipeBookBuildCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookBuildCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RecipeBookBuild.
     * @param {RecipeBookBuildDeleteArgs} args - Arguments to delete one RecipeBookBuild.
     * @example
     * // Delete one RecipeBookBuild
     * const RecipeBookBuild = await prisma.recipeBookBuild.delete({
     *   where: {
     *     // ... filter to delete one RecipeBookBuild
     *   }
     * })
     * 
    **/
    delete<T extends RecipeBookBuildDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookBuildDeleteArgs<ExtArgs>>
    ): Prisma__RecipeBookBuildClient<$Result.GetResult<Prisma.$RecipeBookBuildPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RecipeBookBuild.
     * @param {RecipeBookBuildUpdateArgs} args - Arguments to update one RecipeBookBuild.
     * @example
     * // Update one RecipeBookBuild
     * const recipeBookBuild = await prisma.recipeBookBuild.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RecipeBookBuildUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookBuildUpdateArgs<ExtArgs>>
    ): Prisma__RecipeBookBuildClient<$Result.GetResult<Prisma.$RecipeBookBuildPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RecipeBookBuilds.
     * @param {RecipeBookBuildDeleteManyArgs} args - Arguments to filter RecipeBookBuilds to delete.
     * @example
     * // Delete a few RecipeBookBuilds
     * const { count } = await prisma.recipeBookBuild.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RecipeBookBuildDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeBookBuildDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeBookBuilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookBuildUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecipeBookBuilds
     * const recipeBookBuild = await prisma.recipeBookBuild.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RecipeBookBuildUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookBuildUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RecipeBookBuild.
     * @param {RecipeBookBuildUpsertArgs} args - Arguments to update or create a RecipeBookBuild.
     * @example
     * // Update or create a RecipeBookBuild
     * const recipeBookBuild = await prisma.recipeBookBuild.upsert({
     *   create: {
     *     // ... data to create a RecipeBookBuild
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecipeBookBuild we want to update
     *   }
     * })
    **/
    upsert<T extends RecipeBookBuildUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeBookBuildUpsertArgs<ExtArgs>>
    ): Prisma__RecipeBookBuildClient<$Result.GetResult<Prisma.$RecipeBookBuildPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RecipeBookBuilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookBuildCountArgs} args - Arguments to filter RecipeBookBuilds to count.
     * @example
     * // Count the number of RecipeBookBuilds
     * const count = await prisma.recipeBookBuild.count({
     *   where: {
     *     // ... the filter for the RecipeBookBuilds we want to count
     *   }
     * })
    **/
    count<T extends RecipeBookBuildCountArgs>(
      args?: Subset<T, RecipeBookBuildCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeBookBuildCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecipeBookBuild.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookBuildAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeBookBuildAggregateArgs>(args: Subset<T, RecipeBookBuildAggregateArgs>): Prisma.PrismaPromise<GetRecipeBookBuildAggregateType<T>>

    /**
     * Group by RecipeBookBuild.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeBookBuildGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeBookBuildGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeBookBuildGroupByArgs['orderBy'] }
        : { orderBy?: RecipeBookBuildGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeBookBuildGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeBookBuildGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecipeBookBuild model
   */
  readonly fields: RecipeBookBuildFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecipeBookBuild.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeBookBuildClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    recipeBook<T extends RecipeBookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeBookDefaultArgs<ExtArgs>>): Prisma__RecipeBookClient<$Result.GetResult<Prisma.$RecipeBookPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    build<T extends BuildDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BuildDefaultArgs<ExtArgs>>): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RecipeBookBuild model
   */ 
  interface RecipeBookBuildFieldRefs {
    readonly buildId: FieldRef<"RecipeBookBuild", 'String'>
    readonly recipeBookId: FieldRef<"RecipeBookBuild", 'String'>
  }
    

  // Custom InputTypes

  /**
   * RecipeBookBuild findUnique
   */
  export type RecipeBookBuildFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     */
    select?: RecipeBookBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookBuildInclude<ExtArgs> | null
    /**
     * Filter, which RecipeBookBuild to fetch.
     */
    where: RecipeBookBuildWhereUniqueInput
  }


  /**
   * RecipeBookBuild findUniqueOrThrow
   */
  export type RecipeBookBuildFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     */
    select?: RecipeBookBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookBuildInclude<ExtArgs> | null
    /**
     * Filter, which RecipeBookBuild to fetch.
     */
    where: RecipeBookBuildWhereUniqueInput
  }


  /**
   * RecipeBookBuild findFirst
   */
  export type RecipeBookBuildFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     */
    select?: RecipeBookBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookBuildInclude<ExtArgs> | null
    /**
     * Filter, which RecipeBookBuild to fetch.
     */
    where?: RecipeBookBuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBookBuilds to fetch.
     */
    orderBy?: RecipeBookBuildOrderByWithRelationInput | RecipeBookBuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeBookBuilds.
     */
    cursor?: RecipeBookBuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBookBuilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBookBuilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeBookBuilds.
     */
    distinct?: RecipeBookBuildScalarFieldEnum | RecipeBookBuildScalarFieldEnum[]
  }


  /**
   * RecipeBookBuild findFirstOrThrow
   */
  export type RecipeBookBuildFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     */
    select?: RecipeBookBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookBuildInclude<ExtArgs> | null
    /**
     * Filter, which RecipeBookBuild to fetch.
     */
    where?: RecipeBookBuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBookBuilds to fetch.
     */
    orderBy?: RecipeBookBuildOrderByWithRelationInput | RecipeBookBuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeBookBuilds.
     */
    cursor?: RecipeBookBuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBookBuilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBookBuilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeBookBuilds.
     */
    distinct?: RecipeBookBuildScalarFieldEnum | RecipeBookBuildScalarFieldEnum[]
  }


  /**
   * RecipeBookBuild findMany
   */
  export type RecipeBookBuildFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     */
    select?: RecipeBookBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookBuildInclude<ExtArgs> | null
    /**
     * Filter, which RecipeBookBuilds to fetch.
     */
    where?: RecipeBookBuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeBookBuilds to fetch.
     */
    orderBy?: RecipeBookBuildOrderByWithRelationInput | RecipeBookBuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecipeBookBuilds.
     */
    cursor?: RecipeBookBuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeBookBuilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeBookBuilds.
     */
    skip?: number
    distinct?: RecipeBookBuildScalarFieldEnum | RecipeBookBuildScalarFieldEnum[]
  }


  /**
   * RecipeBookBuild create
   */
  export type RecipeBookBuildCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     */
    select?: RecipeBookBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookBuildInclude<ExtArgs> | null
    /**
     * The data needed to create a RecipeBookBuild.
     */
    data: XOR<RecipeBookBuildCreateInput, RecipeBookBuildUncheckedCreateInput>
  }


  /**
   * RecipeBookBuild createMany
   */
  export type RecipeBookBuildCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecipeBookBuilds.
     */
    data: RecipeBookBuildCreateManyInput | RecipeBookBuildCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RecipeBookBuild update
   */
  export type RecipeBookBuildUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     */
    select?: RecipeBookBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookBuildInclude<ExtArgs> | null
    /**
     * The data needed to update a RecipeBookBuild.
     */
    data: XOR<RecipeBookBuildUpdateInput, RecipeBookBuildUncheckedUpdateInput>
    /**
     * Choose, which RecipeBookBuild to update.
     */
    where: RecipeBookBuildWhereUniqueInput
  }


  /**
   * RecipeBookBuild updateMany
   */
  export type RecipeBookBuildUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecipeBookBuilds.
     */
    data: XOR<RecipeBookBuildUpdateManyMutationInput, RecipeBookBuildUncheckedUpdateManyInput>
    /**
     * Filter which RecipeBookBuilds to update
     */
    where?: RecipeBookBuildWhereInput
  }


  /**
   * RecipeBookBuild upsert
   */
  export type RecipeBookBuildUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     */
    select?: RecipeBookBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookBuildInclude<ExtArgs> | null
    /**
     * The filter to search for the RecipeBookBuild to update in case it exists.
     */
    where: RecipeBookBuildWhereUniqueInput
    /**
     * In case the RecipeBookBuild found by the `where` argument doesn't exist, create a new RecipeBookBuild with this data.
     */
    create: XOR<RecipeBookBuildCreateInput, RecipeBookBuildUncheckedCreateInput>
    /**
     * In case the RecipeBookBuild was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeBookBuildUpdateInput, RecipeBookBuildUncheckedUpdateInput>
  }


  /**
   * RecipeBookBuild delete
   */
  export type RecipeBookBuildDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     */
    select?: RecipeBookBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookBuildInclude<ExtArgs> | null
    /**
     * Filter which RecipeBookBuild to delete.
     */
    where: RecipeBookBuildWhereUniqueInput
  }


  /**
   * RecipeBookBuild deleteMany
   */
  export type RecipeBookBuildDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeBookBuilds to delete
     */
    where?: RecipeBookBuildWhereInput
  }


  /**
   * RecipeBookBuild without action
   */
  export type RecipeBookBuildDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeBookBuild
     */
    select?: RecipeBookBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeBookBuildInclude<ExtArgs> | null
  }



  /**
   * Model Touch
   */

  export type AggregateTouch = {
    _count: TouchCountAggregateOutputType | null
    _avg: TouchAvgAggregateOutputType | null
    _sum: TouchSumAggregateOutputType | null
    _min: TouchMinAggregateOutputType | null
    _max: TouchMaxAggregateOutputType | null
  }

  export type TouchAvgAggregateOutputType = {
    order: number | null
    amount: number | null
    version: number | null
  }

  export type TouchSumAggregateOutputType = {
    order: number | null
    amount: number | null
    version: number | null
  }

  export type TouchMinAggregateOutputType = {
    id: string | null
    buildId: string | null
    order: number | null
    amount: number | null
    unit: string | null
    ingredientTypeId: string | null
    ingredientId: string | null
    version: number | null
  }

  export type TouchMaxAggregateOutputType = {
    id: string | null
    buildId: string | null
    order: number | null
    amount: number | null
    unit: string | null
    ingredientTypeId: string | null
    ingredientId: string | null
    version: number | null
  }

  export type TouchCountAggregateOutputType = {
    id: number
    buildId: number
    order: number
    amount: number
    unit: number
    ingredientTypeId: number
    ingredientId: number
    version: number
    _all: number
  }


  export type TouchAvgAggregateInputType = {
    order?: true
    amount?: true
    version?: true
  }

  export type TouchSumAggregateInputType = {
    order?: true
    amount?: true
    version?: true
  }

  export type TouchMinAggregateInputType = {
    id?: true
    buildId?: true
    order?: true
    amount?: true
    unit?: true
    ingredientTypeId?: true
    ingredientId?: true
    version?: true
  }

  export type TouchMaxAggregateInputType = {
    id?: true
    buildId?: true
    order?: true
    amount?: true
    unit?: true
    ingredientTypeId?: true
    ingredientId?: true
    version?: true
  }

  export type TouchCountAggregateInputType = {
    id?: true
    buildId?: true
    order?: true
    amount?: true
    unit?: true
    ingredientTypeId?: true
    ingredientId?: true
    version?: true
    _all?: true
  }

  export type TouchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Touch to aggregate.
     */
    where?: TouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Touches to fetch.
     */
    orderBy?: TouchOrderByWithRelationInput | TouchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Touches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Touches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Touches
    **/
    _count?: true | TouchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TouchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TouchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TouchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TouchMaxAggregateInputType
  }

  export type GetTouchAggregateType<T extends TouchAggregateArgs> = {
        [P in keyof T & keyof AggregateTouch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTouch[P]>
      : GetScalarType<T[P], AggregateTouch[P]>
  }




  export type TouchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TouchWhereInput
    orderBy?: TouchOrderByWithAggregationInput | TouchOrderByWithAggregationInput[]
    by: TouchScalarFieldEnum[] | TouchScalarFieldEnum
    having?: TouchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TouchCountAggregateInputType | true
    _avg?: TouchAvgAggregateInputType
    _sum?: TouchSumAggregateInputType
    _min?: TouchMinAggregateInputType
    _max?: TouchMaxAggregateInputType
  }

  export type TouchGroupByOutputType = {
    id: string
    buildId: string
    order: number | null
    amount: number | null
    unit: string | null
    ingredientTypeId: string
    ingredientId: string | null
    version: number | null
    _count: TouchCountAggregateOutputType | null
    _avg: TouchAvgAggregateOutputType | null
    _sum: TouchSumAggregateOutputType | null
    _min: TouchMinAggregateOutputType | null
    _max: TouchMaxAggregateOutputType | null
  }

  type GetTouchGroupByPayload<T extends TouchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TouchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TouchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TouchGroupByOutputType[P]>
            : GetScalarType<T[P], TouchGroupByOutputType[P]>
        }
      >
    >


  export type TouchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    buildId?: boolean
    order?: boolean
    amount?: boolean
    unit?: boolean
    ingredientTypeId?: boolean
    ingredientId?: boolean
    version?: boolean
    build?: boolean | BuildDefaultArgs<ExtArgs>
    ingredientType?: boolean | IngredientTypeDefaultArgs<ExtArgs>
    ingredient?: boolean | Touch$ingredientArgs<ExtArgs>
  }, ExtArgs["result"]["touch"]>

  export type TouchSelectScalar = {
    id?: boolean
    buildId?: boolean
    order?: boolean
    amount?: boolean
    unit?: boolean
    ingredientTypeId?: boolean
    ingredientId?: boolean
    version?: boolean
  }

  export type TouchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    build?: boolean | BuildDefaultArgs<ExtArgs>
    ingredientType?: boolean | IngredientTypeDefaultArgs<ExtArgs>
    ingredient?: boolean | Touch$ingredientArgs<ExtArgs>
  }


  export type $TouchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Touch"
    objects: {
      build: Prisma.$BuildPayload<ExtArgs>
      ingredientType: Prisma.$IngredientTypePayload<ExtArgs>
      ingredient: Prisma.$IngredientPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      buildId: string
      order: number | null
      amount: number | null
      unit: string | null
      ingredientTypeId: string
      ingredientId: string | null
      version: number | null
    }, ExtArgs["result"]["touch"]>
    composites: {}
  }


  type TouchGetPayload<S extends boolean | null | undefined | TouchDefaultArgs> = $Result.GetResult<Prisma.$TouchPayload, S>

  type TouchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TouchFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: TouchCountAggregateInputType | true
    }

  export interface TouchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Touch'], meta: { name: 'Touch' } }
    /**
     * Find zero or one Touch that matches the filter.
     * @param {TouchFindUniqueArgs} args - Arguments to find a Touch
     * @example
     * // Get one Touch
     * const touch = await prisma.touch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TouchFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TouchFindUniqueArgs<ExtArgs>>
    ): Prisma__TouchClient<$Result.GetResult<Prisma.$TouchPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Touch that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TouchFindUniqueOrThrowArgs} args - Arguments to find a Touch
     * @example
     * // Get one Touch
     * const touch = await prisma.touch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TouchFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TouchFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TouchClient<$Result.GetResult<Prisma.$TouchPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Touch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchFindFirstArgs} args - Arguments to find a Touch
     * @example
     * // Get one Touch
     * const touch = await prisma.touch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TouchFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TouchFindFirstArgs<ExtArgs>>
    ): Prisma__TouchClient<$Result.GetResult<Prisma.$TouchPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Touch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchFindFirstOrThrowArgs} args - Arguments to find a Touch
     * @example
     * // Get one Touch
     * const touch = await prisma.touch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TouchFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TouchFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TouchClient<$Result.GetResult<Prisma.$TouchPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Touches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Touches
     * const touches = await prisma.touch.findMany()
     * 
     * // Get first 10 Touches
     * const touches = await prisma.touch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const touchWithIdOnly = await prisma.touch.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TouchFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TouchFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TouchPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Touch.
     * @param {TouchCreateArgs} args - Arguments to create a Touch.
     * @example
     * // Create one Touch
     * const Touch = await prisma.touch.create({
     *   data: {
     *     // ... data to create a Touch
     *   }
     * })
     * 
    **/
    create<T extends TouchCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TouchCreateArgs<ExtArgs>>
    ): Prisma__TouchClient<$Result.GetResult<Prisma.$TouchPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Touches.
     *     @param {TouchCreateManyArgs} args - Arguments to create many Touches.
     *     @example
     *     // Create many Touches
     *     const touch = await prisma.touch.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TouchCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TouchCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Touch.
     * @param {TouchDeleteArgs} args - Arguments to delete one Touch.
     * @example
     * // Delete one Touch
     * const Touch = await prisma.touch.delete({
     *   where: {
     *     // ... filter to delete one Touch
     *   }
     * })
     * 
    **/
    delete<T extends TouchDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TouchDeleteArgs<ExtArgs>>
    ): Prisma__TouchClient<$Result.GetResult<Prisma.$TouchPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Touch.
     * @param {TouchUpdateArgs} args - Arguments to update one Touch.
     * @example
     * // Update one Touch
     * const touch = await prisma.touch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TouchUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TouchUpdateArgs<ExtArgs>>
    ): Prisma__TouchClient<$Result.GetResult<Prisma.$TouchPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Touches.
     * @param {TouchDeleteManyArgs} args - Arguments to filter Touches to delete.
     * @example
     * // Delete a few Touches
     * const { count } = await prisma.touch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TouchDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TouchDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Touches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Touches
     * const touch = await prisma.touch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TouchUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TouchUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Touch.
     * @param {TouchUpsertArgs} args - Arguments to update or create a Touch.
     * @example
     * // Update or create a Touch
     * const touch = await prisma.touch.upsert({
     *   create: {
     *     // ... data to create a Touch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Touch we want to update
     *   }
     * })
    **/
    upsert<T extends TouchUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TouchUpsertArgs<ExtArgs>>
    ): Prisma__TouchClient<$Result.GetResult<Prisma.$TouchPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Touches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchCountArgs} args - Arguments to filter Touches to count.
     * @example
     * // Count the number of Touches
     * const count = await prisma.touch.count({
     *   where: {
     *     // ... the filter for the Touches we want to count
     *   }
     * })
    **/
    count<T extends TouchCountArgs>(
      args?: Subset<T, TouchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TouchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Touch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TouchAggregateArgs>(args: Subset<T, TouchAggregateArgs>): Prisma.PrismaPromise<GetTouchAggregateType<T>>

    /**
     * Group by Touch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TouchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TouchGroupByArgs['orderBy'] }
        : { orderBy?: TouchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TouchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTouchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Touch model
   */
  readonly fields: TouchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Touch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TouchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    build<T extends BuildDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BuildDefaultArgs<ExtArgs>>): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    ingredientType<T extends IngredientTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IngredientTypeDefaultArgs<ExtArgs>>): Prisma__IngredientTypeClient<$Result.GetResult<Prisma.$IngredientTypePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    ingredient<T extends Touch$ingredientArgs<ExtArgs> = {}>(args?: Subset<T, Touch$ingredientArgs<ExtArgs>>): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Touch model
   */ 
  interface TouchFieldRefs {
    readonly id: FieldRef<"Touch", 'String'>
    readonly buildId: FieldRef<"Touch", 'String'>
    readonly order: FieldRef<"Touch", 'Int'>
    readonly amount: FieldRef<"Touch", 'Float'>
    readonly unit: FieldRef<"Touch", 'String'>
    readonly ingredientTypeId: FieldRef<"Touch", 'String'>
    readonly ingredientId: FieldRef<"Touch", 'String'>
    readonly version: FieldRef<"Touch", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Touch findUnique
   */
  export type TouchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Touch
     */
    select?: TouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TouchInclude<ExtArgs> | null
    /**
     * Filter, which Touch to fetch.
     */
    where: TouchWhereUniqueInput
  }


  /**
   * Touch findUniqueOrThrow
   */
  export type TouchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Touch
     */
    select?: TouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TouchInclude<ExtArgs> | null
    /**
     * Filter, which Touch to fetch.
     */
    where: TouchWhereUniqueInput
  }


  /**
   * Touch findFirst
   */
  export type TouchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Touch
     */
    select?: TouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TouchInclude<ExtArgs> | null
    /**
     * Filter, which Touch to fetch.
     */
    where?: TouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Touches to fetch.
     */
    orderBy?: TouchOrderByWithRelationInput | TouchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Touches.
     */
    cursor?: TouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Touches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Touches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Touches.
     */
    distinct?: TouchScalarFieldEnum | TouchScalarFieldEnum[]
  }


  /**
   * Touch findFirstOrThrow
   */
  export type TouchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Touch
     */
    select?: TouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TouchInclude<ExtArgs> | null
    /**
     * Filter, which Touch to fetch.
     */
    where?: TouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Touches to fetch.
     */
    orderBy?: TouchOrderByWithRelationInput | TouchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Touches.
     */
    cursor?: TouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Touches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Touches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Touches.
     */
    distinct?: TouchScalarFieldEnum | TouchScalarFieldEnum[]
  }


  /**
   * Touch findMany
   */
  export type TouchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Touch
     */
    select?: TouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TouchInclude<ExtArgs> | null
    /**
     * Filter, which Touches to fetch.
     */
    where?: TouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Touches to fetch.
     */
    orderBy?: TouchOrderByWithRelationInput | TouchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Touches.
     */
    cursor?: TouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Touches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Touches.
     */
    skip?: number
    distinct?: TouchScalarFieldEnum | TouchScalarFieldEnum[]
  }


  /**
   * Touch create
   */
  export type TouchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Touch
     */
    select?: TouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TouchInclude<ExtArgs> | null
    /**
     * The data needed to create a Touch.
     */
    data: XOR<TouchCreateInput, TouchUncheckedCreateInput>
  }


  /**
   * Touch createMany
   */
  export type TouchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Touches.
     */
    data: TouchCreateManyInput | TouchCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Touch update
   */
  export type TouchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Touch
     */
    select?: TouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TouchInclude<ExtArgs> | null
    /**
     * The data needed to update a Touch.
     */
    data: XOR<TouchUpdateInput, TouchUncheckedUpdateInput>
    /**
     * Choose, which Touch to update.
     */
    where: TouchWhereUniqueInput
  }


  /**
   * Touch updateMany
   */
  export type TouchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Touches.
     */
    data: XOR<TouchUpdateManyMutationInput, TouchUncheckedUpdateManyInput>
    /**
     * Filter which Touches to update
     */
    where?: TouchWhereInput
  }


  /**
   * Touch upsert
   */
  export type TouchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Touch
     */
    select?: TouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TouchInclude<ExtArgs> | null
    /**
     * The filter to search for the Touch to update in case it exists.
     */
    where: TouchWhereUniqueInput
    /**
     * In case the Touch found by the `where` argument doesn't exist, create a new Touch with this data.
     */
    create: XOR<TouchCreateInput, TouchUncheckedCreateInput>
    /**
     * In case the Touch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TouchUpdateInput, TouchUncheckedUpdateInput>
  }


  /**
   * Touch delete
   */
  export type TouchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Touch
     */
    select?: TouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TouchInclude<ExtArgs> | null
    /**
     * Filter which Touch to delete.
     */
    where: TouchWhereUniqueInput
  }


  /**
   * Touch deleteMany
   */
  export type TouchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Touches to delete
     */
    where?: TouchWhereInput
  }


  /**
   * Touch.ingredient
   */
  export type Touch$ingredientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientInclude<ExtArgs> | null
    where?: IngredientWhereInput
  }


  /**
   * Touch without action
   */
  export type TouchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Touch
     */
    select?: TouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TouchInclude<ExtArgs> | null
  }



  /**
   * Model ArchivedTouch
   */

  export type AggregateArchivedTouch = {
    _count: ArchivedTouchCountAggregateOutputType | null
    _avg: ArchivedTouchAvgAggregateOutputType | null
    _sum: ArchivedTouchSumAggregateOutputType | null
    _min: ArchivedTouchMinAggregateOutputType | null
    _max: ArchivedTouchMaxAggregateOutputType | null
  }

  export type ArchivedTouchAvgAggregateOutputType = {
    order: number | null
    amount: number | null
    version: number | null
  }

  export type ArchivedTouchSumAggregateOutputType = {
    order: number | null
    amount: number | null
    version: number | null
  }

  export type ArchivedTouchMinAggregateOutputType = {
    id: string | null
    archivedBuildId: string | null
    order: number | null
    amount: number | null
    unit: string | null
    ingredientTypeId: string | null
    ingredientId: string | null
    version: number | null
  }

  export type ArchivedTouchMaxAggregateOutputType = {
    id: string | null
    archivedBuildId: string | null
    order: number | null
    amount: number | null
    unit: string | null
    ingredientTypeId: string | null
    ingredientId: string | null
    version: number | null
  }

  export type ArchivedTouchCountAggregateOutputType = {
    id: number
    archivedBuildId: number
    order: number
    amount: number
    unit: number
    ingredientTypeId: number
    ingredientId: number
    version: number
    _all: number
  }


  export type ArchivedTouchAvgAggregateInputType = {
    order?: true
    amount?: true
    version?: true
  }

  export type ArchivedTouchSumAggregateInputType = {
    order?: true
    amount?: true
    version?: true
  }

  export type ArchivedTouchMinAggregateInputType = {
    id?: true
    archivedBuildId?: true
    order?: true
    amount?: true
    unit?: true
    ingredientTypeId?: true
    ingredientId?: true
    version?: true
  }

  export type ArchivedTouchMaxAggregateInputType = {
    id?: true
    archivedBuildId?: true
    order?: true
    amount?: true
    unit?: true
    ingredientTypeId?: true
    ingredientId?: true
    version?: true
  }

  export type ArchivedTouchCountAggregateInputType = {
    id?: true
    archivedBuildId?: true
    order?: true
    amount?: true
    unit?: true
    ingredientTypeId?: true
    ingredientId?: true
    version?: true
    _all?: true
  }

  export type ArchivedTouchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArchivedTouch to aggregate.
     */
    where?: ArchivedTouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArchivedTouches to fetch.
     */
    orderBy?: ArchivedTouchOrderByWithRelationInput | ArchivedTouchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArchivedTouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArchivedTouches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArchivedTouches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ArchivedTouches
    **/
    _count?: true | ArchivedTouchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArchivedTouchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArchivedTouchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArchivedTouchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArchivedTouchMaxAggregateInputType
  }

  export type GetArchivedTouchAggregateType<T extends ArchivedTouchAggregateArgs> = {
        [P in keyof T & keyof AggregateArchivedTouch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArchivedTouch[P]>
      : GetScalarType<T[P], AggregateArchivedTouch[P]>
  }




  export type ArchivedTouchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArchivedTouchWhereInput
    orderBy?: ArchivedTouchOrderByWithAggregationInput | ArchivedTouchOrderByWithAggregationInput[]
    by: ArchivedTouchScalarFieldEnum[] | ArchivedTouchScalarFieldEnum
    having?: ArchivedTouchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArchivedTouchCountAggregateInputType | true
    _avg?: ArchivedTouchAvgAggregateInputType
    _sum?: ArchivedTouchSumAggregateInputType
    _min?: ArchivedTouchMinAggregateInputType
    _max?: ArchivedTouchMaxAggregateInputType
  }

  export type ArchivedTouchGroupByOutputType = {
    id: string
    archivedBuildId: string
    order: number | null
    amount: number | null
    unit: string | null
    ingredientTypeId: string
    ingredientId: string | null
    version: number | null
    _count: ArchivedTouchCountAggregateOutputType | null
    _avg: ArchivedTouchAvgAggregateOutputType | null
    _sum: ArchivedTouchSumAggregateOutputType | null
    _min: ArchivedTouchMinAggregateOutputType | null
    _max: ArchivedTouchMaxAggregateOutputType | null
  }

  type GetArchivedTouchGroupByPayload<T extends ArchivedTouchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArchivedTouchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArchivedTouchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArchivedTouchGroupByOutputType[P]>
            : GetScalarType<T[P], ArchivedTouchGroupByOutputType[P]>
        }
      >
    >


  export type ArchivedTouchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    archivedBuildId?: boolean
    order?: boolean
    amount?: boolean
    unit?: boolean
    ingredientTypeId?: boolean
    ingredientId?: boolean
    version?: boolean
    archivedBuild?: boolean | ArchivedBuildDefaultArgs<ExtArgs>
    ingredientType?: boolean | IngredientTypeDefaultArgs<ExtArgs>
    ingredient?: boolean | ArchivedTouch$ingredientArgs<ExtArgs>
  }, ExtArgs["result"]["archivedTouch"]>

  export type ArchivedTouchSelectScalar = {
    id?: boolean
    archivedBuildId?: boolean
    order?: boolean
    amount?: boolean
    unit?: boolean
    ingredientTypeId?: boolean
    ingredientId?: boolean
    version?: boolean
  }

  export type ArchivedTouchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    archivedBuild?: boolean | ArchivedBuildDefaultArgs<ExtArgs>
    ingredientType?: boolean | IngredientTypeDefaultArgs<ExtArgs>
    ingredient?: boolean | ArchivedTouch$ingredientArgs<ExtArgs>
  }


  export type $ArchivedTouchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ArchivedTouch"
    objects: {
      archivedBuild: Prisma.$ArchivedBuildPayload<ExtArgs>
      ingredientType: Prisma.$IngredientTypePayload<ExtArgs>
      ingredient: Prisma.$IngredientPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      archivedBuildId: string
      order: number | null
      amount: number | null
      unit: string | null
      ingredientTypeId: string
      ingredientId: string | null
      version: number | null
    }, ExtArgs["result"]["archivedTouch"]>
    composites: {}
  }


  type ArchivedTouchGetPayload<S extends boolean | null | undefined | ArchivedTouchDefaultArgs> = $Result.GetResult<Prisma.$ArchivedTouchPayload, S>

  type ArchivedTouchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ArchivedTouchFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ArchivedTouchCountAggregateInputType | true
    }

  export interface ArchivedTouchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ArchivedTouch'], meta: { name: 'ArchivedTouch' } }
    /**
     * Find zero or one ArchivedTouch that matches the filter.
     * @param {ArchivedTouchFindUniqueArgs} args - Arguments to find a ArchivedTouch
     * @example
     * // Get one ArchivedTouch
     * const archivedTouch = await prisma.archivedTouch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ArchivedTouchFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ArchivedTouchFindUniqueArgs<ExtArgs>>
    ): Prisma__ArchivedTouchClient<$Result.GetResult<Prisma.$ArchivedTouchPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ArchivedTouch that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ArchivedTouchFindUniqueOrThrowArgs} args - Arguments to find a ArchivedTouch
     * @example
     * // Get one ArchivedTouch
     * const archivedTouch = await prisma.archivedTouch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ArchivedTouchFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ArchivedTouchFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ArchivedTouchClient<$Result.GetResult<Prisma.$ArchivedTouchPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ArchivedTouch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArchivedTouchFindFirstArgs} args - Arguments to find a ArchivedTouch
     * @example
     * // Get one ArchivedTouch
     * const archivedTouch = await prisma.archivedTouch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ArchivedTouchFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ArchivedTouchFindFirstArgs<ExtArgs>>
    ): Prisma__ArchivedTouchClient<$Result.GetResult<Prisma.$ArchivedTouchPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ArchivedTouch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArchivedTouchFindFirstOrThrowArgs} args - Arguments to find a ArchivedTouch
     * @example
     * // Get one ArchivedTouch
     * const archivedTouch = await prisma.archivedTouch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ArchivedTouchFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ArchivedTouchFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ArchivedTouchClient<$Result.GetResult<Prisma.$ArchivedTouchPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ArchivedTouches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArchivedTouchFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ArchivedTouches
     * const archivedTouches = await prisma.archivedTouch.findMany()
     * 
     * // Get first 10 ArchivedTouches
     * const archivedTouches = await prisma.archivedTouch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const archivedTouchWithIdOnly = await prisma.archivedTouch.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ArchivedTouchFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ArchivedTouchFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArchivedTouchPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ArchivedTouch.
     * @param {ArchivedTouchCreateArgs} args - Arguments to create a ArchivedTouch.
     * @example
     * // Create one ArchivedTouch
     * const ArchivedTouch = await prisma.archivedTouch.create({
     *   data: {
     *     // ... data to create a ArchivedTouch
     *   }
     * })
     * 
    **/
    create<T extends ArchivedTouchCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ArchivedTouchCreateArgs<ExtArgs>>
    ): Prisma__ArchivedTouchClient<$Result.GetResult<Prisma.$ArchivedTouchPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ArchivedTouches.
     *     @param {ArchivedTouchCreateManyArgs} args - Arguments to create many ArchivedTouches.
     *     @example
     *     // Create many ArchivedTouches
     *     const archivedTouch = await prisma.archivedTouch.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ArchivedTouchCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ArchivedTouchCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ArchivedTouch.
     * @param {ArchivedTouchDeleteArgs} args - Arguments to delete one ArchivedTouch.
     * @example
     * // Delete one ArchivedTouch
     * const ArchivedTouch = await prisma.archivedTouch.delete({
     *   where: {
     *     // ... filter to delete one ArchivedTouch
     *   }
     * })
     * 
    **/
    delete<T extends ArchivedTouchDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ArchivedTouchDeleteArgs<ExtArgs>>
    ): Prisma__ArchivedTouchClient<$Result.GetResult<Prisma.$ArchivedTouchPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ArchivedTouch.
     * @param {ArchivedTouchUpdateArgs} args - Arguments to update one ArchivedTouch.
     * @example
     * // Update one ArchivedTouch
     * const archivedTouch = await prisma.archivedTouch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ArchivedTouchUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ArchivedTouchUpdateArgs<ExtArgs>>
    ): Prisma__ArchivedTouchClient<$Result.GetResult<Prisma.$ArchivedTouchPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ArchivedTouches.
     * @param {ArchivedTouchDeleteManyArgs} args - Arguments to filter ArchivedTouches to delete.
     * @example
     * // Delete a few ArchivedTouches
     * const { count } = await prisma.archivedTouch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ArchivedTouchDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ArchivedTouchDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArchivedTouches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArchivedTouchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ArchivedTouches
     * const archivedTouch = await prisma.archivedTouch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ArchivedTouchUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ArchivedTouchUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ArchivedTouch.
     * @param {ArchivedTouchUpsertArgs} args - Arguments to update or create a ArchivedTouch.
     * @example
     * // Update or create a ArchivedTouch
     * const archivedTouch = await prisma.archivedTouch.upsert({
     *   create: {
     *     // ... data to create a ArchivedTouch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ArchivedTouch we want to update
     *   }
     * })
    **/
    upsert<T extends ArchivedTouchUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ArchivedTouchUpsertArgs<ExtArgs>>
    ): Prisma__ArchivedTouchClient<$Result.GetResult<Prisma.$ArchivedTouchPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ArchivedTouches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArchivedTouchCountArgs} args - Arguments to filter ArchivedTouches to count.
     * @example
     * // Count the number of ArchivedTouches
     * const count = await prisma.archivedTouch.count({
     *   where: {
     *     // ... the filter for the ArchivedTouches we want to count
     *   }
     * })
    **/
    count<T extends ArchivedTouchCountArgs>(
      args?: Subset<T, ArchivedTouchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArchivedTouchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ArchivedTouch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArchivedTouchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArchivedTouchAggregateArgs>(args: Subset<T, ArchivedTouchAggregateArgs>): Prisma.PrismaPromise<GetArchivedTouchAggregateType<T>>

    /**
     * Group by ArchivedTouch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArchivedTouchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArchivedTouchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArchivedTouchGroupByArgs['orderBy'] }
        : { orderBy?: ArchivedTouchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArchivedTouchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArchivedTouchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ArchivedTouch model
   */
  readonly fields: ArchivedTouchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ArchivedTouch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArchivedTouchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    archivedBuild<T extends ArchivedBuildDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArchivedBuildDefaultArgs<ExtArgs>>): Prisma__ArchivedBuildClient<$Result.GetResult<Prisma.$ArchivedBuildPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    ingredientType<T extends IngredientTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IngredientTypeDefaultArgs<ExtArgs>>): Prisma__IngredientTypeClient<$Result.GetResult<Prisma.$IngredientTypePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    ingredient<T extends ArchivedTouch$ingredientArgs<ExtArgs> = {}>(args?: Subset<T, ArchivedTouch$ingredientArgs<ExtArgs>>): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ArchivedTouch model
   */ 
  interface ArchivedTouchFieldRefs {
    readonly id: FieldRef<"ArchivedTouch", 'String'>
    readonly archivedBuildId: FieldRef<"ArchivedTouch", 'String'>
    readonly order: FieldRef<"ArchivedTouch", 'Int'>
    readonly amount: FieldRef<"ArchivedTouch", 'Float'>
    readonly unit: FieldRef<"ArchivedTouch", 'String'>
    readonly ingredientTypeId: FieldRef<"ArchivedTouch", 'String'>
    readonly ingredientId: FieldRef<"ArchivedTouch", 'String'>
    readonly version: FieldRef<"ArchivedTouch", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * ArchivedTouch findUnique
   */
  export type ArchivedTouchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedTouch
     */
    select?: ArchivedTouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedTouchInclude<ExtArgs> | null
    /**
     * Filter, which ArchivedTouch to fetch.
     */
    where: ArchivedTouchWhereUniqueInput
  }


  /**
   * ArchivedTouch findUniqueOrThrow
   */
  export type ArchivedTouchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedTouch
     */
    select?: ArchivedTouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedTouchInclude<ExtArgs> | null
    /**
     * Filter, which ArchivedTouch to fetch.
     */
    where: ArchivedTouchWhereUniqueInput
  }


  /**
   * ArchivedTouch findFirst
   */
  export type ArchivedTouchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedTouch
     */
    select?: ArchivedTouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedTouchInclude<ExtArgs> | null
    /**
     * Filter, which ArchivedTouch to fetch.
     */
    where?: ArchivedTouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArchivedTouches to fetch.
     */
    orderBy?: ArchivedTouchOrderByWithRelationInput | ArchivedTouchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArchivedTouches.
     */
    cursor?: ArchivedTouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArchivedTouches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArchivedTouches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArchivedTouches.
     */
    distinct?: ArchivedTouchScalarFieldEnum | ArchivedTouchScalarFieldEnum[]
  }


  /**
   * ArchivedTouch findFirstOrThrow
   */
  export type ArchivedTouchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedTouch
     */
    select?: ArchivedTouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedTouchInclude<ExtArgs> | null
    /**
     * Filter, which ArchivedTouch to fetch.
     */
    where?: ArchivedTouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArchivedTouches to fetch.
     */
    orderBy?: ArchivedTouchOrderByWithRelationInput | ArchivedTouchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArchivedTouches.
     */
    cursor?: ArchivedTouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArchivedTouches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArchivedTouches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArchivedTouches.
     */
    distinct?: ArchivedTouchScalarFieldEnum | ArchivedTouchScalarFieldEnum[]
  }


  /**
   * ArchivedTouch findMany
   */
  export type ArchivedTouchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedTouch
     */
    select?: ArchivedTouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedTouchInclude<ExtArgs> | null
    /**
     * Filter, which ArchivedTouches to fetch.
     */
    where?: ArchivedTouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArchivedTouches to fetch.
     */
    orderBy?: ArchivedTouchOrderByWithRelationInput | ArchivedTouchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ArchivedTouches.
     */
    cursor?: ArchivedTouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArchivedTouches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArchivedTouches.
     */
    skip?: number
    distinct?: ArchivedTouchScalarFieldEnum | ArchivedTouchScalarFieldEnum[]
  }


  /**
   * ArchivedTouch create
   */
  export type ArchivedTouchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedTouch
     */
    select?: ArchivedTouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedTouchInclude<ExtArgs> | null
    /**
     * The data needed to create a ArchivedTouch.
     */
    data: XOR<ArchivedTouchCreateInput, ArchivedTouchUncheckedCreateInput>
  }


  /**
   * ArchivedTouch createMany
   */
  export type ArchivedTouchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ArchivedTouches.
     */
    data: ArchivedTouchCreateManyInput | ArchivedTouchCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ArchivedTouch update
   */
  export type ArchivedTouchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedTouch
     */
    select?: ArchivedTouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedTouchInclude<ExtArgs> | null
    /**
     * The data needed to update a ArchivedTouch.
     */
    data: XOR<ArchivedTouchUpdateInput, ArchivedTouchUncheckedUpdateInput>
    /**
     * Choose, which ArchivedTouch to update.
     */
    where: ArchivedTouchWhereUniqueInput
  }


  /**
   * ArchivedTouch updateMany
   */
  export type ArchivedTouchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ArchivedTouches.
     */
    data: XOR<ArchivedTouchUpdateManyMutationInput, ArchivedTouchUncheckedUpdateManyInput>
    /**
     * Filter which ArchivedTouches to update
     */
    where?: ArchivedTouchWhereInput
  }


  /**
   * ArchivedTouch upsert
   */
  export type ArchivedTouchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedTouch
     */
    select?: ArchivedTouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedTouchInclude<ExtArgs> | null
    /**
     * The filter to search for the ArchivedTouch to update in case it exists.
     */
    where: ArchivedTouchWhereUniqueInput
    /**
     * In case the ArchivedTouch found by the `where` argument doesn't exist, create a new ArchivedTouch with this data.
     */
    create: XOR<ArchivedTouchCreateInput, ArchivedTouchUncheckedCreateInput>
    /**
     * In case the ArchivedTouch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArchivedTouchUpdateInput, ArchivedTouchUncheckedUpdateInput>
  }


  /**
   * ArchivedTouch delete
   */
  export type ArchivedTouchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedTouch
     */
    select?: ArchivedTouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedTouchInclude<ExtArgs> | null
    /**
     * Filter which ArchivedTouch to delete.
     */
    where: ArchivedTouchWhereUniqueInput
  }


  /**
   * ArchivedTouch deleteMany
   */
  export type ArchivedTouchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArchivedTouches to delete
     */
    where?: ArchivedTouchWhereInput
  }


  /**
   * ArchivedTouch.ingredient
   */
  export type ArchivedTouch$ingredientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientInclude<ExtArgs> | null
    where?: IngredientWhereInput
  }


  /**
   * ArchivedTouch without action
   */
  export type ArchivedTouchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedTouch
     */
    select?: ArchivedTouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedTouchInclude<ExtArgs> | null
  }



  /**
   * Model IngredientType
   */

  export type AggregateIngredientType = {
    _count: IngredientTypeCountAggregateOutputType | null
    _min: IngredientTypeMinAggregateOutputType | null
    _max: IngredientTypeMaxAggregateOutputType | null
  }

  export type IngredientTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
  }

  export type IngredientTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
  }

  export type IngredientTypeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type IngredientTypeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type IngredientTypeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type IngredientTypeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type IngredientTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IngredientType to aggregate.
     */
    where?: IngredientTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientTypes to fetch.
     */
    orderBy?: IngredientTypeOrderByWithRelationInput | IngredientTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IngredientTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IngredientTypes
    **/
    _count?: true | IngredientTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IngredientTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IngredientTypeMaxAggregateInputType
  }

  export type GetIngredientTypeAggregateType<T extends IngredientTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateIngredientType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIngredientType[P]>
      : GetScalarType<T[P], AggregateIngredientType[P]>
  }




  export type IngredientTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngredientTypeWhereInput
    orderBy?: IngredientTypeOrderByWithAggregationInput | IngredientTypeOrderByWithAggregationInput[]
    by: IngredientTypeScalarFieldEnum[] | IngredientTypeScalarFieldEnum
    having?: IngredientTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IngredientTypeCountAggregateInputType | true
    _min?: IngredientTypeMinAggregateInputType
    _max?: IngredientTypeMaxAggregateInputType
  }

  export type IngredientTypeGroupByOutputType = {
    id: string
    name: string
    description: string | null
    _count: IngredientTypeCountAggregateOutputType | null
    _min: IngredientTypeMinAggregateOutputType | null
    _max: IngredientTypeMaxAggregateOutputType | null
  }

  type GetIngredientTypeGroupByPayload<T extends IngredientTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IngredientTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IngredientTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IngredientTypeGroupByOutputType[P]>
            : GetScalarType<T[P], IngredientTypeGroupByOutputType[P]>
        }
      >
    >


  export type IngredientTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    touch?: boolean | IngredientType$touchArgs<ExtArgs>
    archivedTouch?: boolean | IngredientType$archivedTouchArgs<ExtArgs>
    ingredient?: boolean | IngredientType$ingredientArgs<ExtArgs>
    ingredientPreference?: boolean | IngredientType$ingredientPreferenceArgs<ExtArgs>
    _count?: boolean | IngredientTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ingredientType"]>

  export type IngredientTypeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type IngredientTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    touch?: boolean | IngredientType$touchArgs<ExtArgs>
    archivedTouch?: boolean | IngredientType$archivedTouchArgs<ExtArgs>
    ingredient?: boolean | IngredientType$ingredientArgs<ExtArgs>
    ingredientPreference?: boolean | IngredientType$ingredientPreferenceArgs<ExtArgs>
    _count?: boolean | IngredientTypeCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $IngredientTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IngredientType"
    objects: {
      touch: Prisma.$TouchPayload<ExtArgs>[]
      archivedTouch: Prisma.$ArchivedTouchPayload<ExtArgs>[]
      ingredient: Prisma.$IngredientPayload<ExtArgs>[]
      ingredientPreference: Prisma.$IngredientPreferencePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
    }, ExtArgs["result"]["ingredientType"]>
    composites: {}
  }


  type IngredientTypeGetPayload<S extends boolean | null | undefined | IngredientTypeDefaultArgs> = $Result.GetResult<Prisma.$IngredientTypePayload, S>

  type IngredientTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IngredientTypeFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: IngredientTypeCountAggregateInputType | true
    }

  export interface IngredientTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IngredientType'], meta: { name: 'IngredientType' } }
    /**
     * Find zero or one IngredientType that matches the filter.
     * @param {IngredientTypeFindUniqueArgs} args - Arguments to find a IngredientType
     * @example
     * // Get one IngredientType
     * const ingredientType = await prisma.ingredientType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IngredientTypeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientTypeFindUniqueArgs<ExtArgs>>
    ): Prisma__IngredientTypeClient<$Result.GetResult<Prisma.$IngredientTypePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one IngredientType that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {IngredientTypeFindUniqueOrThrowArgs} args - Arguments to find a IngredientType
     * @example
     * // Get one IngredientType
     * const ingredientType = await prisma.ingredientType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends IngredientTypeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientTypeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__IngredientTypeClient<$Result.GetResult<Prisma.$IngredientTypePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first IngredientType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientTypeFindFirstArgs} args - Arguments to find a IngredientType
     * @example
     * // Get one IngredientType
     * const ingredientType = await prisma.ingredientType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IngredientTypeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientTypeFindFirstArgs<ExtArgs>>
    ): Prisma__IngredientTypeClient<$Result.GetResult<Prisma.$IngredientTypePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first IngredientType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientTypeFindFirstOrThrowArgs} args - Arguments to find a IngredientType
     * @example
     * // Get one IngredientType
     * const ingredientType = await prisma.ingredientType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends IngredientTypeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientTypeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__IngredientTypeClient<$Result.GetResult<Prisma.$IngredientTypePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more IngredientTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IngredientTypes
     * const ingredientTypes = await prisma.ingredientType.findMany()
     * 
     * // Get first 10 IngredientTypes
     * const ingredientTypes = await prisma.ingredientType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ingredientTypeWithIdOnly = await prisma.ingredientType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends IngredientTypeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientTypeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientTypePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a IngredientType.
     * @param {IngredientTypeCreateArgs} args - Arguments to create a IngredientType.
     * @example
     * // Create one IngredientType
     * const IngredientType = await prisma.ingredientType.create({
     *   data: {
     *     // ... data to create a IngredientType
     *   }
     * })
     * 
    **/
    create<T extends IngredientTypeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientTypeCreateArgs<ExtArgs>>
    ): Prisma__IngredientTypeClient<$Result.GetResult<Prisma.$IngredientTypePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many IngredientTypes.
     *     @param {IngredientTypeCreateManyArgs} args - Arguments to create many IngredientTypes.
     *     @example
     *     // Create many IngredientTypes
     *     const ingredientType = await prisma.ingredientType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IngredientTypeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientTypeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a IngredientType.
     * @param {IngredientTypeDeleteArgs} args - Arguments to delete one IngredientType.
     * @example
     * // Delete one IngredientType
     * const IngredientType = await prisma.ingredientType.delete({
     *   where: {
     *     // ... filter to delete one IngredientType
     *   }
     * })
     * 
    **/
    delete<T extends IngredientTypeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientTypeDeleteArgs<ExtArgs>>
    ): Prisma__IngredientTypeClient<$Result.GetResult<Prisma.$IngredientTypePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one IngredientType.
     * @param {IngredientTypeUpdateArgs} args - Arguments to update one IngredientType.
     * @example
     * // Update one IngredientType
     * const ingredientType = await prisma.ingredientType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IngredientTypeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientTypeUpdateArgs<ExtArgs>>
    ): Prisma__IngredientTypeClient<$Result.GetResult<Prisma.$IngredientTypePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more IngredientTypes.
     * @param {IngredientTypeDeleteManyArgs} args - Arguments to filter IngredientTypes to delete.
     * @example
     * // Delete a few IngredientTypes
     * const { count } = await prisma.ingredientType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IngredientTypeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientTypeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IngredientTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IngredientTypes
     * const ingredientType = await prisma.ingredientType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IngredientTypeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientTypeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IngredientType.
     * @param {IngredientTypeUpsertArgs} args - Arguments to update or create a IngredientType.
     * @example
     * // Update or create a IngredientType
     * const ingredientType = await prisma.ingredientType.upsert({
     *   create: {
     *     // ... data to create a IngredientType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IngredientType we want to update
     *   }
     * })
    **/
    upsert<T extends IngredientTypeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientTypeUpsertArgs<ExtArgs>>
    ): Prisma__IngredientTypeClient<$Result.GetResult<Prisma.$IngredientTypePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of IngredientTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientTypeCountArgs} args - Arguments to filter IngredientTypes to count.
     * @example
     * // Count the number of IngredientTypes
     * const count = await prisma.ingredientType.count({
     *   where: {
     *     // ... the filter for the IngredientTypes we want to count
     *   }
     * })
    **/
    count<T extends IngredientTypeCountArgs>(
      args?: Subset<T, IngredientTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IngredientTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IngredientType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IngredientTypeAggregateArgs>(args: Subset<T, IngredientTypeAggregateArgs>): Prisma.PrismaPromise<GetIngredientTypeAggregateType<T>>

    /**
     * Group by IngredientType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IngredientTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IngredientTypeGroupByArgs['orderBy'] }
        : { orderBy?: IngredientTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IngredientTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIngredientTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IngredientType model
   */
  readonly fields: IngredientTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IngredientType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IngredientTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    touch<T extends IngredientType$touchArgs<ExtArgs> = {}>(args?: Subset<T, IngredientType$touchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TouchPayload<ExtArgs>, T, 'findMany'> | Null>;

    archivedTouch<T extends IngredientType$archivedTouchArgs<ExtArgs> = {}>(args?: Subset<T, IngredientType$archivedTouchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArchivedTouchPayload<ExtArgs>, T, 'findMany'> | Null>;

    ingredient<T extends IngredientType$ingredientArgs<ExtArgs> = {}>(args?: Subset<T, IngredientType$ingredientArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'findMany'> | Null>;

    ingredientPreference<T extends IngredientType$ingredientPreferenceArgs<ExtArgs> = {}>(args?: Subset<T, IngredientType$ingredientPreferenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientPreferencePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the IngredientType model
   */ 
  interface IngredientTypeFieldRefs {
    readonly id: FieldRef<"IngredientType", 'String'>
    readonly name: FieldRef<"IngredientType", 'String'>
    readonly description: FieldRef<"IngredientType", 'String'>
  }
    

  // Custom InputTypes

  /**
   * IngredientType findUnique
   */
  export type IngredientTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientType
     */
    select?: IngredientTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientTypeInclude<ExtArgs> | null
    /**
     * Filter, which IngredientType to fetch.
     */
    where: IngredientTypeWhereUniqueInput
  }


  /**
   * IngredientType findUniqueOrThrow
   */
  export type IngredientTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientType
     */
    select?: IngredientTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientTypeInclude<ExtArgs> | null
    /**
     * Filter, which IngredientType to fetch.
     */
    where: IngredientTypeWhereUniqueInput
  }


  /**
   * IngredientType findFirst
   */
  export type IngredientTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientType
     */
    select?: IngredientTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientTypeInclude<ExtArgs> | null
    /**
     * Filter, which IngredientType to fetch.
     */
    where?: IngredientTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientTypes to fetch.
     */
    orderBy?: IngredientTypeOrderByWithRelationInput | IngredientTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IngredientTypes.
     */
    cursor?: IngredientTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IngredientTypes.
     */
    distinct?: IngredientTypeScalarFieldEnum | IngredientTypeScalarFieldEnum[]
  }


  /**
   * IngredientType findFirstOrThrow
   */
  export type IngredientTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientType
     */
    select?: IngredientTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientTypeInclude<ExtArgs> | null
    /**
     * Filter, which IngredientType to fetch.
     */
    where?: IngredientTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientTypes to fetch.
     */
    orderBy?: IngredientTypeOrderByWithRelationInput | IngredientTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IngredientTypes.
     */
    cursor?: IngredientTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IngredientTypes.
     */
    distinct?: IngredientTypeScalarFieldEnum | IngredientTypeScalarFieldEnum[]
  }


  /**
   * IngredientType findMany
   */
  export type IngredientTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientType
     */
    select?: IngredientTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientTypeInclude<ExtArgs> | null
    /**
     * Filter, which IngredientTypes to fetch.
     */
    where?: IngredientTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientTypes to fetch.
     */
    orderBy?: IngredientTypeOrderByWithRelationInput | IngredientTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IngredientTypes.
     */
    cursor?: IngredientTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientTypes.
     */
    skip?: number
    distinct?: IngredientTypeScalarFieldEnum | IngredientTypeScalarFieldEnum[]
  }


  /**
   * IngredientType create
   */
  export type IngredientTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientType
     */
    select?: IngredientTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a IngredientType.
     */
    data: XOR<IngredientTypeCreateInput, IngredientTypeUncheckedCreateInput>
  }


  /**
   * IngredientType createMany
   */
  export type IngredientTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IngredientTypes.
     */
    data: IngredientTypeCreateManyInput | IngredientTypeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * IngredientType update
   */
  export type IngredientTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientType
     */
    select?: IngredientTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a IngredientType.
     */
    data: XOR<IngredientTypeUpdateInput, IngredientTypeUncheckedUpdateInput>
    /**
     * Choose, which IngredientType to update.
     */
    where: IngredientTypeWhereUniqueInput
  }


  /**
   * IngredientType updateMany
   */
  export type IngredientTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IngredientTypes.
     */
    data: XOR<IngredientTypeUpdateManyMutationInput, IngredientTypeUncheckedUpdateManyInput>
    /**
     * Filter which IngredientTypes to update
     */
    where?: IngredientTypeWhereInput
  }


  /**
   * IngredientType upsert
   */
  export type IngredientTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientType
     */
    select?: IngredientTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the IngredientType to update in case it exists.
     */
    where: IngredientTypeWhereUniqueInput
    /**
     * In case the IngredientType found by the `where` argument doesn't exist, create a new IngredientType with this data.
     */
    create: XOR<IngredientTypeCreateInput, IngredientTypeUncheckedCreateInput>
    /**
     * In case the IngredientType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IngredientTypeUpdateInput, IngredientTypeUncheckedUpdateInput>
  }


  /**
   * IngredientType delete
   */
  export type IngredientTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientType
     */
    select?: IngredientTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientTypeInclude<ExtArgs> | null
    /**
     * Filter which IngredientType to delete.
     */
    where: IngredientTypeWhereUniqueInput
  }


  /**
   * IngredientType deleteMany
   */
  export type IngredientTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IngredientTypes to delete
     */
    where?: IngredientTypeWhereInput
  }


  /**
   * IngredientType.touch
   */
  export type IngredientType$touchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Touch
     */
    select?: TouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TouchInclude<ExtArgs> | null
    where?: TouchWhereInput
    orderBy?: TouchOrderByWithRelationInput | TouchOrderByWithRelationInput[]
    cursor?: TouchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TouchScalarFieldEnum | TouchScalarFieldEnum[]
  }


  /**
   * IngredientType.archivedTouch
   */
  export type IngredientType$archivedTouchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedTouch
     */
    select?: ArchivedTouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedTouchInclude<ExtArgs> | null
    where?: ArchivedTouchWhereInput
    orderBy?: ArchivedTouchOrderByWithRelationInput | ArchivedTouchOrderByWithRelationInput[]
    cursor?: ArchivedTouchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArchivedTouchScalarFieldEnum | ArchivedTouchScalarFieldEnum[]
  }


  /**
   * IngredientType.ingredient
   */
  export type IngredientType$ingredientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientInclude<ExtArgs> | null
    where?: IngredientWhereInput
    orderBy?: IngredientOrderByWithRelationInput | IngredientOrderByWithRelationInput[]
    cursor?: IngredientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IngredientScalarFieldEnum | IngredientScalarFieldEnum[]
  }


  /**
   * IngredientType.ingredientPreference
   */
  export type IngredientType$ingredientPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientPreference
     */
    select?: IngredientPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientPreferenceInclude<ExtArgs> | null
    where?: IngredientPreferenceWhereInput
    orderBy?: IngredientPreferenceOrderByWithRelationInput | IngredientPreferenceOrderByWithRelationInput[]
    cursor?: IngredientPreferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IngredientPreferenceScalarFieldEnum | IngredientPreferenceScalarFieldEnum[]
  }


  /**
   * IngredientType without action
   */
  export type IngredientTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientType
     */
    select?: IngredientTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientTypeInclude<ExtArgs> | null
  }



  /**
   * Model Ingredient
   */

  export type AggregateIngredient = {
    _count: IngredientCountAggregateOutputType | null
    _avg: IngredientAvgAggregateOutputType | null
    _sum: IngredientSumAggregateOutputType | null
    _min: IngredientMinAggregateOutputType | null
    _max: IngredientMaxAggregateOutputType | null
  }

  export type IngredientAvgAggregateOutputType = {
    price: number | null
    amount: number | null
  }

  export type IngredientSumAggregateOutputType = {
    price: number | null
    amount: number | null
  }

  export type IngredientMinAggregateOutputType = {
    id: string | null
    dateCreated: Date | null
    createdById: string | null
    ingredientTypeId: string | null
    name: string | null
    description: string | null
    price: number | null
    amount: number | null
    unit: string | null
    source: string | null
  }

  export type IngredientMaxAggregateOutputType = {
    id: string | null
    dateCreated: Date | null
    createdById: string | null
    ingredientTypeId: string | null
    name: string | null
    description: string | null
    price: number | null
    amount: number | null
    unit: string | null
    source: string | null
  }

  export type IngredientCountAggregateOutputType = {
    id: number
    dateCreated: number
    createdById: number
    ingredientTypeId: number
    name: number
    description: number
    price: number
    amount: number
    unit: number
    source: number
    _all: number
  }


  export type IngredientAvgAggregateInputType = {
    price?: true
    amount?: true
  }

  export type IngredientSumAggregateInputType = {
    price?: true
    amount?: true
  }

  export type IngredientMinAggregateInputType = {
    id?: true
    dateCreated?: true
    createdById?: true
    ingredientTypeId?: true
    name?: true
    description?: true
    price?: true
    amount?: true
    unit?: true
    source?: true
  }

  export type IngredientMaxAggregateInputType = {
    id?: true
    dateCreated?: true
    createdById?: true
    ingredientTypeId?: true
    name?: true
    description?: true
    price?: true
    amount?: true
    unit?: true
    source?: true
  }

  export type IngredientCountAggregateInputType = {
    id?: true
    dateCreated?: true
    createdById?: true
    ingredientTypeId?: true
    name?: true
    description?: true
    price?: true
    amount?: true
    unit?: true
    source?: true
    _all?: true
  }

  export type IngredientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ingredient to aggregate.
     */
    where?: IngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ingredients to fetch.
     */
    orderBy?: IngredientOrderByWithRelationInput | IngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ingredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ingredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ingredients
    **/
    _count?: true | IngredientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IngredientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IngredientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IngredientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IngredientMaxAggregateInputType
  }

  export type GetIngredientAggregateType<T extends IngredientAggregateArgs> = {
        [P in keyof T & keyof AggregateIngredient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIngredient[P]>
      : GetScalarType<T[P], AggregateIngredient[P]>
  }




  export type IngredientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngredientWhereInput
    orderBy?: IngredientOrderByWithAggregationInput | IngredientOrderByWithAggregationInput[]
    by: IngredientScalarFieldEnum[] | IngredientScalarFieldEnum
    having?: IngredientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IngredientCountAggregateInputType | true
    _avg?: IngredientAvgAggregateInputType
    _sum?: IngredientSumAggregateInputType
    _min?: IngredientMinAggregateInputType
    _max?: IngredientMaxAggregateInputType
  }

  export type IngredientGroupByOutputType = {
    id: string
    dateCreated: Date
    createdById: string | null
    ingredientTypeId: string
    name: string
    description: string
    price: number | null
    amount: number | null
    unit: string | null
    source: string | null
    _count: IngredientCountAggregateOutputType | null
    _avg: IngredientAvgAggregateOutputType | null
    _sum: IngredientSumAggregateOutputType | null
    _min: IngredientMinAggregateOutputType | null
    _max: IngredientMaxAggregateOutputType | null
  }

  type GetIngredientGroupByPayload<T extends IngredientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IngredientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IngredientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IngredientGroupByOutputType[P]>
            : GetScalarType<T[P], IngredientGroupByOutputType[P]>
        }
      >
    >


  export type IngredientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dateCreated?: boolean
    createdById?: boolean
    ingredientTypeId?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    amount?: boolean
    unit?: boolean
    source?: boolean
    createdBy?: boolean | Ingredient$createdByArgs<ExtArgs>
    ingredientType?: boolean | IngredientTypeDefaultArgs<ExtArgs>
    touch?: boolean | Ingredient$touchArgs<ExtArgs>
    archivedTouch?: boolean | Ingredient$archivedTouchArgs<ExtArgs>
    ingredientStorage?: boolean | Ingredient$ingredientStorageArgs<ExtArgs>
    ingredientUser?: boolean | Ingredient$ingredientUserArgs<ExtArgs>
    ingredientPreference?: boolean | Ingredient$ingredientPreferenceArgs<ExtArgs>
    crewIngredient?: boolean | Ingredient$crewIngredientArgs<ExtArgs>
    _count?: boolean | IngredientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ingredient"]>

  export type IngredientSelectScalar = {
    id?: boolean
    dateCreated?: boolean
    createdById?: boolean
    ingredientTypeId?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    amount?: boolean
    unit?: boolean
    source?: boolean
  }

  export type IngredientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Ingredient$createdByArgs<ExtArgs>
    ingredientType?: boolean | IngredientTypeDefaultArgs<ExtArgs>
    touch?: boolean | Ingredient$touchArgs<ExtArgs>
    archivedTouch?: boolean | Ingredient$archivedTouchArgs<ExtArgs>
    ingredientStorage?: boolean | Ingredient$ingredientStorageArgs<ExtArgs>
    ingredientUser?: boolean | Ingredient$ingredientUserArgs<ExtArgs>
    ingredientPreference?: boolean | Ingredient$ingredientPreferenceArgs<ExtArgs>
    crewIngredient?: boolean | Ingredient$crewIngredientArgs<ExtArgs>
    _count?: boolean | IngredientCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $IngredientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ingredient"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      ingredientType: Prisma.$IngredientTypePayload<ExtArgs>
      touch: Prisma.$TouchPayload<ExtArgs>[]
      archivedTouch: Prisma.$ArchivedTouchPayload<ExtArgs>[]
      ingredientStorage: Prisma.$IngredientStoragePayload<ExtArgs>[]
      ingredientUser: Prisma.$IngredientUserPayload<ExtArgs>[]
      ingredientPreference: Prisma.$IngredientPreferencePayload<ExtArgs>[]
      crewIngredient: Prisma.$CrewIngredientPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dateCreated: Date
      createdById: string | null
      ingredientTypeId: string
      name: string
      description: string
      price: number | null
      amount: number | null
      unit: string | null
      source: string | null
    }, ExtArgs["result"]["ingredient"]>
    composites: {}
  }


  type IngredientGetPayload<S extends boolean | null | undefined | IngredientDefaultArgs> = $Result.GetResult<Prisma.$IngredientPayload, S>

  type IngredientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IngredientFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: IngredientCountAggregateInputType | true
    }

  export interface IngredientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ingredient'], meta: { name: 'Ingredient' } }
    /**
     * Find zero or one Ingredient that matches the filter.
     * @param {IngredientFindUniqueArgs} args - Arguments to find a Ingredient
     * @example
     * // Get one Ingredient
     * const ingredient = await prisma.ingredient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IngredientFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientFindUniqueArgs<ExtArgs>>
    ): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Ingredient that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {IngredientFindUniqueOrThrowArgs} args - Arguments to find a Ingredient
     * @example
     * // Get one Ingredient
     * const ingredient = await prisma.ingredient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends IngredientFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Ingredient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientFindFirstArgs} args - Arguments to find a Ingredient
     * @example
     * // Get one Ingredient
     * const ingredient = await prisma.ingredient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IngredientFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientFindFirstArgs<ExtArgs>>
    ): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Ingredient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientFindFirstOrThrowArgs} args - Arguments to find a Ingredient
     * @example
     * // Get one Ingredient
     * const ingredient = await prisma.ingredient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends IngredientFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Ingredients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ingredients
     * const ingredients = await prisma.ingredient.findMany()
     * 
     * // Get first 10 Ingredients
     * const ingredients = await prisma.ingredient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ingredientWithIdOnly = await prisma.ingredient.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends IngredientFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Ingredient.
     * @param {IngredientCreateArgs} args - Arguments to create a Ingredient.
     * @example
     * // Create one Ingredient
     * const Ingredient = await prisma.ingredient.create({
     *   data: {
     *     // ... data to create a Ingredient
     *   }
     * })
     * 
    **/
    create<T extends IngredientCreateArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientCreateArgs<ExtArgs>>
    ): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Ingredients.
     *     @param {IngredientCreateManyArgs} args - Arguments to create many Ingredients.
     *     @example
     *     // Create many Ingredients
     *     const ingredient = await prisma.ingredient.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IngredientCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ingredient.
     * @param {IngredientDeleteArgs} args - Arguments to delete one Ingredient.
     * @example
     * // Delete one Ingredient
     * const Ingredient = await prisma.ingredient.delete({
     *   where: {
     *     // ... filter to delete one Ingredient
     *   }
     * })
     * 
    **/
    delete<T extends IngredientDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientDeleteArgs<ExtArgs>>
    ): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Ingredient.
     * @param {IngredientUpdateArgs} args - Arguments to update one Ingredient.
     * @example
     * // Update one Ingredient
     * const ingredient = await prisma.ingredient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IngredientUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientUpdateArgs<ExtArgs>>
    ): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Ingredients.
     * @param {IngredientDeleteManyArgs} args - Arguments to filter Ingredients to delete.
     * @example
     * // Delete a few Ingredients
     * const { count } = await prisma.ingredient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IngredientDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ingredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ingredients
     * const ingredient = await prisma.ingredient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IngredientUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ingredient.
     * @param {IngredientUpsertArgs} args - Arguments to update or create a Ingredient.
     * @example
     * // Update or create a Ingredient
     * const ingredient = await prisma.ingredient.upsert({
     *   create: {
     *     // ... data to create a Ingredient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ingredient we want to update
     *   }
     * })
    **/
    upsert<T extends IngredientUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientUpsertArgs<ExtArgs>>
    ): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Ingredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientCountArgs} args - Arguments to filter Ingredients to count.
     * @example
     * // Count the number of Ingredients
     * const count = await prisma.ingredient.count({
     *   where: {
     *     // ... the filter for the Ingredients we want to count
     *   }
     * })
    **/
    count<T extends IngredientCountArgs>(
      args?: Subset<T, IngredientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IngredientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ingredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IngredientAggregateArgs>(args: Subset<T, IngredientAggregateArgs>): Prisma.PrismaPromise<GetIngredientAggregateType<T>>

    /**
     * Group by Ingredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IngredientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IngredientGroupByArgs['orderBy'] }
        : { orderBy?: IngredientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IngredientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIngredientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ingredient model
   */
  readonly fields: IngredientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ingredient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IngredientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    createdBy<T extends Ingredient$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Ingredient$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    ingredientType<T extends IngredientTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IngredientTypeDefaultArgs<ExtArgs>>): Prisma__IngredientTypeClient<$Result.GetResult<Prisma.$IngredientTypePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    touch<T extends Ingredient$touchArgs<ExtArgs> = {}>(args?: Subset<T, Ingredient$touchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TouchPayload<ExtArgs>, T, 'findMany'> | Null>;

    archivedTouch<T extends Ingredient$archivedTouchArgs<ExtArgs> = {}>(args?: Subset<T, Ingredient$archivedTouchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArchivedTouchPayload<ExtArgs>, T, 'findMany'> | Null>;

    ingredientStorage<T extends Ingredient$ingredientStorageArgs<ExtArgs> = {}>(args?: Subset<T, Ingredient$ingredientStorageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientStoragePayload<ExtArgs>, T, 'findMany'> | Null>;

    ingredientUser<T extends Ingredient$ingredientUserArgs<ExtArgs> = {}>(args?: Subset<T, Ingredient$ingredientUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    ingredientPreference<T extends Ingredient$ingredientPreferenceArgs<ExtArgs> = {}>(args?: Subset<T, Ingredient$ingredientPreferenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientPreferencePayload<ExtArgs>, T, 'findMany'> | Null>;

    crewIngredient<T extends Ingredient$crewIngredientArgs<ExtArgs> = {}>(args?: Subset<T, Ingredient$crewIngredientArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewIngredientPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Ingredient model
   */ 
  interface IngredientFieldRefs {
    readonly id: FieldRef<"Ingredient", 'String'>
    readonly dateCreated: FieldRef<"Ingredient", 'DateTime'>
    readonly createdById: FieldRef<"Ingredient", 'String'>
    readonly ingredientTypeId: FieldRef<"Ingredient", 'String'>
    readonly name: FieldRef<"Ingredient", 'String'>
    readonly description: FieldRef<"Ingredient", 'String'>
    readonly price: FieldRef<"Ingredient", 'Float'>
    readonly amount: FieldRef<"Ingredient", 'Float'>
    readonly unit: FieldRef<"Ingredient", 'String'>
    readonly source: FieldRef<"Ingredient", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Ingredient findUnique
   */
  export type IngredientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * Filter, which Ingredient to fetch.
     */
    where: IngredientWhereUniqueInput
  }


  /**
   * Ingredient findUniqueOrThrow
   */
  export type IngredientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * Filter, which Ingredient to fetch.
     */
    where: IngredientWhereUniqueInput
  }


  /**
   * Ingredient findFirst
   */
  export type IngredientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * Filter, which Ingredient to fetch.
     */
    where?: IngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ingredients to fetch.
     */
    orderBy?: IngredientOrderByWithRelationInput | IngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ingredients.
     */
    cursor?: IngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ingredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ingredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ingredients.
     */
    distinct?: IngredientScalarFieldEnum | IngredientScalarFieldEnum[]
  }


  /**
   * Ingredient findFirstOrThrow
   */
  export type IngredientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * Filter, which Ingredient to fetch.
     */
    where?: IngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ingredients to fetch.
     */
    orderBy?: IngredientOrderByWithRelationInput | IngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ingredients.
     */
    cursor?: IngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ingredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ingredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ingredients.
     */
    distinct?: IngredientScalarFieldEnum | IngredientScalarFieldEnum[]
  }


  /**
   * Ingredient findMany
   */
  export type IngredientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * Filter, which Ingredients to fetch.
     */
    where?: IngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ingredients to fetch.
     */
    orderBy?: IngredientOrderByWithRelationInput | IngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ingredients.
     */
    cursor?: IngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ingredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ingredients.
     */
    skip?: number
    distinct?: IngredientScalarFieldEnum | IngredientScalarFieldEnum[]
  }


  /**
   * Ingredient create
   */
  export type IngredientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * The data needed to create a Ingredient.
     */
    data: XOR<IngredientCreateInput, IngredientUncheckedCreateInput>
  }


  /**
   * Ingredient createMany
   */
  export type IngredientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ingredients.
     */
    data: IngredientCreateManyInput | IngredientCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Ingredient update
   */
  export type IngredientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * The data needed to update a Ingredient.
     */
    data: XOR<IngredientUpdateInput, IngredientUncheckedUpdateInput>
    /**
     * Choose, which Ingredient to update.
     */
    where: IngredientWhereUniqueInput
  }


  /**
   * Ingredient updateMany
   */
  export type IngredientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ingredients.
     */
    data: XOR<IngredientUpdateManyMutationInput, IngredientUncheckedUpdateManyInput>
    /**
     * Filter which Ingredients to update
     */
    where?: IngredientWhereInput
  }


  /**
   * Ingredient upsert
   */
  export type IngredientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * The filter to search for the Ingredient to update in case it exists.
     */
    where: IngredientWhereUniqueInput
    /**
     * In case the Ingredient found by the `where` argument doesn't exist, create a new Ingredient with this data.
     */
    create: XOR<IngredientCreateInput, IngredientUncheckedCreateInput>
    /**
     * In case the Ingredient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IngredientUpdateInput, IngredientUncheckedUpdateInput>
  }


  /**
   * Ingredient delete
   */
  export type IngredientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * Filter which Ingredient to delete.
     */
    where: IngredientWhereUniqueInput
  }


  /**
   * Ingredient deleteMany
   */
  export type IngredientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ingredients to delete
     */
    where?: IngredientWhereInput
  }


  /**
   * Ingredient.createdBy
   */
  export type Ingredient$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Ingredient.touch
   */
  export type Ingredient$touchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Touch
     */
    select?: TouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TouchInclude<ExtArgs> | null
    where?: TouchWhereInput
    orderBy?: TouchOrderByWithRelationInput | TouchOrderByWithRelationInput[]
    cursor?: TouchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TouchScalarFieldEnum | TouchScalarFieldEnum[]
  }


  /**
   * Ingredient.archivedTouch
   */
  export type Ingredient$archivedTouchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchivedTouch
     */
    select?: ArchivedTouchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArchivedTouchInclude<ExtArgs> | null
    where?: ArchivedTouchWhereInput
    orderBy?: ArchivedTouchOrderByWithRelationInput | ArchivedTouchOrderByWithRelationInput[]
    cursor?: ArchivedTouchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArchivedTouchScalarFieldEnum | ArchivedTouchScalarFieldEnum[]
  }


  /**
   * Ingredient.ingredientStorage
   */
  export type Ingredient$ingredientStorageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientStorage
     */
    select?: IngredientStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientStorageInclude<ExtArgs> | null
    where?: IngredientStorageWhereInput
    orderBy?: IngredientStorageOrderByWithRelationInput | IngredientStorageOrderByWithRelationInput[]
    cursor?: IngredientStorageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IngredientStorageScalarFieldEnum | IngredientStorageScalarFieldEnum[]
  }


  /**
   * Ingredient.ingredientUser
   */
  export type Ingredient$ingredientUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientUser
     */
    select?: IngredientUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientUserInclude<ExtArgs> | null
    where?: IngredientUserWhereInput
    orderBy?: IngredientUserOrderByWithRelationInput | IngredientUserOrderByWithRelationInput[]
    cursor?: IngredientUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IngredientUserScalarFieldEnum | IngredientUserScalarFieldEnum[]
  }


  /**
   * Ingredient.ingredientPreference
   */
  export type Ingredient$ingredientPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientPreference
     */
    select?: IngredientPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientPreferenceInclude<ExtArgs> | null
    where?: IngredientPreferenceWhereInput
    orderBy?: IngredientPreferenceOrderByWithRelationInput | IngredientPreferenceOrderByWithRelationInput[]
    cursor?: IngredientPreferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IngredientPreferenceScalarFieldEnum | IngredientPreferenceScalarFieldEnum[]
  }


  /**
   * Ingredient.crewIngredient
   */
  export type Ingredient$crewIngredientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewIngredient
     */
    select?: CrewIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewIngredientInclude<ExtArgs> | null
    where?: CrewIngredientWhereInput
    orderBy?: CrewIngredientOrderByWithRelationInput | CrewIngredientOrderByWithRelationInput[]
    cursor?: CrewIngredientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrewIngredientScalarFieldEnum | CrewIngredientScalarFieldEnum[]
  }


  /**
   * Ingredient without action
   */
  export type IngredientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientInclude<ExtArgs> | null
  }



  /**
   * Model IngredientUser
   */

  export type AggregateIngredientUser = {
    _count: IngredientUserCountAggregateOutputType | null
    _min: IngredientUserMinAggregateOutputType | null
    _max: IngredientUserMaxAggregateOutputType | null
  }

  export type IngredientUserMinAggregateOutputType = {
    ingredientId: string | null
    userId: string | null
    permission: string | null
  }

  export type IngredientUserMaxAggregateOutputType = {
    ingredientId: string | null
    userId: string | null
    permission: string | null
  }

  export type IngredientUserCountAggregateOutputType = {
    ingredientId: number
    userId: number
    permission: number
    _all: number
  }


  export type IngredientUserMinAggregateInputType = {
    ingredientId?: true
    userId?: true
    permission?: true
  }

  export type IngredientUserMaxAggregateInputType = {
    ingredientId?: true
    userId?: true
    permission?: true
  }

  export type IngredientUserCountAggregateInputType = {
    ingredientId?: true
    userId?: true
    permission?: true
    _all?: true
  }

  export type IngredientUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IngredientUser to aggregate.
     */
    where?: IngredientUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientUsers to fetch.
     */
    orderBy?: IngredientUserOrderByWithRelationInput | IngredientUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IngredientUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IngredientUsers
    **/
    _count?: true | IngredientUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IngredientUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IngredientUserMaxAggregateInputType
  }

  export type GetIngredientUserAggregateType<T extends IngredientUserAggregateArgs> = {
        [P in keyof T & keyof AggregateIngredientUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIngredientUser[P]>
      : GetScalarType<T[P], AggregateIngredientUser[P]>
  }




  export type IngredientUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngredientUserWhereInput
    orderBy?: IngredientUserOrderByWithAggregationInput | IngredientUserOrderByWithAggregationInput[]
    by: IngredientUserScalarFieldEnum[] | IngredientUserScalarFieldEnum
    having?: IngredientUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IngredientUserCountAggregateInputType | true
    _min?: IngredientUserMinAggregateInputType
    _max?: IngredientUserMaxAggregateInputType
  }

  export type IngredientUserGroupByOutputType = {
    ingredientId: string
    userId: string
    permission: string
    _count: IngredientUserCountAggregateOutputType | null
    _min: IngredientUserMinAggregateOutputType | null
    _max: IngredientUserMaxAggregateOutputType | null
  }

  type GetIngredientUserGroupByPayload<T extends IngredientUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IngredientUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IngredientUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IngredientUserGroupByOutputType[P]>
            : GetScalarType<T[P], IngredientUserGroupByOutputType[P]>
        }
      >
    >


  export type IngredientUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ingredientId?: boolean
    userId?: boolean
    permission?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    ingredient?: boolean | IngredientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ingredientUser"]>

  export type IngredientUserSelectScalar = {
    ingredientId?: boolean
    userId?: boolean
    permission?: boolean
  }

  export type IngredientUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    ingredient?: boolean | IngredientDefaultArgs<ExtArgs>
  }


  export type $IngredientUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IngredientUser"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      ingredient: Prisma.$IngredientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ingredientId: string
      userId: string
      permission: string
    }, ExtArgs["result"]["ingredientUser"]>
    composites: {}
  }


  type IngredientUserGetPayload<S extends boolean | null | undefined | IngredientUserDefaultArgs> = $Result.GetResult<Prisma.$IngredientUserPayload, S>

  type IngredientUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IngredientUserFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: IngredientUserCountAggregateInputType | true
    }

  export interface IngredientUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IngredientUser'], meta: { name: 'IngredientUser' } }
    /**
     * Find zero or one IngredientUser that matches the filter.
     * @param {IngredientUserFindUniqueArgs} args - Arguments to find a IngredientUser
     * @example
     * // Get one IngredientUser
     * const ingredientUser = await prisma.ingredientUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IngredientUserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientUserFindUniqueArgs<ExtArgs>>
    ): Prisma__IngredientUserClient<$Result.GetResult<Prisma.$IngredientUserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one IngredientUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {IngredientUserFindUniqueOrThrowArgs} args - Arguments to find a IngredientUser
     * @example
     * // Get one IngredientUser
     * const ingredientUser = await prisma.ingredientUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends IngredientUserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientUserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__IngredientUserClient<$Result.GetResult<Prisma.$IngredientUserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first IngredientUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientUserFindFirstArgs} args - Arguments to find a IngredientUser
     * @example
     * // Get one IngredientUser
     * const ingredientUser = await prisma.ingredientUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IngredientUserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientUserFindFirstArgs<ExtArgs>>
    ): Prisma__IngredientUserClient<$Result.GetResult<Prisma.$IngredientUserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first IngredientUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientUserFindFirstOrThrowArgs} args - Arguments to find a IngredientUser
     * @example
     * // Get one IngredientUser
     * const ingredientUser = await prisma.ingredientUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends IngredientUserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientUserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__IngredientUserClient<$Result.GetResult<Prisma.$IngredientUserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more IngredientUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IngredientUsers
     * const ingredientUsers = await prisma.ingredientUser.findMany()
     * 
     * // Get first 10 IngredientUsers
     * const ingredientUsers = await prisma.ingredientUser.findMany({ take: 10 })
     * 
     * // Only select the `ingredientId`
     * const ingredientUserWithIngredientIdOnly = await prisma.ingredientUser.findMany({ select: { ingredientId: true } })
     * 
    **/
    findMany<T extends IngredientUserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientUserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientUserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a IngredientUser.
     * @param {IngredientUserCreateArgs} args - Arguments to create a IngredientUser.
     * @example
     * // Create one IngredientUser
     * const IngredientUser = await prisma.ingredientUser.create({
     *   data: {
     *     // ... data to create a IngredientUser
     *   }
     * })
     * 
    **/
    create<T extends IngredientUserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientUserCreateArgs<ExtArgs>>
    ): Prisma__IngredientUserClient<$Result.GetResult<Prisma.$IngredientUserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many IngredientUsers.
     *     @param {IngredientUserCreateManyArgs} args - Arguments to create many IngredientUsers.
     *     @example
     *     // Create many IngredientUsers
     *     const ingredientUser = await prisma.ingredientUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IngredientUserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientUserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a IngredientUser.
     * @param {IngredientUserDeleteArgs} args - Arguments to delete one IngredientUser.
     * @example
     * // Delete one IngredientUser
     * const IngredientUser = await prisma.ingredientUser.delete({
     *   where: {
     *     // ... filter to delete one IngredientUser
     *   }
     * })
     * 
    **/
    delete<T extends IngredientUserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientUserDeleteArgs<ExtArgs>>
    ): Prisma__IngredientUserClient<$Result.GetResult<Prisma.$IngredientUserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one IngredientUser.
     * @param {IngredientUserUpdateArgs} args - Arguments to update one IngredientUser.
     * @example
     * // Update one IngredientUser
     * const ingredientUser = await prisma.ingredientUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IngredientUserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientUserUpdateArgs<ExtArgs>>
    ): Prisma__IngredientUserClient<$Result.GetResult<Prisma.$IngredientUserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more IngredientUsers.
     * @param {IngredientUserDeleteManyArgs} args - Arguments to filter IngredientUsers to delete.
     * @example
     * // Delete a few IngredientUsers
     * const { count } = await prisma.ingredientUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IngredientUserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientUserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IngredientUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IngredientUsers
     * const ingredientUser = await prisma.ingredientUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IngredientUserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientUserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IngredientUser.
     * @param {IngredientUserUpsertArgs} args - Arguments to update or create a IngredientUser.
     * @example
     * // Update or create a IngredientUser
     * const ingredientUser = await prisma.ingredientUser.upsert({
     *   create: {
     *     // ... data to create a IngredientUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IngredientUser we want to update
     *   }
     * })
    **/
    upsert<T extends IngredientUserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientUserUpsertArgs<ExtArgs>>
    ): Prisma__IngredientUserClient<$Result.GetResult<Prisma.$IngredientUserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of IngredientUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientUserCountArgs} args - Arguments to filter IngredientUsers to count.
     * @example
     * // Count the number of IngredientUsers
     * const count = await prisma.ingredientUser.count({
     *   where: {
     *     // ... the filter for the IngredientUsers we want to count
     *   }
     * })
    **/
    count<T extends IngredientUserCountArgs>(
      args?: Subset<T, IngredientUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IngredientUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IngredientUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IngredientUserAggregateArgs>(args: Subset<T, IngredientUserAggregateArgs>): Prisma.PrismaPromise<GetIngredientUserAggregateType<T>>

    /**
     * Group by IngredientUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IngredientUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IngredientUserGroupByArgs['orderBy'] }
        : { orderBy?: IngredientUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IngredientUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIngredientUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IngredientUser model
   */
  readonly fields: IngredientUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IngredientUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IngredientUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    ingredient<T extends IngredientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IngredientDefaultArgs<ExtArgs>>): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the IngredientUser model
   */ 
  interface IngredientUserFieldRefs {
    readonly ingredientId: FieldRef<"IngredientUser", 'String'>
    readonly userId: FieldRef<"IngredientUser", 'String'>
    readonly permission: FieldRef<"IngredientUser", 'String'>
  }
    

  // Custom InputTypes

  /**
   * IngredientUser findUnique
   */
  export type IngredientUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientUser
     */
    select?: IngredientUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientUserInclude<ExtArgs> | null
    /**
     * Filter, which IngredientUser to fetch.
     */
    where: IngredientUserWhereUniqueInput
  }


  /**
   * IngredientUser findUniqueOrThrow
   */
  export type IngredientUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientUser
     */
    select?: IngredientUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientUserInclude<ExtArgs> | null
    /**
     * Filter, which IngredientUser to fetch.
     */
    where: IngredientUserWhereUniqueInput
  }


  /**
   * IngredientUser findFirst
   */
  export type IngredientUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientUser
     */
    select?: IngredientUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientUserInclude<ExtArgs> | null
    /**
     * Filter, which IngredientUser to fetch.
     */
    where?: IngredientUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientUsers to fetch.
     */
    orderBy?: IngredientUserOrderByWithRelationInput | IngredientUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IngredientUsers.
     */
    cursor?: IngredientUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IngredientUsers.
     */
    distinct?: IngredientUserScalarFieldEnum | IngredientUserScalarFieldEnum[]
  }


  /**
   * IngredientUser findFirstOrThrow
   */
  export type IngredientUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientUser
     */
    select?: IngredientUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientUserInclude<ExtArgs> | null
    /**
     * Filter, which IngredientUser to fetch.
     */
    where?: IngredientUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientUsers to fetch.
     */
    orderBy?: IngredientUserOrderByWithRelationInput | IngredientUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IngredientUsers.
     */
    cursor?: IngredientUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IngredientUsers.
     */
    distinct?: IngredientUserScalarFieldEnum | IngredientUserScalarFieldEnum[]
  }


  /**
   * IngredientUser findMany
   */
  export type IngredientUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientUser
     */
    select?: IngredientUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientUserInclude<ExtArgs> | null
    /**
     * Filter, which IngredientUsers to fetch.
     */
    where?: IngredientUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientUsers to fetch.
     */
    orderBy?: IngredientUserOrderByWithRelationInput | IngredientUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IngredientUsers.
     */
    cursor?: IngredientUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientUsers.
     */
    skip?: number
    distinct?: IngredientUserScalarFieldEnum | IngredientUserScalarFieldEnum[]
  }


  /**
   * IngredientUser create
   */
  export type IngredientUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientUser
     */
    select?: IngredientUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientUserInclude<ExtArgs> | null
    /**
     * The data needed to create a IngredientUser.
     */
    data: XOR<IngredientUserCreateInput, IngredientUserUncheckedCreateInput>
  }


  /**
   * IngredientUser createMany
   */
  export type IngredientUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IngredientUsers.
     */
    data: IngredientUserCreateManyInput | IngredientUserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * IngredientUser update
   */
  export type IngredientUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientUser
     */
    select?: IngredientUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientUserInclude<ExtArgs> | null
    /**
     * The data needed to update a IngredientUser.
     */
    data: XOR<IngredientUserUpdateInput, IngredientUserUncheckedUpdateInput>
    /**
     * Choose, which IngredientUser to update.
     */
    where: IngredientUserWhereUniqueInput
  }


  /**
   * IngredientUser updateMany
   */
  export type IngredientUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IngredientUsers.
     */
    data: XOR<IngredientUserUpdateManyMutationInput, IngredientUserUncheckedUpdateManyInput>
    /**
     * Filter which IngredientUsers to update
     */
    where?: IngredientUserWhereInput
  }


  /**
   * IngredientUser upsert
   */
  export type IngredientUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientUser
     */
    select?: IngredientUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientUserInclude<ExtArgs> | null
    /**
     * The filter to search for the IngredientUser to update in case it exists.
     */
    where: IngredientUserWhereUniqueInput
    /**
     * In case the IngredientUser found by the `where` argument doesn't exist, create a new IngredientUser with this data.
     */
    create: XOR<IngredientUserCreateInput, IngredientUserUncheckedCreateInput>
    /**
     * In case the IngredientUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IngredientUserUpdateInput, IngredientUserUncheckedUpdateInput>
  }


  /**
   * IngredientUser delete
   */
  export type IngredientUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientUser
     */
    select?: IngredientUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientUserInclude<ExtArgs> | null
    /**
     * Filter which IngredientUser to delete.
     */
    where: IngredientUserWhereUniqueInput
  }


  /**
   * IngredientUser deleteMany
   */
  export type IngredientUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IngredientUsers to delete
     */
    where?: IngredientUserWhereInput
  }


  /**
   * IngredientUser without action
   */
  export type IngredientUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientUser
     */
    select?: IngredientUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientUserInclude<ExtArgs> | null
  }



  /**
   * Model IngredientPreference
   */

  export type AggregateIngredientPreference = {
    _count: IngredientPreferenceCountAggregateOutputType | null
    _min: IngredientPreferenceMinAggregateOutputType | null
    _max: IngredientPreferenceMaxAggregateOutputType | null
  }

  export type IngredientPreferenceMinAggregateOutputType = {
    ingredientTypeId: string | null
    ingredientId: string | null
    userId: string | null
  }

  export type IngredientPreferenceMaxAggregateOutputType = {
    ingredientTypeId: string | null
    ingredientId: string | null
    userId: string | null
  }

  export type IngredientPreferenceCountAggregateOutputType = {
    ingredientTypeId: number
    ingredientId: number
    userId: number
    _all: number
  }


  export type IngredientPreferenceMinAggregateInputType = {
    ingredientTypeId?: true
    ingredientId?: true
    userId?: true
  }

  export type IngredientPreferenceMaxAggregateInputType = {
    ingredientTypeId?: true
    ingredientId?: true
    userId?: true
  }

  export type IngredientPreferenceCountAggregateInputType = {
    ingredientTypeId?: true
    ingredientId?: true
    userId?: true
    _all?: true
  }

  export type IngredientPreferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IngredientPreference to aggregate.
     */
    where?: IngredientPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientPreferences to fetch.
     */
    orderBy?: IngredientPreferenceOrderByWithRelationInput | IngredientPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IngredientPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IngredientPreferences
    **/
    _count?: true | IngredientPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IngredientPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IngredientPreferenceMaxAggregateInputType
  }

  export type GetIngredientPreferenceAggregateType<T extends IngredientPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateIngredientPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIngredientPreference[P]>
      : GetScalarType<T[P], AggregateIngredientPreference[P]>
  }




  export type IngredientPreferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngredientPreferenceWhereInput
    orderBy?: IngredientPreferenceOrderByWithAggregationInput | IngredientPreferenceOrderByWithAggregationInput[]
    by: IngredientPreferenceScalarFieldEnum[] | IngredientPreferenceScalarFieldEnum
    having?: IngredientPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IngredientPreferenceCountAggregateInputType | true
    _min?: IngredientPreferenceMinAggregateInputType
    _max?: IngredientPreferenceMaxAggregateInputType
  }

  export type IngredientPreferenceGroupByOutputType = {
    ingredientTypeId: string
    ingredientId: string
    userId: string
    _count: IngredientPreferenceCountAggregateOutputType | null
    _min: IngredientPreferenceMinAggregateOutputType | null
    _max: IngredientPreferenceMaxAggregateOutputType | null
  }

  type GetIngredientPreferenceGroupByPayload<T extends IngredientPreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IngredientPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IngredientPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IngredientPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], IngredientPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type IngredientPreferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ingredientTypeId?: boolean
    ingredientId?: boolean
    userId?: boolean
    ingredientType?: boolean | IngredientTypeDefaultArgs<ExtArgs>
    ingredient?: boolean | IngredientDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ingredientPreference"]>

  export type IngredientPreferenceSelectScalar = {
    ingredientTypeId?: boolean
    ingredientId?: boolean
    userId?: boolean
  }

  export type IngredientPreferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ingredientType?: boolean | IngredientTypeDefaultArgs<ExtArgs>
    ingredient?: boolean | IngredientDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $IngredientPreferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IngredientPreference"
    objects: {
      ingredientType: Prisma.$IngredientTypePayload<ExtArgs>
      ingredient: Prisma.$IngredientPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ingredientTypeId: string
      ingredientId: string
      userId: string
    }, ExtArgs["result"]["ingredientPreference"]>
    composites: {}
  }


  type IngredientPreferenceGetPayload<S extends boolean | null | undefined | IngredientPreferenceDefaultArgs> = $Result.GetResult<Prisma.$IngredientPreferencePayload, S>

  type IngredientPreferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IngredientPreferenceFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: IngredientPreferenceCountAggregateInputType | true
    }

  export interface IngredientPreferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IngredientPreference'], meta: { name: 'IngredientPreference' } }
    /**
     * Find zero or one IngredientPreference that matches the filter.
     * @param {IngredientPreferenceFindUniqueArgs} args - Arguments to find a IngredientPreference
     * @example
     * // Get one IngredientPreference
     * const ingredientPreference = await prisma.ingredientPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IngredientPreferenceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientPreferenceFindUniqueArgs<ExtArgs>>
    ): Prisma__IngredientPreferenceClient<$Result.GetResult<Prisma.$IngredientPreferencePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one IngredientPreference that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {IngredientPreferenceFindUniqueOrThrowArgs} args - Arguments to find a IngredientPreference
     * @example
     * // Get one IngredientPreference
     * const ingredientPreference = await prisma.ingredientPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends IngredientPreferenceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientPreferenceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__IngredientPreferenceClient<$Result.GetResult<Prisma.$IngredientPreferencePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first IngredientPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientPreferenceFindFirstArgs} args - Arguments to find a IngredientPreference
     * @example
     * // Get one IngredientPreference
     * const ingredientPreference = await prisma.ingredientPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IngredientPreferenceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientPreferenceFindFirstArgs<ExtArgs>>
    ): Prisma__IngredientPreferenceClient<$Result.GetResult<Prisma.$IngredientPreferencePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first IngredientPreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientPreferenceFindFirstOrThrowArgs} args - Arguments to find a IngredientPreference
     * @example
     * // Get one IngredientPreference
     * const ingredientPreference = await prisma.ingredientPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends IngredientPreferenceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientPreferenceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__IngredientPreferenceClient<$Result.GetResult<Prisma.$IngredientPreferencePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more IngredientPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientPreferenceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IngredientPreferences
     * const ingredientPreferences = await prisma.ingredientPreference.findMany()
     * 
     * // Get first 10 IngredientPreferences
     * const ingredientPreferences = await prisma.ingredientPreference.findMany({ take: 10 })
     * 
     * // Only select the `ingredientTypeId`
     * const ingredientPreferenceWithIngredientTypeIdOnly = await prisma.ingredientPreference.findMany({ select: { ingredientTypeId: true } })
     * 
    **/
    findMany<T extends IngredientPreferenceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientPreferenceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientPreferencePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a IngredientPreference.
     * @param {IngredientPreferenceCreateArgs} args - Arguments to create a IngredientPreference.
     * @example
     * // Create one IngredientPreference
     * const IngredientPreference = await prisma.ingredientPreference.create({
     *   data: {
     *     // ... data to create a IngredientPreference
     *   }
     * })
     * 
    **/
    create<T extends IngredientPreferenceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientPreferenceCreateArgs<ExtArgs>>
    ): Prisma__IngredientPreferenceClient<$Result.GetResult<Prisma.$IngredientPreferencePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many IngredientPreferences.
     *     @param {IngredientPreferenceCreateManyArgs} args - Arguments to create many IngredientPreferences.
     *     @example
     *     // Create many IngredientPreferences
     *     const ingredientPreference = await prisma.ingredientPreference.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IngredientPreferenceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientPreferenceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a IngredientPreference.
     * @param {IngredientPreferenceDeleteArgs} args - Arguments to delete one IngredientPreference.
     * @example
     * // Delete one IngredientPreference
     * const IngredientPreference = await prisma.ingredientPreference.delete({
     *   where: {
     *     // ... filter to delete one IngredientPreference
     *   }
     * })
     * 
    **/
    delete<T extends IngredientPreferenceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientPreferenceDeleteArgs<ExtArgs>>
    ): Prisma__IngredientPreferenceClient<$Result.GetResult<Prisma.$IngredientPreferencePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one IngredientPreference.
     * @param {IngredientPreferenceUpdateArgs} args - Arguments to update one IngredientPreference.
     * @example
     * // Update one IngredientPreference
     * const ingredientPreference = await prisma.ingredientPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IngredientPreferenceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientPreferenceUpdateArgs<ExtArgs>>
    ): Prisma__IngredientPreferenceClient<$Result.GetResult<Prisma.$IngredientPreferencePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more IngredientPreferences.
     * @param {IngredientPreferenceDeleteManyArgs} args - Arguments to filter IngredientPreferences to delete.
     * @example
     * // Delete a few IngredientPreferences
     * const { count } = await prisma.ingredientPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IngredientPreferenceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientPreferenceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IngredientPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IngredientPreferences
     * const ingredientPreference = await prisma.ingredientPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IngredientPreferenceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientPreferenceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IngredientPreference.
     * @param {IngredientPreferenceUpsertArgs} args - Arguments to update or create a IngredientPreference.
     * @example
     * // Update or create a IngredientPreference
     * const ingredientPreference = await prisma.ingredientPreference.upsert({
     *   create: {
     *     // ... data to create a IngredientPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IngredientPreference we want to update
     *   }
     * })
    **/
    upsert<T extends IngredientPreferenceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientPreferenceUpsertArgs<ExtArgs>>
    ): Prisma__IngredientPreferenceClient<$Result.GetResult<Prisma.$IngredientPreferencePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of IngredientPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientPreferenceCountArgs} args - Arguments to filter IngredientPreferences to count.
     * @example
     * // Count the number of IngredientPreferences
     * const count = await prisma.ingredientPreference.count({
     *   where: {
     *     // ... the filter for the IngredientPreferences we want to count
     *   }
     * })
    **/
    count<T extends IngredientPreferenceCountArgs>(
      args?: Subset<T, IngredientPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IngredientPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IngredientPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IngredientPreferenceAggregateArgs>(args: Subset<T, IngredientPreferenceAggregateArgs>): Prisma.PrismaPromise<GetIngredientPreferenceAggregateType<T>>

    /**
     * Group by IngredientPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IngredientPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IngredientPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: IngredientPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IngredientPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIngredientPreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IngredientPreference model
   */
  readonly fields: IngredientPreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IngredientPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IngredientPreferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    ingredientType<T extends IngredientTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IngredientTypeDefaultArgs<ExtArgs>>): Prisma__IngredientTypeClient<$Result.GetResult<Prisma.$IngredientTypePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    ingredient<T extends IngredientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IngredientDefaultArgs<ExtArgs>>): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the IngredientPreference model
   */ 
  interface IngredientPreferenceFieldRefs {
    readonly ingredientTypeId: FieldRef<"IngredientPreference", 'String'>
    readonly ingredientId: FieldRef<"IngredientPreference", 'String'>
    readonly userId: FieldRef<"IngredientPreference", 'String'>
  }
    

  // Custom InputTypes

  /**
   * IngredientPreference findUnique
   */
  export type IngredientPreferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientPreference
     */
    select?: IngredientPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which IngredientPreference to fetch.
     */
    where: IngredientPreferenceWhereUniqueInput
  }


  /**
   * IngredientPreference findUniqueOrThrow
   */
  export type IngredientPreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientPreference
     */
    select?: IngredientPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which IngredientPreference to fetch.
     */
    where: IngredientPreferenceWhereUniqueInput
  }


  /**
   * IngredientPreference findFirst
   */
  export type IngredientPreferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientPreference
     */
    select?: IngredientPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which IngredientPreference to fetch.
     */
    where?: IngredientPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientPreferences to fetch.
     */
    orderBy?: IngredientPreferenceOrderByWithRelationInput | IngredientPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IngredientPreferences.
     */
    cursor?: IngredientPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IngredientPreferences.
     */
    distinct?: IngredientPreferenceScalarFieldEnum | IngredientPreferenceScalarFieldEnum[]
  }


  /**
   * IngredientPreference findFirstOrThrow
   */
  export type IngredientPreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientPreference
     */
    select?: IngredientPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which IngredientPreference to fetch.
     */
    where?: IngredientPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientPreferences to fetch.
     */
    orderBy?: IngredientPreferenceOrderByWithRelationInput | IngredientPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IngredientPreferences.
     */
    cursor?: IngredientPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IngredientPreferences.
     */
    distinct?: IngredientPreferenceScalarFieldEnum | IngredientPreferenceScalarFieldEnum[]
  }


  /**
   * IngredientPreference findMany
   */
  export type IngredientPreferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientPreference
     */
    select?: IngredientPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which IngredientPreferences to fetch.
     */
    where?: IngredientPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientPreferences to fetch.
     */
    orderBy?: IngredientPreferenceOrderByWithRelationInput | IngredientPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IngredientPreferences.
     */
    cursor?: IngredientPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientPreferences.
     */
    skip?: number
    distinct?: IngredientPreferenceScalarFieldEnum | IngredientPreferenceScalarFieldEnum[]
  }


  /**
   * IngredientPreference create
   */
  export type IngredientPreferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientPreference
     */
    select?: IngredientPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a IngredientPreference.
     */
    data: XOR<IngredientPreferenceCreateInput, IngredientPreferenceUncheckedCreateInput>
  }


  /**
   * IngredientPreference createMany
   */
  export type IngredientPreferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IngredientPreferences.
     */
    data: IngredientPreferenceCreateManyInput | IngredientPreferenceCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * IngredientPreference update
   */
  export type IngredientPreferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientPreference
     */
    select?: IngredientPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a IngredientPreference.
     */
    data: XOR<IngredientPreferenceUpdateInput, IngredientPreferenceUncheckedUpdateInput>
    /**
     * Choose, which IngredientPreference to update.
     */
    where: IngredientPreferenceWhereUniqueInput
  }


  /**
   * IngredientPreference updateMany
   */
  export type IngredientPreferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IngredientPreferences.
     */
    data: XOR<IngredientPreferenceUpdateManyMutationInput, IngredientPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which IngredientPreferences to update
     */
    where?: IngredientPreferenceWhereInput
  }


  /**
   * IngredientPreference upsert
   */
  export type IngredientPreferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientPreference
     */
    select?: IngredientPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientPreferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the IngredientPreference to update in case it exists.
     */
    where: IngredientPreferenceWhereUniqueInput
    /**
     * In case the IngredientPreference found by the `where` argument doesn't exist, create a new IngredientPreference with this data.
     */
    create: XOR<IngredientPreferenceCreateInput, IngredientPreferenceUncheckedCreateInput>
    /**
     * In case the IngredientPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IngredientPreferenceUpdateInput, IngredientPreferenceUncheckedUpdateInput>
  }


  /**
   * IngredientPreference delete
   */
  export type IngredientPreferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientPreference
     */
    select?: IngredientPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientPreferenceInclude<ExtArgs> | null
    /**
     * Filter which IngredientPreference to delete.
     */
    where: IngredientPreferenceWhereUniqueInput
  }


  /**
   * IngredientPreference deleteMany
   */
  export type IngredientPreferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IngredientPreferences to delete
     */
    where?: IngredientPreferenceWhereInput
  }


  /**
   * IngredientPreference without action
   */
  export type IngredientPreferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientPreference
     */
    select?: IngredientPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientPreferenceInclude<ExtArgs> | null
  }



  /**
   * Model Inventory
   */

  export type AggregateInventory = {
    _count: InventoryCountAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  export type InventoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
  }

  export type InventoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
  }

  export type InventoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    editedAt: number
    createdById: number
    editedById: number
    _all: number
  }


  export type InventoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
  }

  export type InventoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
  }

  export type InventoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
    _all?: true
  }

  export type InventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventory to aggregate.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inventories
    **/
    _count?: true | InventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMaxAggregateInputType
  }

  export type GetInventoryAggregateType<T extends InventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventory[P]>
      : GetScalarType<T[P], AggregateInventory[P]>
  }




  export type InventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithAggregationInput | InventoryOrderByWithAggregationInput[]
    by: InventoryScalarFieldEnum[] | InventoryScalarFieldEnum
    having?: InventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryCountAggregateInputType | true
    _min?: InventoryMinAggregateInputType
    _max?: InventoryMaxAggregateInputType
  }

  export type InventoryGroupByOutputType = {
    id: string
    name: string
    description: string
    createdAt: Date
    editedAt: Date
    createdById: string
    editedById: string
    _count: InventoryCountAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  type GetInventoryGroupByPayload<T extends InventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryGroupByOutputType[P]>
        }
      >
    >


  export type InventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    editedAt?: boolean
    createdById?: boolean
    editedById?: boolean
    createdBy?: boolean | Inventory$createdByArgs<ExtArgs>
    editedBy?: boolean | Inventory$editedByArgs<ExtArgs>
    inventoryStorage?: boolean | Inventory$inventoryStorageArgs<ExtArgs>
    inventoryUser?: boolean | Inventory$inventoryUserArgs<ExtArgs>
    crewInventory?: boolean | Inventory$crewInventoryArgs<ExtArgs>
    _count?: boolean | InventoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    editedAt?: boolean
    createdById?: boolean
    editedById?: boolean
  }

  export type InventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Inventory$createdByArgs<ExtArgs>
    editedBy?: boolean | Inventory$editedByArgs<ExtArgs>
    inventoryStorage?: boolean | Inventory$inventoryStorageArgs<ExtArgs>
    inventoryUser?: boolean | Inventory$inventoryUserArgs<ExtArgs>
    crewInventory?: boolean | Inventory$crewInventoryArgs<ExtArgs>
    _count?: boolean | InventoryCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $InventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inventory"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      editedBy: Prisma.$UserPayload<ExtArgs> | null
      inventoryStorage: Prisma.$InventoryStoragePayload<ExtArgs>[]
      inventoryUser: Prisma.$InventoryUserPayload<ExtArgs>[]
      crewInventory: Prisma.$CrewInventoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      createdAt: Date
      editedAt: Date
      createdById: string
      editedById: string
    }, ExtArgs["result"]["inventory"]>
    composites: {}
  }


  type InventoryGetPayload<S extends boolean | null | undefined | InventoryDefaultArgs> = $Result.GetResult<Prisma.$InventoryPayload, S>

  type InventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InventoryFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: InventoryCountAggregateInputType | true
    }

  export interface InventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inventory'], meta: { name: 'Inventory' } }
    /**
     * Find zero or one Inventory that matches the filter.
     * @param {InventoryFindUniqueArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InventoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryFindUniqueArgs<ExtArgs>>
    ): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inventory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InventoryFindUniqueOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InventoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InventoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryFindFirstArgs<ExtArgs>>
    ): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InventoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventories
     * const inventories = await prisma.inventory.findMany()
     * 
     * // Get first 10 Inventories
     * const inventories = await prisma.inventory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryWithIdOnly = await prisma.inventory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InventoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inventory.
     * @param {InventoryCreateArgs} args - Arguments to create a Inventory.
     * @example
     * // Create one Inventory
     * const Inventory = await prisma.inventory.create({
     *   data: {
     *     // ... data to create a Inventory
     *   }
     * })
     * 
    **/
    create<T extends InventoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryCreateArgs<ExtArgs>>
    ): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inventories.
     *     @param {InventoryCreateManyArgs} args - Arguments to create many Inventories.
     *     @example
     *     // Create many Inventories
     *     const inventory = await prisma.inventory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InventoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inventory.
     * @param {InventoryDeleteArgs} args - Arguments to delete one Inventory.
     * @example
     * // Delete one Inventory
     * const Inventory = await prisma.inventory.delete({
     *   where: {
     *     // ... filter to delete one Inventory
     *   }
     * })
     * 
    **/
    delete<T extends InventoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryDeleteArgs<ExtArgs>>
    ): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inventory.
     * @param {InventoryUpdateArgs} args - Arguments to update one Inventory.
     * @example
     * // Update one Inventory
     * const inventory = await prisma.inventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InventoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryUpdateArgs<ExtArgs>>
    ): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inventories.
     * @param {InventoryDeleteManyArgs} args - Arguments to filter Inventories to delete.
     * @example
     * // Delete a few Inventories
     * const { count } = await prisma.inventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InventoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InventoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inventory.
     * @param {InventoryUpsertArgs} args - Arguments to update or create a Inventory.
     * @example
     * // Update or create a Inventory
     * const inventory = await prisma.inventory.upsert({
     *   create: {
     *     // ... data to create a Inventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventory we want to update
     *   }
     * })
    **/
    upsert<T extends InventoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryUpsertArgs<ExtArgs>>
    ): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCountArgs} args - Arguments to filter Inventories to count.
     * @example
     * // Count the number of Inventories
     * const count = await prisma.inventory.count({
     *   where: {
     *     // ... the filter for the Inventories we want to count
     *   }
     * })
    **/
    count<T extends InventoryCountArgs>(
      args?: Subset<T, InventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryAggregateArgs>(args: Subset<T, InventoryAggregateArgs>): Prisma.PrismaPromise<GetInventoryAggregateType<T>>

    /**
     * Group by Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryGroupByArgs['orderBy'] }
        : { orderBy?: InventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inventory model
   */
  readonly fields: InventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    createdBy<T extends Inventory$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Inventory$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    editedBy<T extends Inventory$editedByArgs<ExtArgs> = {}>(args?: Subset<T, Inventory$editedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    inventoryStorage<T extends Inventory$inventoryStorageArgs<ExtArgs> = {}>(args?: Subset<T, Inventory$inventoryStorageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryStoragePayload<ExtArgs>, T, 'findMany'> | Null>;

    inventoryUser<T extends Inventory$inventoryUserArgs<ExtArgs> = {}>(args?: Subset<T, Inventory$inventoryUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    crewInventory<T extends Inventory$crewInventoryArgs<ExtArgs> = {}>(args?: Subset<T, Inventory$crewInventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewInventoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Inventory model
   */ 
  interface InventoryFieldRefs {
    readonly id: FieldRef<"Inventory", 'String'>
    readonly name: FieldRef<"Inventory", 'String'>
    readonly description: FieldRef<"Inventory", 'String'>
    readonly createdAt: FieldRef<"Inventory", 'DateTime'>
    readonly editedAt: FieldRef<"Inventory", 'DateTime'>
    readonly createdById: FieldRef<"Inventory", 'String'>
    readonly editedById: FieldRef<"Inventory", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Inventory findUnique
   */
  export type InventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }


  /**
   * Inventory findUniqueOrThrow
   */
  export type InventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }


  /**
   * Inventory findFirst
   */
  export type InventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }


  /**
   * Inventory findFirstOrThrow
   */
  export type InventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }


  /**
   * Inventory findMany
   */
  export type InventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventories to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }


  /**
   * Inventory create
   */
  export type InventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Inventory.
     */
    data: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
  }


  /**
   * Inventory createMany
   */
  export type InventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inventories.
     */
    data: InventoryCreateManyInput | InventoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Inventory update
   */
  export type InventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Inventory.
     */
    data: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
    /**
     * Choose, which Inventory to update.
     */
    where: InventoryWhereUniqueInput
  }


  /**
   * Inventory updateMany
   */
  export type InventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inventories.
     */
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyInput>
    /**
     * Filter which Inventories to update
     */
    where?: InventoryWhereInput
  }


  /**
   * Inventory upsert
   */
  export type InventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Inventory to update in case it exists.
     */
    where: InventoryWhereUniqueInput
    /**
     * In case the Inventory found by the `where` argument doesn't exist, create a new Inventory with this data.
     */
    create: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
    /**
     * In case the Inventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
  }


  /**
   * Inventory delete
   */
  export type InventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter which Inventory to delete.
     */
    where: InventoryWhereUniqueInput
  }


  /**
   * Inventory deleteMany
   */
  export type InventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventories to delete
     */
    where?: InventoryWhereInput
  }


  /**
   * Inventory.createdBy
   */
  export type Inventory$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Inventory.editedBy
   */
  export type Inventory$editedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Inventory.inventoryStorage
   */
  export type Inventory$inventoryStorageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     */
    select?: InventoryStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryStorageInclude<ExtArgs> | null
    where?: InventoryStorageWhereInput
    orderBy?: InventoryStorageOrderByWithRelationInput | InventoryStorageOrderByWithRelationInput[]
    cursor?: InventoryStorageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryStorageScalarFieldEnum | InventoryStorageScalarFieldEnum[]
  }


  /**
   * Inventory.inventoryUser
   */
  export type Inventory$inventoryUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUser
     */
    select?: InventoryUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryUserInclude<ExtArgs> | null
    where?: InventoryUserWhereInput
    orderBy?: InventoryUserOrderByWithRelationInput | InventoryUserOrderByWithRelationInput[]
    cursor?: InventoryUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryUserScalarFieldEnum | InventoryUserScalarFieldEnum[]
  }


  /**
   * Inventory.crewInventory
   */
  export type Inventory$crewInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewInventory
     */
    select?: CrewInventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInventoryInclude<ExtArgs> | null
    where?: CrewInventoryWhereInput
    orderBy?: CrewInventoryOrderByWithRelationInput | CrewInventoryOrderByWithRelationInput[]
    cursor?: CrewInventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrewInventoryScalarFieldEnum | CrewInventoryScalarFieldEnum[]
  }


  /**
   * Inventory without action
   */
  export type InventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
  }



  /**
   * Model InventoryUser
   */

  export type AggregateInventoryUser = {
    _count: InventoryUserCountAggregateOutputType | null
    _min: InventoryUserMinAggregateOutputType | null
    _max: InventoryUserMaxAggregateOutputType | null
  }

  export type InventoryUserMinAggregateOutputType = {
    userId: string | null
    inventoryId: string | null
    permission: string | null
  }

  export type InventoryUserMaxAggregateOutputType = {
    userId: string | null
    inventoryId: string | null
    permission: string | null
  }

  export type InventoryUserCountAggregateOutputType = {
    userId: number
    inventoryId: number
    permission: number
    _all: number
  }


  export type InventoryUserMinAggregateInputType = {
    userId?: true
    inventoryId?: true
    permission?: true
  }

  export type InventoryUserMaxAggregateInputType = {
    userId?: true
    inventoryId?: true
    permission?: true
  }

  export type InventoryUserCountAggregateInputType = {
    userId?: true
    inventoryId?: true
    permission?: true
    _all?: true
  }

  export type InventoryUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryUser to aggregate.
     */
    where?: InventoryUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryUsers to fetch.
     */
    orderBy?: InventoryUserOrderByWithRelationInput | InventoryUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryUsers
    **/
    _count?: true | InventoryUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryUserMaxAggregateInputType
  }

  export type GetInventoryUserAggregateType<T extends InventoryUserAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryUser[P]>
      : GetScalarType<T[P], AggregateInventoryUser[P]>
  }




  export type InventoryUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryUserWhereInput
    orderBy?: InventoryUserOrderByWithAggregationInput | InventoryUserOrderByWithAggregationInput[]
    by: InventoryUserScalarFieldEnum[] | InventoryUserScalarFieldEnum
    having?: InventoryUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryUserCountAggregateInputType | true
    _min?: InventoryUserMinAggregateInputType
    _max?: InventoryUserMaxAggregateInputType
  }

  export type InventoryUserGroupByOutputType = {
    userId: string
    inventoryId: string
    permission: string
    _count: InventoryUserCountAggregateOutputType | null
    _min: InventoryUserMinAggregateOutputType | null
    _max: InventoryUserMaxAggregateOutputType | null
  }

  type GetInventoryUserGroupByPayload<T extends InventoryUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryUserGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryUserGroupByOutputType[P]>
        }
      >
    >


  export type InventoryUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    inventoryId?: boolean
    permission?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryUser"]>

  export type InventoryUserSelectScalar = {
    userId?: boolean
    inventoryId?: boolean
    permission?: boolean
  }

  export type InventoryUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
  }


  export type $InventoryUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryUser"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      inventory: Prisma.$InventoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      inventoryId: string
      permission: string
    }, ExtArgs["result"]["inventoryUser"]>
    composites: {}
  }


  type InventoryUserGetPayload<S extends boolean | null | undefined | InventoryUserDefaultArgs> = $Result.GetResult<Prisma.$InventoryUserPayload, S>

  type InventoryUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InventoryUserFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: InventoryUserCountAggregateInputType | true
    }

  export interface InventoryUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryUser'], meta: { name: 'InventoryUser' } }
    /**
     * Find zero or one InventoryUser that matches the filter.
     * @param {InventoryUserFindUniqueArgs} args - Arguments to find a InventoryUser
     * @example
     * // Get one InventoryUser
     * const inventoryUser = await prisma.inventoryUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InventoryUserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryUserFindUniqueArgs<ExtArgs>>
    ): Prisma__InventoryUserClient<$Result.GetResult<Prisma.$InventoryUserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one InventoryUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InventoryUserFindUniqueOrThrowArgs} args - Arguments to find a InventoryUser
     * @example
     * // Get one InventoryUser
     * const inventoryUser = await prisma.inventoryUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InventoryUserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryUserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InventoryUserClient<$Result.GetResult<Prisma.$InventoryUserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first InventoryUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUserFindFirstArgs} args - Arguments to find a InventoryUser
     * @example
     * // Get one InventoryUser
     * const inventoryUser = await prisma.inventoryUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InventoryUserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryUserFindFirstArgs<ExtArgs>>
    ): Prisma__InventoryUserClient<$Result.GetResult<Prisma.$InventoryUserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first InventoryUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUserFindFirstOrThrowArgs} args - Arguments to find a InventoryUser
     * @example
     * // Get one InventoryUser
     * const inventoryUser = await prisma.inventoryUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InventoryUserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryUserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InventoryUserClient<$Result.GetResult<Prisma.$InventoryUserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more InventoryUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryUsers
     * const inventoryUsers = await prisma.inventoryUser.findMany()
     * 
     * // Get first 10 InventoryUsers
     * const inventoryUsers = await prisma.inventoryUser.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const inventoryUserWithUserIdOnly = await prisma.inventoryUser.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends InventoryUserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryUserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryUserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a InventoryUser.
     * @param {InventoryUserCreateArgs} args - Arguments to create a InventoryUser.
     * @example
     * // Create one InventoryUser
     * const InventoryUser = await prisma.inventoryUser.create({
     *   data: {
     *     // ... data to create a InventoryUser
     *   }
     * })
     * 
    **/
    create<T extends InventoryUserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryUserCreateArgs<ExtArgs>>
    ): Prisma__InventoryUserClient<$Result.GetResult<Prisma.$InventoryUserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many InventoryUsers.
     *     @param {InventoryUserCreateManyArgs} args - Arguments to create many InventoryUsers.
     *     @example
     *     // Create many InventoryUsers
     *     const inventoryUser = await prisma.inventoryUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InventoryUserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryUserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InventoryUser.
     * @param {InventoryUserDeleteArgs} args - Arguments to delete one InventoryUser.
     * @example
     * // Delete one InventoryUser
     * const InventoryUser = await prisma.inventoryUser.delete({
     *   where: {
     *     // ... filter to delete one InventoryUser
     *   }
     * })
     * 
    **/
    delete<T extends InventoryUserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryUserDeleteArgs<ExtArgs>>
    ): Prisma__InventoryUserClient<$Result.GetResult<Prisma.$InventoryUserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one InventoryUser.
     * @param {InventoryUserUpdateArgs} args - Arguments to update one InventoryUser.
     * @example
     * // Update one InventoryUser
     * const inventoryUser = await prisma.inventoryUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InventoryUserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryUserUpdateArgs<ExtArgs>>
    ): Prisma__InventoryUserClient<$Result.GetResult<Prisma.$InventoryUserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more InventoryUsers.
     * @param {InventoryUserDeleteManyArgs} args - Arguments to filter InventoryUsers to delete.
     * @example
     * // Delete a few InventoryUsers
     * const { count } = await prisma.inventoryUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InventoryUserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryUserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryUsers
     * const inventoryUser = await prisma.inventoryUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InventoryUserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryUserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InventoryUser.
     * @param {InventoryUserUpsertArgs} args - Arguments to update or create a InventoryUser.
     * @example
     * // Update or create a InventoryUser
     * const inventoryUser = await prisma.inventoryUser.upsert({
     *   create: {
     *     // ... data to create a InventoryUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryUser we want to update
     *   }
     * })
    **/
    upsert<T extends InventoryUserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryUserUpsertArgs<ExtArgs>>
    ): Prisma__InventoryUserClient<$Result.GetResult<Prisma.$InventoryUserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of InventoryUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUserCountArgs} args - Arguments to filter InventoryUsers to count.
     * @example
     * // Count the number of InventoryUsers
     * const count = await prisma.inventoryUser.count({
     *   where: {
     *     // ... the filter for the InventoryUsers we want to count
     *   }
     * })
    **/
    count<T extends InventoryUserCountArgs>(
      args?: Subset<T, InventoryUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryUserAggregateArgs>(args: Subset<T, InventoryUserAggregateArgs>): Prisma.PrismaPromise<GetInventoryUserAggregateType<T>>

    /**
     * Group by InventoryUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryUserGroupByArgs['orderBy'] }
        : { orderBy?: InventoryUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryUser model
   */
  readonly fields: InventoryUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    inventory<T extends InventoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryDefaultArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the InventoryUser model
   */ 
  interface InventoryUserFieldRefs {
    readonly userId: FieldRef<"InventoryUser", 'String'>
    readonly inventoryId: FieldRef<"InventoryUser", 'String'>
    readonly permission: FieldRef<"InventoryUser", 'String'>
  }
    

  // Custom InputTypes

  /**
   * InventoryUser findUnique
   */
  export type InventoryUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUser
     */
    select?: InventoryUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryUserInclude<ExtArgs> | null
    /**
     * Filter, which InventoryUser to fetch.
     */
    where: InventoryUserWhereUniqueInput
  }


  /**
   * InventoryUser findUniqueOrThrow
   */
  export type InventoryUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUser
     */
    select?: InventoryUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryUserInclude<ExtArgs> | null
    /**
     * Filter, which InventoryUser to fetch.
     */
    where: InventoryUserWhereUniqueInput
  }


  /**
   * InventoryUser findFirst
   */
  export type InventoryUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUser
     */
    select?: InventoryUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryUserInclude<ExtArgs> | null
    /**
     * Filter, which InventoryUser to fetch.
     */
    where?: InventoryUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryUsers to fetch.
     */
    orderBy?: InventoryUserOrderByWithRelationInput | InventoryUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryUsers.
     */
    cursor?: InventoryUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryUsers.
     */
    distinct?: InventoryUserScalarFieldEnum | InventoryUserScalarFieldEnum[]
  }


  /**
   * InventoryUser findFirstOrThrow
   */
  export type InventoryUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUser
     */
    select?: InventoryUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryUserInclude<ExtArgs> | null
    /**
     * Filter, which InventoryUser to fetch.
     */
    where?: InventoryUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryUsers to fetch.
     */
    orderBy?: InventoryUserOrderByWithRelationInput | InventoryUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryUsers.
     */
    cursor?: InventoryUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryUsers.
     */
    distinct?: InventoryUserScalarFieldEnum | InventoryUserScalarFieldEnum[]
  }


  /**
   * InventoryUser findMany
   */
  export type InventoryUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUser
     */
    select?: InventoryUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryUserInclude<ExtArgs> | null
    /**
     * Filter, which InventoryUsers to fetch.
     */
    where?: InventoryUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryUsers to fetch.
     */
    orderBy?: InventoryUserOrderByWithRelationInput | InventoryUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryUsers.
     */
    cursor?: InventoryUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryUsers.
     */
    skip?: number
    distinct?: InventoryUserScalarFieldEnum | InventoryUserScalarFieldEnum[]
  }


  /**
   * InventoryUser create
   */
  export type InventoryUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUser
     */
    select?: InventoryUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryUserInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryUser.
     */
    data: XOR<InventoryUserCreateInput, InventoryUserUncheckedCreateInput>
  }


  /**
   * InventoryUser createMany
   */
  export type InventoryUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryUsers.
     */
    data: InventoryUserCreateManyInput | InventoryUserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * InventoryUser update
   */
  export type InventoryUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUser
     */
    select?: InventoryUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryUserInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryUser.
     */
    data: XOR<InventoryUserUpdateInput, InventoryUserUncheckedUpdateInput>
    /**
     * Choose, which InventoryUser to update.
     */
    where: InventoryUserWhereUniqueInput
  }


  /**
   * InventoryUser updateMany
   */
  export type InventoryUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryUsers.
     */
    data: XOR<InventoryUserUpdateManyMutationInput, InventoryUserUncheckedUpdateManyInput>
    /**
     * Filter which InventoryUsers to update
     */
    where?: InventoryUserWhereInput
  }


  /**
   * InventoryUser upsert
   */
  export type InventoryUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUser
     */
    select?: InventoryUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryUserInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryUser to update in case it exists.
     */
    where: InventoryUserWhereUniqueInput
    /**
     * In case the InventoryUser found by the `where` argument doesn't exist, create a new InventoryUser with this data.
     */
    create: XOR<InventoryUserCreateInput, InventoryUserUncheckedCreateInput>
    /**
     * In case the InventoryUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryUserUpdateInput, InventoryUserUncheckedUpdateInput>
  }


  /**
   * InventoryUser delete
   */
  export type InventoryUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUser
     */
    select?: InventoryUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryUserInclude<ExtArgs> | null
    /**
     * Filter which InventoryUser to delete.
     */
    where: InventoryUserWhereUniqueInput
  }


  /**
   * InventoryUser deleteMany
   */
  export type InventoryUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryUsers to delete
     */
    where?: InventoryUserWhereInput
  }


  /**
   * InventoryUser without action
   */
  export type InventoryUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUser
     */
    select?: InventoryUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryUserInclude<ExtArgs> | null
  }



  /**
   * Model Storage
   */

  export type AggregateStorage = {
    _count: StorageCountAggregateOutputType | null
    _min: StorageMinAggregateOutputType | null
    _max: StorageMaxAggregateOutputType | null
  }

  export type StorageMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
  }

  export type StorageMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
  }

  export type StorageCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    editedAt: number
    createdById: number
    editedById: number
    _all: number
  }


  export type StorageMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
  }

  export type StorageMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
  }

  export type StorageCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
    _all?: true
  }

  export type StorageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Storage to aggregate.
     */
    where?: StorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Storages to fetch.
     */
    orderBy?: StorageOrderByWithRelationInput | StorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Storages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Storages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Storages
    **/
    _count?: true | StorageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StorageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StorageMaxAggregateInputType
  }

  export type GetStorageAggregateType<T extends StorageAggregateArgs> = {
        [P in keyof T & keyof AggregateStorage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStorage[P]>
      : GetScalarType<T[P], AggregateStorage[P]>
  }




  export type StorageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorageWhereInput
    orderBy?: StorageOrderByWithAggregationInput | StorageOrderByWithAggregationInput[]
    by: StorageScalarFieldEnum[] | StorageScalarFieldEnum
    having?: StorageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StorageCountAggregateInputType | true
    _min?: StorageMinAggregateInputType
    _max?: StorageMaxAggregateInputType
  }

  export type StorageGroupByOutputType = {
    id: string
    name: string
    description: string
    createdAt: Date
    editedAt: Date
    createdById: string
    editedById: string
    _count: StorageCountAggregateOutputType | null
    _min: StorageMinAggregateOutputType | null
    _max: StorageMaxAggregateOutputType | null
  }

  type GetStorageGroupByPayload<T extends StorageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StorageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StorageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StorageGroupByOutputType[P]>
            : GetScalarType<T[P], StorageGroupByOutputType[P]>
        }
      >
    >


  export type StorageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    editedAt?: boolean
    createdById?: boolean
    editedById?: boolean
    createdBy?: boolean | Storage$createdByArgs<ExtArgs>
    editedBy?: boolean | Storage$editedByArgs<ExtArgs>
    inventoryStorage?: boolean | Storage$inventoryStorageArgs<ExtArgs>
    ingredientStorage?: boolean | Storage$ingredientStorageArgs<ExtArgs>
    storageUser?: boolean | Storage$storageUserArgs<ExtArgs>
    crewStorage?: boolean | Storage$crewStorageArgs<ExtArgs>
    _count?: boolean | StorageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storage"]>

  export type StorageSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    editedAt?: boolean
    createdById?: boolean
    editedById?: boolean
  }

  export type StorageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Storage$createdByArgs<ExtArgs>
    editedBy?: boolean | Storage$editedByArgs<ExtArgs>
    inventoryStorage?: boolean | Storage$inventoryStorageArgs<ExtArgs>
    ingredientStorage?: boolean | Storage$ingredientStorageArgs<ExtArgs>
    storageUser?: boolean | Storage$storageUserArgs<ExtArgs>
    crewStorage?: boolean | Storage$crewStorageArgs<ExtArgs>
    _count?: boolean | StorageCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $StoragePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Storage"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      editedBy: Prisma.$UserPayload<ExtArgs> | null
      inventoryStorage: Prisma.$InventoryStoragePayload<ExtArgs>[]
      ingredientStorage: Prisma.$IngredientStoragePayload<ExtArgs>[]
      storageUser: Prisma.$StorageUserPayload<ExtArgs>[]
      crewStorage: Prisma.$CrewStoragePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      createdAt: Date
      editedAt: Date
      createdById: string
      editedById: string
    }, ExtArgs["result"]["storage"]>
    composites: {}
  }


  type StorageGetPayload<S extends boolean | null | undefined | StorageDefaultArgs> = $Result.GetResult<Prisma.$StoragePayload, S>

  type StorageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StorageFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: StorageCountAggregateInputType | true
    }

  export interface StorageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Storage'], meta: { name: 'Storage' } }
    /**
     * Find zero or one Storage that matches the filter.
     * @param {StorageFindUniqueArgs} args - Arguments to find a Storage
     * @example
     * // Get one Storage
     * const storage = await prisma.storage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StorageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StorageFindUniqueArgs<ExtArgs>>
    ): Prisma__StorageClient<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Storage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StorageFindUniqueOrThrowArgs} args - Arguments to find a Storage
     * @example
     * // Get one Storage
     * const storage = await prisma.storage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StorageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StorageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StorageClient<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Storage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageFindFirstArgs} args - Arguments to find a Storage
     * @example
     * // Get one Storage
     * const storage = await prisma.storage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StorageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StorageFindFirstArgs<ExtArgs>>
    ): Prisma__StorageClient<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Storage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageFindFirstOrThrowArgs} args - Arguments to find a Storage
     * @example
     * // Get one Storage
     * const storage = await prisma.storage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StorageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StorageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StorageClient<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Storages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Storages
     * const storages = await prisma.storage.findMany()
     * 
     * // Get first 10 Storages
     * const storages = await prisma.storage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storageWithIdOnly = await prisma.storage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StorageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StorageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Storage.
     * @param {StorageCreateArgs} args - Arguments to create a Storage.
     * @example
     * // Create one Storage
     * const Storage = await prisma.storage.create({
     *   data: {
     *     // ... data to create a Storage
     *   }
     * })
     * 
    **/
    create<T extends StorageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StorageCreateArgs<ExtArgs>>
    ): Prisma__StorageClient<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Storages.
     *     @param {StorageCreateManyArgs} args - Arguments to create many Storages.
     *     @example
     *     // Create many Storages
     *     const storage = await prisma.storage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StorageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StorageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Storage.
     * @param {StorageDeleteArgs} args - Arguments to delete one Storage.
     * @example
     * // Delete one Storage
     * const Storage = await prisma.storage.delete({
     *   where: {
     *     // ... filter to delete one Storage
     *   }
     * })
     * 
    **/
    delete<T extends StorageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StorageDeleteArgs<ExtArgs>>
    ): Prisma__StorageClient<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Storage.
     * @param {StorageUpdateArgs} args - Arguments to update one Storage.
     * @example
     * // Update one Storage
     * const storage = await prisma.storage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StorageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StorageUpdateArgs<ExtArgs>>
    ): Prisma__StorageClient<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Storages.
     * @param {StorageDeleteManyArgs} args - Arguments to filter Storages to delete.
     * @example
     * // Delete a few Storages
     * const { count } = await prisma.storage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StorageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StorageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Storages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Storages
     * const storage = await prisma.storage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StorageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StorageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Storage.
     * @param {StorageUpsertArgs} args - Arguments to update or create a Storage.
     * @example
     * // Update or create a Storage
     * const storage = await prisma.storage.upsert({
     *   create: {
     *     // ... data to create a Storage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Storage we want to update
     *   }
     * })
    **/
    upsert<T extends StorageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StorageUpsertArgs<ExtArgs>>
    ): Prisma__StorageClient<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Storages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageCountArgs} args - Arguments to filter Storages to count.
     * @example
     * // Count the number of Storages
     * const count = await prisma.storage.count({
     *   where: {
     *     // ... the filter for the Storages we want to count
     *   }
     * })
    **/
    count<T extends StorageCountArgs>(
      args?: Subset<T, StorageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StorageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Storage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StorageAggregateArgs>(args: Subset<T, StorageAggregateArgs>): Prisma.PrismaPromise<GetStorageAggregateType<T>>

    /**
     * Group by Storage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StorageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StorageGroupByArgs['orderBy'] }
        : { orderBy?: StorageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StorageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStorageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Storage model
   */
  readonly fields: StorageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Storage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StorageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    createdBy<T extends Storage$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Storage$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    editedBy<T extends Storage$editedByArgs<ExtArgs> = {}>(args?: Subset<T, Storage$editedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    inventoryStorage<T extends Storage$inventoryStorageArgs<ExtArgs> = {}>(args?: Subset<T, Storage$inventoryStorageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryStoragePayload<ExtArgs>, T, 'findMany'> | Null>;

    ingredientStorage<T extends Storage$ingredientStorageArgs<ExtArgs> = {}>(args?: Subset<T, Storage$ingredientStorageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientStoragePayload<ExtArgs>, T, 'findMany'> | Null>;

    storageUser<T extends Storage$storageUserArgs<ExtArgs> = {}>(args?: Subset<T, Storage$storageUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorageUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    crewStorage<T extends Storage$crewStorageArgs<ExtArgs> = {}>(args?: Subset<T, Storage$crewStorageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewStoragePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Storage model
   */ 
  interface StorageFieldRefs {
    readonly id: FieldRef<"Storage", 'String'>
    readonly name: FieldRef<"Storage", 'String'>
    readonly description: FieldRef<"Storage", 'String'>
    readonly createdAt: FieldRef<"Storage", 'DateTime'>
    readonly editedAt: FieldRef<"Storage", 'DateTime'>
    readonly createdById: FieldRef<"Storage", 'String'>
    readonly editedById: FieldRef<"Storage", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Storage findUnique
   */
  export type StorageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageInclude<ExtArgs> | null
    /**
     * Filter, which Storage to fetch.
     */
    where: StorageWhereUniqueInput
  }


  /**
   * Storage findUniqueOrThrow
   */
  export type StorageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageInclude<ExtArgs> | null
    /**
     * Filter, which Storage to fetch.
     */
    where: StorageWhereUniqueInput
  }


  /**
   * Storage findFirst
   */
  export type StorageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageInclude<ExtArgs> | null
    /**
     * Filter, which Storage to fetch.
     */
    where?: StorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Storages to fetch.
     */
    orderBy?: StorageOrderByWithRelationInput | StorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Storages.
     */
    cursor?: StorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Storages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Storages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Storages.
     */
    distinct?: StorageScalarFieldEnum | StorageScalarFieldEnum[]
  }


  /**
   * Storage findFirstOrThrow
   */
  export type StorageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageInclude<ExtArgs> | null
    /**
     * Filter, which Storage to fetch.
     */
    where?: StorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Storages to fetch.
     */
    orderBy?: StorageOrderByWithRelationInput | StorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Storages.
     */
    cursor?: StorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Storages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Storages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Storages.
     */
    distinct?: StorageScalarFieldEnum | StorageScalarFieldEnum[]
  }


  /**
   * Storage findMany
   */
  export type StorageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageInclude<ExtArgs> | null
    /**
     * Filter, which Storages to fetch.
     */
    where?: StorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Storages to fetch.
     */
    orderBy?: StorageOrderByWithRelationInput | StorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Storages.
     */
    cursor?: StorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Storages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Storages.
     */
    skip?: number
    distinct?: StorageScalarFieldEnum | StorageScalarFieldEnum[]
  }


  /**
   * Storage create
   */
  export type StorageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageInclude<ExtArgs> | null
    /**
     * The data needed to create a Storage.
     */
    data: XOR<StorageCreateInput, StorageUncheckedCreateInput>
  }


  /**
   * Storage createMany
   */
  export type StorageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Storages.
     */
    data: StorageCreateManyInput | StorageCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Storage update
   */
  export type StorageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageInclude<ExtArgs> | null
    /**
     * The data needed to update a Storage.
     */
    data: XOR<StorageUpdateInput, StorageUncheckedUpdateInput>
    /**
     * Choose, which Storage to update.
     */
    where: StorageWhereUniqueInput
  }


  /**
   * Storage updateMany
   */
  export type StorageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Storages.
     */
    data: XOR<StorageUpdateManyMutationInput, StorageUncheckedUpdateManyInput>
    /**
     * Filter which Storages to update
     */
    where?: StorageWhereInput
  }


  /**
   * Storage upsert
   */
  export type StorageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageInclude<ExtArgs> | null
    /**
     * The filter to search for the Storage to update in case it exists.
     */
    where: StorageWhereUniqueInput
    /**
     * In case the Storage found by the `where` argument doesn't exist, create a new Storage with this data.
     */
    create: XOR<StorageCreateInput, StorageUncheckedCreateInput>
    /**
     * In case the Storage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StorageUpdateInput, StorageUncheckedUpdateInput>
  }


  /**
   * Storage delete
   */
  export type StorageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageInclude<ExtArgs> | null
    /**
     * Filter which Storage to delete.
     */
    where: StorageWhereUniqueInput
  }


  /**
   * Storage deleteMany
   */
  export type StorageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Storages to delete
     */
    where?: StorageWhereInput
  }


  /**
   * Storage.createdBy
   */
  export type Storage$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Storage.editedBy
   */
  export type Storage$editedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Storage.inventoryStorage
   */
  export type Storage$inventoryStorageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     */
    select?: InventoryStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryStorageInclude<ExtArgs> | null
    where?: InventoryStorageWhereInput
    orderBy?: InventoryStorageOrderByWithRelationInput | InventoryStorageOrderByWithRelationInput[]
    cursor?: InventoryStorageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryStorageScalarFieldEnum | InventoryStorageScalarFieldEnum[]
  }


  /**
   * Storage.ingredientStorage
   */
  export type Storage$ingredientStorageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientStorage
     */
    select?: IngredientStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientStorageInclude<ExtArgs> | null
    where?: IngredientStorageWhereInput
    orderBy?: IngredientStorageOrderByWithRelationInput | IngredientStorageOrderByWithRelationInput[]
    cursor?: IngredientStorageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IngredientStorageScalarFieldEnum | IngredientStorageScalarFieldEnum[]
  }


  /**
   * Storage.storageUser
   */
  export type Storage$storageUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageUser
     */
    select?: StorageUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageUserInclude<ExtArgs> | null
    where?: StorageUserWhereInput
    orderBy?: StorageUserOrderByWithRelationInput | StorageUserOrderByWithRelationInput[]
    cursor?: StorageUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StorageUserScalarFieldEnum | StorageUserScalarFieldEnum[]
  }


  /**
   * Storage.crewStorage
   */
  export type Storage$crewStorageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewStorage
     */
    select?: CrewStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewStorageInclude<ExtArgs> | null
    where?: CrewStorageWhereInput
    orderBy?: CrewStorageOrderByWithRelationInput | CrewStorageOrderByWithRelationInput[]
    cursor?: CrewStorageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrewStorageScalarFieldEnum | CrewStorageScalarFieldEnum[]
  }


  /**
   * Storage without action
   */
  export type StorageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Storage
     */
    select?: StorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageInclude<ExtArgs> | null
  }



  /**
   * Model InventoryStorage
   */

  export type AggregateInventoryStorage = {
    _count: InventoryStorageCountAggregateOutputType | null
    _min: InventoryStorageMinAggregateOutputType | null
    _max: InventoryStorageMaxAggregateOutputType | null
  }

  export type InventoryStorageMinAggregateOutputType = {
    inventoryId: string | null
    storageId: string | null
  }

  export type InventoryStorageMaxAggregateOutputType = {
    inventoryId: string | null
    storageId: string | null
  }

  export type InventoryStorageCountAggregateOutputType = {
    inventoryId: number
    storageId: number
    _all: number
  }


  export type InventoryStorageMinAggregateInputType = {
    inventoryId?: true
    storageId?: true
  }

  export type InventoryStorageMaxAggregateInputType = {
    inventoryId?: true
    storageId?: true
  }

  export type InventoryStorageCountAggregateInputType = {
    inventoryId?: true
    storageId?: true
    _all?: true
  }

  export type InventoryStorageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryStorage to aggregate.
     */
    where?: InventoryStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryStorages to fetch.
     */
    orderBy?: InventoryStorageOrderByWithRelationInput | InventoryStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryStorages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryStorages
    **/
    _count?: true | InventoryStorageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryStorageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryStorageMaxAggregateInputType
  }

  export type GetInventoryStorageAggregateType<T extends InventoryStorageAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryStorage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryStorage[P]>
      : GetScalarType<T[P], AggregateInventoryStorage[P]>
  }




  export type InventoryStorageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryStorageWhereInput
    orderBy?: InventoryStorageOrderByWithAggregationInput | InventoryStorageOrderByWithAggregationInput[]
    by: InventoryStorageScalarFieldEnum[] | InventoryStorageScalarFieldEnum
    having?: InventoryStorageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryStorageCountAggregateInputType | true
    _min?: InventoryStorageMinAggregateInputType
    _max?: InventoryStorageMaxAggregateInputType
  }

  export type InventoryStorageGroupByOutputType = {
    inventoryId: string
    storageId: string
    _count: InventoryStorageCountAggregateOutputType | null
    _min: InventoryStorageMinAggregateOutputType | null
    _max: InventoryStorageMaxAggregateOutputType | null
  }

  type GetInventoryStorageGroupByPayload<T extends InventoryStorageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryStorageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryStorageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryStorageGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryStorageGroupByOutputType[P]>
        }
      >
    >


  export type InventoryStorageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    inventoryId?: boolean
    storageId?: boolean
    storage?: boolean | StorageDefaultArgs<ExtArgs>
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryStorage"]>

  export type InventoryStorageSelectScalar = {
    inventoryId?: boolean
    storageId?: boolean
  }

  export type InventoryStorageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    storage?: boolean | StorageDefaultArgs<ExtArgs>
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
  }


  export type $InventoryStoragePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryStorage"
    objects: {
      storage: Prisma.$StoragePayload<ExtArgs>
      inventory: Prisma.$InventoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      inventoryId: string
      storageId: string
    }, ExtArgs["result"]["inventoryStorage"]>
    composites: {}
  }


  type InventoryStorageGetPayload<S extends boolean | null | undefined | InventoryStorageDefaultArgs> = $Result.GetResult<Prisma.$InventoryStoragePayload, S>

  type InventoryStorageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InventoryStorageFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: InventoryStorageCountAggregateInputType | true
    }

  export interface InventoryStorageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryStorage'], meta: { name: 'InventoryStorage' } }
    /**
     * Find zero or one InventoryStorage that matches the filter.
     * @param {InventoryStorageFindUniqueArgs} args - Arguments to find a InventoryStorage
     * @example
     * // Get one InventoryStorage
     * const inventoryStorage = await prisma.inventoryStorage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InventoryStorageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryStorageFindUniqueArgs<ExtArgs>>
    ): Prisma__InventoryStorageClient<$Result.GetResult<Prisma.$InventoryStoragePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one InventoryStorage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InventoryStorageFindUniqueOrThrowArgs} args - Arguments to find a InventoryStorage
     * @example
     * // Get one InventoryStorage
     * const inventoryStorage = await prisma.inventoryStorage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InventoryStorageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryStorageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InventoryStorageClient<$Result.GetResult<Prisma.$InventoryStoragePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first InventoryStorage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryStorageFindFirstArgs} args - Arguments to find a InventoryStorage
     * @example
     * // Get one InventoryStorage
     * const inventoryStorage = await prisma.inventoryStorage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InventoryStorageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryStorageFindFirstArgs<ExtArgs>>
    ): Prisma__InventoryStorageClient<$Result.GetResult<Prisma.$InventoryStoragePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first InventoryStorage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryStorageFindFirstOrThrowArgs} args - Arguments to find a InventoryStorage
     * @example
     * // Get one InventoryStorage
     * const inventoryStorage = await prisma.inventoryStorage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InventoryStorageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryStorageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InventoryStorageClient<$Result.GetResult<Prisma.$InventoryStoragePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more InventoryStorages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryStorageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryStorages
     * const inventoryStorages = await prisma.inventoryStorage.findMany()
     * 
     * // Get first 10 InventoryStorages
     * const inventoryStorages = await prisma.inventoryStorage.findMany({ take: 10 })
     * 
     * // Only select the `inventoryId`
     * const inventoryStorageWithInventoryIdOnly = await prisma.inventoryStorage.findMany({ select: { inventoryId: true } })
     * 
    **/
    findMany<T extends InventoryStorageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryStorageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryStoragePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a InventoryStorage.
     * @param {InventoryStorageCreateArgs} args - Arguments to create a InventoryStorage.
     * @example
     * // Create one InventoryStorage
     * const InventoryStorage = await prisma.inventoryStorage.create({
     *   data: {
     *     // ... data to create a InventoryStorage
     *   }
     * })
     * 
    **/
    create<T extends InventoryStorageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryStorageCreateArgs<ExtArgs>>
    ): Prisma__InventoryStorageClient<$Result.GetResult<Prisma.$InventoryStoragePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many InventoryStorages.
     *     @param {InventoryStorageCreateManyArgs} args - Arguments to create many InventoryStorages.
     *     @example
     *     // Create many InventoryStorages
     *     const inventoryStorage = await prisma.inventoryStorage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InventoryStorageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryStorageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InventoryStorage.
     * @param {InventoryStorageDeleteArgs} args - Arguments to delete one InventoryStorage.
     * @example
     * // Delete one InventoryStorage
     * const InventoryStorage = await prisma.inventoryStorage.delete({
     *   where: {
     *     // ... filter to delete one InventoryStorage
     *   }
     * })
     * 
    **/
    delete<T extends InventoryStorageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryStorageDeleteArgs<ExtArgs>>
    ): Prisma__InventoryStorageClient<$Result.GetResult<Prisma.$InventoryStoragePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one InventoryStorage.
     * @param {InventoryStorageUpdateArgs} args - Arguments to update one InventoryStorage.
     * @example
     * // Update one InventoryStorage
     * const inventoryStorage = await prisma.inventoryStorage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InventoryStorageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryStorageUpdateArgs<ExtArgs>>
    ): Prisma__InventoryStorageClient<$Result.GetResult<Prisma.$InventoryStoragePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more InventoryStorages.
     * @param {InventoryStorageDeleteManyArgs} args - Arguments to filter InventoryStorages to delete.
     * @example
     * // Delete a few InventoryStorages
     * const { count } = await prisma.inventoryStorage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InventoryStorageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryStorageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryStorages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryStorageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryStorages
     * const inventoryStorage = await prisma.inventoryStorage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InventoryStorageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryStorageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InventoryStorage.
     * @param {InventoryStorageUpsertArgs} args - Arguments to update or create a InventoryStorage.
     * @example
     * // Update or create a InventoryStorage
     * const inventoryStorage = await prisma.inventoryStorage.upsert({
     *   create: {
     *     // ... data to create a InventoryStorage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryStorage we want to update
     *   }
     * })
    **/
    upsert<T extends InventoryStorageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryStorageUpsertArgs<ExtArgs>>
    ): Prisma__InventoryStorageClient<$Result.GetResult<Prisma.$InventoryStoragePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of InventoryStorages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryStorageCountArgs} args - Arguments to filter InventoryStorages to count.
     * @example
     * // Count the number of InventoryStorages
     * const count = await prisma.inventoryStorage.count({
     *   where: {
     *     // ... the filter for the InventoryStorages we want to count
     *   }
     * })
    **/
    count<T extends InventoryStorageCountArgs>(
      args?: Subset<T, InventoryStorageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryStorageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryStorage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryStorageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryStorageAggregateArgs>(args: Subset<T, InventoryStorageAggregateArgs>): Prisma.PrismaPromise<GetInventoryStorageAggregateType<T>>

    /**
     * Group by InventoryStorage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryStorageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryStorageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryStorageGroupByArgs['orderBy'] }
        : { orderBy?: InventoryStorageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryStorageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryStorageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryStorage model
   */
  readonly fields: InventoryStorageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryStorage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryStorageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    storage<T extends StorageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StorageDefaultArgs<ExtArgs>>): Prisma__StorageClient<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    inventory<T extends InventoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryDefaultArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the InventoryStorage model
   */ 
  interface InventoryStorageFieldRefs {
    readonly inventoryId: FieldRef<"InventoryStorage", 'String'>
    readonly storageId: FieldRef<"InventoryStorage", 'String'>
  }
    

  // Custom InputTypes

  /**
   * InventoryStorage findUnique
   */
  export type InventoryStorageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     */
    select?: InventoryStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryStorageInclude<ExtArgs> | null
    /**
     * Filter, which InventoryStorage to fetch.
     */
    where: InventoryStorageWhereUniqueInput
  }


  /**
   * InventoryStorage findUniqueOrThrow
   */
  export type InventoryStorageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     */
    select?: InventoryStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryStorageInclude<ExtArgs> | null
    /**
     * Filter, which InventoryStorage to fetch.
     */
    where: InventoryStorageWhereUniqueInput
  }


  /**
   * InventoryStorage findFirst
   */
  export type InventoryStorageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     */
    select?: InventoryStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryStorageInclude<ExtArgs> | null
    /**
     * Filter, which InventoryStorage to fetch.
     */
    where?: InventoryStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryStorages to fetch.
     */
    orderBy?: InventoryStorageOrderByWithRelationInput | InventoryStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryStorages.
     */
    cursor?: InventoryStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryStorages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryStorages.
     */
    distinct?: InventoryStorageScalarFieldEnum | InventoryStorageScalarFieldEnum[]
  }


  /**
   * InventoryStorage findFirstOrThrow
   */
  export type InventoryStorageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     */
    select?: InventoryStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryStorageInclude<ExtArgs> | null
    /**
     * Filter, which InventoryStorage to fetch.
     */
    where?: InventoryStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryStorages to fetch.
     */
    orderBy?: InventoryStorageOrderByWithRelationInput | InventoryStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryStorages.
     */
    cursor?: InventoryStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryStorages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryStorages.
     */
    distinct?: InventoryStorageScalarFieldEnum | InventoryStorageScalarFieldEnum[]
  }


  /**
   * InventoryStorage findMany
   */
  export type InventoryStorageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     */
    select?: InventoryStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryStorageInclude<ExtArgs> | null
    /**
     * Filter, which InventoryStorages to fetch.
     */
    where?: InventoryStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryStorages to fetch.
     */
    orderBy?: InventoryStorageOrderByWithRelationInput | InventoryStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryStorages.
     */
    cursor?: InventoryStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryStorages.
     */
    skip?: number
    distinct?: InventoryStorageScalarFieldEnum | InventoryStorageScalarFieldEnum[]
  }


  /**
   * InventoryStorage create
   */
  export type InventoryStorageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     */
    select?: InventoryStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryStorageInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryStorage.
     */
    data: XOR<InventoryStorageCreateInput, InventoryStorageUncheckedCreateInput>
  }


  /**
   * InventoryStorage createMany
   */
  export type InventoryStorageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryStorages.
     */
    data: InventoryStorageCreateManyInput | InventoryStorageCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * InventoryStorage update
   */
  export type InventoryStorageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     */
    select?: InventoryStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryStorageInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryStorage.
     */
    data: XOR<InventoryStorageUpdateInput, InventoryStorageUncheckedUpdateInput>
    /**
     * Choose, which InventoryStorage to update.
     */
    where: InventoryStorageWhereUniqueInput
  }


  /**
   * InventoryStorage updateMany
   */
  export type InventoryStorageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryStorages.
     */
    data: XOR<InventoryStorageUpdateManyMutationInput, InventoryStorageUncheckedUpdateManyInput>
    /**
     * Filter which InventoryStorages to update
     */
    where?: InventoryStorageWhereInput
  }


  /**
   * InventoryStorage upsert
   */
  export type InventoryStorageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     */
    select?: InventoryStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryStorageInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryStorage to update in case it exists.
     */
    where: InventoryStorageWhereUniqueInput
    /**
     * In case the InventoryStorage found by the `where` argument doesn't exist, create a new InventoryStorage with this data.
     */
    create: XOR<InventoryStorageCreateInput, InventoryStorageUncheckedCreateInput>
    /**
     * In case the InventoryStorage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryStorageUpdateInput, InventoryStorageUncheckedUpdateInput>
  }


  /**
   * InventoryStorage delete
   */
  export type InventoryStorageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     */
    select?: InventoryStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryStorageInclude<ExtArgs> | null
    /**
     * Filter which InventoryStorage to delete.
     */
    where: InventoryStorageWhereUniqueInput
  }


  /**
   * InventoryStorage deleteMany
   */
  export type InventoryStorageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryStorages to delete
     */
    where?: InventoryStorageWhereInput
  }


  /**
   * InventoryStorage without action
   */
  export type InventoryStorageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryStorage
     */
    select?: InventoryStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryStorageInclude<ExtArgs> | null
  }



  /**
   * Model IngredientStorage
   */

  export type AggregateIngredientStorage = {
    _count: IngredientStorageCountAggregateOutputType | null
    _avg: IngredientStorageAvgAggregateOutputType | null
    _sum: IngredientStorageSumAggregateOutputType | null
    _min: IngredientStorageMinAggregateOutputType | null
    _max: IngredientStorageMaxAggregateOutputType | null
  }

  export type IngredientStorageAvgAggregateOutputType = {
    quantity: number | null
  }

  export type IngredientStorageSumAggregateOutputType = {
    quantity: number | null
  }

  export type IngredientStorageMinAggregateOutputType = {
    ingredientId: string | null
    storageId: string | null
    quantity: number | null
  }

  export type IngredientStorageMaxAggregateOutputType = {
    ingredientId: string | null
    storageId: string | null
    quantity: number | null
  }

  export type IngredientStorageCountAggregateOutputType = {
    ingredientId: number
    storageId: number
    quantity: number
    _all: number
  }


  export type IngredientStorageAvgAggregateInputType = {
    quantity?: true
  }

  export type IngredientStorageSumAggregateInputType = {
    quantity?: true
  }

  export type IngredientStorageMinAggregateInputType = {
    ingredientId?: true
    storageId?: true
    quantity?: true
  }

  export type IngredientStorageMaxAggregateInputType = {
    ingredientId?: true
    storageId?: true
    quantity?: true
  }

  export type IngredientStorageCountAggregateInputType = {
    ingredientId?: true
    storageId?: true
    quantity?: true
    _all?: true
  }

  export type IngredientStorageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IngredientStorage to aggregate.
     */
    where?: IngredientStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientStorages to fetch.
     */
    orderBy?: IngredientStorageOrderByWithRelationInput | IngredientStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IngredientStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientStorages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IngredientStorages
    **/
    _count?: true | IngredientStorageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IngredientStorageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IngredientStorageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IngredientStorageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IngredientStorageMaxAggregateInputType
  }

  export type GetIngredientStorageAggregateType<T extends IngredientStorageAggregateArgs> = {
        [P in keyof T & keyof AggregateIngredientStorage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIngredientStorage[P]>
      : GetScalarType<T[P], AggregateIngredientStorage[P]>
  }




  export type IngredientStorageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngredientStorageWhereInput
    orderBy?: IngredientStorageOrderByWithAggregationInput | IngredientStorageOrderByWithAggregationInput[]
    by: IngredientStorageScalarFieldEnum[] | IngredientStorageScalarFieldEnum
    having?: IngredientStorageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IngredientStorageCountAggregateInputType | true
    _avg?: IngredientStorageAvgAggregateInputType
    _sum?: IngredientStorageSumAggregateInputType
    _min?: IngredientStorageMinAggregateInputType
    _max?: IngredientStorageMaxAggregateInputType
  }

  export type IngredientStorageGroupByOutputType = {
    ingredientId: string
    storageId: string
    quantity: number | null
    _count: IngredientStorageCountAggregateOutputType | null
    _avg: IngredientStorageAvgAggregateOutputType | null
    _sum: IngredientStorageSumAggregateOutputType | null
    _min: IngredientStorageMinAggregateOutputType | null
    _max: IngredientStorageMaxAggregateOutputType | null
  }

  type GetIngredientStorageGroupByPayload<T extends IngredientStorageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IngredientStorageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IngredientStorageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IngredientStorageGroupByOutputType[P]>
            : GetScalarType<T[P], IngredientStorageGroupByOutputType[P]>
        }
      >
    >


  export type IngredientStorageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ingredientId?: boolean
    storageId?: boolean
    quantity?: boolean
    ingredient?: boolean | IngredientDefaultArgs<ExtArgs>
    Storage?: boolean | StorageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ingredientStorage"]>

  export type IngredientStorageSelectScalar = {
    ingredientId?: boolean
    storageId?: boolean
    quantity?: boolean
  }

  export type IngredientStorageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ingredient?: boolean | IngredientDefaultArgs<ExtArgs>
    Storage?: boolean | StorageDefaultArgs<ExtArgs>
  }


  export type $IngredientStoragePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IngredientStorage"
    objects: {
      ingredient: Prisma.$IngredientPayload<ExtArgs>
      Storage: Prisma.$StoragePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ingredientId: string
      storageId: string
      quantity: number | null
    }, ExtArgs["result"]["ingredientStorage"]>
    composites: {}
  }


  type IngredientStorageGetPayload<S extends boolean | null | undefined | IngredientStorageDefaultArgs> = $Result.GetResult<Prisma.$IngredientStoragePayload, S>

  type IngredientStorageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IngredientStorageFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: IngredientStorageCountAggregateInputType | true
    }

  export interface IngredientStorageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IngredientStorage'], meta: { name: 'IngredientStorage' } }
    /**
     * Find zero or one IngredientStorage that matches the filter.
     * @param {IngredientStorageFindUniqueArgs} args - Arguments to find a IngredientStorage
     * @example
     * // Get one IngredientStorage
     * const ingredientStorage = await prisma.ingredientStorage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IngredientStorageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientStorageFindUniqueArgs<ExtArgs>>
    ): Prisma__IngredientStorageClient<$Result.GetResult<Prisma.$IngredientStoragePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one IngredientStorage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {IngredientStorageFindUniqueOrThrowArgs} args - Arguments to find a IngredientStorage
     * @example
     * // Get one IngredientStorage
     * const ingredientStorage = await prisma.ingredientStorage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends IngredientStorageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientStorageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__IngredientStorageClient<$Result.GetResult<Prisma.$IngredientStoragePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first IngredientStorage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientStorageFindFirstArgs} args - Arguments to find a IngredientStorage
     * @example
     * // Get one IngredientStorage
     * const ingredientStorage = await prisma.ingredientStorage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IngredientStorageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientStorageFindFirstArgs<ExtArgs>>
    ): Prisma__IngredientStorageClient<$Result.GetResult<Prisma.$IngredientStoragePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first IngredientStorage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientStorageFindFirstOrThrowArgs} args - Arguments to find a IngredientStorage
     * @example
     * // Get one IngredientStorage
     * const ingredientStorage = await prisma.ingredientStorage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends IngredientStorageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientStorageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__IngredientStorageClient<$Result.GetResult<Prisma.$IngredientStoragePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more IngredientStorages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientStorageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IngredientStorages
     * const ingredientStorages = await prisma.ingredientStorage.findMany()
     * 
     * // Get first 10 IngredientStorages
     * const ingredientStorages = await prisma.ingredientStorage.findMany({ take: 10 })
     * 
     * // Only select the `ingredientId`
     * const ingredientStorageWithIngredientIdOnly = await prisma.ingredientStorage.findMany({ select: { ingredientId: true } })
     * 
    **/
    findMany<T extends IngredientStorageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientStorageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientStoragePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a IngredientStorage.
     * @param {IngredientStorageCreateArgs} args - Arguments to create a IngredientStorage.
     * @example
     * // Create one IngredientStorage
     * const IngredientStorage = await prisma.ingredientStorage.create({
     *   data: {
     *     // ... data to create a IngredientStorage
     *   }
     * })
     * 
    **/
    create<T extends IngredientStorageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientStorageCreateArgs<ExtArgs>>
    ): Prisma__IngredientStorageClient<$Result.GetResult<Prisma.$IngredientStoragePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many IngredientStorages.
     *     @param {IngredientStorageCreateManyArgs} args - Arguments to create many IngredientStorages.
     *     @example
     *     // Create many IngredientStorages
     *     const ingredientStorage = await prisma.ingredientStorage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IngredientStorageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientStorageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a IngredientStorage.
     * @param {IngredientStorageDeleteArgs} args - Arguments to delete one IngredientStorage.
     * @example
     * // Delete one IngredientStorage
     * const IngredientStorage = await prisma.ingredientStorage.delete({
     *   where: {
     *     // ... filter to delete one IngredientStorage
     *   }
     * })
     * 
    **/
    delete<T extends IngredientStorageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientStorageDeleteArgs<ExtArgs>>
    ): Prisma__IngredientStorageClient<$Result.GetResult<Prisma.$IngredientStoragePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one IngredientStorage.
     * @param {IngredientStorageUpdateArgs} args - Arguments to update one IngredientStorage.
     * @example
     * // Update one IngredientStorage
     * const ingredientStorage = await prisma.ingredientStorage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IngredientStorageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientStorageUpdateArgs<ExtArgs>>
    ): Prisma__IngredientStorageClient<$Result.GetResult<Prisma.$IngredientStoragePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more IngredientStorages.
     * @param {IngredientStorageDeleteManyArgs} args - Arguments to filter IngredientStorages to delete.
     * @example
     * // Delete a few IngredientStorages
     * const { count } = await prisma.ingredientStorage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IngredientStorageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientStorageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IngredientStorages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientStorageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IngredientStorages
     * const ingredientStorage = await prisma.ingredientStorage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IngredientStorageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientStorageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IngredientStorage.
     * @param {IngredientStorageUpsertArgs} args - Arguments to update or create a IngredientStorage.
     * @example
     * // Update or create a IngredientStorage
     * const ingredientStorage = await prisma.ingredientStorage.upsert({
     *   create: {
     *     // ... data to create a IngredientStorage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IngredientStorage we want to update
     *   }
     * })
    **/
    upsert<T extends IngredientStorageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientStorageUpsertArgs<ExtArgs>>
    ): Prisma__IngredientStorageClient<$Result.GetResult<Prisma.$IngredientStoragePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of IngredientStorages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientStorageCountArgs} args - Arguments to filter IngredientStorages to count.
     * @example
     * // Count the number of IngredientStorages
     * const count = await prisma.ingredientStorage.count({
     *   where: {
     *     // ... the filter for the IngredientStorages we want to count
     *   }
     * })
    **/
    count<T extends IngredientStorageCountArgs>(
      args?: Subset<T, IngredientStorageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IngredientStorageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IngredientStorage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientStorageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IngredientStorageAggregateArgs>(args: Subset<T, IngredientStorageAggregateArgs>): Prisma.PrismaPromise<GetIngredientStorageAggregateType<T>>

    /**
     * Group by IngredientStorage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientStorageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IngredientStorageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IngredientStorageGroupByArgs['orderBy'] }
        : { orderBy?: IngredientStorageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IngredientStorageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIngredientStorageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IngredientStorage model
   */
  readonly fields: IngredientStorageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IngredientStorage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IngredientStorageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    ingredient<T extends IngredientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IngredientDefaultArgs<ExtArgs>>): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Storage<T extends StorageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StorageDefaultArgs<ExtArgs>>): Prisma__StorageClient<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the IngredientStorage model
   */ 
  interface IngredientStorageFieldRefs {
    readonly ingredientId: FieldRef<"IngredientStorage", 'String'>
    readonly storageId: FieldRef<"IngredientStorage", 'String'>
    readonly quantity: FieldRef<"IngredientStorage", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * IngredientStorage findUnique
   */
  export type IngredientStorageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientStorage
     */
    select?: IngredientStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientStorageInclude<ExtArgs> | null
    /**
     * Filter, which IngredientStorage to fetch.
     */
    where: IngredientStorageWhereUniqueInput
  }


  /**
   * IngredientStorage findUniqueOrThrow
   */
  export type IngredientStorageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientStorage
     */
    select?: IngredientStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientStorageInclude<ExtArgs> | null
    /**
     * Filter, which IngredientStorage to fetch.
     */
    where: IngredientStorageWhereUniqueInput
  }


  /**
   * IngredientStorage findFirst
   */
  export type IngredientStorageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientStorage
     */
    select?: IngredientStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientStorageInclude<ExtArgs> | null
    /**
     * Filter, which IngredientStorage to fetch.
     */
    where?: IngredientStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientStorages to fetch.
     */
    orderBy?: IngredientStorageOrderByWithRelationInput | IngredientStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IngredientStorages.
     */
    cursor?: IngredientStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientStorages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IngredientStorages.
     */
    distinct?: IngredientStorageScalarFieldEnum | IngredientStorageScalarFieldEnum[]
  }


  /**
   * IngredientStorage findFirstOrThrow
   */
  export type IngredientStorageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientStorage
     */
    select?: IngredientStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientStorageInclude<ExtArgs> | null
    /**
     * Filter, which IngredientStorage to fetch.
     */
    where?: IngredientStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientStorages to fetch.
     */
    orderBy?: IngredientStorageOrderByWithRelationInput | IngredientStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IngredientStorages.
     */
    cursor?: IngredientStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientStorages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IngredientStorages.
     */
    distinct?: IngredientStorageScalarFieldEnum | IngredientStorageScalarFieldEnum[]
  }


  /**
   * IngredientStorage findMany
   */
  export type IngredientStorageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientStorage
     */
    select?: IngredientStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientStorageInclude<ExtArgs> | null
    /**
     * Filter, which IngredientStorages to fetch.
     */
    where?: IngredientStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientStorages to fetch.
     */
    orderBy?: IngredientStorageOrderByWithRelationInput | IngredientStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IngredientStorages.
     */
    cursor?: IngredientStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientStorages.
     */
    skip?: number
    distinct?: IngredientStorageScalarFieldEnum | IngredientStorageScalarFieldEnum[]
  }


  /**
   * IngredientStorage create
   */
  export type IngredientStorageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientStorage
     */
    select?: IngredientStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientStorageInclude<ExtArgs> | null
    /**
     * The data needed to create a IngredientStorage.
     */
    data: XOR<IngredientStorageCreateInput, IngredientStorageUncheckedCreateInput>
  }


  /**
   * IngredientStorage createMany
   */
  export type IngredientStorageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IngredientStorages.
     */
    data: IngredientStorageCreateManyInput | IngredientStorageCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * IngredientStorage update
   */
  export type IngredientStorageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientStorage
     */
    select?: IngredientStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientStorageInclude<ExtArgs> | null
    /**
     * The data needed to update a IngredientStorage.
     */
    data: XOR<IngredientStorageUpdateInput, IngredientStorageUncheckedUpdateInput>
    /**
     * Choose, which IngredientStorage to update.
     */
    where: IngredientStorageWhereUniqueInput
  }


  /**
   * IngredientStorage updateMany
   */
  export type IngredientStorageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IngredientStorages.
     */
    data: XOR<IngredientStorageUpdateManyMutationInput, IngredientStorageUncheckedUpdateManyInput>
    /**
     * Filter which IngredientStorages to update
     */
    where?: IngredientStorageWhereInput
  }


  /**
   * IngredientStorage upsert
   */
  export type IngredientStorageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientStorage
     */
    select?: IngredientStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientStorageInclude<ExtArgs> | null
    /**
     * The filter to search for the IngredientStorage to update in case it exists.
     */
    where: IngredientStorageWhereUniqueInput
    /**
     * In case the IngredientStorage found by the `where` argument doesn't exist, create a new IngredientStorage with this data.
     */
    create: XOR<IngredientStorageCreateInput, IngredientStorageUncheckedCreateInput>
    /**
     * In case the IngredientStorage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IngredientStorageUpdateInput, IngredientStorageUncheckedUpdateInput>
  }


  /**
   * IngredientStorage delete
   */
  export type IngredientStorageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientStorage
     */
    select?: IngredientStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientStorageInclude<ExtArgs> | null
    /**
     * Filter which IngredientStorage to delete.
     */
    where: IngredientStorageWhereUniqueInput
  }


  /**
   * IngredientStorage deleteMany
   */
  export type IngredientStorageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IngredientStorages to delete
     */
    where?: IngredientStorageWhereInput
  }


  /**
   * IngredientStorage without action
   */
  export type IngredientStorageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientStorage
     */
    select?: IngredientStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientStorageInclude<ExtArgs> | null
  }



  /**
   * Model StorageUser
   */

  export type AggregateStorageUser = {
    _count: StorageUserCountAggregateOutputType | null
    _min: StorageUserMinAggregateOutputType | null
    _max: StorageUserMaxAggregateOutputType | null
  }

  export type StorageUserMinAggregateOutputType = {
    userId: string | null
    storageId: string | null
    permission: string | null
  }

  export type StorageUserMaxAggregateOutputType = {
    userId: string | null
    storageId: string | null
    permission: string | null
  }

  export type StorageUserCountAggregateOutputType = {
    userId: number
    storageId: number
    permission: number
    _all: number
  }


  export type StorageUserMinAggregateInputType = {
    userId?: true
    storageId?: true
    permission?: true
  }

  export type StorageUserMaxAggregateInputType = {
    userId?: true
    storageId?: true
    permission?: true
  }

  export type StorageUserCountAggregateInputType = {
    userId?: true
    storageId?: true
    permission?: true
    _all?: true
  }

  export type StorageUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StorageUser to aggregate.
     */
    where?: StorageUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageUsers to fetch.
     */
    orderBy?: StorageUserOrderByWithRelationInput | StorageUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StorageUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StorageUsers
    **/
    _count?: true | StorageUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StorageUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StorageUserMaxAggregateInputType
  }

  export type GetStorageUserAggregateType<T extends StorageUserAggregateArgs> = {
        [P in keyof T & keyof AggregateStorageUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStorageUser[P]>
      : GetScalarType<T[P], AggregateStorageUser[P]>
  }




  export type StorageUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorageUserWhereInput
    orderBy?: StorageUserOrderByWithAggregationInput | StorageUserOrderByWithAggregationInput[]
    by: StorageUserScalarFieldEnum[] | StorageUserScalarFieldEnum
    having?: StorageUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StorageUserCountAggregateInputType | true
    _min?: StorageUserMinAggregateInputType
    _max?: StorageUserMaxAggregateInputType
  }

  export type StorageUserGroupByOutputType = {
    userId: string
    storageId: string
    permission: string
    _count: StorageUserCountAggregateOutputType | null
    _min: StorageUserMinAggregateOutputType | null
    _max: StorageUserMaxAggregateOutputType | null
  }

  type GetStorageUserGroupByPayload<T extends StorageUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StorageUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StorageUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StorageUserGroupByOutputType[P]>
            : GetScalarType<T[P], StorageUserGroupByOutputType[P]>
        }
      >
    >


  export type StorageUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    storageId?: boolean
    permission?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    Storage?: boolean | StorageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storageUser"]>

  export type StorageUserSelectScalar = {
    userId?: boolean
    storageId?: boolean
    permission?: boolean
  }

  export type StorageUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    Storage?: boolean | StorageDefaultArgs<ExtArgs>
  }


  export type $StorageUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StorageUser"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      Storage: Prisma.$StoragePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      storageId: string
      permission: string
    }, ExtArgs["result"]["storageUser"]>
    composites: {}
  }


  type StorageUserGetPayload<S extends boolean | null | undefined | StorageUserDefaultArgs> = $Result.GetResult<Prisma.$StorageUserPayload, S>

  type StorageUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StorageUserFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: StorageUserCountAggregateInputType | true
    }

  export interface StorageUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StorageUser'], meta: { name: 'StorageUser' } }
    /**
     * Find zero or one StorageUser that matches the filter.
     * @param {StorageUserFindUniqueArgs} args - Arguments to find a StorageUser
     * @example
     * // Get one StorageUser
     * const storageUser = await prisma.storageUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StorageUserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StorageUserFindUniqueArgs<ExtArgs>>
    ): Prisma__StorageUserClient<$Result.GetResult<Prisma.$StorageUserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StorageUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StorageUserFindUniqueOrThrowArgs} args - Arguments to find a StorageUser
     * @example
     * // Get one StorageUser
     * const storageUser = await prisma.storageUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StorageUserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StorageUserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StorageUserClient<$Result.GetResult<Prisma.$StorageUserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StorageUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageUserFindFirstArgs} args - Arguments to find a StorageUser
     * @example
     * // Get one StorageUser
     * const storageUser = await prisma.storageUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StorageUserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StorageUserFindFirstArgs<ExtArgs>>
    ): Prisma__StorageUserClient<$Result.GetResult<Prisma.$StorageUserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StorageUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageUserFindFirstOrThrowArgs} args - Arguments to find a StorageUser
     * @example
     * // Get one StorageUser
     * const storageUser = await prisma.storageUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StorageUserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StorageUserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StorageUserClient<$Result.GetResult<Prisma.$StorageUserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StorageUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StorageUsers
     * const storageUsers = await prisma.storageUser.findMany()
     * 
     * // Get first 10 StorageUsers
     * const storageUsers = await prisma.storageUser.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const storageUserWithUserIdOnly = await prisma.storageUser.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends StorageUserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StorageUserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorageUserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StorageUser.
     * @param {StorageUserCreateArgs} args - Arguments to create a StorageUser.
     * @example
     * // Create one StorageUser
     * const StorageUser = await prisma.storageUser.create({
     *   data: {
     *     // ... data to create a StorageUser
     *   }
     * })
     * 
    **/
    create<T extends StorageUserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StorageUserCreateArgs<ExtArgs>>
    ): Prisma__StorageUserClient<$Result.GetResult<Prisma.$StorageUserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StorageUsers.
     *     @param {StorageUserCreateManyArgs} args - Arguments to create many StorageUsers.
     *     @example
     *     // Create many StorageUsers
     *     const storageUser = await prisma.storageUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StorageUserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StorageUserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StorageUser.
     * @param {StorageUserDeleteArgs} args - Arguments to delete one StorageUser.
     * @example
     * // Delete one StorageUser
     * const StorageUser = await prisma.storageUser.delete({
     *   where: {
     *     // ... filter to delete one StorageUser
     *   }
     * })
     * 
    **/
    delete<T extends StorageUserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StorageUserDeleteArgs<ExtArgs>>
    ): Prisma__StorageUserClient<$Result.GetResult<Prisma.$StorageUserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StorageUser.
     * @param {StorageUserUpdateArgs} args - Arguments to update one StorageUser.
     * @example
     * // Update one StorageUser
     * const storageUser = await prisma.storageUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StorageUserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StorageUserUpdateArgs<ExtArgs>>
    ): Prisma__StorageUserClient<$Result.GetResult<Prisma.$StorageUserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StorageUsers.
     * @param {StorageUserDeleteManyArgs} args - Arguments to filter StorageUsers to delete.
     * @example
     * // Delete a few StorageUsers
     * const { count } = await prisma.storageUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StorageUserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StorageUserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StorageUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StorageUsers
     * const storageUser = await prisma.storageUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StorageUserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StorageUserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StorageUser.
     * @param {StorageUserUpsertArgs} args - Arguments to update or create a StorageUser.
     * @example
     * // Update or create a StorageUser
     * const storageUser = await prisma.storageUser.upsert({
     *   create: {
     *     // ... data to create a StorageUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StorageUser we want to update
     *   }
     * })
    **/
    upsert<T extends StorageUserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StorageUserUpsertArgs<ExtArgs>>
    ): Prisma__StorageUserClient<$Result.GetResult<Prisma.$StorageUserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StorageUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageUserCountArgs} args - Arguments to filter StorageUsers to count.
     * @example
     * // Count the number of StorageUsers
     * const count = await prisma.storageUser.count({
     *   where: {
     *     // ... the filter for the StorageUsers we want to count
     *   }
     * })
    **/
    count<T extends StorageUserCountArgs>(
      args?: Subset<T, StorageUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StorageUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StorageUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StorageUserAggregateArgs>(args: Subset<T, StorageUserAggregateArgs>): Prisma.PrismaPromise<GetStorageUserAggregateType<T>>

    /**
     * Group by StorageUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StorageUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StorageUserGroupByArgs['orderBy'] }
        : { orderBy?: StorageUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StorageUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStorageUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StorageUser model
   */
  readonly fields: StorageUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StorageUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StorageUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Storage<T extends StorageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StorageDefaultArgs<ExtArgs>>): Prisma__StorageClient<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StorageUser model
   */ 
  interface StorageUserFieldRefs {
    readonly userId: FieldRef<"StorageUser", 'String'>
    readonly storageId: FieldRef<"StorageUser", 'String'>
    readonly permission: FieldRef<"StorageUser", 'String'>
  }
    

  // Custom InputTypes

  /**
   * StorageUser findUnique
   */
  export type StorageUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageUser
     */
    select?: StorageUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageUserInclude<ExtArgs> | null
    /**
     * Filter, which StorageUser to fetch.
     */
    where: StorageUserWhereUniqueInput
  }


  /**
   * StorageUser findUniqueOrThrow
   */
  export type StorageUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageUser
     */
    select?: StorageUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageUserInclude<ExtArgs> | null
    /**
     * Filter, which StorageUser to fetch.
     */
    where: StorageUserWhereUniqueInput
  }


  /**
   * StorageUser findFirst
   */
  export type StorageUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageUser
     */
    select?: StorageUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageUserInclude<ExtArgs> | null
    /**
     * Filter, which StorageUser to fetch.
     */
    where?: StorageUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageUsers to fetch.
     */
    orderBy?: StorageUserOrderByWithRelationInput | StorageUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StorageUsers.
     */
    cursor?: StorageUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StorageUsers.
     */
    distinct?: StorageUserScalarFieldEnum | StorageUserScalarFieldEnum[]
  }


  /**
   * StorageUser findFirstOrThrow
   */
  export type StorageUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageUser
     */
    select?: StorageUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageUserInclude<ExtArgs> | null
    /**
     * Filter, which StorageUser to fetch.
     */
    where?: StorageUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageUsers to fetch.
     */
    orderBy?: StorageUserOrderByWithRelationInput | StorageUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StorageUsers.
     */
    cursor?: StorageUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StorageUsers.
     */
    distinct?: StorageUserScalarFieldEnum | StorageUserScalarFieldEnum[]
  }


  /**
   * StorageUser findMany
   */
  export type StorageUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageUser
     */
    select?: StorageUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageUserInclude<ExtArgs> | null
    /**
     * Filter, which StorageUsers to fetch.
     */
    where?: StorageUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageUsers to fetch.
     */
    orderBy?: StorageUserOrderByWithRelationInput | StorageUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StorageUsers.
     */
    cursor?: StorageUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageUsers.
     */
    skip?: number
    distinct?: StorageUserScalarFieldEnum | StorageUserScalarFieldEnum[]
  }


  /**
   * StorageUser create
   */
  export type StorageUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageUser
     */
    select?: StorageUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageUserInclude<ExtArgs> | null
    /**
     * The data needed to create a StorageUser.
     */
    data: XOR<StorageUserCreateInput, StorageUserUncheckedCreateInput>
  }


  /**
   * StorageUser createMany
   */
  export type StorageUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StorageUsers.
     */
    data: StorageUserCreateManyInput | StorageUserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * StorageUser update
   */
  export type StorageUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageUser
     */
    select?: StorageUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageUserInclude<ExtArgs> | null
    /**
     * The data needed to update a StorageUser.
     */
    data: XOR<StorageUserUpdateInput, StorageUserUncheckedUpdateInput>
    /**
     * Choose, which StorageUser to update.
     */
    where: StorageUserWhereUniqueInput
  }


  /**
   * StorageUser updateMany
   */
  export type StorageUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StorageUsers.
     */
    data: XOR<StorageUserUpdateManyMutationInput, StorageUserUncheckedUpdateManyInput>
    /**
     * Filter which StorageUsers to update
     */
    where?: StorageUserWhereInput
  }


  /**
   * StorageUser upsert
   */
  export type StorageUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageUser
     */
    select?: StorageUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageUserInclude<ExtArgs> | null
    /**
     * The filter to search for the StorageUser to update in case it exists.
     */
    where: StorageUserWhereUniqueInput
    /**
     * In case the StorageUser found by the `where` argument doesn't exist, create a new StorageUser with this data.
     */
    create: XOR<StorageUserCreateInput, StorageUserUncheckedCreateInput>
    /**
     * In case the StorageUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StorageUserUpdateInput, StorageUserUncheckedUpdateInput>
  }


  /**
   * StorageUser delete
   */
  export type StorageUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageUser
     */
    select?: StorageUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageUserInclude<ExtArgs> | null
    /**
     * Filter which StorageUser to delete.
     */
    where: StorageUserWhereUniqueInput
  }


  /**
   * StorageUser deleteMany
   */
  export type StorageUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StorageUsers to delete
     */
    where?: StorageUserWhereInput
  }


  /**
   * StorageUser without action
   */
  export type StorageUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageUser
     */
    select?: StorageUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StorageUserInclude<ExtArgs> | null
  }



  /**
   * Model Crew
   */

  export type AggregateCrew = {
    _count: CrewCountAggregateOutputType | null
    _min: CrewMinAggregateOutputType | null
    _max: CrewMaxAggregateOutputType | null
  }

  export type CrewMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
  }

  export type CrewMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    editedAt: Date | null
    createdById: string | null
    editedById: string | null
  }

  export type CrewCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    editedAt: number
    createdById: number
    editedById: number
    _all: number
  }


  export type CrewMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
  }

  export type CrewMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
  }

  export type CrewCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    editedAt?: true
    createdById?: true
    editedById?: true
    _all?: true
  }

  export type CrewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Crew to aggregate.
     */
    where?: CrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crews to fetch.
     */
    orderBy?: CrewOrderByWithRelationInput | CrewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Crews
    **/
    _count?: true | CrewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrewMaxAggregateInputType
  }

  export type GetCrewAggregateType<T extends CrewAggregateArgs> = {
        [P in keyof T & keyof AggregateCrew]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrew[P]>
      : GetScalarType<T[P], AggregateCrew[P]>
  }




  export type CrewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewWhereInput
    orderBy?: CrewOrderByWithAggregationInput | CrewOrderByWithAggregationInput[]
    by: CrewScalarFieldEnum[] | CrewScalarFieldEnum
    having?: CrewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrewCountAggregateInputType | true
    _min?: CrewMinAggregateInputType
    _max?: CrewMaxAggregateInputType
  }

  export type CrewGroupByOutputType = {
    id: string
    name: string
    description: string
    createdAt: Date
    editedAt: Date
    createdById: string
    editedById: string
    _count: CrewCountAggregateOutputType | null
    _min: CrewMinAggregateOutputType | null
    _max: CrewMaxAggregateOutputType | null
  }

  type GetCrewGroupByPayload<T extends CrewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrewGroupByOutputType[P]>
            : GetScalarType<T[P], CrewGroupByOutputType[P]>
        }
      >
    >


  export type CrewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    editedAt?: boolean
    createdById?: boolean
    editedById?: boolean
    createdBy?: boolean | Crew$createdByArgs<ExtArgs>
    editedBy?: boolean | Crew$editedByArgs<ExtArgs>
    crewUser?: boolean | Crew$crewUserArgs<ExtArgs>
    crewInventory?: boolean | Crew$crewInventoryArgs<ExtArgs>
    crewStorage?: boolean | Crew$crewStorageArgs<ExtArgs>
    crewIngredient?: boolean | Crew$crewIngredientArgs<ExtArgs>
    crewRecipeBook?: boolean | Crew$crewRecipeBookArgs<ExtArgs>
    crewBuild?: boolean | Crew$crewBuildArgs<ExtArgs>
    _count?: boolean | CrewCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crew"]>

  export type CrewSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    editedAt?: boolean
    createdById?: boolean
    editedById?: boolean
  }

  export type CrewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Crew$createdByArgs<ExtArgs>
    editedBy?: boolean | Crew$editedByArgs<ExtArgs>
    crewUser?: boolean | Crew$crewUserArgs<ExtArgs>
    crewInventory?: boolean | Crew$crewInventoryArgs<ExtArgs>
    crewStorage?: boolean | Crew$crewStorageArgs<ExtArgs>
    crewIngredient?: boolean | Crew$crewIngredientArgs<ExtArgs>
    crewRecipeBook?: boolean | Crew$crewRecipeBookArgs<ExtArgs>
    crewBuild?: boolean | Crew$crewBuildArgs<ExtArgs>
    _count?: boolean | CrewCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CrewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Crew"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      editedBy: Prisma.$UserPayload<ExtArgs> | null
      crewUser: Prisma.$CrewUserPayload<ExtArgs>[]
      crewInventory: Prisma.$CrewInventoryPayload<ExtArgs>[]
      crewStorage: Prisma.$CrewStoragePayload<ExtArgs>[]
      crewIngredient: Prisma.$CrewIngredientPayload<ExtArgs>[]
      crewRecipeBook: Prisma.$CrewRecipeBookPayload<ExtArgs>[]
      crewBuild: Prisma.$CrewBuildPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      createdAt: Date
      editedAt: Date
      createdById: string
      editedById: string
    }, ExtArgs["result"]["crew"]>
    composites: {}
  }


  type CrewGetPayload<S extends boolean | null | undefined | CrewDefaultArgs> = $Result.GetResult<Prisma.$CrewPayload, S>

  type CrewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CrewFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CrewCountAggregateInputType | true
    }

  export interface CrewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Crew'], meta: { name: 'Crew' } }
    /**
     * Find zero or one Crew that matches the filter.
     * @param {CrewFindUniqueArgs} args - Arguments to find a Crew
     * @example
     * // Get one Crew
     * const crew = await prisma.crew.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CrewFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CrewFindUniqueArgs<ExtArgs>>
    ): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Crew that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CrewFindUniqueOrThrowArgs} args - Arguments to find a Crew
     * @example
     * // Get one Crew
     * const crew = await prisma.crew.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CrewFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Crew that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewFindFirstArgs} args - Arguments to find a Crew
     * @example
     * // Get one Crew
     * const crew = await prisma.crew.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CrewFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewFindFirstArgs<ExtArgs>>
    ): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Crew that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewFindFirstOrThrowArgs} args - Arguments to find a Crew
     * @example
     * // Get one Crew
     * const crew = await prisma.crew.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CrewFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Crews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Crews
     * const crews = await prisma.crew.findMany()
     * 
     * // Get first 10 Crews
     * const crews = await prisma.crew.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const crewWithIdOnly = await prisma.crew.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CrewFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Crew.
     * @param {CrewCreateArgs} args - Arguments to create a Crew.
     * @example
     * // Create one Crew
     * const Crew = await prisma.crew.create({
     *   data: {
     *     // ... data to create a Crew
     *   }
     * })
     * 
    **/
    create<T extends CrewCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CrewCreateArgs<ExtArgs>>
    ): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Crews.
     *     @param {CrewCreateManyArgs} args - Arguments to create many Crews.
     *     @example
     *     // Create many Crews
     *     const crew = await prisma.crew.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CrewCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Crew.
     * @param {CrewDeleteArgs} args - Arguments to delete one Crew.
     * @example
     * // Delete one Crew
     * const Crew = await prisma.crew.delete({
     *   where: {
     *     // ... filter to delete one Crew
     *   }
     * })
     * 
    **/
    delete<T extends CrewDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CrewDeleteArgs<ExtArgs>>
    ): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Crew.
     * @param {CrewUpdateArgs} args - Arguments to update one Crew.
     * @example
     * // Update one Crew
     * const crew = await prisma.crew.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CrewUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CrewUpdateArgs<ExtArgs>>
    ): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Crews.
     * @param {CrewDeleteManyArgs} args - Arguments to filter Crews to delete.
     * @example
     * // Delete a few Crews
     * const { count } = await prisma.crew.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CrewDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Crews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Crews
     * const crew = await prisma.crew.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CrewUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CrewUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Crew.
     * @param {CrewUpsertArgs} args - Arguments to update or create a Crew.
     * @example
     * // Update or create a Crew
     * const crew = await prisma.crew.upsert({
     *   create: {
     *     // ... data to create a Crew
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Crew we want to update
     *   }
     * })
    **/
    upsert<T extends CrewUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CrewUpsertArgs<ExtArgs>>
    ): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Crews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewCountArgs} args - Arguments to filter Crews to count.
     * @example
     * // Count the number of Crews
     * const count = await prisma.crew.count({
     *   where: {
     *     // ... the filter for the Crews we want to count
     *   }
     * })
    **/
    count<T extends CrewCountArgs>(
      args?: Subset<T, CrewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Crew.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrewAggregateArgs>(args: Subset<T, CrewAggregateArgs>): Prisma.PrismaPromise<GetCrewAggregateType<T>>

    /**
     * Group by Crew.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrewGroupByArgs['orderBy'] }
        : { orderBy?: CrewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Crew model
   */
  readonly fields: CrewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Crew.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CrewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    createdBy<T extends Crew$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Crew$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    editedBy<T extends Crew$editedByArgs<ExtArgs> = {}>(args?: Subset<T, Crew$editedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    crewUser<T extends Crew$crewUserArgs<ExtArgs> = {}>(args?: Subset<T, Crew$crewUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    crewInventory<T extends Crew$crewInventoryArgs<ExtArgs> = {}>(args?: Subset<T, Crew$crewInventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewInventoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    crewStorage<T extends Crew$crewStorageArgs<ExtArgs> = {}>(args?: Subset<T, Crew$crewStorageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewStoragePayload<ExtArgs>, T, 'findMany'> | Null>;

    crewIngredient<T extends Crew$crewIngredientArgs<ExtArgs> = {}>(args?: Subset<T, Crew$crewIngredientArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewIngredientPayload<ExtArgs>, T, 'findMany'> | Null>;

    crewRecipeBook<T extends Crew$crewRecipeBookArgs<ExtArgs> = {}>(args?: Subset<T, Crew$crewRecipeBookArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewRecipeBookPayload<ExtArgs>, T, 'findMany'> | Null>;

    crewBuild<T extends Crew$crewBuildArgs<ExtArgs> = {}>(args?: Subset<T, Crew$crewBuildArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewBuildPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Crew model
   */ 
  interface CrewFieldRefs {
    readonly id: FieldRef<"Crew", 'String'>
    readonly name: FieldRef<"Crew", 'String'>
    readonly description: FieldRef<"Crew", 'String'>
    readonly createdAt: FieldRef<"Crew", 'DateTime'>
    readonly editedAt: FieldRef<"Crew", 'DateTime'>
    readonly createdById: FieldRef<"Crew", 'String'>
    readonly editedById: FieldRef<"Crew", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Crew findUnique
   */
  export type CrewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * Filter, which Crew to fetch.
     */
    where: CrewWhereUniqueInput
  }


  /**
   * Crew findUniqueOrThrow
   */
  export type CrewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * Filter, which Crew to fetch.
     */
    where: CrewWhereUniqueInput
  }


  /**
   * Crew findFirst
   */
  export type CrewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * Filter, which Crew to fetch.
     */
    where?: CrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crews to fetch.
     */
    orderBy?: CrewOrderByWithRelationInput | CrewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Crews.
     */
    cursor?: CrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Crews.
     */
    distinct?: CrewScalarFieldEnum | CrewScalarFieldEnum[]
  }


  /**
   * Crew findFirstOrThrow
   */
  export type CrewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * Filter, which Crew to fetch.
     */
    where?: CrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crews to fetch.
     */
    orderBy?: CrewOrderByWithRelationInput | CrewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Crews.
     */
    cursor?: CrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Crews.
     */
    distinct?: CrewScalarFieldEnum | CrewScalarFieldEnum[]
  }


  /**
   * Crew findMany
   */
  export type CrewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * Filter, which Crews to fetch.
     */
    where?: CrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crews to fetch.
     */
    orderBy?: CrewOrderByWithRelationInput | CrewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Crews.
     */
    cursor?: CrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crews.
     */
    skip?: number
    distinct?: CrewScalarFieldEnum | CrewScalarFieldEnum[]
  }


  /**
   * Crew create
   */
  export type CrewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * The data needed to create a Crew.
     */
    data: XOR<CrewCreateInput, CrewUncheckedCreateInput>
  }


  /**
   * Crew createMany
   */
  export type CrewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Crews.
     */
    data: CrewCreateManyInput | CrewCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Crew update
   */
  export type CrewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * The data needed to update a Crew.
     */
    data: XOR<CrewUpdateInput, CrewUncheckedUpdateInput>
    /**
     * Choose, which Crew to update.
     */
    where: CrewWhereUniqueInput
  }


  /**
   * Crew updateMany
   */
  export type CrewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Crews.
     */
    data: XOR<CrewUpdateManyMutationInput, CrewUncheckedUpdateManyInput>
    /**
     * Filter which Crews to update
     */
    where?: CrewWhereInput
  }


  /**
   * Crew upsert
   */
  export type CrewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * The filter to search for the Crew to update in case it exists.
     */
    where: CrewWhereUniqueInput
    /**
     * In case the Crew found by the `where` argument doesn't exist, create a new Crew with this data.
     */
    create: XOR<CrewCreateInput, CrewUncheckedCreateInput>
    /**
     * In case the Crew was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CrewUpdateInput, CrewUncheckedUpdateInput>
  }


  /**
   * Crew delete
   */
  export type CrewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * Filter which Crew to delete.
     */
    where: CrewWhereUniqueInput
  }


  /**
   * Crew deleteMany
   */
  export type CrewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Crews to delete
     */
    where?: CrewWhereInput
  }


  /**
   * Crew.createdBy
   */
  export type Crew$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Crew.editedBy
   */
  export type Crew$editedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Crew.crewUser
   */
  export type Crew$crewUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewUser
     */
    select?: CrewUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewUserInclude<ExtArgs> | null
    where?: CrewUserWhereInput
    orderBy?: CrewUserOrderByWithRelationInput | CrewUserOrderByWithRelationInput[]
    cursor?: CrewUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrewUserScalarFieldEnum | CrewUserScalarFieldEnum[]
  }


  /**
   * Crew.crewInventory
   */
  export type Crew$crewInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewInventory
     */
    select?: CrewInventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInventoryInclude<ExtArgs> | null
    where?: CrewInventoryWhereInput
    orderBy?: CrewInventoryOrderByWithRelationInput | CrewInventoryOrderByWithRelationInput[]
    cursor?: CrewInventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrewInventoryScalarFieldEnum | CrewInventoryScalarFieldEnum[]
  }


  /**
   * Crew.crewStorage
   */
  export type Crew$crewStorageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewStorage
     */
    select?: CrewStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewStorageInclude<ExtArgs> | null
    where?: CrewStorageWhereInput
    orderBy?: CrewStorageOrderByWithRelationInput | CrewStorageOrderByWithRelationInput[]
    cursor?: CrewStorageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrewStorageScalarFieldEnum | CrewStorageScalarFieldEnum[]
  }


  /**
   * Crew.crewIngredient
   */
  export type Crew$crewIngredientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewIngredient
     */
    select?: CrewIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewIngredientInclude<ExtArgs> | null
    where?: CrewIngredientWhereInput
    orderBy?: CrewIngredientOrderByWithRelationInput | CrewIngredientOrderByWithRelationInput[]
    cursor?: CrewIngredientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrewIngredientScalarFieldEnum | CrewIngredientScalarFieldEnum[]
  }


  /**
   * Crew.crewRecipeBook
   */
  export type Crew$crewRecipeBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewRecipeBook
     */
    select?: CrewRecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewRecipeBookInclude<ExtArgs> | null
    where?: CrewRecipeBookWhereInput
    orderBy?: CrewRecipeBookOrderByWithRelationInput | CrewRecipeBookOrderByWithRelationInput[]
    cursor?: CrewRecipeBookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrewRecipeBookScalarFieldEnum | CrewRecipeBookScalarFieldEnum[]
  }


  /**
   * Crew.crewBuild
   */
  export type Crew$crewBuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewBuild
     */
    select?: CrewBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewBuildInclude<ExtArgs> | null
    where?: CrewBuildWhereInput
    orderBy?: CrewBuildOrderByWithRelationInput | CrewBuildOrderByWithRelationInput[]
    cursor?: CrewBuildWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrewBuildScalarFieldEnum | CrewBuildScalarFieldEnum[]
  }


  /**
   * Crew without action
   */
  export type CrewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInclude<ExtArgs> | null
  }



  /**
   * Model CrewUser
   */

  export type AggregateCrewUser = {
    _count: CrewUserCountAggregateOutputType | null
    _min: CrewUserMinAggregateOutputType | null
    _max: CrewUserMaxAggregateOutputType | null
  }

  export type CrewUserMinAggregateOutputType = {
    userId: string | null
    crewId: string | null
    permission: string | null
  }

  export type CrewUserMaxAggregateOutputType = {
    userId: string | null
    crewId: string | null
    permission: string | null
  }

  export type CrewUserCountAggregateOutputType = {
    userId: number
    crewId: number
    permission: number
    _all: number
  }


  export type CrewUserMinAggregateInputType = {
    userId?: true
    crewId?: true
    permission?: true
  }

  export type CrewUserMaxAggregateInputType = {
    userId?: true
    crewId?: true
    permission?: true
  }

  export type CrewUserCountAggregateInputType = {
    userId?: true
    crewId?: true
    permission?: true
    _all?: true
  }

  export type CrewUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrewUser to aggregate.
     */
    where?: CrewUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewUsers to fetch.
     */
    orderBy?: CrewUserOrderByWithRelationInput | CrewUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CrewUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CrewUsers
    **/
    _count?: true | CrewUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrewUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrewUserMaxAggregateInputType
  }

  export type GetCrewUserAggregateType<T extends CrewUserAggregateArgs> = {
        [P in keyof T & keyof AggregateCrewUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrewUser[P]>
      : GetScalarType<T[P], AggregateCrewUser[P]>
  }




  export type CrewUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewUserWhereInput
    orderBy?: CrewUserOrderByWithAggregationInput | CrewUserOrderByWithAggregationInput[]
    by: CrewUserScalarFieldEnum[] | CrewUserScalarFieldEnum
    having?: CrewUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrewUserCountAggregateInputType | true
    _min?: CrewUserMinAggregateInputType
    _max?: CrewUserMaxAggregateInputType
  }

  export type CrewUserGroupByOutputType = {
    userId: string
    crewId: string
    permission: string
    _count: CrewUserCountAggregateOutputType | null
    _min: CrewUserMinAggregateOutputType | null
    _max: CrewUserMaxAggregateOutputType | null
  }

  type GetCrewUserGroupByPayload<T extends CrewUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrewUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrewUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrewUserGroupByOutputType[P]>
            : GetScalarType<T[P], CrewUserGroupByOutputType[P]>
        }
      >
    >


  export type CrewUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    crewId?: boolean
    permission?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    crew?: boolean | CrewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crewUser"]>

  export type CrewUserSelectScalar = {
    userId?: boolean
    crewId?: boolean
    permission?: boolean
  }

  export type CrewUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    crew?: boolean | CrewDefaultArgs<ExtArgs>
  }


  export type $CrewUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CrewUser"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      crew: Prisma.$CrewPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      crewId: string
      permission: string
    }, ExtArgs["result"]["crewUser"]>
    composites: {}
  }


  type CrewUserGetPayload<S extends boolean | null | undefined | CrewUserDefaultArgs> = $Result.GetResult<Prisma.$CrewUserPayload, S>

  type CrewUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CrewUserFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CrewUserCountAggregateInputType | true
    }

  export interface CrewUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CrewUser'], meta: { name: 'CrewUser' } }
    /**
     * Find zero or one CrewUser that matches the filter.
     * @param {CrewUserFindUniqueArgs} args - Arguments to find a CrewUser
     * @example
     * // Get one CrewUser
     * const crewUser = await prisma.crewUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CrewUserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CrewUserFindUniqueArgs<ExtArgs>>
    ): Prisma__CrewUserClient<$Result.GetResult<Prisma.$CrewUserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CrewUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CrewUserFindUniqueOrThrowArgs} args - Arguments to find a CrewUser
     * @example
     * // Get one CrewUser
     * const crewUser = await prisma.crewUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CrewUserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewUserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CrewUserClient<$Result.GetResult<Prisma.$CrewUserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CrewUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewUserFindFirstArgs} args - Arguments to find a CrewUser
     * @example
     * // Get one CrewUser
     * const crewUser = await prisma.crewUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CrewUserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewUserFindFirstArgs<ExtArgs>>
    ): Prisma__CrewUserClient<$Result.GetResult<Prisma.$CrewUserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CrewUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewUserFindFirstOrThrowArgs} args - Arguments to find a CrewUser
     * @example
     * // Get one CrewUser
     * const crewUser = await prisma.crewUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CrewUserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewUserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CrewUserClient<$Result.GetResult<Prisma.$CrewUserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CrewUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrewUsers
     * const crewUsers = await prisma.crewUser.findMany()
     * 
     * // Get first 10 CrewUsers
     * const crewUsers = await prisma.crewUser.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const crewUserWithUserIdOnly = await prisma.crewUser.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends CrewUserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewUserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewUserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CrewUser.
     * @param {CrewUserCreateArgs} args - Arguments to create a CrewUser.
     * @example
     * // Create one CrewUser
     * const CrewUser = await prisma.crewUser.create({
     *   data: {
     *     // ... data to create a CrewUser
     *   }
     * })
     * 
    **/
    create<T extends CrewUserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CrewUserCreateArgs<ExtArgs>>
    ): Prisma__CrewUserClient<$Result.GetResult<Prisma.$CrewUserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CrewUsers.
     *     @param {CrewUserCreateManyArgs} args - Arguments to create many CrewUsers.
     *     @example
     *     // Create many CrewUsers
     *     const crewUser = await prisma.crewUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CrewUserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewUserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CrewUser.
     * @param {CrewUserDeleteArgs} args - Arguments to delete one CrewUser.
     * @example
     * // Delete one CrewUser
     * const CrewUser = await prisma.crewUser.delete({
     *   where: {
     *     // ... filter to delete one CrewUser
     *   }
     * })
     * 
    **/
    delete<T extends CrewUserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CrewUserDeleteArgs<ExtArgs>>
    ): Prisma__CrewUserClient<$Result.GetResult<Prisma.$CrewUserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CrewUser.
     * @param {CrewUserUpdateArgs} args - Arguments to update one CrewUser.
     * @example
     * // Update one CrewUser
     * const crewUser = await prisma.crewUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CrewUserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CrewUserUpdateArgs<ExtArgs>>
    ): Prisma__CrewUserClient<$Result.GetResult<Prisma.$CrewUserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CrewUsers.
     * @param {CrewUserDeleteManyArgs} args - Arguments to filter CrewUsers to delete.
     * @example
     * // Delete a few CrewUsers
     * const { count } = await prisma.crewUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CrewUserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewUserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrewUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrewUsers
     * const crewUser = await prisma.crewUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CrewUserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CrewUserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CrewUser.
     * @param {CrewUserUpsertArgs} args - Arguments to update or create a CrewUser.
     * @example
     * // Update or create a CrewUser
     * const crewUser = await prisma.crewUser.upsert({
     *   create: {
     *     // ... data to create a CrewUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrewUser we want to update
     *   }
     * })
    **/
    upsert<T extends CrewUserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CrewUserUpsertArgs<ExtArgs>>
    ): Prisma__CrewUserClient<$Result.GetResult<Prisma.$CrewUserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CrewUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewUserCountArgs} args - Arguments to filter CrewUsers to count.
     * @example
     * // Count the number of CrewUsers
     * const count = await prisma.crewUser.count({
     *   where: {
     *     // ... the filter for the CrewUsers we want to count
     *   }
     * })
    **/
    count<T extends CrewUserCountArgs>(
      args?: Subset<T, CrewUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrewUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrewUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrewUserAggregateArgs>(args: Subset<T, CrewUserAggregateArgs>): Prisma.PrismaPromise<GetCrewUserAggregateType<T>>

    /**
     * Group by CrewUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrewUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrewUserGroupByArgs['orderBy'] }
        : { orderBy?: CrewUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrewUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrewUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CrewUser model
   */
  readonly fields: CrewUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CrewUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CrewUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    crew<T extends CrewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CrewDefaultArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CrewUser model
   */ 
  interface CrewUserFieldRefs {
    readonly userId: FieldRef<"CrewUser", 'String'>
    readonly crewId: FieldRef<"CrewUser", 'String'>
    readonly permission: FieldRef<"CrewUser", 'String'>
  }
    

  // Custom InputTypes

  /**
   * CrewUser findUnique
   */
  export type CrewUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewUser
     */
    select?: CrewUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewUserInclude<ExtArgs> | null
    /**
     * Filter, which CrewUser to fetch.
     */
    where: CrewUserWhereUniqueInput
  }


  /**
   * CrewUser findUniqueOrThrow
   */
  export type CrewUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewUser
     */
    select?: CrewUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewUserInclude<ExtArgs> | null
    /**
     * Filter, which CrewUser to fetch.
     */
    where: CrewUserWhereUniqueInput
  }


  /**
   * CrewUser findFirst
   */
  export type CrewUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewUser
     */
    select?: CrewUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewUserInclude<ExtArgs> | null
    /**
     * Filter, which CrewUser to fetch.
     */
    where?: CrewUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewUsers to fetch.
     */
    orderBy?: CrewUserOrderByWithRelationInput | CrewUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrewUsers.
     */
    cursor?: CrewUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrewUsers.
     */
    distinct?: CrewUserScalarFieldEnum | CrewUserScalarFieldEnum[]
  }


  /**
   * CrewUser findFirstOrThrow
   */
  export type CrewUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewUser
     */
    select?: CrewUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewUserInclude<ExtArgs> | null
    /**
     * Filter, which CrewUser to fetch.
     */
    where?: CrewUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewUsers to fetch.
     */
    orderBy?: CrewUserOrderByWithRelationInput | CrewUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrewUsers.
     */
    cursor?: CrewUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrewUsers.
     */
    distinct?: CrewUserScalarFieldEnum | CrewUserScalarFieldEnum[]
  }


  /**
   * CrewUser findMany
   */
  export type CrewUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewUser
     */
    select?: CrewUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewUserInclude<ExtArgs> | null
    /**
     * Filter, which CrewUsers to fetch.
     */
    where?: CrewUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewUsers to fetch.
     */
    orderBy?: CrewUserOrderByWithRelationInput | CrewUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CrewUsers.
     */
    cursor?: CrewUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewUsers.
     */
    skip?: number
    distinct?: CrewUserScalarFieldEnum | CrewUserScalarFieldEnum[]
  }


  /**
   * CrewUser create
   */
  export type CrewUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewUser
     */
    select?: CrewUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewUserInclude<ExtArgs> | null
    /**
     * The data needed to create a CrewUser.
     */
    data: XOR<CrewUserCreateInput, CrewUserUncheckedCreateInput>
  }


  /**
   * CrewUser createMany
   */
  export type CrewUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CrewUsers.
     */
    data: CrewUserCreateManyInput | CrewUserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CrewUser update
   */
  export type CrewUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewUser
     */
    select?: CrewUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewUserInclude<ExtArgs> | null
    /**
     * The data needed to update a CrewUser.
     */
    data: XOR<CrewUserUpdateInput, CrewUserUncheckedUpdateInput>
    /**
     * Choose, which CrewUser to update.
     */
    where: CrewUserWhereUniqueInput
  }


  /**
   * CrewUser updateMany
   */
  export type CrewUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CrewUsers.
     */
    data: XOR<CrewUserUpdateManyMutationInput, CrewUserUncheckedUpdateManyInput>
    /**
     * Filter which CrewUsers to update
     */
    where?: CrewUserWhereInput
  }


  /**
   * CrewUser upsert
   */
  export type CrewUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewUser
     */
    select?: CrewUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewUserInclude<ExtArgs> | null
    /**
     * The filter to search for the CrewUser to update in case it exists.
     */
    where: CrewUserWhereUniqueInput
    /**
     * In case the CrewUser found by the `where` argument doesn't exist, create a new CrewUser with this data.
     */
    create: XOR<CrewUserCreateInput, CrewUserUncheckedCreateInput>
    /**
     * In case the CrewUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CrewUserUpdateInput, CrewUserUncheckedUpdateInput>
  }


  /**
   * CrewUser delete
   */
  export type CrewUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewUser
     */
    select?: CrewUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewUserInclude<ExtArgs> | null
    /**
     * Filter which CrewUser to delete.
     */
    where: CrewUserWhereUniqueInput
  }


  /**
   * CrewUser deleteMany
   */
  export type CrewUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrewUsers to delete
     */
    where?: CrewUserWhereInput
  }


  /**
   * CrewUser without action
   */
  export type CrewUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewUser
     */
    select?: CrewUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewUserInclude<ExtArgs> | null
  }



  /**
   * Model CrewInventory
   */

  export type AggregateCrewInventory = {
    _count: CrewInventoryCountAggregateOutputType | null
    _min: CrewInventoryMinAggregateOutputType | null
    _max: CrewInventoryMaxAggregateOutputType | null
  }

  export type CrewInventoryMinAggregateOutputType = {
    inventoryId: string | null
    crewId: string | null
  }

  export type CrewInventoryMaxAggregateOutputType = {
    inventoryId: string | null
    crewId: string | null
  }

  export type CrewInventoryCountAggregateOutputType = {
    inventoryId: number
    crewId: number
    _all: number
  }


  export type CrewInventoryMinAggregateInputType = {
    inventoryId?: true
    crewId?: true
  }

  export type CrewInventoryMaxAggregateInputType = {
    inventoryId?: true
    crewId?: true
  }

  export type CrewInventoryCountAggregateInputType = {
    inventoryId?: true
    crewId?: true
    _all?: true
  }

  export type CrewInventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrewInventory to aggregate.
     */
    where?: CrewInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewInventories to fetch.
     */
    orderBy?: CrewInventoryOrderByWithRelationInput | CrewInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CrewInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CrewInventories
    **/
    _count?: true | CrewInventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrewInventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrewInventoryMaxAggregateInputType
  }

  export type GetCrewInventoryAggregateType<T extends CrewInventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCrewInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrewInventory[P]>
      : GetScalarType<T[P], AggregateCrewInventory[P]>
  }




  export type CrewInventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewInventoryWhereInput
    orderBy?: CrewInventoryOrderByWithAggregationInput | CrewInventoryOrderByWithAggregationInput[]
    by: CrewInventoryScalarFieldEnum[] | CrewInventoryScalarFieldEnum
    having?: CrewInventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrewInventoryCountAggregateInputType | true
    _min?: CrewInventoryMinAggregateInputType
    _max?: CrewInventoryMaxAggregateInputType
  }

  export type CrewInventoryGroupByOutputType = {
    inventoryId: string
    crewId: string
    _count: CrewInventoryCountAggregateOutputType | null
    _min: CrewInventoryMinAggregateOutputType | null
    _max: CrewInventoryMaxAggregateOutputType | null
  }

  type GetCrewInventoryGroupByPayload<T extends CrewInventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrewInventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrewInventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrewInventoryGroupByOutputType[P]>
            : GetScalarType<T[P], CrewInventoryGroupByOutputType[P]>
        }
      >
    >


  export type CrewInventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    inventoryId?: boolean
    crewId?: boolean
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
    crew?: boolean | CrewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crewInventory"]>

  export type CrewInventorySelectScalar = {
    inventoryId?: boolean
    crewId?: boolean
  }

  export type CrewInventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
    crew?: boolean | CrewDefaultArgs<ExtArgs>
  }


  export type $CrewInventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CrewInventory"
    objects: {
      inventory: Prisma.$InventoryPayload<ExtArgs>
      crew: Prisma.$CrewPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      inventoryId: string
      crewId: string
    }, ExtArgs["result"]["crewInventory"]>
    composites: {}
  }


  type CrewInventoryGetPayload<S extends boolean | null | undefined | CrewInventoryDefaultArgs> = $Result.GetResult<Prisma.$CrewInventoryPayload, S>

  type CrewInventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CrewInventoryFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CrewInventoryCountAggregateInputType | true
    }

  export interface CrewInventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CrewInventory'], meta: { name: 'CrewInventory' } }
    /**
     * Find zero or one CrewInventory that matches the filter.
     * @param {CrewInventoryFindUniqueArgs} args - Arguments to find a CrewInventory
     * @example
     * // Get one CrewInventory
     * const crewInventory = await prisma.crewInventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CrewInventoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CrewInventoryFindUniqueArgs<ExtArgs>>
    ): Prisma__CrewInventoryClient<$Result.GetResult<Prisma.$CrewInventoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CrewInventory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CrewInventoryFindUniqueOrThrowArgs} args - Arguments to find a CrewInventory
     * @example
     * // Get one CrewInventory
     * const crewInventory = await prisma.crewInventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CrewInventoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewInventoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CrewInventoryClient<$Result.GetResult<Prisma.$CrewInventoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CrewInventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewInventoryFindFirstArgs} args - Arguments to find a CrewInventory
     * @example
     * // Get one CrewInventory
     * const crewInventory = await prisma.crewInventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CrewInventoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewInventoryFindFirstArgs<ExtArgs>>
    ): Prisma__CrewInventoryClient<$Result.GetResult<Prisma.$CrewInventoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CrewInventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewInventoryFindFirstOrThrowArgs} args - Arguments to find a CrewInventory
     * @example
     * // Get one CrewInventory
     * const crewInventory = await prisma.crewInventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CrewInventoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewInventoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CrewInventoryClient<$Result.GetResult<Prisma.$CrewInventoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CrewInventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewInventoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrewInventories
     * const crewInventories = await prisma.crewInventory.findMany()
     * 
     * // Get first 10 CrewInventories
     * const crewInventories = await prisma.crewInventory.findMany({ take: 10 })
     * 
     * // Only select the `inventoryId`
     * const crewInventoryWithInventoryIdOnly = await prisma.crewInventory.findMany({ select: { inventoryId: true } })
     * 
    **/
    findMany<T extends CrewInventoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewInventoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewInventoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CrewInventory.
     * @param {CrewInventoryCreateArgs} args - Arguments to create a CrewInventory.
     * @example
     * // Create one CrewInventory
     * const CrewInventory = await prisma.crewInventory.create({
     *   data: {
     *     // ... data to create a CrewInventory
     *   }
     * })
     * 
    **/
    create<T extends CrewInventoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CrewInventoryCreateArgs<ExtArgs>>
    ): Prisma__CrewInventoryClient<$Result.GetResult<Prisma.$CrewInventoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CrewInventories.
     *     @param {CrewInventoryCreateManyArgs} args - Arguments to create many CrewInventories.
     *     @example
     *     // Create many CrewInventories
     *     const crewInventory = await prisma.crewInventory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CrewInventoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewInventoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CrewInventory.
     * @param {CrewInventoryDeleteArgs} args - Arguments to delete one CrewInventory.
     * @example
     * // Delete one CrewInventory
     * const CrewInventory = await prisma.crewInventory.delete({
     *   where: {
     *     // ... filter to delete one CrewInventory
     *   }
     * })
     * 
    **/
    delete<T extends CrewInventoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CrewInventoryDeleteArgs<ExtArgs>>
    ): Prisma__CrewInventoryClient<$Result.GetResult<Prisma.$CrewInventoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CrewInventory.
     * @param {CrewInventoryUpdateArgs} args - Arguments to update one CrewInventory.
     * @example
     * // Update one CrewInventory
     * const crewInventory = await prisma.crewInventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CrewInventoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CrewInventoryUpdateArgs<ExtArgs>>
    ): Prisma__CrewInventoryClient<$Result.GetResult<Prisma.$CrewInventoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CrewInventories.
     * @param {CrewInventoryDeleteManyArgs} args - Arguments to filter CrewInventories to delete.
     * @example
     * // Delete a few CrewInventories
     * const { count } = await prisma.crewInventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CrewInventoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewInventoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrewInventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewInventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrewInventories
     * const crewInventory = await prisma.crewInventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CrewInventoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CrewInventoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CrewInventory.
     * @param {CrewInventoryUpsertArgs} args - Arguments to update or create a CrewInventory.
     * @example
     * // Update or create a CrewInventory
     * const crewInventory = await prisma.crewInventory.upsert({
     *   create: {
     *     // ... data to create a CrewInventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrewInventory we want to update
     *   }
     * })
    **/
    upsert<T extends CrewInventoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CrewInventoryUpsertArgs<ExtArgs>>
    ): Prisma__CrewInventoryClient<$Result.GetResult<Prisma.$CrewInventoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CrewInventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewInventoryCountArgs} args - Arguments to filter CrewInventories to count.
     * @example
     * // Count the number of CrewInventories
     * const count = await prisma.crewInventory.count({
     *   where: {
     *     // ... the filter for the CrewInventories we want to count
     *   }
     * })
    **/
    count<T extends CrewInventoryCountArgs>(
      args?: Subset<T, CrewInventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrewInventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrewInventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewInventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrewInventoryAggregateArgs>(args: Subset<T, CrewInventoryAggregateArgs>): Prisma.PrismaPromise<GetCrewInventoryAggregateType<T>>

    /**
     * Group by CrewInventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewInventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrewInventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrewInventoryGroupByArgs['orderBy'] }
        : { orderBy?: CrewInventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrewInventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrewInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CrewInventory model
   */
  readonly fields: CrewInventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CrewInventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CrewInventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    inventory<T extends InventoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryDefaultArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    crew<T extends CrewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CrewDefaultArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CrewInventory model
   */ 
  interface CrewInventoryFieldRefs {
    readonly inventoryId: FieldRef<"CrewInventory", 'String'>
    readonly crewId: FieldRef<"CrewInventory", 'String'>
  }
    

  // Custom InputTypes

  /**
   * CrewInventory findUnique
   */
  export type CrewInventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewInventory
     */
    select?: CrewInventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInventoryInclude<ExtArgs> | null
    /**
     * Filter, which CrewInventory to fetch.
     */
    where: CrewInventoryWhereUniqueInput
  }


  /**
   * CrewInventory findUniqueOrThrow
   */
  export type CrewInventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewInventory
     */
    select?: CrewInventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInventoryInclude<ExtArgs> | null
    /**
     * Filter, which CrewInventory to fetch.
     */
    where: CrewInventoryWhereUniqueInput
  }


  /**
   * CrewInventory findFirst
   */
  export type CrewInventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewInventory
     */
    select?: CrewInventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInventoryInclude<ExtArgs> | null
    /**
     * Filter, which CrewInventory to fetch.
     */
    where?: CrewInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewInventories to fetch.
     */
    orderBy?: CrewInventoryOrderByWithRelationInput | CrewInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrewInventories.
     */
    cursor?: CrewInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrewInventories.
     */
    distinct?: CrewInventoryScalarFieldEnum | CrewInventoryScalarFieldEnum[]
  }


  /**
   * CrewInventory findFirstOrThrow
   */
  export type CrewInventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewInventory
     */
    select?: CrewInventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInventoryInclude<ExtArgs> | null
    /**
     * Filter, which CrewInventory to fetch.
     */
    where?: CrewInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewInventories to fetch.
     */
    orderBy?: CrewInventoryOrderByWithRelationInput | CrewInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrewInventories.
     */
    cursor?: CrewInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrewInventories.
     */
    distinct?: CrewInventoryScalarFieldEnum | CrewInventoryScalarFieldEnum[]
  }


  /**
   * CrewInventory findMany
   */
  export type CrewInventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewInventory
     */
    select?: CrewInventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInventoryInclude<ExtArgs> | null
    /**
     * Filter, which CrewInventories to fetch.
     */
    where?: CrewInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewInventories to fetch.
     */
    orderBy?: CrewInventoryOrderByWithRelationInput | CrewInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CrewInventories.
     */
    cursor?: CrewInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewInventories.
     */
    skip?: number
    distinct?: CrewInventoryScalarFieldEnum | CrewInventoryScalarFieldEnum[]
  }


  /**
   * CrewInventory create
   */
  export type CrewInventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewInventory
     */
    select?: CrewInventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInventoryInclude<ExtArgs> | null
    /**
     * The data needed to create a CrewInventory.
     */
    data: XOR<CrewInventoryCreateInput, CrewInventoryUncheckedCreateInput>
  }


  /**
   * CrewInventory createMany
   */
  export type CrewInventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CrewInventories.
     */
    data: CrewInventoryCreateManyInput | CrewInventoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CrewInventory update
   */
  export type CrewInventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewInventory
     */
    select?: CrewInventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInventoryInclude<ExtArgs> | null
    /**
     * The data needed to update a CrewInventory.
     */
    data: XOR<CrewInventoryUpdateInput, CrewInventoryUncheckedUpdateInput>
    /**
     * Choose, which CrewInventory to update.
     */
    where: CrewInventoryWhereUniqueInput
  }


  /**
   * CrewInventory updateMany
   */
  export type CrewInventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CrewInventories.
     */
    data: XOR<CrewInventoryUpdateManyMutationInput, CrewInventoryUncheckedUpdateManyInput>
    /**
     * Filter which CrewInventories to update
     */
    where?: CrewInventoryWhereInput
  }


  /**
   * CrewInventory upsert
   */
  export type CrewInventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewInventory
     */
    select?: CrewInventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInventoryInclude<ExtArgs> | null
    /**
     * The filter to search for the CrewInventory to update in case it exists.
     */
    where: CrewInventoryWhereUniqueInput
    /**
     * In case the CrewInventory found by the `where` argument doesn't exist, create a new CrewInventory with this data.
     */
    create: XOR<CrewInventoryCreateInput, CrewInventoryUncheckedCreateInput>
    /**
     * In case the CrewInventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CrewInventoryUpdateInput, CrewInventoryUncheckedUpdateInput>
  }


  /**
   * CrewInventory delete
   */
  export type CrewInventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewInventory
     */
    select?: CrewInventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInventoryInclude<ExtArgs> | null
    /**
     * Filter which CrewInventory to delete.
     */
    where: CrewInventoryWhereUniqueInput
  }


  /**
   * CrewInventory deleteMany
   */
  export type CrewInventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrewInventories to delete
     */
    where?: CrewInventoryWhereInput
  }


  /**
   * CrewInventory without action
   */
  export type CrewInventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewInventory
     */
    select?: CrewInventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewInventoryInclude<ExtArgs> | null
  }



  /**
   * Model CrewStorage
   */

  export type AggregateCrewStorage = {
    _count: CrewStorageCountAggregateOutputType | null
    _min: CrewStorageMinAggregateOutputType | null
    _max: CrewStorageMaxAggregateOutputType | null
  }

  export type CrewStorageMinAggregateOutputType = {
    storageId: string | null
    crewId: string | null
  }

  export type CrewStorageMaxAggregateOutputType = {
    storageId: string | null
    crewId: string | null
  }

  export type CrewStorageCountAggregateOutputType = {
    storageId: number
    crewId: number
    _all: number
  }


  export type CrewStorageMinAggregateInputType = {
    storageId?: true
    crewId?: true
  }

  export type CrewStorageMaxAggregateInputType = {
    storageId?: true
    crewId?: true
  }

  export type CrewStorageCountAggregateInputType = {
    storageId?: true
    crewId?: true
    _all?: true
  }

  export type CrewStorageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrewStorage to aggregate.
     */
    where?: CrewStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewStorages to fetch.
     */
    orderBy?: CrewStorageOrderByWithRelationInput | CrewStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CrewStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewStorages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CrewStorages
    **/
    _count?: true | CrewStorageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrewStorageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrewStorageMaxAggregateInputType
  }

  export type GetCrewStorageAggregateType<T extends CrewStorageAggregateArgs> = {
        [P in keyof T & keyof AggregateCrewStorage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrewStorage[P]>
      : GetScalarType<T[P], AggregateCrewStorage[P]>
  }




  export type CrewStorageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewStorageWhereInput
    orderBy?: CrewStorageOrderByWithAggregationInput | CrewStorageOrderByWithAggregationInput[]
    by: CrewStorageScalarFieldEnum[] | CrewStorageScalarFieldEnum
    having?: CrewStorageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrewStorageCountAggregateInputType | true
    _min?: CrewStorageMinAggregateInputType
    _max?: CrewStorageMaxAggregateInputType
  }

  export type CrewStorageGroupByOutputType = {
    storageId: string
    crewId: string
    _count: CrewStorageCountAggregateOutputType | null
    _min: CrewStorageMinAggregateOutputType | null
    _max: CrewStorageMaxAggregateOutputType | null
  }

  type GetCrewStorageGroupByPayload<T extends CrewStorageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrewStorageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrewStorageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrewStorageGroupByOutputType[P]>
            : GetScalarType<T[P], CrewStorageGroupByOutputType[P]>
        }
      >
    >


  export type CrewStorageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    storageId?: boolean
    crewId?: boolean
    storage?: boolean | StorageDefaultArgs<ExtArgs>
    crew?: boolean | CrewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crewStorage"]>

  export type CrewStorageSelectScalar = {
    storageId?: boolean
    crewId?: boolean
  }

  export type CrewStorageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    storage?: boolean | StorageDefaultArgs<ExtArgs>
    crew?: boolean | CrewDefaultArgs<ExtArgs>
  }


  export type $CrewStoragePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CrewStorage"
    objects: {
      storage: Prisma.$StoragePayload<ExtArgs>
      crew: Prisma.$CrewPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      storageId: string
      crewId: string
    }, ExtArgs["result"]["crewStorage"]>
    composites: {}
  }


  type CrewStorageGetPayload<S extends boolean | null | undefined | CrewStorageDefaultArgs> = $Result.GetResult<Prisma.$CrewStoragePayload, S>

  type CrewStorageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CrewStorageFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CrewStorageCountAggregateInputType | true
    }

  export interface CrewStorageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CrewStorage'], meta: { name: 'CrewStorage' } }
    /**
     * Find zero or one CrewStorage that matches the filter.
     * @param {CrewStorageFindUniqueArgs} args - Arguments to find a CrewStorage
     * @example
     * // Get one CrewStorage
     * const crewStorage = await prisma.crewStorage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CrewStorageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CrewStorageFindUniqueArgs<ExtArgs>>
    ): Prisma__CrewStorageClient<$Result.GetResult<Prisma.$CrewStoragePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CrewStorage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CrewStorageFindUniqueOrThrowArgs} args - Arguments to find a CrewStorage
     * @example
     * // Get one CrewStorage
     * const crewStorage = await prisma.crewStorage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CrewStorageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewStorageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CrewStorageClient<$Result.GetResult<Prisma.$CrewStoragePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CrewStorage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewStorageFindFirstArgs} args - Arguments to find a CrewStorage
     * @example
     * // Get one CrewStorage
     * const crewStorage = await prisma.crewStorage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CrewStorageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewStorageFindFirstArgs<ExtArgs>>
    ): Prisma__CrewStorageClient<$Result.GetResult<Prisma.$CrewStoragePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CrewStorage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewStorageFindFirstOrThrowArgs} args - Arguments to find a CrewStorage
     * @example
     * // Get one CrewStorage
     * const crewStorage = await prisma.crewStorage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CrewStorageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewStorageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CrewStorageClient<$Result.GetResult<Prisma.$CrewStoragePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CrewStorages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewStorageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrewStorages
     * const crewStorages = await prisma.crewStorage.findMany()
     * 
     * // Get first 10 CrewStorages
     * const crewStorages = await prisma.crewStorage.findMany({ take: 10 })
     * 
     * // Only select the `storageId`
     * const crewStorageWithStorageIdOnly = await prisma.crewStorage.findMany({ select: { storageId: true } })
     * 
    **/
    findMany<T extends CrewStorageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewStorageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewStoragePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CrewStorage.
     * @param {CrewStorageCreateArgs} args - Arguments to create a CrewStorage.
     * @example
     * // Create one CrewStorage
     * const CrewStorage = await prisma.crewStorage.create({
     *   data: {
     *     // ... data to create a CrewStorage
     *   }
     * })
     * 
    **/
    create<T extends CrewStorageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CrewStorageCreateArgs<ExtArgs>>
    ): Prisma__CrewStorageClient<$Result.GetResult<Prisma.$CrewStoragePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CrewStorages.
     *     @param {CrewStorageCreateManyArgs} args - Arguments to create many CrewStorages.
     *     @example
     *     // Create many CrewStorages
     *     const crewStorage = await prisma.crewStorage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CrewStorageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewStorageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CrewStorage.
     * @param {CrewStorageDeleteArgs} args - Arguments to delete one CrewStorage.
     * @example
     * // Delete one CrewStorage
     * const CrewStorage = await prisma.crewStorage.delete({
     *   where: {
     *     // ... filter to delete one CrewStorage
     *   }
     * })
     * 
    **/
    delete<T extends CrewStorageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CrewStorageDeleteArgs<ExtArgs>>
    ): Prisma__CrewStorageClient<$Result.GetResult<Prisma.$CrewStoragePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CrewStorage.
     * @param {CrewStorageUpdateArgs} args - Arguments to update one CrewStorage.
     * @example
     * // Update one CrewStorage
     * const crewStorage = await prisma.crewStorage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CrewStorageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CrewStorageUpdateArgs<ExtArgs>>
    ): Prisma__CrewStorageClient<$Result.GetResult<Prisma.$CrewStoragePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CrewStorages.
     * @param {CrewStorageDeleteManyArgs} args - Arguments to filter CrewStorages to delete.
     * @example
     * // Delete a few CrewStorages
     * const { count } = await prisma.crewStorage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CrewStorageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewStorageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrewStorages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewStorageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrewStorages
     * const crewStorage = await prisma.crewStorage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CrewStorageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CrewStorageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CrewStorage.
     * @param {CrewStorageUpsertArgs} args - Arguments to update or create a CrewStorage.
     * @example
     * // Update or create a CrewStorage
     * const crewStorage = await prisma.crewStorage.upsert({
     *   create: {
     *     // ... data to create a CrewStorage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrewStorage we want to update
     *   }
     * })
    **/
    upsert<T extends CrewStorageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CrewStorageUpsertArgs<ExtArgs>>
    ): Prisma__CrewStorageClient<$Result.GetResult<Prisma.$CrewStoragePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CrewStorages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewStorageCountArgs} args - Arguments to filter CrewStorages to count.
     * @example
     * // Count the number of CrewStorages
     * const count = await prisma.crewStorage.count({
     *   where: {
     *     // ... the filter for the CrewStorages we want to count
     *   }
     * })
    **/
    count<T extends CrewStorageCountArgs>(
      args?: Subset<T, CrewStorageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrewStorageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrewStorage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewStorageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrewStorageAggregateArgs>(args: Subset<T, CrewStorageAggregateArgs>): Prisma.PrismaPromise<GetCrewStorageAggregateType<T>>

    /**
     * Group by CrewStorage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewStorageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrewStorageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrewStorageGroupByArgs['orderBy'] }
        : { orderBy?: CrewStorageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrewStorageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrewStorageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CrewStorage model
   */
  readonly fields: CrewStorageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CrewStorage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CrewStorageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    storage<T extends StorageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StorageDefaultArgs<ExtArgs>>): Prisma__StorageClient<$Result.GetResult<Prisma.$StoragePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    crew<T extends CrewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CrewDefaultArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CrewStorage model
   */ 
  interface CrewStorageFieldRefs {
    readonly storageId: FieldRef<"CrewStorage", 'String'>
    readonly crewId: FieldRef<"CrewStorage", 'String'>
  }
    

  // Custom InputTypes

  /**
   * CrewStorage findUnique
   */
  export type CrewStorageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewStorage
     */
    select?: CrewStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewStorageInclude<ExtArgs> | null
    /**
     * Filter, which CrewStorage to fetch.
     */
    where: CrewStorageWhereUniqueInput
  }


  /**
   * CrewStorage findUniqueOrThrow
   */
  export type CrewStorageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewStorage
     */
    select?: CrewStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewStorageInclude<ExtArgs> | null
    /**
     * Filter, which CrewStorage to fetch.
     */
    where: CrewStorageWhereUniqueInput
  }


  /**
   * CrewStorage findFirst
   */
  export type CrewStorageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewStorage
     */
    select?: CrewStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewStorageInclude<ExtArgs> | null
    /**
     * Filter, which CrewStorage to fetch.
     */
    where?: CrewStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewStorages to fetch.
     */
    orderBy?: CrewStorageOrderByWithRelationInput | CrewStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrewStorages.
     */
    cursor?: CrewStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewStorages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrewStorages.
     */
    distinct?: CrewStorageScalarFieldEnum | CrewStorageScalarFieldEnum[]
  }


  /**
   * CrewStorage findFirstOrThrow
   */
  export type CrewStorageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewStorage
     */
    select?: CrewStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewStorageInclude<ExtArgs> | null
    /**
     * Filter, which CrewStorage to fetch.
     */
    where?: CrewStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewStorages to fetch.
     */
    orderBy?: CrewStorageOrderByWithRelationInput | CrewStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrewStorages.
     */
    cursor?: CrewStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewStorages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrewStorages.
     */
    distinct?: CrewStorageScalarFieldEnum | CrewStorageScalarFieldEnum[]
  }


  /**
   * CrewStorage findMany
   */
  export type CrewStorageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewStorage
     */
    select?: CrewStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewStorageInclude<ExtArgs> | null
    /**
     * Filter, which CrewStorages to fetch.
     */
    where?: CrewStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewStorages to fetch.
     */
    orderBy?: CrewStorageOrderByWithRelationInput | CrewStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CrewStorages.
     */
    cursor?: CrewStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewStorages.
     */
    skip?: number
    distinct?: CrewStorageScalarFieldEnum | CrewStorageScalarFieldEnum[]
  }


  /**
   * CrewStorage create
   */
  export type CrewStorageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewStorage
     */
    select?: CrewStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewStorageInclude<ExtArgs> | null
    /**
     * The data needed to create a CrewStorage.
     */
    data: XOR<CrewStorageCreateInput, CrewStorageUncheckedCreateInput>
  }


  /**
   * CrewStorage createMany
   */
  export type CrewStorageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CrewStorages.
     */
    data: CrewStorageCreateManyInput | CrewStorageCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CrewStorage update
   */
  export type CrewStorageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewStorage
     */
    select?: CrewStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewStorageInclude<ExtArgs> | null
    /**
     * The data needed to update a CrewStorage.
     */
    data: XOR<CrewStorageUpdateInput, CrewStorageUncheckedUpdateInput>
    /**
     * Choose, which CrewStorage to update.
     */
    where: CrewStorageWhereUniqueInput
  }


  /**
   * CrewStorage updateMany
   */
  export type CrewStorageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CrewStorages.
     */
    data: XOR<CrewStorageUpdateManyMutationInput, CrewStorageUncheckedUpdateManyInput>
    /**
     * Filter which CrewStorages to update
     */
    where?: CrewStorageWhereInput
  }


  /**
   * CrewStorage upsert
   */
  export type CrewStorageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewStorage
     */
    select?: CrewStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewStorageInclude<ExtArgs> | null
    /**
     * The filter to search for the CrewStorage to update in case it exists.
     */
    where: CrewStorageWhereUniqueInput
    /**
     * In case the CrewStorage found by the `where` argument doesn't exist, create a new CrewStorage with this data.
     */
    create: XOR<CrewStorageCreateInput, CrewStorageUncheckedCreateInput>
    /**
     * In case the CrewStorage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CrewStorageUpdateInput, CrewStorageUncheckedUpdateInput>
  }


  /**
   * CrewStorage delete
   */
  export type CrewStorageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewStorage
     */
    select?: CrewStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewStorageInclude<ExtArgs> | null
    /**
     * Filter which CrewStorage to delete.
     */
    where: CrewStorageWhereUniqueInput
  }


  /**
   * CrewStorage deleteMany
   */
  export type CrewStorageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrewStorages to delete
     */
    where?: CrewStorageWhereInput
  }


  /**
   * CrewStorage without action
   */
  export type CrewStorageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewStorage
     */
    select?: CrewStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewStorageInclude<ExtArgs> | null
  }



  /**
   * Model CrewIngredient
   */

  export type AggregateCrewIngredient = {
    _count: CrewIngredientCountAggregateOutputType | null
    _min: CrewIngredientMinAggregateOutputType | null
    _max: CrewIngredientMaxAggregateOutputType | null
  }

  export type CrewIngredientMinAggregateOutputType = {
    ingredientId: string | null
    crewId: string | null
  }

  export type CrewIngredientMaxAggregateOutputType = {
    ingredientId: string | null
    crewId: string | null
  }

  export type CrewIngredientCountAggregateOutputType = {
    ingredientId: number
    crewId: number
    _all: number
  }


  export type CrewIngredientMinAggregateInputType = {
    ingredientId?: true
    crewId?: true
  }

  export type CrewIngredientMaxAggregateInputType = {
    ingredientId?: true
    crewId?: true
  }

  export type CrewIngredientCountAggregateInputType = {
    ingredientId?: true
    crewId?: true
    _all?: true
  }

  export type CrewIngredientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrewIngredient to aggregate.
     */
    where?: CrewIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewIngredients to fetch.
     */
    orderBy?: CrewIngredientOrderByWithRelationInput | CrewIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CrewIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewIngredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CrewIngredients
    **/
    _count?: true | CrewIngredientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrewIngredientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrewIngredientMaxAggregateInputType
  }

  export type GetCrewIngredientAggregateType<T extends CrewIngredientAggregateArgs> = {
        [P in keyof T & keyof AggregateCrewIngredient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrewIngredient[P]>
      : GetScalarType<T[P], AggregateCrewIngredient[P]>
  }




  export type CrewIngredientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewIngredientWhereInput
    orderBy?: CrewIngredientOrderByWithAggregationInput | CrewIngredientOrderByWithAggregationInput[]
    by: CrewIngredientScalarFieldEnum[] | CrewIngredientScalarFieldEnum
    having?: CrewIngredientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrewIngredientCountAggregateInputType | true
    _min?: CrewIngredientMinAggregateInputType
    _max?: CrewIngredientMaxAggregateInputType
  }

  export type CrewIngredientGroupByOutputType = {
    ingredientId: string
    crewId: string
    _count: CrewIngredientCountAggregateOutputType | null
    _min: CrewIngredientMinAggregateOutputType | null
    _max: CrewIngredientMaxAggregateOutputType | null
  }

  type GetCrewIngredientGroupByPayload<T extends CrewIngredientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrewIngredientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrewIngredientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrewIngredientGroupByOutputType[P]>
            : GetScalarType<T[P], CrewIngredientGroupByOutputType[P]>
        }
      >
    >


  export type CrewIngredientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ingredientId?: boolean
    crewId?: boolean
    ingredient?: boolean | IngredientDefaultArgs<ExtArgs>
    crew?: boolean | CrewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crewIngredient"]>

  export type CrewIngredientSelectScalar = {
    ingredientId?: boolean
    crewId?: boolean
  }

  export type CrewIngredientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ingredient?: boolean | IngredientDefaultArgs<ExtArgs>
    crew?: boolean | CrewDefaultArgs<ExtArgs>
  }


  export type $CrewIngredientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CrewIngredient"
    objects: {
      ingredient: Prisma.$IngredientPayload<ExtArgs>
      crew: Prisma.$CrewPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ingredientId: string
      crewId: string
    }, ExtArgs["result"]["crewIngredient"]>
    composites: {}
  }


  type CrewIngredientGetPayload<S extends boolean | null | undefined | CrewIngredientDefaultArgs> = $Result.GetResult<Prisma.$CrewIngredientPayload, S>

  type CrewIngredientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CrewIngredientFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CrewIngredientCountAggregateInputType | true
    }

  export interface CrewIngredientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CrewIngredient'], meta: { name: 'CrewIngredient' } }
    /**
     * Find zero or one CrewIngredient that matches the filter.
     * @param {CrewIngredientFindUniqueArgs} args - Arguments to find a CrewIngredient
     * @example
     * // Get one CrewIngredient
     * const crewIngredient = await prisma.crewIngredient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CrewIngredientFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CrewIngredientFindUniqueArgs<ExtArgs>>
    ): Prisma__CrewIngredientClient<$Result.GetResult<Prisma.$CrewIngredientPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CrewIngredient that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CrewIngredientFindUniqueOrThrowArgs} args - Arguments to find a CrewIngredient
     * @example
     * // Get one CrewIngredient
     * const crewIngredient = await prisma.crewIngredient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CrewIngredientFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewIngredientFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CrewIngredientClient<$Result.GetResult<Prisma.$CrewIngredientPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CrewIngredient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewIngredientFindFirstArgs} args - Arguments to find a CrewIngredient
     * @example
     * // Get one CrewIngredient
     * const crewIngredient = await prisma.crewIngredient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CrewIngredientFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewIngredientFindFirstArgs<ExtArgs>>
    ): Prisma__CrewIngredientClient<$Result.GetResult<Prisma.$CrewIngredientPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CrewIngredient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewIngredientFindFirstOrThrowArgs} args - Arguments to find a CrewIngredient
     * @example
     * // Get one CrewIngredient
     * const crewIngredient = await prisma.crewIngredient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CrewIngredientFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewIngredientFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CrewIngredientClient<$Result.GetResult<Prisma.$CrewIngredientPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CrewIngredients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewIngredientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrewIngredients
     * const crewIngredients = await prisma.crewIngredient.findMany()
     * 
     * // Get first 10 CrewIngredients
     * const crewIngredients = await prisma.crewIngredient.findMany({ take: 10 })
     * 
     * // Only select the `ingredientId`
     * const crewIngredientWithIngredientIdOnly = await prisma.crewIngredient.findMany({ select: { ingredientId: true } })
     * 
    **/
    findMany<T extends CrewIngredientFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewIngredientFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewIngredientPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CrewIngredient.
     * @param {CrewIngredientCreateArgs} args - Arguments to create a CrewIngredient.
     * @example
     * // Create one CrewIngredient
     * const CrewIngredient = await prisma.crewIngredient.create({
     *   data: {
     *     // ... data to create a CrewIngredient
     *   }
     * })
     * 
    **/
    create<T extends CrewIngredientCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CrewIngredientCreateArgs<ExtArgs>>
    ): Prisma__CrewIngredientClient<$Result.GetResult<Prisma.$CrewIngredientPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CrewIngredients.
     *     @param {CrewIngredientCreateManyArgs} args - Arguments to create many CrewIngredients.
     *     @example
     *     // Create many CrewIngredients
     *     const crewIngredient = await prisma.crewIngredient.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CrewIngredientCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewIngredientCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CrewIngredient.
     * @param {CrewIngredientDeleteArgs} args - Arguments to delete one CrewIngredient.
     * @example
     * // Delete one CrewIngredient
     * const CrewIngredient = await prisma.crewIngredient.delete({
     *   where: {
     *     // ... filter to delete one CrewIngredient
     *   }
     * })
     * 
    **/
    delete<T extends CrewIngredientDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CrewIngredientDeleteArgs<ExtArgs>>
    ): Prisma__CrewIngredientClient<$Result.GetResult<Prisma.$CrewIngredientPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CrewIngredient.
     * @param {CrewIngredientUpdateArgs} args - Arguments to update one CrewIngredient.
     * @example
     * // Update one CrewIngredient
     * const crewIngredient = await prisma.crewIngredient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CrewIngredientUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CrewIngredientUpdateArgs<ExtArgs>>
    ): Prisma__CrewIngredientClient<$Result.GetResult<Prisma.$CrewIngredientPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CrewIngredients.
     * @param {CrewIngredientDeleteManyArgs} args - Arguments to filter CrewIngredients to delete.
     * @example
     * // Delete a few CrewIngredients
     * const { count } = await prisma.crewIngredient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CrewIngredientDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewIngredientDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrewIngredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewIngredientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrewIngredients
     * const crewIngredient = await prisma.crewIngredient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CrewIngredientUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CrewIngredientUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CrewIngredient.
     * @param {CrewIngredientUpsertArgs} args - Arguments to update or create a CrewIngredient.
     * @example
     * // Update or create a CrewIngredient
     * const crewIngredient = await prisma.crewIngredient.upsert({
     *   create: {
     *     // ... data to create a CrewIngredient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrewIngredient we want to update
     *   }
     * })
    **/
    upsert<T extends CrewIngredientUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CrewIngredientUpsertArgs<ExtArgs>>
    ): Prisma__CrewIngredientClient<$Result.GetResult<Prisma.$CrewIngredientPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CrewIngredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewIngredientCountArgs} args - Arguments to filter CrewIngredients to count.
     * @example
     * // Count the number of CrewIngredients
     * const count = await prisma.crewIngredient.count({
     *   where: {
     *     // ... the filter for the CrewIngredients we want to count
     *   }
     * })
    **/
    count<T extends CrewIngredientCountArgs>(
      args?: Subset<T, CrewIngredientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrewIngredientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrewIngredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewIngredientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrewIngredientAggregateArgs>(args: Subset<T, CrewIngredientAggregateArgs>): Prisma.PrismaPromise<GetCrewIngredientAggregateType<T>>

    /**
     * Group by CrewIngredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewIngredientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrewIngredientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrewIngredientGroupByArgs['orderBy'] }
        : { orderBy?: CrewIngredientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrewIngredientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrewIngredientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CrewIngredient model
   */
  readonly fields: CrewIngredientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CrewIngredient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CrewIngredientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    ingredient<T extends IngredientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IngredientDefaultArgs<ExtArgs>>): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    crew<T extends CrewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CrewDefaultArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CrewIngredient model
   */ 
  interface CrewIngredientFieldRefs {
    readonly ingredientId: FieldRef<"CrewIngredient", 'String'>
    readonly crewId: FieldRef<"CrewIngredient", 'String'>
  }
    

  // Custom InputTypes

  /**
   * CrewIngredient findUnique
   */
  export type CrewIngredientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewIngredient
     */
    select?: CrewIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewIngredientInclude<ExtArgs> | null
    /**
     * Filter, which CrewIngredient to fetch.
     */
    where: CrewIngredientWhereUniqueInput
  }


  /**
   * CrewIngredient findUniqueOrThrow
   */
  export type CrewIngredientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewIngredient
     */
    select?: CrewIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewIngredientInclude<ExtArgs> | null
    /**
     * Filter, which CrewIngredient to fetch.
     */
    where: CrewIngredientWhereUniqueInput
  }


  /**
   * CrewIngredient findFirst
   */
  export type CrewIngredientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewIngredient
     */
    select?: CrewIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewIngredientInclude<ExtArgs> | null
    /**
     * Filter, which CrewIngredient to fetch.
     */
    where?: CrewIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewIngredients to fetch.
     */
    orderBy?: CrewIngredientOrderByWithRelationInput | CrewIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrewIngredients.
     */
    cursor?: CrewIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewIngredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrewIngredients.
     */
    distinct?: CrewIngredientScalarFieldEnum | CrewIngredientScalarFieldEnum[]
  }


  /**
   * CrewIngredient findFirstOrThrow
   */
  export type CrewIngredientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewIngredient
     */
    select?: CrewIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewIngredientInclude<ExtArgs> | null
    /**
     * Filter, which CrewIngredient to fetch.
     */
    where?: CrewIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewIngredients to fetch.
     */
    orderBy?: CrewIngredientOrderByWithRelationInput | CrewIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrewIngredients.
     */
    cursor?: CrewIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewIngredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrewIngredients.
     */
    distinct?: CrewIngredientScalarFieldEnum | CrewIngredientScalarFieldEnum[]
  }


  /**
   * CrewIngredient findMany
   */
  export type CrewIngredientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewIngredient
     */
    select?: CrewIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewIngredientInclude<ExtArgs> | null
    /**
     * Filter, which CrewIngredients to fetch.
     */
    where?: CrewIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewIngredients to fetch.
     */
    orderBy?: CrewIngredientOrderByWithRelationInput | CrewIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CrewIngredients.
     */
    cursor?: CrewIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewIngredients.
     */
    skip?: number
    distinct?: CrewIngredientScalarFieldEnum | CrewIngredientScalarFieldEnum[]
  }


  /**
   * CrewIngredient create
   */
  export type CrewIngredientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewIngredient
     */
    select?: CrewIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewIngredientInclude<ExtArgs> | null
    /**
     * The data needed to create a CrewIngredient.
     */
    data: XOR<CrewIngredientCreateInput, CrewIngredientUncheckedCreateInput>
  }


  /**
   * CrewIngredient createMany
   */
  export type CrewIngredientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CrewIngredients.
     */
    data: CrewIngredientCreateManyInput | CrewIngredientCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CrewIngredient update
   */
  export type CrewIngredientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewIngredient
     */
    select?: CrewIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewIngredientInclude<ExtArgs> | null
    /**
     * The data needed to update a CrewIngredient.
     */
    data: XOR<CrewIngredientUpdateInput, CrewIngredientUncheckedUpdateInput>
    /**
     * Choose, which CrewIngredient to update.
     */
    where: CrewIngredientWhereUniqueInput
  }


  /**
   * CrewIngredient updateMany
   */
  export type CrewIngredientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CrewIngredients.
     */
    data: XOR<CrewIngredientUpdateManyMutationInput, CrewIngredientUncheckedUpdateManyInput>
    /**
     * Filter which CrewIngredients to update
     */
    where?: CrewIngredientWhereInput
  }


  /**
   * CrewIngredient upsert
   */
  export type CrewIngredientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewIngredient
     */
    select?: CrewIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewIngredientInclude<ExtArgs> | null
    /**
     * The filter to search for the CrewIngredient to update in case it exists.
     */
    where: CrewIngredientWhereUniqueInput
    /**
     * In case the CrewIngredient found by the `where` argument doesn't exist, create a new CrewIngredient with this data.
     */
    create: XOR<CrewIngredientCreateInput, CrewIngredientUncheckedCreateInput>
    /**
     * In case the CrewIngredient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CrewIngredientUpdateInput, CrewIngredientUncheckedUpdateInput>
  }


  /**
   * CrewIngredient delete
   */
  export type CrewIngredientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewIngredient
     */
    select?: CrewIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewIngredientInclude<ExtArgs> | null
    /**
     * Filter which CrewIngredient to delete.
     */
    where: CrewIngredientWhereUniqueInput
  }


  /**
   * CrewIngredient deleteMany
   */
  export type CrewIngredientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrewIngredients to delete
     */
    where?: CrewIngredientWhereInput
  }


  /**
   * CrewIngredient without action
   */
  export type CrewIngredientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewIngredient
     */
    select?: CrewIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewIngredientInclude<ExtArgs> | null
  }



  /**
   * Model CrewRecipeBook
   */

  export type AggregateCrewRecipeBook = {
    _count: CrewRecipeBookCountAggregateOutputType | null
    _min: CrewRecipeBookMinAggregateOutputType | null
    _max: CrewRecipeBookMaxAggregateOutputType | null
  }

  export type CrewRecipeBookMinAggregateOutputType = {
    recipeBookId: string | null
    crewId: string | null
  }

  export type CrewRecipeBookMaxAggregateOutputType = {
    recipeBookId: string | null
    crewId: string | null
  }

  export type CrewRecipeBookCountAggregateOutputType = {
    recipeBookId: number
    crewId: number
    _all: number
  }


  export type CrewRecipeBookMinAggregateInputType = {
    recipeBookId?: true
    crewId?: true
  }

  export type CrewRecipeBookMaxAggregateInputType = {
    recipeBookId?: true
    crewId?: true
  }

  export type CrewRecipeBookCountAggregateInputType = {
    recipeBookId?: true
    crewId?: true
    _all?: true
  }

  export type CrewRecipeBookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrewRecipeBook to aggregate.
     */
    where?: CrewRecipeBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewRecipeBooks to fetch.
     */
    orderBy?: CrewRecipeBookOrderByWithRelationInput | CrewRecipeBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CrewRecipeBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewRecipeBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewRecipeBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CrewRecipeBooks
    **/
    _count?: true | CrewRecipeBookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrewRecipeBookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrewRecipeBookMaxAggregateInputType
  }

  export type GetCrewRecipeBookAggregateType<T extends CrewRecipeBookAggregateArgs> = {
        [P in keyof T & keyof AggregateCrewRecipeBook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrewRecipeBook[P]>
      : GetScalarType<T[P], AggregateCrewRecipeBook[P]>
  }




  export type CrewRecipeBookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewRecipeBookWhereInput
    orderBy?: CrewRecipeBookOrderByWithAggregationInput | CrewRecipeBookOrderByWithAggregationInput[]
    by: CrewRecipeBookScalarFieldEnum[] | CrewRecipeBookScalarFieldEnum
    having?: CrewRecipeBookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrewRecipeBookCountAggregateInputType | true
    _min?: CrewRecipeBookMinAggregateInputType
    _max?: CrewRecipeBookMaxAggregateInputType
  }

  export type CrewRecipeBookGroupByOutputType = {
    recipeBookId: string
    crewId: string
    _count: CrewRecipeBookCountAggregateOutputType | null
    _min: CrewRecipeBookMinAggregateOutputType | null
    _max: CrewRecipeBookMaxAggregateOutputType | null
  }

  type GetCrewRecipeBookGroupByPayload<T extends CrewRecipeBookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrewRecipeBookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrewRecipeBookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrewRecipeBookGroupByOutputType[P]>
            : GetScalarType<T[P], CrewRecipeBookGroupByOutputType[P]>
        }
      >
    >


  export type CrewRecipeBookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    recipeBookId?: boolean
    crewId?: boolean
    recipeBook?: boolean | RecipeBookDefaultArgs<ExtArgs>
    crew?: boolean | CrewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crewRecipeBook"]>

  export type CrewRecipeBookSelectScalar = {
    recipeBookId?: boolean
    crewId?: boolean
  }

  export type CrewRecipeBookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipeBook?: boolean | RecipeBookDefaultArgs<ExtArgs>
    crew?: boolean | CrewDefaultArgs<ExtArgs>
  }


  export type $CrewRecipeBookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CrewRecipeBook"
    objects: {
      recipeBook: Prisma.$RecipeBookPayload<ExtArgs>
      crew: Prisma.$CrewPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      recipeBookId: string
      crewId: string
    }, ExtArgs["result"]["crewRecipeBook"]>
    composites: {}
  }


  type CrewRecipeBookGetPayload<S extends boolean | null | undefined | CrewRecipeBookDefaultArgs> = $Result.GetResult<Prisma.$CrewRecipeBookPayload, S>

  type CrewRecipeBookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CrewRecipeBookFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CrewRecipeBookCountAggregateInputType | true
    }

  export interface CrewRecipeBookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CrewRecipeBook'], meta: { name: 'CrewRecipeBook' } }
    /**
     * Find zero or one CrewRecipeBook that matches the filter.
     * @param {CrewRecipeBookFindUniqueArgs} args - Arguments to find a CrewRecipeBook
     * @example
     * // Get one CrewRecipeBook
     * const crewRecipeBook = await prisma.crewRecipeBook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CrewRecipeBookFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CrewRecipeBookFindUniqueArgs<ExtArgs>>
    ): Prisma__CrewRecipeBookClient<$Result.GetResult<Prisma.$CrewRecipeBookPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CrewRecipeBook that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CrewRecipeBookFindUniqueOrThrowArgs} args - Arguments to find a CrewRecipeBook
     * @example
     * // Get one CrewRecipeBook
     * const crewRecipeBook = await prisma.crewRecipeBook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CrewRecipeBookFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewRecipeBookFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CrewRecipeBookClient<$Result.GetResult<Prisma.$CrewRecipeBookPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CrewRecipeBook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewRecipeBookFindFirstArgs} args - Arguments to find a CrewRecipeBook
     * @example
     * // Get one CrewRecipeBook
     * const crewRecipeBook = await prisma.crewRecipeBook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CrewRecipeBookFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewRecipeBookFindFirstArgs<ExtArgs>>
    ): Prisma__CrewRecipeBookClient<$Result.GetResult<Prisma.$CrewRecipeBookPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CrewRecipeBook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewRecipeBookFindFirstOrThrowArgs} args - Arguments to find a CrewRecipeBook
     * @example
     * // Get one CrewRecipeBook
     * const crewRecipeBook = await prisma.crewRecipeBook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CrewRecipeBookFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewRecipeBookFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CrewRecipeBookClient<$Result.GetResult<Prisma.$CrewRecipeBookPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CrewRecipeBooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewRecipeBookFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrewRecipeBooks
     * const crewRecipeBooks = await prisma.crewRecipeBook.findMany()
     * 
     * // Get first 10 CrewRecipeBooks
     * const crewRecipeBooks = await prisma.crewRecipeBook.findMany({ take: 10 })
     * 
     * // Only select the `recipeBookId`
     * const crewRecipeBookWithRecipeBookIdOnly = await prisma.crewRecipeBook.findMany({ select: { recipeBookId: true } })
     * 
    **/
    findMany<T extends CrewRecipeBookFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewRecipeBookFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewRecipeBookPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CrewRecipeBook.
     * @param {CrewRecipeBookCreateArgs} args - Arguments to create a CrewRecipeBook.
     * @example
     * // Create one CrewRecipeBook
     * const CrewRecipeBook = await prisma.crewRecipeBook.create({
     *   data: {
     *     // ... data to create a CrewRecipeBook
     *   }
     * })
     * 
    **/
    create<T extends CrewRecipeBookCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CrewRecipeBookCreateArgs<ExtArgs>>
    ): Prisma__CrewRecipeBookClient<$Result.GetResult<Prisma.$CrewRecipeBookPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CrewRecipeBooks.
     *     @param {CrewRecipeBookCreateManyArgs} args - Arguments to create many CrewRecipeBooks.
     *     @example
     *     // Create many CrewRecipeBooks
     *     const crewRecipeBook = await prisma.crewRecipeBook.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CrewRecipeBookCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewRecipeBookCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CrewRecipeBook.
     * @param {CrewRecipeBookDeleteArgs} args - Arguments to delete one CrewRecipeBook.
     * @example
     * // Delete one CrewRecipeBook
     * const CrewRecipeBook = await prisma.crewRecipeBook.delete({
     *   where: {
     *     // ... filter to delete one CrewRecipeBook
     *   }
     * })
     * 
    **/
    delete<T extends CrewRecipeBookDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CrewRecipeBookDeleteArgs<ExtArgs>>
    ): Prisma__CrewRecipeBookClient<$Result.GetResult<Prisma.$CrewRecipeBookPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CrewRecipeBook.
     * @param {CrewRecipeBookUpdateArgs} args - Arguments to update one CrewRecipeBook.
     * @example
     * // Update one CrewRecipeBook
     * const crewRecipeBook = await prisma.crewRecipeBook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CrewRecipeBookUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CrewRecipeBookUpdateArgs<ExtArgs>>
    ): Prisma__CrewRecipeBookClient<$Result.GetResult<Prisma.$CrewRecipeBookPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CrewRecipeBooks.
     * @param {CrewRecipeBookDeleteManyArgs} args - Arguments to filter CrewRecipeBooks to delete.
     * @example
     * // Delete a few CrewRecipeBooks
     * const { count } = await prisma.crewRecipeBook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CrewRecipeBookDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewRecipeBookDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrewRecipeBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewRecipeBookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrewRecipeBooks
     * const crewRecipeBook = await prisma.crewRecipeBook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CrewRecipeBookUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CrewRecipeBookUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CrewRecipeBook.
     * @param {CrewRecipeBookUpsertArgs} args - Arguments to update or create a CrewRecipeBook.
     * @example
     * // Update or create a CrewRecipeBook
     * const crewRecipeBook = await prisma.crewRecipeBook.upsert({
     *   create: {
     *     // ... data to create a CrewRecipeBook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrewRecipeBook we want to update
     *   }
     * })
    **/
    upsert<T extends CrewRecipeBookUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CrewRecipeBookUpsertArgs<ExtArgs>>
    ): Prisma__CrewRecipeBookClient<$Result.GetResult<Prisma.$CrewRecipeBookPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CrewRecipeBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewRecipeBookCountArgs} args - Arguments to filter CrewRecipeBooks to count.
     * @example
     * // Count the number of CrewRecipeBooks
     * const count = await prisma.crewRecipeBook.count({
     *   where: {
     *     // ... the filter for the CrewRecipeBooks we want to count
     *   }
     * })
    **/
    count<T extends CrewRecipeBookCountArgs>(
      args?: Subset<T, CrewRecipeBookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrewRecipeBookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrewRecipeBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewRecipeBookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrewRecipeBookAggregateArgs>(args: Subset<T, CrewRecipeBookAggregateArgs>): Prisma.PrismaPromise<GetCrewRecipeBookAggregateType<T>>

    /**
     * Group by CrewRecipeBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewRecipeBookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrewRecipeBookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrewRecipeBookGroupByArgs['orderBy'] }
        : { orderBy?: CrewRecipeBookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrewRecipeBookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrewRecipeBookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CrewRecipeBook model
   */
  readonly fields: CrewRecipeBookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CrewRecipeBook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CrewRecipeBookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    recipeBook<T extends RecipeBookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeBookDefaultArgs<ExtArgs>>): Prisma__RecipeBookClient<$Result.GetResult<Prisma.$RecipeBookPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    crew<T extends CrewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CrewDefaultArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CrewRecipeBook model
   */ 
  interface CrewRecipeBookFieldRefs {
    readonly recipeBookId: FieldRef<"CrewRecipeBook", 'String'>
    readonly crewId: FieldRef<"CrewRecipeBook", 'String'>
  }
    

  // Custom InputTypes

  /**
   * CrewRecipeBook findUnique
   */
  export type CrewRecipeBookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewRecipeBook
     */
    select?: CrewRecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewRecipeBookInclude<ExtArgs> | null
    /**
     * Filter, which CrewRecipeBook to fetch.
     */
    where: CrewRecipeBookWhereUniqueInput
  }


  /**
   * CrewRecipeBook findUniqueOrThrow
   */
  export type CrewRecipeBookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewRecipeBook
     */
    select?: CrewRecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewRecipeBookInclude<ExtArgs> | null
    /**
     * Filter, which CrewRecipeBook to fetch.
     */
    where: CrewRecipeBookWhereUniqueInput
  }


  /**
   * CrewRecipeBook findFirst
   */
  export type CrewRecipeBookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewRecipeBook
     */
    select?: CrewRecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewRecipeBookInclude<ExtArgs> | null
    /**
     * Filter, which CrewRecipeBook to fetch.
     */
    where?: CrewRecipeBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewRecipeBooks to fetch.
     */
    orderBy?: CrewRecipeBookOrderByWithRelationInput | CrewRecipeBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrewRecipeBooks.
     */
    cursor?: CrewRecipeBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewRecipeBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewRecipeBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrewRecipeBooks.
     */
    distinct?: CrewRecipeBookScalarFieldEnum | CrewRecipeBookScalarFieldEnum[]
  }


  /**
   * CrewRecipeBook findFirstOrThrow
   */
  export type CrewRecipeBookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewRecipeBook
     */
    select?: CrewRecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewRecipeBookInclude<ExtArgs> | null
    /**
     * Filter, which CrewRecipeBook to fetch.
     */
    where?: CrewRecipeBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewRecipeBooks to fetch.
     */
    orderBy?: CrewRecipeBookOrderByWithRelationInput | CrewRecipeBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrewRecipeBooks.
     */
    cursor?: CrewRecipeBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewRecipeBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewRecipeBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrewRecipeBooks.
     */
    distinct?: CrewRecipeBookScalarFieldEnum | CrewRecipeBookScalarFieldEnum[]
  }


  /**
   * CrewRecipeBook findMany
   */
  export type CrewRecipeBookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewRecipeBook
     */
    select?: CrewRecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewRecipeBookInclude<ExtArgs> | null
    /**
     * Filter, which CrewRecipeBooks to fetch.
     */
    where?: CrewRecipeBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewRecipeBooks to fetch.
     */
    orderBy?: CrewRecipeBookOrderByWithRelationInput | CrewRecipeBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CrewRecipeBooks.
     */
    cursor?: CrewRecipeBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewRecipeBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewRecipeBooks.
     */
    skip?: number
    distinct?: CrewRecipeBookScalarFieldEnum | CrewRecipeBookScalarFieldEnum[]
  }


  /**
   * CrewRecipeBook create
   */
  export type CrewRecipeBookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewRecipeBook
     */
    select?: CrewRecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewRecipeBookInclude<ExtArgs> | null
    /**
     * The data needed to create a CrewRecipeBook.
     */
    data: XOR<CrewRecipeBookCreateInput, CrewRecipeBookUncheckedCreateInput>
  }


  /**
   * CrewRecipeBook createMany
   */
  export type CrewRecipeBookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CrewRecipeBooks.
     */
    data: CrewRecipeBookCreateManyInput | CrewRecipeBookCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CrewRecipeBook update
   */
  export type CrewRecipeBookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewRecipeBook
     */
    select?: CrewRecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewRecipeBookInclude<ExtArgs> | null
    /**
     * The data needed to update a CrewRecipeBook.
     */
    data: XOR<CrewRecipeBookUpdateInput, CrewRecipeBookUncheckedUpdateInput>
    /**
     * Choose, which CrewRecipeBook to update.
     */
    where: CrewRecipeBookWhereUniqueInput
  }


  /**
   * CrewRecipeBook updateMany
   */
  export type CrewRecipeBookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CrewRecipeBooks.
     */
    data: XOR<CrewRecipeBookUpdateManyMutationInput, CrewRecipeBookUncheckedUpdateManyInput>
    /**
     * Filter which CrewRecipeBooks to update
     */
    where?: CrewRecipeBookWhereInput
  }


  /**
   * CrewRecipeBook upsert
   */
  export type CrewRecipeBookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewRecipeBook
     */
    select?: CrewRecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewRecipeBookInclude<ExtArgs> | null
    /**
     * The filter to search for the CrewRecipeBook to update in case it exists.
     */
    where: CrewRecipeBookWhereUniqueInput
    /**
     * In case the CrewRecipeBook found by the `where` argument doesn't exist, create a new CrewRecipeBook with this data.
     */
    create: XOR<CrewRecipeBookCreateInput, CrewRecipeBookUncheckedCreateInput>
    /**
     * In case the CrewRecipeBook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CrewRecipeBookUpdateInput, CrewRecipeBookUncheckedUpdateInput>
  }


  /**
   * CrewRecipeBook delete
   */
  export type CrewRecipeBookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewRecipeBook
     */
    select?: CrewRecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewRecipeBookInclude<ExtArgs> | null
    /**
     * Filter which CrewRecipeBook to delete.
     */
    where: CrewRecipeBookWhereUniqueInput
  }


  /**
   * CrewRecipeBook deleteMany
   */
  export type CrewRecipeBookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrewRecipeBooks to delete
     */
    where?: CrewRecipeBookWhereInput
  }


  /**
   * CrewRecipeBook without action
   */
  export type CrewRecipeBookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewRecipeBook
     */
    select?: CrewRecipeBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewRecipeBookInclude<ExtArgs> | null
  }



  /**
   * Model CrewBuild
   */

  export type AggregateCrewBuild = {
    _count: CrewBuildCountAggregateOutputType | null
    _min: CrewBuildMinAggregateOutputType | null
    _max: CrewBuildMaxAggregateOutputType | null
  }

  export type CrewBuildMinAggregateOutputType = {
    buildId: string | null
    crewId: string | null
  }

  export type CrewBuildMaxAggregateOutputType = {
    buildId: string | null
    crewId: string | null
  }

  export type CrewBuildCountAggregateOutputType = {
    buildId: number
    crewId: number
    _all: number
  }


  export type CrewBuildMinAggregateInputType = {
    buildId?: true
    crewId?: true
  }

  export type CrewBuildMaxAggregateInputType = {
    buildId?: true
    crewId?: true
  }

  export type CrewBuildCountAggregateInputType = {
    buildId?: true
    crewId?: true
    _all?: true
  }

  export type CrewBuildAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrewBuild to aggregate.
     */
    where?: CrewBuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewBuilds to fetch.
     */
    orderBy?: CrewBuildOrderByWithRelationInput | CrewBuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CrewBuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewBuilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewBuilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CrewBuilds
    **/
    _count?: true | CrewBuildCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrewBuildMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrewBuildMaxAggregateInputType
  }

  export type GetCrewBuildAggregateType<T extends CrewBuildAggregateArgs> = {
        [P in keyof T & keyof AggregateCrewBuild]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrewBuild[P]>
      : GetScalarType<T[P], AggregateCrewBuild[P]>
  }




  export type CrewBuildGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewBuildWhereInput
    orderBy?: CrewBuildOrderByWithAggregationInput | CrewBuildOrderByWithAggregationInput[]
    by: CrewBuildScalarFieldEnum[] | CrewBuildScalarFieldEnum
    having?: CrewBuildScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrewBuildCountAggregateInputType | true
    _min?: CrewBuildMinAggregateInputType
    _max?: CrewBuildMaxAggregateInputType
  }

  export type CrewBuildGroupByOutputType = {
    buildId: string
    crewId: string
    _count: CrewBuildCountAggregateOutputType | null
    _min: CrewBuildMinAggregateOutputType | null
    _max: CrewBuildMaxAggregateOutputType | null
  }

  type GetCrewBuildGroupByPayload<T extends CrewBuildGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrewBuildGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrewBuildGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrewBuildGroupByOutputType[P]>
            : GetScalarType<T[P], CrewBuildGroupByOutputType[P]>
        }
      >
    >


  export type CrewBuildSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    buildId?: boolean
    crewId?: boolean
    build?: boolean | BuildDefaultArgs<ExtArgs>
    crew?: boolean | CrewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crewBuild"]>

  export type CrewBuildSelectScalar = {
    buildId?: boolean
    crewId?: boolean
  }

  export type CrewBuildInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    build?: boolean | BuildDefaultArgs<ExtArgs>
    crew?: boolean | CrewDefaultArgs<ExtArgs>
  }


  export type $CrewBuildPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CrewBuild"
    objects: {
      build: Prisma.$BuildPayload<ExtArgs>
      crew: Prisma.$CrewPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      buildId: string
      crewId: string
    }, ExtArgs["result"]["crewBuild"]>
    composites: {}
  }


  type CrewBuildGetPayload<S extends boolean | null | undefined | CrewBuildDefaultArgs> = $Result.GetResult<Prisma.$CrewBuildPayload, S>

  type CrewBuildCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CrewBuildFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CrewBuildCountAggregateInputType | true
    }

  export interface CrewBuildDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CrewBuild'], meta: { name: 'CrewBuild' } }
    /**
     * Find zero or one CrewBuild that matches the filter.
     * @param {CrewBuildFindUniqueArgs} args - Arguments to find a CrewBuild
     * @example
     * // Get one CrewBuild
     * const crewBuild = await prisma.crewBuild.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CrewBuildFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CrewBuildFindUniqueArgs<ExtArgs>>
    ): Prisma__CrewBuildClient<$Result.GetResult<Prisma.$CrewBuildPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CrewBuild that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CrewBuildFindUniqueOrThrowArgs} args - Arguments to find a CrewBuild
     * @example
     * // Get one CrewBuild
     * const crewBuild = await prisma.crewBuild.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CrewBuildFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewBuildFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CrewBuildClient<$Result.GetResult<Prisma.$CrewBuildPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CrewBuild that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewBuildFindFirstArgs} args - Arguments to find a CrewBuild
     * @example
     * // Get one CrewBuild
     * const crewBuild = await prisma.crewBuild.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CrewBuildFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewBuildFindFirstArgs<ExtArgs>>
    ): Prisma__CrewBuildClient<$Result.GetResult<Prisma.$CrewBuildPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CrewBuild that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewBuildFindFirstOrThrowArgs} args - Arguments to find a CrewBuild
     * @example
     * // Get one CrewBuild
     * const crewBuild = await prisma.crewBuild.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CrewBuildFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewBuildFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CrewBuildClient<$Result.GetResult<Prisma.$CrewBuildPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CrewBuilds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewBuildFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrewBuilds
     * const crewBuilds = await prisma.crewBuild.findMany()
     * 
     * // Get first 10 CrewBuilds
     * const crewBuilds = await prisma.crewBuild.findMany({ take: 10 })
     * 
     * // Only select the `buildId`
     * const crewBuildWithBuildIdOnly = await prisma.crewBuild.findMany({ select: { buildId: true } })
     * 
    **/
    findMany<T extends CrewBuildFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewBuildFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewBuildPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CrewBuild.
     * @param {CrewBuildCreateArgs} args - Arguments to create a CrewBuild.
     * @example
     * // Create one CrewBuild
     * const CrewBuild = await prisma.crewBuild.create({
     *   data: {
     *     // ... data to create a CrewBuild
     *   }
     * })
     * 
    **/
    create<T extends CrewBuildCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CrewBuildCreateArgs<ExtArgs>>
    ): Prisma__CrewBuildClient<$Result.GetResult<Prisma.$CrewBuildPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CrewBuilds.
     *     @param {CrewBuildCreateManyArgs} args - Arguments to create many CrewBuilds.
     *     @example
     *     // Create many CrewBuilds
     *     const crewBuild = await prisma.crewBuild.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CrewBuildCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewBuildCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CrewBuild.
     * @param {CrewBuildDeleteArgs} args - Arguments to delete one CrewBuild.
     * @example
     * // Delete one CrewBuild
     * const CrewBuild = await prisma.crewBuild.delete({
     *   where: {
     *     // ... filter to delete one CrewBuild
     *   }
     * })
     * 
    **/
    delete<T extends CrewBuildDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CrewBuildDeleteArgs<ExtArgs>>
    ): Prisma__CrewBuildClient<$Result.GetResult<Prisma.$CrewBuildPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CrewBuild.
     * @param {CrewBuildUpdateArgs} args - Arguments to update one CrewBuild.
     * @example
     * // Update one CrewBuild
     * const crewBuild = await prisma.crewBuild.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CrewBuildUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CrewBuildUpdateArgs<ExtArgs>>
    ): Prisma__CrewBuildClient<$Result.GetResult<Prisma.$CrewBuildPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CrewBuilds.
     * @param {CrewBuildDeleteManyArgs} args - Arguments to filter CrewBuilds to delete.
     * @example
     * // Delete a few CrewBuilds
     * const { count } = await prisma.crewBuild.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CrewBuildDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CrewBuildDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrewBuilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewBuildUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrewBuilds
     * const crewBuild = await prisma.crewBuild.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CrewBuildUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CrewBuildUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CrewBuild.
     * @param {CrewBuildUpsertArgs} args - Arguments to update or create a CrewBuild.
     * @example
     * // Update or create a CrewBuild
     * const crewBuild = await prisma.crewBuild.upsert({
     *   create: {
     *     // ... data to create a CrewBuild
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrewBuild we want to update
     *   }
     * })
    **/
    upsert<T extends CrewBuildUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CrewBuildUpsertArgs<ExtArgs>>
    ): Prisma__CrewBuildClient<$Result.GetResult<Prisma.$CrewBuildPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CrewBuilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewBuildCountArgs} args - Arguments to filter CrewBuilds to count.
     * @example
     * // Count the number of CrewBuilds
     * const count = await prisma.crewBuild.count({
     *   where: {
     *     // ... the filter for the CrewBuilds we want to count
     *   }
     * })
    **/
    count<T extends CrewBuildCountArgs>(
      args?: Subset<T, CrewBuildCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrewBuildCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrewBuild.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewBuildAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrewBuildAggregateArgs>(args: Subset<T, CrewBuildAggregateArgs>): Prisma.PrismaPromise<GetCrewBuildAggregateType<T>>

    /**
     * Group by CrewBuild.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewBuildGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrewBuildGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrewBuildGroupByArgs['orderBy'] }
        : { orderBy?: CrewBuildGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrewBuildGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrewBuildGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CrewBuild model
   */
  readonly fields: CrewBuildFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CrewBuild.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CrewBuildClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    build<T extends BuildDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BuildDefaultArgs<ExtArgs>>): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    crew<T extends CrewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CrewDefaultArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CrewBuild model
   */ 
  interface CrewBuildFieldRefs {
    readonly buildId: FieldRef<"CrewBuild", 'String'>
    readonly crewId: FieldRef<"CrewBuild", 'String'>
  }
    

  // Custom InputTypes

  /**
   * CrewBuild findUnique
   */
  export type CrewBuildFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewBuild
     */
    select?: CrewBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewBuildInclude<ExtArgs> | null
    /**
     * Filter, which CrewBuild to fetch.
     */
    where: CrewBuildWhereUniqueInput
  }


  /**
   * CrewBuild findUniqueOrThrow
   */
  export type CrewBuildFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewBuild
     */
    select?: CrewBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewBuildInclude<ExtArgs> | null
    /**
     * Filter, which CrewBuild to fetch.
     */
    where: CrewBuildWhereUniqueInput
  }


  /**
   * CrewBuild findFirst
   */
  export type CrewBuildFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewBuild
     */
    select?: CrewBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewBuildInclude<ExtArgs> | null
    /**
     * Filter, which CrewBuild to fetch.
     */
    where?: CrewBuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewBuilds to fetch.
     */
    orderBy?: CrewBuildOrderByWithRelationInput | CrewBuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrewBuilds.
     */
    cursor?: CrewBuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewBuilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewBuilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrewBuilds.
     */
    distinct?: CrewBuildScalarFieldEnum | CrewBuildScalarFieldEnum[]
  }


  /**
   * CrewBuild findFirstOrThrow
   */
  export type CrewBuildFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewBuild
     */
    select?: CrewBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewBuildInclude<ExtArgs> | null
    /**
     * Filter, which CrewBuild to fetch.
     */
    where?: CrewBuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewBuilds to fetch.
     */
    orderBy?: CrewBuildOrderByWithRelationInput | CrewBuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrewBuilds.
     */
    cursor?: CrewBuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewBuilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewBuilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrewBuilds.
     */
    distinct?: CrewBuildScalarFieldEnum | CrewBuildScalarFieldEnum[]
  }


  /**
   * CrewBuild findMany
   */
  export type CrewBuildFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewBuild
     */
    select?: CrewBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewBuildInclude<ExtArgs> | null
    /**
     * Filter, which CrewBuilds to fetch.
     */
    where?: CrewBuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrewBuilds to fetch.
     */
    orderBy?: CrewBuildOrderByWithRelationInput | CrewBuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CrewBuilds.
     */
    cursor?: CrewBuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrewBuilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrewBuilds.
     */
    skip?: number
    distinct?: CrewBuildScalarFieldEnum | CrewBuildScalarFieldEnum[]
  }


  /**
   * CrewBuild create
   */
  export type CrewBuildCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewBuild
     */
    select?: CrewBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewBuildInclude<ExtArgs> | null
    /**
     * The data needed to create a CrewBuild.
     */
    data: XOR<CrewBuildCreateInput, CrewBuildUncheckedCreateInput>
  }


  /**
   * CrewBuild createMany
   */
  export type CrewBuildCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CrewBuilds.
     */
    data: CrewBuildCreateManyInput | CrewBuildCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CrewBuild update
   */
  export type CrewBuildUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewBuild
     */
    select?: CrewBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewBuildInclude<ExtArgs> | null
    /**
     * The data needed to update a CrewBuild.
     */
    data: XOR<CrewBuildUpdateInput, CrewBuildUncheckedUpdateInput>
    /**
     * Choose, which CrewBuild to update.
     */
    where: CrewBuildWhereUniqueInput
  }


  /**
   * CrewBuild updateMany
   */
  export type CrewBuildUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CrewBuilds.
     */
    data: XOR<CrewBuildUpdateManyMutationInput, CrewBuildUncheckedUpdateManyInput>
    /**
     * Filter which CrewBuilds to update
     */
    where?: CrewBuildWhereInput
  }


  /**
   * CrewBuild upsert
   */
  export type CrewBuildUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewBuild
     */
    select?: CrewBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewBuildInclude<ExtArgs> | null
    /**
     * The filter to search for the CrewBuild to update in case it exists.
     */
    where: CrewBuildWhereUniqueInput
    /**
     * In case the CrewBuild found by the `where` argument doesn't exist, create a new CrewBuild with this data.
     */
    create: XOR<CrewBuildCreateInput, CrewBuildUncheckedCreateInput>
    /**
     * In case the CrewBuild was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CrewBuildUpdateInput, CrewBuildUncheckedUpdateInput>
  }


  /**
   * CrewBuild delete
   */
  export type CrewBuildDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewBuild
     */
    select?: CrewBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewBuildInclude<ExtArgs> | null
    /**
     * Filter which CrewBuild to delete.
     */
    where: CrewBuildWhereUniqueInput
  }


  /**
   * CrewBuild deleteMany
   */
  export type CrewBuildDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrewBuilds to delete
     */
    where?: CrewBuildWhereInput
  }


  /**
   * CrewBuild without action
   */
  export type CrewBuildDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewBuild
     */
    select?: CrewBuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CrewBuildInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    userName: 'userName',
    firstName: 'firstName',
    lastName: 'lastName',
    dateJoined: 'dateJoined',
    lastEdited: 'lastEdited',
    email: 'email',
    password: 'password'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const FollowScalarFieldEnum: {
    followedById: 'followedById',
    followingId: 'followingId',
    relationship: 'relationship'
  };

  export type FollowScalarFieldEnum = (typeof FollowScalarFieldEnum)[keyof typeof FollowScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    photo: 'photo'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const RecipeBookScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    editedAt: 'editedAt',
    createdById: 'createdById',
    editedById: 'editedById'
  };

  export type RecipeBookScalarFieldEnum = (typeof RecipeBookScalarFieldEnum)[keyof typeof RecipeBookScalarFieldEnum]


  export const RecipeBookUserScalarFieldEnum: {
    userId: 'userId',
    recipeBookId: 'recipeBookId',
    permission: 'permission'
  };

  export type RecipeBookUserScalarFieldEnum = (typeof RecipeBookUserScalarFieldEnum)[keyof typeof RecipeBookUserScalarFieldEnum]


  export const BuildScalarFieldEnum: {
    id: 'id',
    buildName: 'buildName',
    createdAt: 'createdAt',
    editedAt: 'editedAt',
    createdById: 'createdById',
    editedById: 'editedById',
    recipeId: 'recipeId',
    instructions: 'instructions',
    notes: 'notes',
    glassware: 'glassware',
    ice: 'ice',
    version: 'version'
  };

  export type BuildScalarFieldEnum = (typeof BuildScalarFieldEnum)[keyof typeof BuildScalarFieldEnum]


  export const ArchivedBuildScalarFieldEnum: {
    id: 'id',
    buildName: 'buildName',
    createdAt: 'createdAt',
    createdById: 'createdById',
    buildId: 'buildId',
    recipeId: 'recipeId',
    instructions: 'instructions',
    notes: 'notes',
    glassware: 'glassware',
    ice: 'ice',
    version: 'version'
  };

  export type ArchivedBuildScalarFieldEnum = (typeof ArchivedBuildScalarFieldEnum)[keyof typeof ArchivedBuildScalarFieldEnum]


  export const BuildUserScalarFieldEnum: {
    userId: 'userId',
    buildId: 'buildId',
    permission: 'permission'
  };

  export type BuildUserScalarFieldEnum = (typeof BuildUserScalarFieldEnum)[keyof typeof BuildUserScalarFieldEnum]


  export const RecipeScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    editedAt: 'editedAt',
    name: 'name',
    origin: 'origin',
    history: 'history',
    createdById: 'createdById',
    editedById: 'editedById'
  };

  export type RecipeScalarFieldEnum = (typeof RecipeScalarFieldEnum)[keyof typeof RecipeScalarFieldEnum]


  export const RecipeBookBuildScalarFieldEnum: {
    buildId: 'buildId',
    recipeBookId: 'recipeBookId'
  };

  export type RecipeBookBuildScalarFieldEnum = (typeof RecipeBookBuildScalarFieldEnum)[keyof typeof RecipeBookBuildScalarFieldEnum]


  export const TouchScalarFieldEnum: {
    id: 'id',
    buildId: 'buildId',
    order: 'order',
    amount: 'amount',
    unit: 'unit',
    ingredientTypeId: 'ingredientTypeId',
    ingredientId: 'ingredientId',
    version: 'version'
  };

  export type TouchScalarFieldEnum = (typeof TouchScalarFieldEnum)[keyof typeof TouchScalarFieldEnum]


  export const ArchivedTouchScalarFieldEnum: {
    id: 'id',
    archivedBuildId: 'archivedBuildId',
    order: 'order',
    amount: 'amount',
    unit: 'unit',
    ingredientTypeId: 'ingredientTypeId',
    ingredientId: 'ingredientId',
    version: 'version'
  };

  export type ArchivedTouchScalarFieldEnum = (typeof ArchivedTouchScalarFieldEnum)[keyof typeof ArchivedTouchScalarFieldEnum]


  export const IngredientTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type IngredientTypeScalarFieldEnum = (typeof IngredientTypeScalarFieldEnum)[keyof typeof IngredientTypeScalarFieldEnum]


  export const IngredientScalarFieldEnum: {
    id: 'id',
    dateCreated: 'dateCreated',
    createdById: 'createdById',
    ingredientTypeId: 'ingredientTypeId',
    name: 'name',
    description: 'description',
    price: 'price',
    amount: 'amount',
    unit: 'unit',
    source: 'source'
  };

  export type IngredientScalarFieldEnum = (typeof IngredientScalarFieldEnum)[keyof typeof IngredientScalarFieldEnum]


  export const IngredientUserScalarFieldEnum: {
    ingredientId: 'ingredientId',
    userId: 'userId',
    permission: 'permission'
  };

  export type IngredientUserScalarFieldEnum = (typeof IngredientUserScalarFieldEnum)[keyof typeof IngredientUserScalarFieldEnum]


  export const IngredientPreferenceScalarFieldEnum: {
    ingredientTypeId: 'ingredientTypeId',
    ingredientId: 'ingredientId',
    userId: 'userId'
  };

  export type IngredientPreferenceScalarFieldEnum = (typeof IngredientPreferenceScalarFieldEnum)[keyof typeof IngredientPreferenceScalarFieldEnum]


  export const InventoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    editedAt: 'editedAt',
    createdById: 'createdById',
    editedById: 'editedById'
  };

  export type InventoryScalarFieldEnum = (typeof InventoryScalarFieldEnum)[keyof typeof InventoryScalarFieldEnum]


  export const InventoryUserScalarFieldEnum: {
    userId: 'userId',
    inventoryId: 'inventoryId',
    permission: 'permission'
  };

  export type InventoryUserScalarFieldEnum = (typeof InventoryUserScalarFieldEnum)[keyof typeof InventoryUserScalarFieldEnum]


  export const StorageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    editedAt: 'editedAt',
    createdById: 'createdById',
    editedById: 'editedById'
  };

  export type StorageScalarFieldEnum = (typeof StorageScalarFieldEnum)[keyof typeof StorageScalarFieldEnum]


  export const InventoryStorageScalarFieldEnum: {
    inventoryId: 'inventoryId',
    storageId: 'storageId'
  };

  export type InventoryStorageScalarFieldEnum = (typeof InventoryStorageScalarFieldEnum)[keyof typeof InventoryStorageScalarFieldEnum]


  export const IngredientStorageScalarFieldEnum: {
    ingredientId: 'ingredientId',
    storageId: 'storageId',
    quantity: 'quantity'
  };

  export type IngredientStorageScalarFieldEnum = (typeof IngredientStorageScalarFieldEnum)[keyof typeof IngredientStorageScalarFieldEnum]


  export const StorageUserScalarFieldEnum: {
    userId: 'userId',
    storageId: 'storageId',
    permission: 'permission'
  };

  export type StorageUserScalarFieldEnum = (typeof StorageUserScalarFieldEnum)[keyof typeof StorageUserScalarFieldEnum]


  export const CrewScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    editedAt: 'editedAt',
    createdById: 'createdById',
    editedById: 'editedById'
  };

  export type CrewScalarFieldEnum = (typeof CrewScalarFieldEnum)[keyof typeof CrewScalarFieldEnum]


  export const CrewUserScalarFieldEnum: {
    userId: 'userId',
    crewId: 'crewId',
    permission: 'permission'
  };

  export type CrewUserScalarFieldEnum = (typeof CrewUserScalarFieldEnum)[keyof typeof CrewUserScalarFieldEnum]


  export const CrewInventoryScalarFieldEnum: {
    inventoryId: 'inventoryId',
    crewId: 'crewId'
  };

  export type CrewInventoryScalarFieldEnum = (typeof CrewInventoryScalarFieldEnum)[keyof typeof CrewInventoryScalarFieldEnum]


  export const CrewStorageScalarFieldEnum: {
    storageId: 'storageId',
    crewId: 'crewId'
  };

  export type CrewStorageScalarFieldEnum = (typeof CrewStorageScalarFieldEnum)[keyof typeof CrewStorageScalarFieldEnum]


  export const CrewIngredientScalarFieldEnum: {
    ingredientId: 'ingredientId',
    crewId: 'crewId'
  };

  export type CrewIngredientScalarFieldEnum = (typeof CrewIngredientScalarFieldEnum)[keyof typeof CrewIngredientScalarFieldEnum]


  export const CrewRecipeBookScalarFieldEnum: {
    recipeBookId: 'recipeBookId',
    crewId: 'crewId'
  };

  export type CrewRecipeBookScalarFieldEnum = (typeof CrewRecipeBookScalarFieldEnum)[keyof typeof CrewRecipeBookScalarFieldEnum]


  export const CrewBuildScalarFieldEnum: {
    buildId: 'buildId',
    crewId: 'crewId'
  };

  export type CrewBuildScalarFieldEnum = (typeof CrewBuildScalarFieldEnum)[keyof typeof CrewBuildScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    userName?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    dateJoined?: DateTimeFilter<"User"> | Date | string
    lastEdited?: DateTimeFilter<"User"> | Date | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    recipeBookUser?: RecipeBookUserListRelationFilter
    recipeBook?: RecipeBookListRelationFilter
    recipeBookEditedBy?: RecipeBookListRelationFilter
    recipe?: RecipeListRelationFilter
    recipeEditedBy?: RecipeListRelationFilter
    buildUser?: BuildUserListRelationFilter
    build?: BuildListRelationFilter
    buildEditedBy?: BuildListRelationFilter
    archivedBuild?: ArchivedBuildListRelationFilter
    crewUser?: CrewUserListRelationFilter
    crew?: CrewListRelationFilter
    crewEditedBy?: CrewListRelationFilter
    ingredient?: IngredientListRelationFilter
    ingredientPreference?: IngredientPreferenceListRelationFilter
    ingredientUser?: IngredientUserListRelationFilter
    storageUser?: StorageUserListRelationFilter
    storage?: StorageListRelationFilter
    storageEditedBy?: StorageListRelationFilter
    inventory?: InventoryListRelationFilter
    inventoryEditedBy?: InventoryListRelationFilter
    inventoryUser?: InventoryUserListRelationFilter
    followedBy?: FollowListRelationFilter
    following?: FollowListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    userName?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    dateJoined?: SortOrder
    lastEdited?: SortOrder
    email?: SortOrder
    password?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    recipeBookUser?: RecipeBookUserOrderByRelationAggregateInput
    recipeBook?: RecipeBookOrderByRelationAggregateInput
    recipeBookEditedBy?: RecipeBookOrderByRelationAggregateInput
    recipe?: RecipeOrderByRelationAggregateInput
    recipeEditedBy?: RecipeOrderByRelationAggregateInput
    buildUser?: BuildUserOrderByRelationAggregateInput
    build?: BuildOrderByRelationAggregateInput
    buildEditedBy?: BuildOrderByRelationAggregateInput
    archivedBuild?: ArchivedBuildOrderByRelationAggregateInput
    crewUser?: CrewUserOrderByRelationAggregateInput
    crew?: CrewOrderByRelationAggregateInput
    crewEditedBy?: CrewOrderByRelationAggregateInput
    ingredient?: IngredientOrderByRelationAggregateInput
    ingredientPreference?: IngredientPreferenceOrderByRelationAggregateInput
    ingredientUser?: IngredientUserOrderByRelationAggregateInput
    storageUser?: StorageUserOrderByRelationAggregateInput
    storage?: StorageOrderByRelationAggregateInput
    storageEditedBy?: StorageOrderByRelationAggregateInput
    inventory?: InventoryOrderByRelationAggregateInput
    inventoryEditedBy?: InventoryOrderByRelationAggregateInput
    inventoryUser?: InventoryUserOrderByRelationAggregateInput
    followedBy?: FollowOrderByRelationAggregateInput
    following?: FollowOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    userName?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    dateJoined?: DateTimeFilter<"User"> | Date | string
    lastEdited?: DateTimeFilter<"User"> | Date | string
    password?: StringFilter<"User"> | string
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    recipeBookUser?: RecipeBookUserListRelationFilter
    recipeBook?: RecipeBookListRelationFilter
    recipeBookEditedBy?: RecipeBookListRelationFilter
    recipe?: RecipeListRelationFilter
    recipeEditedBy?: RecipeListRelationFilter
    buildUser?: BuildUserListRelationFilter
    build?: BuildListRelationFilter
    buildEditedBy?: BuildListRelationFilter
    archivedBuild?: ArchivedBuildListRelationFilter
    crewUser?: CrewUserListRelationFilter
    crew?: CrewListRelationFilter
    crewEditedBy?: CrewListRelationFilter
    ingredient?: IngredientListRelationFilter
    ingredientPreference?: IngredientPreferenceListRelationFilter
    ingredientUser?: IngredientUserListRelationFilter
    storageUser?: StorageUserListRelationFilter
    storage?: StorageListRelationFilter
    storageEditedBy?: StorageListRelationFilter
    inventory?: InventoryListRelationFilter
    inventoryEditedBy?: InventoryListRelationFilter
    inventoryUser?: InventoryUserListRelationFilter
    followedBy?: FollowListRelationFilter
    following?: FollowListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    userName?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    dateJoined?: SortOrder
    lastEdited?: SortOrder
    email?: SortOrder
    password?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    userName?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    dateJoined?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastEdited?: DateTimeWithAggregatesFilter<"User"> | Date | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
  }

  export type FollowWhereInput = {
    AND?: FollowWhereInput | FollowWhereInput[]
    OR?: FollowWhereInput[]
    NOT?: FollowWhereInput | FollowWhereInput[]
    followedById?: StringFilter<"Follow"> | string
    followingId?: StringFilter<"Follow"> | string
    relationship?: StringFilter<"Follow"> | string
    followedBy?: XOR<UserRelationFilter, UserWhereInput>
    following?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type FollowOrderByWithRelationInput = {
    followedById?: SortOrder
    followingId?: SortOrder
    relationship?: SortOrder
    followedBy?: UserOrderByWithRelationInput
    following?: UserOrderByWithRelationInput
  }

  export type FollowWhereUniqueInput = Prisma.AtLeast<{
    followingId_followedById?: FollowFollowingIdFollowedByIdCompoundUniqueInput
    AND?: FollowWhereInput | FollowWhereInput[]
    OR?: FollowWhereInput[]
    NOT?: FollowWhereInput | FollowWhereInput[]
    followedById?: StringFilter<"Follow"> | string
    followingId?: StringFilter<"Follow"> | string
    relationship?: StringFilter<"Follow"> | string
    followedBy?: XOR<UserRelationFilter, UserWhereInput>
    following?: XOR<UserRelationFilter, UserWhereInput>
  }, "followingId_followedById">

  export type FollowOrderByWithAggregationInput = {
    followedById?: SortOrder
    followingId?: SortOrder
    relationship?: SortOrder
    _count?: FollowCountOrderByAggregateInput
    _max?: FollowMaxOrderByAggregateInput
    _min?: FollowMinOrderByAggregateInput
  }

  export type FollowScalarWhereWithAggregatesInput = {
    AND?: FollowScalarWhereWithAggregatesInput | FollowScalarWhereWithAggregatesInput[]
    OR?: FollowScalarWhereWithAggregatesInput[]
    NOT?: FollowScalarWhereWithAggregatesInput | FollowScalarWhereWithAggregatesInput[]
    followedById?: StringWithAggregatesFilter<"Follow"> | string
    followingId?: StringWithAggregatesFilter<"Follow"> | string
    relationship?: StringWithAggregatesFilter<"Follow"> | string
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: StringFilter<"Profile"> | string
    userId?: StringFilter<"Profile"> | string
    photo?: StringFilter<"Profile"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    photo?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    photo?: StringFilter<"Profile"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    photo?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Profile"> | string
    userId?: StringWithAggregatesFilter<"Profile"> | string
    photo?: StringWithAggregatesFilter<"Profile"> | string
  }

  export type RecipeBookWhereInput = {
    AND?: RecipeBookWhereInput | RecipeBookWhereInput[]
    OR?: RecipeBookWhereInput[]
    NOT?: RecipeBookWhereInput | RecipeBookWhereInput[]
    id?: StringFilter<"RecipeBook"> | string
    name?: StringFilter<"RecipeBook"> | string
    description?: StringNullableFilter<"RecipeBook"> | string | null
    createdAt?: DateTimeFilter<"RecipeBook"> | Date | string
    editedAt?: DateTimeFilter<"RecipeBook"> | Date | string
    createdById?: StringNullableFilter<"RecipeBook"> | string | null
    editedById?: StringNullableFilter<"RecipeBook"> | string | null
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    editedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    recipeBookBuild?: RecipeBookBuildListRelationFilter
    recipeBookUser?: RecipeBookUserListRelationFilter
    crewRecipeBook?: CrewRecipeBookListRelationFilter
  }

  export type RecipeBookOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    editedById?: SortOrderInput | SortOrder
    createdBy?: UserOrderByWithRelationInput
    editedBy?: UserOrderByWithRelationInput
    recipeBookBuild?: RecipeBookBuildOrderByRelationAggregateInput
    recipeBookUser?: RecipeBookUserOrderByRelationAggregateInput
    crewRecipeBook?: CrewRecipeBookOrderByRelationAggregateInput
  }

  export type RecipeBookWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RecipeBookWhereInput | RecipeBookWhereInput[]
    OR?: RecipeBookWhereInput[]
    NOT?: RecipeBookWhereInput | RecipeBookWhereInput[]
    name?: StringFilter<"RecipeBook"> | string
    description?: StringNullableFilter<"RecipeBook"> | string | null
    createdAt?: DateTimeFilter<"RecipeBook"> | Date | string
    editedAt?: DateTimeFilter<"RecipeBook"> | Date | string
    createdById?: StringNullableFilter<"RecipeBook"> | string | null
    editedById?: StringNullableFilter<"RecipeBook"> | string | null
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    editedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    recipeBookBuild?: RecipeBookBuildListRelationFilter
    recipeBookUser?: RecipeBookUserListRelationFilter
    crewRecipeBook?: CrewRecipeBookListRelationFilter
  }, "id">

  export type RecipeBookOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    editedById?: SortOrderInput | SortOrder
    _count?: RecipeBookCountOrderByAggregateInput
    _max?: RecipeBookMaxOrderByAggregateInput
    _min?: RecipeBookMinOrderByAggregateInput
  }

  export type RecipeBookScalarWhereWithAggregatesInput = {
    AND?: RecipeBookScalarWhereWithAggregatesInput | RecipeBookScalarWhereWithAggregatesInput[]
    OR?: RecipeBookScalarWhereWithAggregatesInput[]
    NOT?: RecipeBookScalarWhereWithAggregatesInput | RecipeBookScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RecipeBook"> | string
    name?: StringWithAggregatesFilter<"RecipeBook"> | string
    description?: StringNullableWithAggregatesFilter<"RecipeBook"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RecipeBook"> | Date | string
    editedAt?: DateTimeWithAggregatesFilter<"RecipeBook"> | Date | string
    createdById?: StringNullableWithAggregatesFilter<"RecipeBook"> | string | null
    editedById?: StringNullableWithAggregatesFilter<"RecipeBook"> | string | null
  }

  export type RecipeBookUserWhereInput = {
    AND?: RecipeBookUserWhereInput | RecipeBookUserWhereInput[]
    OR?: RecipeBookUserWhereInput[]
    NOT?: RecipeBookUserWhereInput | RecipeBookUserWhereInput[]
    userId?: StringFilter<"RecipeBookUser"> | string
    recipeBookId?: StringFilter<"RecipeBookUser"> | string
    permission?: StringFilter<"RecipeBookUser"> | string
    recipeBook?: XOR<RecipeBookRelationFilter, RecipeBookWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RecipeBookUserOrderByWithRelationInput = {
    userId?: SortOrder
    recipeBookId?: SortOrder
    permission?: SortOrder
    recipeBook?: RecipeBookOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type RecipeBookUserWhereUniqueInput = Prisma.AtLeast<{
    userId_recipeBookId?: RecipeBookUserUserIdRecipeBookIdCompoundUniqueInput
    AND?: RecipeBookUserWhereInput | RecipeBookUserWhereInput[]
    OR?: RecipeBookUserWhereInput[]
    NOT?: RecipeBookUserWhereInput | RecipeBookUserWhereInput[]
    userId?: StringFilter<"RecipeBookUser"> | string
    recipeBookId?: StringFilter<"RecipeBookUser"> | string
    permission?: StringFilter<"RecipeBookUser"> | string
    recipeBook?: XOR<RecipeBookRelationFilter, RecipeBookWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "userId_recipeBookId">

  export type RecipeBookUserOrderByWithAggregationInput = {
    userId?: SortOrder
    recipeBookId?: SortOrder
    permission?: SortOrder
    _count?: RecipeBookUserCountOrderByAggregateInput
    _max?: RecipeBookUserMaxOrderByAggregateInput
    _min?: RecipeBookUserMinOrderByAggregateInput
  }

  export type RecipeBookUserScalarWhereWithAggregatesInput = {
    AND?: RecipeBookUserScalarWhereWithAggregatesInput | RecipeBookUserScalarWhereWithAggregatesInput[]
    OR?: RecipeBookUserScalarWhereWithAggregatesInput[]
    NOT?: RecipeBookUserScalarWhereWithAggregatesInput | RecipeBookUserScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"RecipeBookUser"> | string
    recipeBookId?: StringWithAggregatesFilter<"RecipeBookUser"> | string
    permission?: StringWithAggregatesFilter<"RecipeBookUser"> | string
  }

  export type BuildWhereInput = {
    AND?: BuildWhereInput | BuildWhereInput[]
    OR?: BuildWhereInput[]
    NOT?: BuildWhereInput | BuildWhereInput[]
    id?: StringFilter<"Build"> | string
    buildName?: StringFilter<"Build"> | string
    createdAt?: DateTimeFilter<"Build"> | Date | string
    editedAt?: DateTimeFilter<"Build"> | Date | string
    createdById?: StringNullableFilter<"Build"> | string | null
    editedById?: StringNullableFilter<"Build"> | string | null
    recipeId?: StringNullableFilter<"Build"> | string | null
    instructions?: StringNullableFilter<"Build"> | string | null
    notes?: StringNullableFilter<"Build"> | string | null
    glassware?: StringNullableFilter<"Build"> | string | null
    ice?: StringNullableFilter<"Build"> | string | null
    version?: IntFilter<"Build"> | number
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    editedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    recipe?: XOR<RecipeNullableRelationFilter, RecipeWhereInput> | null
    touch?: TouchListRelationFilter
    archivedBuild?: ArchivedBuildListRelationFilter
    RecipeBookBuild?: RecipeBookBuildListRelationFilter
    buildUser?: BuildUserListRelationFilter
    crewBuild?: CrewBuildListRelationFilter
  }

  export type BuildOrderByWithRelationInput = {
    id?: SortOrder
    buildName?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    editedById?: SortOrderInput | SortOrder
    recipeId?: SortOrderInput | SortOrder
    instructions?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    glassware?: SortOrderInput | SortOrder
    ice?: SortOrderInput | SortOrder
    version?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    editedBy?: UserOrderByWithRelationInput
    recipe?: RecipeOrderByWithRelationInput
    touch?: TouchOrderByRelationAggregateInput
    archivedBuild?: ArchivedBuildOrderByRelationAggregateInput
    RecipeBookBuild?: RecipeBookBuildOrderByRelationAggregateInput
    buildUser?: BuildUserOrderByRelationAggregateInput
    crewBuild?: CrewBuildOrderByRelationAggregateInput
  }

  export type BuildWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BuildWhereInput | BuildWhereInput[]
    OR?: BuildWhereInput[]
    NOT?: BuildWhereInput | BuildWhereInput[]
    buildName?: StringFilter<"Build"> | string
    createdAt?: DateTimeFilter<"Build"> | Date | string
    editedAt?: DateTimeFilter<"Build"> | Date | string
    createdById?: StringNullableFilter<"Build"> | string | null
    editedById?: StringNullableFilter<"Build"> | string | null
    recipeId?: StringNullableFilter<"Build"> | string | null
    instructions?: StringNullableFilter<"Build"> | string | null
    notes?: StringNullableFilter<"Build"> | string | null
    glassware?: StringNullableFilter<"Build"> | string | null
    ice?: StringNullableFilter<"Build"> | string | null
    version?: IntFilter<"Build"> | number
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    editedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    recipe?: XOR<RecipeNullableRelationFilter, RecipeWhereInput> | null
    touch?: TouchListRelationFilter
    archivedBuild?: ArchivedBuildListRelationFilter
    RecipeBookBuild?: RecipeBookBuildListRelationFilter
    buildUser?: BuildUserListRelationFilter
    crewBuild?: CrewBuildListRelationFilter
  }, "id">

  export type BuildOrderByWithAggregationInput = {
    id?: SortOrder
    buildName?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    editedById?: SortOrderInput | SortOrder
    recipeId?: SortOrderInput | SortOrder
    instructions?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    glassware?: SortOrderInput | SortOrder
    ice?: SortOrderInput | SortOrder
    version?: SortOrder
    _count?: BuildCountOrderByAggregateInput
    _avg?: BuildAvgOrderByAggregateInput
    _max?: BuildMaxOrderByAggregateInput
    _min?: BuildMinOrderByAggregateInput
    _sum?: BuildSumOrderByAggregateInput
  }

  export type BuildScalarWhereWithAggregatesInput = {
    AND?: BuildScalarWhereWithAggregatesInput | BuildScalarWhereWithAggregatesInput[]
    OR?: BuildScalarWhereWithAggregatesInput[]
    NOT?: BuildScalarWhereWithAggregatesInput | BuildScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Build"> | string
    buildName?: StringWithAggregatesFilter<"Build"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Build"> | Date | string
    editedAt?: DateTimeWithAggregatesFilter<"Build"> | Date | string
    createdById?: StringNullableWithAggregatesFilter<"Build"> | string | null
    editedById?: StringNullableWithAggregatesFilter<"Build"> | string | null
    recipeId?: StringNullableWithAggregatesFilter<"Build"> | string | null
    instructions?: StringNullableWithAggregatesFilter<"Build"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Build"> | string | null
    glassware?: StringNullableWithAggregatesFilter<"Build"> | string | null
    ice?: StringNullableWithAggregatesFilter<"Build"> | string | null
    version?: IntWithAggregatesFilter<"Build"> | number
  }

  export type ArchivedBuildWhereInput = {
    AND?: ArchivedBuildWhereInput | ArchivedBuildWhereInput[]
    OR?: ArchivedBuildWhereInput[]
    NOT?: ArchivedBuildWhereInput | ArchivedBuildWhereInput[]
    id?: StringFilter<"ArchivedBuild"> | string
    buildName?: StringFilter<"ArchivedBuild"> | string
    createdAt?: DateTimeFilter<"ArchivedBuild"> | Date | string
    createdById?: StringNullableFilter<"ArchivedBuild"> | string | null
    buildId?: StringFilter<"ArchivedBuild"> | string
    recipeId?: StringNullableFilter<"ArchivedBuild"> | string | null
    instructions?: StringNullableFilter<"ArchivedBuild"> | string | null
    notes?: StringNullableFilter<"ArchivedBuild"> | string | null
    glassware?: StringNullableFilter<"ArchivedBuild"> | string | null
    ice?: StringNullableFilter<"ArchivedBuild"> | string | null
    version?: IntFilter<"ArchivedBuild"> | number
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    build?: XOR<BuildRelationFilter, BuildWhereInput>
    recipe?: XOR<RecipeNullableRelationFilter, RecipeWhereInput> | null
    archivedTouch?: ArchivedTouchListRelationFilter
  }

  export type ArchivedBuildOrderByWithRelationInput = {
    id?: SortOrder
    buildName?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    buildId?: SortOrder
    recipeId?: SortOrderInput | SortOrder
    instructions?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    glassware?: SortOrderInput | SortOrder
    ice?: SortOrderInput | SortOrder
    version?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    build?: BuildOrderByWithRelationInput
    recipe?: RecipeOrderByWithRelationInput
    archivedTouch?: ArchivedTouchOrderByRelationAggregateInput
  }

  export type ArchivedBuildWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ArchivedBuildWhereInput | ArchivedBuildWhereInput[]
    OR?: ArchivedBuildWhereInput[]
    NOT?: ArchivedBuildWhereInput | ArchivedBuildWhereInput[]
    buildName?: StringFilter<"ArchivedBuild"> | string
    createdAt?: DateTimeFilter<"ArchivedBuild"> | Date | string
    createdById?: StringNullableFilter<"ArchivedBuild"> | string | null
    buildId?: StringFilter<"ArchivedBuild"> | string
    recipeId?: StringNullableFilter<"ArchivedBuild"> | string | null
    instructions?: StringNullableFilter<"ArchivedBuild"> | string | null
    notes?: StringNullableFilter<"ArchivedBuild"> | string | null
    glassware?: StringNullableFilter<"ArchivedBuild"> | string | null
    ice?: StringNullableFilter<"ArchivedBuild"> | string | null
    version?: IntFilter<"ArchivedBuild"> | number
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    build?: XOR<BuildRelationFilter, BuildWhereInput>
    recipe?: XOR<RecipeNullableRelationFilter, RecipeWhereInput> | null
    archivedTouch?: ArchivedTouchListRelationFilter
  }, "id">

  export type ArchivedBuildOrderByWithAggregationInput = {
    id?: SortOrder
    buildName?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    buildId?: SortOrder
    recipeId?: SortOrderInput | SortOrder
    instructions?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    glassware?: SortOrderInput | SortOrder
    ice?: SortOrderInput | SortOrder
    version?: SortOrder
    _count?: ArchivedBuildCountOrderByAggregateInput
    _avg?: ArchivedBuildAvgOrderByAggregateInput
    _max?: ArchivedBuildMaxOrderByAggregateInput
    _min?: ArchivedBuildMinOrderByAggregateInput
    _sum?: ArchivedBuildSumOrderByAggregateInput
  }

  export type ArchivedBuildScalarWhereWithAggregatesInput = {
    AND?: ArchivedBuildScalarWhereWithAggregatesInput | ArchivedBuildScalarWhereWithAggregatesInput[]
    OR?: ArchivedBuildScalarWhereWithAggregatesInput[]
    NOT?: ArchivedBuildScalarWhereWithAggregatesInput | ArchivedBuildScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ArchivedBuild"> | string
    buildName?: StringWithAggregatesFilter<"ArchivedBuild"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ArchivedBuild"> | Date | string
    createdById?: StringNullableWithAggregatesFilter<"ArchivedBuild"> | string | null
    buildId?: StringWithAggregatesFilter<"ArchivedBuild"> | string
    recipeId?: StringNullableWithAggregatesFilter<"ArchivedBuild"> | string | null
    instructions?: StringNullableWithAggregatesFilter<"ArchivedBuild"> | string | null
    notes?: StringNullableWithAggregatesFilter<"ArchivedBuild"> | string | null
    glassware?: StringNullableWithAggregatesFilter<"ArchivedBuild"> | string | null
    ice?: StringNullableWithAggregatesFilter<"ArchivedBuild"> | string | null
    version?: IntWithAggregatesFilter<"ArchivedBuild"> | number
  }

  export type BuildUserWhereInput = {
    AND?: BuildUserWhereInput | BuildUserWhereInput[]
    OR?: BuildUserWhereInput[]
    NOT?: BuildUserWhereInput | BuildUserWhereInput[]
    userId?: StringFilter<"BuildUser"> | string
    buildId?: StringFilter<"BuildUser"> | string
    permission?: StringFilter<"BuildUser"> | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    build?: XOR<BuildNullableRelationFilter, BuildWhereInput> | null
  }

  export type BuildUserOrderByWithRelationInput = {
    userId?: SortOrder
    buildId?: SortOrder
    permission?: SortOrder
    user?: UserOrderByWithRelationInput
    build?: BuildOrderByWithRelationInput
  }

  export type BuildUserWhereUniqueInput = Prisma.AtLeast<{
    userId_buildId?: BuildUserUserIdBuildIdCompoundUniqueInput
    AND?: BuildUserWhereInput | BuildUserWhereInput[]
    OR?: BuildUserWhereInput[]
    NOT?: BuildUserWhereInput | BuildUserWhereInput[]
    userId?: StringFilter<"BuildUser"> | string
    buildId?: StringFilter<"BuildUser"> | string
    permission?: StringFilter<"BuildUser"> | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    build?: XOR<BuildNullableRelationFilter, BuildWhereInput> | null
  }, "userId_buildId">

  export type BuildUserOrderByWithAggregationInput = {
    userId?: SortOrder
    buildId?: SortOrder
    permission?: SortOrder
    _count?: BuildUserCountOrderByAggregateInput
    _max?: BuildUserMaxOrderByAggregateInput
    _min?: BuildUserMinOrderByAggregateInput
  }

  export type BuildUserScalarWhereWithAggregatesInput = {
    AND?: BuildUserScalarWhereWithAggregatesInput | BuildUserScalarWhereWithAggregatesInput[]
    OR?: BuildUserScalarWhereWithAggregatesInput[]
    NOT?: BuildUserScalarWhereWithAggregatesInput | BuildUserScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"BuildUser"> | string
    buildId?: StringWithAggregatesFilter<"BuildUser"> | string
    permission?: StringWithAggregatesFilter<"BuildUser"> | string
  }

  export type RecipeWhereInput = {
    AND?: RecipeWhereInput | RecipeWhereInput[]
    OR?: RecipeWhereInput[]
    NOT?: RecipeWhereInput | RecipeWhereInput[]
    id?: StringFilter<"Recipe"> | string
    createdAt?: DateTimeFilter<"Recipe"> | Date | string
    editedAt?: DateTimeFilter<"Recipe"> | Date | string
    name?: StringFilter<"Recipe"> | string
    origin?: StringNullableFilter<"Recipe"> | string | null
    history?: StringNullableFilter<"Recipe"> | string | null
    createdById?: StringNullableFilter<"Recipe"> | string | null
    editedById?: StringNullableFilter<"Recipe"> | string | null
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    editedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    build?: BuildListRelationFilter
    archivedBuild?: ArchivedBuildListRelationFilter
  }

  export type RecipeOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    name?: SortOrder
    origin?: SortOrderInput | SortOrder
    history?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    editedById?: SortOrderInput | SortOrder
    createdBy?: UserOrderByWithRelationInput
    editedBy?: UserOrderByWithRelationInput
    build?: BuildOrderByRelationAggregateInput
    archivedBuild?: ArchivedBuildOrderByRelationAggregateInput
  }

  export type RecipeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RecipeWhereInput | RecipeWhereInput[]
    OR?: RecipeWhereInput[]
    NOT?: RecipeWhereInput | RecipeWhereInput[]
    createdAt?: DateTimeFilter<"Recipe"> | Date | string
    editedAt?: DateTimeFilter<"Recipe"> | Date | string
    name?: StringFilter<"Recipe"> | string
    origin?: StringNullableFilter<"Recipe"> | string | null
    history?: StringNullableFilter<"Recipe"> | string | null
    createdById?: StringNullableFilter<"Recipe"> | string | null
    editedById?: StringNullableFilter<"Recipe"> | string | null
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    editedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    build?: BuildListRelationFilter
    archivedBuild?: ArchivedBuildListRelationFilter
  }, "id">

  export type RecipeOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    name?: SortOrder
    origin?: SortOrderInput | SortOrder
    history?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    editedById?: SortOrderInput | SortOrder
    _count?: RecipeCountOrderByAggregateInput
    _max?: RecipeMaxOrderByAggregateInput
    _min?: RecipeMinOrderByAggregateInput
  }

  export type RecipeScalarWhereWithAggregatesInput = {
    AND?: RecipeScalarWhereWithAggregatesInput | RecipeScalarWhereWithAggregatesInput[]
    OR?: RecipeScalarWhereWithAggregatesInput[]
    NOT?: RecipeScalarWhereWithAggregatesInput | RecipeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Recipe"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Recipe"> | Date | string
    editedAt?: DateTimeWithAggregatesFilter<"Recipe"> | Date | string
    name?: StringWithAggregatesFilter<"Recipe"> | string
    origin?: StringNullableWithAggregatesFilter<"Recipe"> | string | null
    history?: StringNullableWithAggregatesFilter<"Recipe"> | string | null
    createdById?: StringNullableWithAggregatesFilter<"Recipe"> | string | null
    editedById?: StringNullableWithAggregatesFilter<"Recipe"> | string | null
  }

  export type RecipeBookBuildWhereInput = {
    AND?: RecipeBookBuildWhereInput | RecipeBookBuildWhereInput[]
    OR?: RecipeBookBuildWhereInput[]
    NOT?: RecipeBookBuildWhereInput | RecipeBookBuildWhereInput[]
    buildId?: StringFilter<"RecipeBookBuild"> | string
    recipeBookId?: StringFilter<"RecipeBookBuild"> | string
    recipeBook?: XOR<RecipeBookRelationFilter, RecipeBookWhereInput>
    build?: XOR<BuildRelationFilter, BuildWhereInput>
  }

  export type RecipeBookBuildOrderByWithRelationInput = {
    buildId?: SortOrder
    recipeBookId?: SortOrder
    recipeBook?: RecipeBookOrderByWithRelationInput
    build?: BuildOrderByWithRelationInput
  }

  export type RecipeBookBuildWhereUniqueInput = Prisma.AtLeast<{
    buildId_recipeBookId?: RecipeBookBuildBuildIdRecipeBookIdCompoundUniqueInput
    AND?: RecipeBookBuildWhereInput | RecipeBookBuildWhereInput[]
    OR?: RecipeBookBuildWhereInput[]
    NOT?: RecipeBookBuildWhereInput | RecipeBookBuildWhereInput[]
    buildId?: StringFilter<"RecipeBookBuild"> | string
    recipeBookId?: StringFilter<"RecipeBookBuild"> | string
    recipeBook?: XOR<RecipeBookRelationFilter, RecipeBookWhereInput>
    build?: XOR<BuildRelationFilter, BuildWhereInput>
  }, "buildId_recipeBookId">

  export type RecipeBookBuildOrderByWithAggregationInput = {
    buildId?: SortOrder
    recipeBookId?: SortOrder
    _count?: RecipeBookBuildCountOrderByAggregateInput
    _max?: RecipeBookBuildMaxOrderByAggregateInput
    _min?: RecipeBookBuildMinOrderByAggregateInput
  }

  export type RecipeBookBuildScalarWhereWithAggregatesInput = {
    AND?: RecipeBookBuildScalarWhereWithAggregatesInput | RecipeBookBuildScalarWhereWithAggregatesInput[]
    OR?: RecipeBookBuildScalarWhereWithAggregatesInput[]
    NOT?: RecipeBookBuildScalarWhereWithAggregatesInput | RecipeBookBuildScalarWhereWithAggregatesInput[]
    buildId?: StringWithAggregatesFilter<"RecipeBookBuild"> | string
    recipeBookId?: StringWithAggregatesFilter<"RecipeBookBuild"> | string
  }

  export type TouchWhereInput = {
    AND?: TouchWhereInput | TouchWhereInput[]
    OR?: TouchWhereInput[]
    NOT?: TouchWhereInput | TouchWhereInput[]
    id?: StringFilter<"Touch"> | string
    buildId?: StringFilter<"Touch"> | string
    order?: IntNullableFilter<"Touch"> | number | null
    amount?: FloatNullableFilter<"Touch"> | number | null
    unit?: StringNullableFilter<"Touch"> | string | null
    ingredientTypeId?: StringFilter<"Touch"> | string
    ingredientId?: StringNullableFilter<"Touch"> | string | null
    version?: IntNullableFilter<"Touch"> | number | null
    build?: XOR<BuildRelationFilter, BuildWhereInput>
    ingredientType?: XOR<IngredientTypeRelationFilter, IngredientTypeWhereInput>
    ingredient?: XOR<IngredientNullableRelationFilter, IngredientWhereInput> | null
  }

  export type TouchOrderByWithRelationInput = {
    id?: SortOrder
    buildId?: SortOrder
    order?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    ingredientTypeId?: SortOrder
    ingredientId?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    build?: BuildOrderByWithRelationInput
    ingredientType?: IngredientTypeOrderByWithRelationInput
    ingredient?: IngredientOrderByWithRelationInput
  }

  export type TouchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TouchWhereInput | TouchWhereInput[]
    OR?: TouchWhereInput[]
    NOT?: TouchWhereInput | TouchWhereInput[]
    buildId?: StringFilter<"Touch"> | string
    order?: IntNullableFilter<"Touch"> | number | null
    amount?: FloatNullableFilter<"Touch"> | number | null
    unit?: StringNullableFilter<"Touch"> | string | null
    ingredientTypeId?: StringFilter<"Touch"> | string
    ingredientId?: StringNullableFilter<"Touch"> | string | null
    version?: IntNullableFilter<"Touch"> | number | null
    build?: XOR<BuildRelationFilter, BuildWhereInput>
    ingredientType?: XOR<IngredientTypeRelationFilter, IngredientTypeWhereInput>
    ingredient?: XOR<IngredientNullableRelationFilter, IngredientWhereInput> | null
  }, "id">

  export type TouchOrderByWithAggregationInput = {
    id?: SortOrder
    buildId?: SortOrder
    order?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    ingredientTypeId?: SortOrder
    ingredientId?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    _count?: TouchCountOrderByAggregateInput
    _avg?: TouchAvgOrderByAggregateInput
    _max?: TouchMaxOrderByAggregateInput
    _min?: TouchMinOrderByAggregateInput
    _sum?: TouchSumOrderByAggregateInput
  }

  export type TouchScalarWhereWithAggregatesInput = {
    AND?: TouchScalarWhereWithAggregatesInput | TouchScalarWhereWithAggregatesInput[]
    OR?: TouchScalarWhereWithAggregatesInput[]
    NOT?: TouchScalarWhereWithAggregatesInput | TouchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Touch"> | string
    buildId?: StringWithAggregatesFilter<"Touch"> | string
    order?: IntNullableWithAggregatesFilter<"Touch"> | number | null
    amount?: FloatNullableWithAggregatesFilter<"Touch"> | number | null
    unit?: StringNullableWithAggregatesFilter<"Touch"> | string | null
    ingredientTypeId?: StringWithAggregatesFilter<"Touch"> | string
    ingredientId?: StringNullableWithAggregatesFilter<"Touch"> | string | null
    version?: IntNullableWithAggregatesFilter<"Touch"> | number | null
  }

  export type ArchivedTouchWhereInput = {
    AND?: ArchivedTouchWhereInput | ArchivedTouchWhereInput[]
    OR?: ArchivedTouchWhereInput[]
    NOT?: ArchivedTouchWhereInput | ArchivedTouchWhereInput[]
    id?: StringFilter<"ArchivedTouch"> | string
    archivedBuildId?: StringFilter<"ArchivedTouch"> | string
    order?: IntNullableFilter<"ArchivedTouch"> | number | null
    amount?: FloatNullableFilter<"ArchivedTouch"> | number | null
    unit?: StringNullableFilter<"ArchivedTouch"> | string | null
    ingredientTypeId?: StringFilter<"ArchivedTouch"> | string
    ingredientId?: StringNullableFilter<"ArchivedTouch"> | string | null
    version?: IntNullableFilter<"ArchivedTouch"> | number | null
    archivedBuild?: XOR<ArchivedBuildRelationFilter, ArchivedBuildWhereInput>
    ingredientType?: XOR<IngredientTypeRelationFilter, IngredientTypeWhereInput>
    ingredient?: XOR<IngredientNullableRelationFilter, IngredientWhereInput> | null
  }

  export type ArchivedTouchOrderByWithRelationInput = {
    id?: SortOrder
    archivedBuildId?: SortOrder
    order?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    ingredientTypeId?: SortOrder
    ingredientId?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    archivedBuild?: ArchivedBuildOrderByWithRelationInput
    ingredientType?: IngredientTypeOrderByWithRelationInput
    ingredient?: IngredientOrderByWithRelationInput
  }

  export type ArchivedTouchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ArchivedTouchWhereInput | ArchivedTouchWhereInput[]
    OR?: ArchivedTouchWhereInput[]
    NOT?: ArchivedTouchWhereInput | ArchivedTouchWhereInput[]
    archivedBuildId?: StringFilter<"ArchivedTouch"> | string
    order?: IntNullableFilter<"ArchivedTouch"> | number | null
    amount?: FloatNullableFilter<"ArchivedTouch"> | number | null
    unit?: StringNullableFilter<"ArchivedTouch"> | string | null
    ingredientTypeId?: StringFilter<"ArchivedTouch"> | string
    ingredientId?: StringNullableFilter<"ArchivedTouch"> | string | null
    version?: IntNullableFilter<"ArchivedTouch"> | number | null
    archivedBuild?: XOR<ArchivedBuildRelationFilter, ArchivedBuildWhereInput>
    ingredientType?: XOR<IngredientTypeRelationFilter, IngredientTypeWhereInput>
    ingredient?: XOR<IngredientNullableRelationFilter, IngredientWhereInput> | null
  }, "id">

  export type ArchivedTouchOrderByWithAggregationInput = {
    id?: SortOrder
    archivedBuildId?: SortOrder
    order?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    ingredientTypeId?: SortOrder
    ingredientId?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    _count?: ArchivedTouchCountOrderByAggregateInput
    _avg?: ArchivedTouchAvgOrderByAggregateInput
    _max?: ArchivedTouchMaxOrderByAggregateInput
    _min?: ArchivedTouchMinOrderByAggregateInput
    _sum?: ArchivedTouchSumOrderByAggregateInput
  }

  export type ArchivedTouchScalarWhereWithAggregatesInput = {
    AND?: ArchivedTouchScalarWhereWithAggregatesInput | ArchivedTouchScalarWhereWithAggregatesInput[]
    OR?: ArchivedTouchScalarWhereWithAggregatesInput[]
    NOT?: ArchivedTouchScalarWhereWithAggregatesInput | ArchivedTouchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ArchivedTouch"> | string
    archivedBuildId?: StringWithAggregatesFilter<"ArchivedTouch"> | string
    order?: IntNullableWithAggregatesFilter<"ArchivedTouch"> | number | null
    amount?: FloatNullableWithAggregatesFilter<"ArchivedTouch"> | number | null
    unit?: StringNullableWithAggregatesFilter<"ArchivedTouch"> | string | null
    ingredientTypeId?: StringWithAggregatesFilter<"ArchivedTouch"> | string
    ingredientId?: StringNullableWithAggregatesFilter<"ArchivedTouch"> | string | null
    version?: IntNullableWithAggregatesFilter<"ArchivedTouch"> | number | null
  }

  export type IngredientTypeWhereInput = {
    AND?: IngredientTypeWhereInput | IngredientTypeWhereInput[]
    OR?: IngredientTypeWhereInput[]
    NOT?: IngredientTypeWhereInput | IngredientTypeWhereInput[]
    id?: StringFilter<"IngredientType"> | string
    name?: StringFilter<"IngredientType"> | string
    description?: StringNullableFilter<"IngredientType"> | string | null
    touch?: TouchListRelationFilter
    archivedTouch?: ArchivedTouchListRelationFilter
    ingredient?: IngredientListRelationFilter
    ingredientPreference?: IngredientPreferenceListRelationFilter
  }

  export type IngredientTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    touch?: TouchOrderByRelationAggregateInput
    archivedTouch?: ArchivedTouchOrderByRelationAggregateInput
    ingredient?: IngredientOrderByRelationAggregateInput
    ingredientPreference?: IngredientPreferenceOrderByRelationAggregateInput
  }

  export type IngredientTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IngredientTypeWhereInput | IngredientTypeWhereInput[]
    OR?: IngredientTypeWhereInput[]
    NOT?: IngredientTypeWhereInput | IngredientTypeWhereInput[]
    name?: StringFilter<"IngredientType"> | string
    description?: StringNullableFilter<"IngredientType"> | string | null
    touch?: TouchListRelationFilter
    archivedTouch?: ArchivedTouchListRelationFilter
    ingredient?: IngredientListRelationFilter
    ingredientPreference?: IngredientPreferenceListRelationFilter
  }, "id">

  export type IngredientTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: IngredientTypeCountOrderByAggregateInput
    _max?: IngredientTypeMaxOrderByAggregateInput
    _min?: IngredientTypeMinOrderByAggregateInput
  }

  export type IngredientTypeScalarWhereWithAggregatesInput = {
    AND?: IngredientTypeScalarWhereWithAggregatesInput | IngredientTypeScalarWhereWithAggregatesInput[]
    OR?: IngredientTypeScalarWhereWithAggregatesInput[]
    NOT?: IngredientTypeScalarWhereWithAggregatesInput | IngredientTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IngredientType"> | string
    name?: StringWithAggregatesFilter<"IngredientType"> | string
    description?: StringNullableWithAggregatesFilter<"IngredientType"> | string | null
  }

  export type IngredientWhereInput = {
    AND?: IngredientWhereInput | IngredientWhereInput[]
    OR?: IngredientWhereInput[]
    NOT?: IngredientWhereInput | IngredientWhereInput[]
    id?: StringFilter<"Ingredient"> | string
    dateCreated?: DateTimeFilter<"Ingredient"> | Date | string
    createdById?: StringNullableFilter<"Ingredient"> | string | null
    ingredientTypeId?: StringFilter<"Ingredient"> | string
    name?: StringFilter<"Ingredient"> | string
    description?: StringFilter<"Ingredient"> | string
    price?: FloatNullableFilter<"Ingredient"> | number | null
    amount?: FloatNullableFilter<"Ingredient"> | number | null
    unit?: StringNullableFilter<"Ingredient"> | string | null
    source?: StringNullableFilter<"Ingredient"> | string | null
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    ingredientType?: XOR<IngredientTypeRelationFilter, IngredientTypeWhereInput>
    touch?: TouchListRelationFilter
    archivedTouch?: ArchivedTouchListRelationFilter
    ingredientStorage?: IngredientStorageListRelationFilter
    ingredientUser?: IngredientUserListRelationFilter
    ingredientPreference?: IngredientPreferenceListRelationFilter
    crewIngredient?: CrewIngredientListRelationFilter
  }

  export type IngredientOrderByWithRelationInput = {
    id?: SortOrder
    dateCreated?: SortOrder
    createdById?: SortOrderInput | SortOrder
    ingredientTypeId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    createdBy?: UserOrderByWithRelationInput
    ingredientType?: IngredientTypeOrderByWithRelationInput
    touch?: TouchOrderByRelationAggregateInput
    archivedTouch?: ArchivedTouchOrderByRelationAggregateInput
    ingredientStorage?: IngredientStorageOrderByRelationAggregateInput
    ingredientUser?: IngredientUserOrderByRelationAggregateInput
    ingredientPreference?: IngredientPreferenceOrderByRelationAggregateInput
    crewIngredient?: CrewIngredientOrderByRelationAggregateInput
  }

  export type IngredientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IngredientWhereInput | IngredientWhereInput[]
    OR?: IngredientWhereInput[]
    NOT?: IngredientWhereInput | IngredientWhereInput[]
    dateCreated?: DateTimeFilter<"Ingredient"> | Date | string
    createdById?: StringNullableFilter<"Ingredient"> | string | null
    ingredientTypeId?: StringFilter<"Ingredient"> | string
    name?: StringFilter<"Ingredient"> | string
    description?: StringFilter<"Ingredient"> | string
    price?: FloatNullableFilter<"Ingredient"> | number | null
    amount?: FloatNullableFilter<"Ingredient"> | number | null
    unit?: StringNullableFilter<"Ingredient"> | string | null
    source?: StringNullableFilter<"Ingredient"> | string | null
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    ingredientType?: XOR<IngredientTypeRelationFilter, IngredientTypeWhereInput>
    touch?: TouchListRelationFilter
    archivedTouch?: ArchivedTouchListRelationFilter
    ingredientStorage?: IngredientStorageListRelationFilter
    ingredientUser?: IngredientUserListRelationFilter
    ingredientPreference?: IngredientPreferenceListRelationFilter
    crewIngredient?: CrewIngredientListRelationFilter
  }, "id">

  export type IngredientOrderByWithAggregationInput = {
    id?: SortOrder
    dateCreated?: SortOrder
    createdById?: SortOrderInput | SortOrder
    ingredientTypeId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    _count?: IngredientCountOrderByAggregateInput
    _avg?: IngredientAvgOrderByAggregateInput
    _max?: IngredientMaxOrderByAggregateInput
    _min?: IngredientMinOrderByAggregateInput
    _sum?: IngredientSumOrderByAggregateInput
  }

  export type IngredientScalarWhereWithAggregatesInput = {
    AND?: IngredientScalarWhereWithAggregatesInput | IngredientScalarWhereWithAggregatesInput[]
    OR?: IngredientScalarWhereWithAggregatesInput[]
    NOT?: IngredientScalarWhereWithAggregatesInput | IngredientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ingredient"> | string
    dateCreated?: DateTimeWithAggregatesFilter<"Ingredient"> | Date | string
    createdById?: StringNullableWithAggregatesFilter<"Ingredient"> | string | null
    ingredientTypeId?: StringWithAggregatesFilter<"Ingredient"> | string
    name?: StringWithAggregatesFilter<"Ingredient"> | string
    description?: StringWithAggregatesFilter<"Ingredient"> | string
    price?: FloatNullableWithAggregatesFilter<"Ingredient"> | number | null
    amount?: FloatNullableWithAggregatesFilter<"Ingredient"> | number | null
    unit?: StringNullableWithAggregatesFilter<"Ingredient"> | string | null
    source?: StringNullableWithAggregatesFilter<"Ingredient"> | string | null
  }

  export type IngredientUserWhereInput = {
    AND?: IngredientUserWhereInput | IngredientUserWhereInput[]
    OR?: IngredientUserWhereInput[]
    NOT?: IngredientUserWhereInput | IngredientUserWhereInput[]
    ingredientId?: StringFilter<"IngredientUser"> | string
    userId?: StringFilter<"IngredientUser"> | string
    permission?: StringFilter<"IngredientUser"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    ingredient?: XOR<IngredientRelationFilter, IngredientWhereInput>
  }

  export type IngredientUserOrderByWithRelationInput = {
    ingredientId?: SortOrder
    userId?: SortOrder
    permission?: SortOrder
    user?: UserOrderByWithRelationInput
    ingredient?: IngredientOrderByWithRelationInput
  }

  export type IngredientUserWhereUniqueInput = Prisma.AtLeast<{
    ingredientId_userId?: IngredientUserIngredientIdUserIdCompoundUniqueInput
    AND?: IngredientUserWhereInput | IngredientUserWhereInput[]
    OR?: IngredientUserWhereInput[]
    NOT?: IngredientUserWhereInput | IngredientUserWhereInput[]
    ingredientId?: StringFilter<"IngredientUser"> | string
    userId?: StringFilter<"IngredientUser"> | string
    permission?: StringFilter<"IngredientUser"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    ingredient?: XOR<IngredientRelationFilter, IngredientWhereInput>
  }, "ingredientId_userId">

  export type IngredientUserOrderByWithAggregationInput = {
    ingredientId?: SortOrder
    userId?: SortOrder
    permission?: SortOrder
    _count?: IngredientUserCountOrderByAggregateInput
    _max?: IngredientUserMaxOrderByAggregateInput
    _min?: IngredientUserMinOrderByAggregateInput
  }

  export type IngredientUserScalarWhereWithAggregatesInput = {
    AND?: IngredientUserScalarWhereWithAggregatesInput | IngredientUserScalarWhereWithAggregatesInput[]
    OR?: IngredientUserScalarWhereWithAggregatesInput[]
    NOT?: IngredientUserScalarWhereWithAggregatesInput | IngredientUserScalarWhereWithAggregatesInput[]
    ingredientId?: StringWithAggregatesFilter<"IngredientUser"> | string
    userId?: StringWithAggregatesFilter<"IngredientUser"> | string
    permission?: StringWithAggregatesFilter<"IngredientUser"> | string
  }

  export type IngredientPreferenceWhereInput = {
    AND?: IngredientPreferenceWhereInput | IngredientPreferenceWhereInput[]
    OR?: IngredientPreferenceWhereInput[]
    NOT?: IngredientPreferenceWhereInput | IngredientPreferenceWhereInput[]
    ingredientTypeId?: StringFilter<"IngredientPreference"> | string
    ingredientId?: StringFilter<"IngredientPreference"> | string
    userId?: StringFilter<"IngredientPreference"> | string
    ingredientType?: XOR<IngredientTypeRelationFilter, IngredientTypeWhereInput>
    ingredient?: XOR<IngredientRelationFilter, IngredientWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type IngredientPreferenceOrderByWithRelationInput = {
    ingredientTypeId?: SortOrder
    ingredientId?: SortOrder
    userId?: SortOrder
    ingredientType?: IngredientTypeOrderByWithRelationInput
    ingredient?: IngredientOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type IngredientPreferenceWhereUniqueInput = Prisma.AtLeast<{
    ingredientTypeId_ingredientId?: IngredientPreferenceIngredientTypeIdIngredientIdCompoundUniqueInput
    AND?: IngredientPreferenceWhereInput | IngredientPreferenceWhereInput[]
    OR?: IngredientPreferenceWhereInput[]
    NOT?: IngredientPreferenceWhereInput | IngredientPreferenceWhereInput[]
    ingredientTypeId?: StringFilter<"IngredientPreference"> | string
    ingredientId?: StringFilter<"IngredientPreference"> | string
    userId?: StringFilter<"IngredientPreference"> | string
    ingredientType?: XOR<IngredientTypeRelationFilter, IngredientTypeWhereInput>
    ingredient?: XOR<IngredientRelationFilter, IngredientWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "ingredientTypeId_ingredientId">

  export type IngredientPreferenceOrderByWithAggregationInput = {
    ingredientTypeId?: SortOrder
    ingredientId?: SortOrder
    userId?: SortOrder
    _count?: IngredientPreferenceCountOrderByAggregateInput
    _max?: IngredientPreferenceMaxOrderByAggregateInput
    _min?: IngredientPreferenceMinOrderByAggregateInput
  }

  export type IngredientPreferenceScalarWhereWithAggregatesInput = {
    AND?: IngredientPreferenceScalarWhereWithAggregatesInput | IngredientPreferenceScalarWhereWithAggregatesInput[]
    OR?: IngredientPreferenceScalarWhereWithAggregatesInput[]
    NOT?: IngredientPreferenceScalarWhereWithAggregatesInput | IngredientPreferenceScalarWhereWithAggregatesInput[]
    ingredientTypeId?: StringWithAggregatesFilter<"IngredientPreference"> | string
    ingredientId?: StringWithAggregatesFilter<"IngredientPreference"> | string
    userId?: StringWithAggregatesFilter<"IngredientPreference"> | string
  }

  export type InventoryWhereInput = {
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    id?: StringFilter<"Inventory"> | string
    name?: StringFilter<"Inventory"> | string
    description?: StringFilter<"Inventory"> | string
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    editedAt?: DateTimeFilter<"Inventory"> | Date | string
    createdById?: StringFilter<"Inventory"> | string
    editedById?: StringFilter<"Inventory"> | string
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    editedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    inventoryStorage?: InventoryStorageListRelationFilter
    inventoryUser?: InventoryUserListRelationFilter
    crewInventory?: CrewInventoryListRelationFilter
  }

  export type InventoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    editedBy?: UserOrderByWithRelationInput
    inventoryStorage?: InventoryStorageOrderByRelationAggregateInput
    inventoryUser?: InventoryUserOrderByRelationAggregateInput
    crewInventory?: CrewInventoryOrderByRelationAggregateInput
  }

  export type InventoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    name?: StringFilter<"Inventory"> | string
    description?: StringFilter<"Inventory"> | string
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    editedAt?: DateTimeFilter<"Inventory"> | Date | string
    createdById?: StringFilter<"Inventory"> | string
    editedById?: StringFilter<"Inventory"> | string
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    editedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    inventoryStorage?: InventoryStorageListRelationFilter
    inventoryUser?: InventoryUserListRelationFilter
    crewInventory?: CrewInventoryListRelationFilter
  }, "id">

  export type InventoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    _count?: InventoryCountOrderByAggregateInput
    _max?: InventoryMaxOrderByAggregateInput
    _min?: InventoryMinOrderByAggregateInput
  }

  export type InventoryScalarWhereWithAggregatesInput = {
    AND?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    OR?: InventoryScalarWhereWithAggregatesInput[]
    NOT?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Inventory"> | string
    name?: StringWithAggregatesFilter<"Inventory"> | string
    description?: StringWithAggregatesFilter<"Inventory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string
    editedAt?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string
    createdById?: StringWithAggregatesFilter<"Inventory"> | string
    editedById?: StringWithAggregatesFilter<"Inventory"> | string
  }

  export type InventoryUserWhereInput = {
    AND?: InventoryUserWhereInput | InventoryUserWhereInput[]
    OR?: InventoryUserWhereInput[]
    NOT?: InventoryUserWhereInput | InventoryUserWhereInput[]
    userId?: StringFilter<"InventoryUser"> | string
    inventoryId?: StringFilter<"InventoryUser"> | string
    permission?: StringFilter<"InventoryUser"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    inventory?: XOR<InventoryRelationFilter, InventoryWhereInput>
  }

  export type InventoryUserOrderByWithRelationInput = {
    userId?: SortOrder
    inventoryId?: SortOrder
    permission?: SortOrder
    user?: UserOrderByWithRelationInput
    inventory?: InventoryOrderByWithRelationInput
  }

  export type InventoryUserWhereUniqueInput = Prisma.AtLeast<{
    userId_inventoryId?: InventoryUserUserIdInventoryIdCompoundUniqueInput
    AND?: InventoryUserWhereInput | InventoryUserWhereInput[]
    OR?: InventoryUserWhereInput[]
    NOT?: InventoryUserWhereInput | InventoryUserWhereInput[]
    userId?: StringFilter<"InventoryUser"> | string
    inventoryId?: StringFilter<"InventoryUser"> | string
    permission?: StringFilter<"InventoryUser"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    inventory?: XOR<InventoryRelationFilter, InventoryWhereInput>
  }, "userId_inventoryId">

  export type InventoryUserOrderByWithAggregationInput = {
    userId?: SortOrder
    inventoryId?: SortOrder
    permission?: SortOrder
    _count?: InventoryUserCountOrderByAggregateInput
    _max?: InventoryUserMaxOrderByAggregateInput
    _min?: InventoryUserMinOrderByAggregateInput
  }

  export type InventoryUserScalarWhereWithAggregatesInput = {
    AND?: InventoryUserScalarWhereWithAggregatesInput | InventoryUserScalarWhereWithAggregatesInput[]
    OR?: InventoryUserScalarWhereWithAggregatesInput[]
    NOT?: InventoryUserScalarWhereWithAggregatesInput | InventoryUserScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"InventoryUser"> | string
    inventoryId?: StringWithAggregatesFilter<"InventoryUser"> | string
    permission?: StringWithAggregatesFilter<"InventoryUser"> | string
  }

  export type StorageWhereInput = {
    AND?: StorageWhereInput | StorageWhereInput[]
    OR?: StorageWhereInput[]
    NOT?: StorageWhereInput | StorageWhereInput[]
    id?: StringFilter<"Storage"> | string
    name?: StringFilter<"Storage"> | string
    description?: StringFilter<"Storage"> | string
    createdAt?: DateTimeFilter<"Storage"> | Date | string
    editedAt?: DateTimeFilter<"Storage"> | Date | string
    createdById?: StringFilter<"Storage"> | string
    editedById?: StringFilter<"Storage"> | string
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    editedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    inventoryStorage?: InventoryStorageListRelationFilter
    ingredientStorage?: IngredientStorageListRelationFilter
    storageUser?: StorageUserListRelationFilter
    crewStorage?: CrewStorageListRelationFilter
  }

  export type StorageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    editedBy?: UserOrderByWithRelationInput
    inventoryStorage?: InventoryStorageOrderByRelationAggregateInput
    ingredientStorage?: IngredientStorageOrderByRelationAggregateInput
    storageUser?: StorageUserOrderByRelationAggregateInput
    crewStorage?: CrewStorageOrderByRelationAggregateInput
  }

  export type StorageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StorageWhereInput | StorageWhereInput[]
    OR?: StorageWhereInput[]
    NOT?: StorageWhereInput | StorageWhereInput[]
    name?: StringFilter<"Storage"> | string
    description?: StringFilter<"Storage"> | string
    createdAt?: DateTimeFilter<"Storage"> | Date | string
    editedAt?: DateTimeFilter<"Storage"> | Date | string
    createdById?: StringFilter<"Storage"> | string
    editedById?: StringFilter<"Storage"> | string
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    editedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    inventoryStorage?: InventoryStorageListRelationFilter
    ingredientStorage?: IngredientStorageListRelationFilter
    storageUser?: StorageUserListRelationFilter
    crewStorage?: CrewStorageListRelationFilter
  }, "id">

  export type StorageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    _count?: StorageCountOrderByAggregateInput
    _max?: StorageMaxOrderByAggregateInput
    _min?: StorageMinOrderByAggregateInput
  }

  export type StorageScalarWhereWithAggregatesInput = {
    AND?: StorageScalarWhereWithAggregatesInput | StorageScalarWhereWithAggregatesInput[]
    OR?: StorageScalarWhereWithAggregatesInput[]
    NOT?: StorageScalarWhereWithAggregatesInput | StorageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Storage"> | string
    name?: StringWithAggregatesFilter<"Storage"> | string
    description?: StringWithAggregatesFilter<"Storage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Storage"> | Date | string
    editedAt?: DateTimeWithAggregatesFilter<"Storage"> | Date | string
    createdById?: StringWithAggregatesFilter<"Storage"> | string
    editedById?: StringWithAggregatesFilter<"Storage"> | string
  }

  export type InventoryStorageWhereInput = {
    AND?: InventoryStorageWhereInput | InventoryStorageWhereInput[]
    OR?: InventoryStorageWhereInput[]
    NOT?: InventoryStorageWhereInput | InventoryStorageWhereInput[]
    inventoryId?: StringFilter<"InventoryStorage"> | string
    storageId?: StringFilter<"InventoryStorage"> | string
    storage?: XOR<StorageRelationFilter, StorageWhereInput>
    inventory?: XOR<InventoryRelationFilter, InventoryWhereInput>
  }

  export type InventoryStorageOrderByWithRelationInput = {
    inventoryId?: SortOrder
    storageId?: SortOrder
    storage?: StorageOrderByWithRelationInput
    inventory?: InventoryOrderByWithRelationInput
  }

  export type InventoryStorageWhereUniqueInput = Prisma.AtLeast<{
    inventoryId_storageId?: InventoryStorageInventoryIdStorageIdCompoundUniqueInput
    AND?: InventoryStorageWhereInput | InventoryStorageWhereInput[]
    OR?: InventoryStorageWhereInput[]
    NOT?: InventoryStorageWhereInput | InventoryStorageWhereInput[]
    inventoryId?: StringFilter<"InventoryStorage"> | string
    storageId?: StringFilter<"InventoryStorage"> | string
    storage?: XOR<StorageRelationFilter, StorageWhereInput>
    inventory?: XOR<InventoryRelationFilter, InventoryWhereInput>
  }, "inventoryId_storageId">

  export type InventoryStorageOrderByWithAggregationInput = {
    inventoryId?: SortOrder
    storageId?: SortOrder
    _count?: InventoryStorageCountOrderByAggregateInput
    _max?: InventoryStorageMaxOrderByAggregateInput
    _min?: InventoryStorageMinOrderByAggregateInput
  }

  export type InventoryStorageScalarWhereWithAggregatesInput = {
    AND?: InventoryStorageScalarWhereWithAggregatesInput | InventoryStorageScalarWhereWithAggregatesInput[]
    OR?: InventoryStorageScalarWhereWithAggregatesInput[]
    NOT?: InventoryStorageScalarWhereWithAggregatesInput | InventoryStorageScalarWhereWithAggregatesInput[]
    inventoryId?: StringWithAggregatesFilter<"InventoryStorage"> | string
    storageId?: StringWithAggregatesFilter<"InventoryStorage"> | string
  }

  export type IngredientStorageWhereInput = {
    AND?: IngredientStorageWhereInput | IngredientStorageWhereInput[]
    OR?: IngredientStorageWhereInput[]
    NOT?: IngredientStorageWhereInput | IngredientStorageWhereInput[]
    ingredientId?: StringFilter<"IngredientStorage"> | string
    storageId?: StringFilter<"IngredientStorage"> | string
    quantity?: FloatNullableFilter<"IngredientStorage"> | number | null
    ingredient?: XOR<IngredientRelationFilter, IngredientWhereInput>
    Storage?: XOR<StorageRelationFilter, StorageWhereInput>
  }

  export type IngredientStorageOrderByWithRelationInput = {
    ingredientId?: SortOrder
    storageId?: SortOrder
    quantity?: SortOrderInput | SortOrder
    ingredient?: IngredientOrderByWithRelationInput
    Storage?: StorageOrderByWithRelationInput
  }

  export type IngredientStorageWhereUniqueInput = Prisma.AtLeast<{
    ingredientId_storageId?: IngredientStorageIngredientIdStorageIdCompoundUniqueInput
    AND?: IngredientStorageWhereInput | IngredientStorageWhereInput[]
    OR?: IngredientStorageWhereInput[]
    NOT?: IngredientStorageWhereInput | IngredientStorageWhereInput[]
    ingredientId?: StringFilter<"IngredientStorage"> | string
    storageId?: StringFilter<"IngredientStorage"> | string
    quantity?: FloatNullableFilter<"IngredientStorage"> | number | null
    ingredient?: XOR<IngredientRelationFilter, IngredientWhereInput>
    Storage?: XOR<StorageRelationFilter, StorageWhereInput>
  }, "ingredientId_storageId">

  export type IngredientStorageOrderByWithAggregationInput = {
    ingredientId?: SortOrder
    storageId?: SortOrder
    quantity?: SortOrderInput | SortOrder
    _count?: IngredientStorageCountOrderByAggregateInput
    _avg?: IngredientStorageAvgOrderByAggregateInput
    _max?: IngredientStorageMaxOrderByAggregateInput
    _min?: IngredientStorageMinOrderByAggregateInput
    _sum?: IngredientStorageSumOrderByAggregateInput
  }

  export type IngredientStorageScalarWhereWithAggregatesInput = {
    AND?: IngredientStorageScalarWhereWithAggregatesInput | IngredientStorageScalarWhereWithAggregatesInput[]
    OR?: IngredientStorageScalarWhereWithAggregatesInput[]
    NOT?: IngredientStorageScalarWhereWithAggregatesInput | IngredientStorageScalarWhereWithAggregatesInput[]
    ingredientId?: StringWithAggregatesFilter<"IngredientStorage"> | string
    storageId?: StringWithAggregatesFilter<"IngredientStorage"> | string
    quantity?: FloatNullableWithAggregatesFilter<"IngredientStorage"> | number | null
  }

  export type StorageUserWhereInput = {
    AND?: StorageUserWhereInput | StorageUserWhereInput[]
    OR?: StorageUserWhereInput[]
    NOT?: StorageUserWhereInput | StorageUserWhereInput[]
    userId?: StringFilter<"StorageUser"> | string
    storageId?: StringFilter<"StorageUser"> | string
    permission?: StringFilter<"StorageUser"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    Storage?: XOR<StorageRelationFilter, StorageWhereInput>
  }

  export type StorageUserOrderByWithRelationInput = {
    userId?: SortOrder
    storageId?: SortOrder
    permission?: SortOrder
    user?: UserOrderByWithRelationInput
    Storage?: StorageOrderByWithRelationInput
  }

  export type StorageUserWhereUniqueInput = Prisma.AtLeast<{
    userId_storageId?: StorageUserUserIdStorageIdCompoundUniqueInput
    AND?: StorageUserWhereInput | StorageUserWhereInput[]
    OR?: StorageUserWhereInput[]
    NOT?: StorageUserWhereInput | StorageUserWhereInput[]
    userId?: StringFilter<"StorageUser"> | string
    storageId?: StringFilter<"StorageUser"> | string
    permission?: StringFilter<"StorageUser"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    Storage?: XOR<StorageRelationFilter, StorageWhereInput>
  }, "userId_storageId">

  export type StorageUserOrderByWithAggregationInput = {
    userId?: SortOrder
    storageId?: SortOrder
    permission?: SortOrder
    _count?: StorageUserCountOrderByAggregateInput
    _max?: StorageUserMaxOrderByAggregateInput
    _min?: StorageUserMinOrderByAggregateInput
  }

  export type StorageUserScalarWhereWithAggregatesInput = {
    AND?: StorageUserScalarWhereWithAggregatesInput | StorageUserScalarWhereWithAggregatesInput[]
    OR?: StorageUserScalarWhereWithAggregatesInput[]
    NOT?: StorageUserScalarWhereWithAggregatesInput | StorageUserScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"StorageUser"> | string
    storageId?: StringWithAggregatesFilter<"StorageUser"> | string
    permission?: StringWithAggregatesFilter<"StorageUser"> | string
  }

  export type CrewWhereInput = {
    AND?: CrewWhereInput | CrewWhereInput[]
    OR?: CrewWhereInput[]
    NOT?: CrewWhereInput | CrewWhereInput[]
    id?: StringFilter<"Crew"> | string
    name?: StringFilter<"Crew"> | string
    description?: StringFilter<"Crew"> | string
    createdAt?: DateTimeFilter<"Crew"> | Date | string
    editedAt?: DateTimeFilter<"Crew"> | Date | string
    createdById?: StringFilter<"Crew"> | string
    editedById?: StringFilter<"Crew"> | string
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    editedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    crewUser?: CrewUserListRelationFilter
    crewInventory?: CrewInventoryListRelationFilter
    crewStorage?: CrewStorageListRelationFilter
    crewIngredient?: CrewIngredientListRelationFilter
    crewRecipeBook?: CrewRecipeBookListRelationFilter
    crewBuild?: CrewBuildListRelationFilter
  }

  export type CrewOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    editedBy?: UserOrderByWithRelationInput
    crewUser?: CrewUserOrderByRelationAggregateInput
    crewInventory?: CrewInventoryOrderByRelationAggregateInput
    crewStorage?: CrewStorageOrderByRelationAggregateInput
    crewIngredient?: CrewIngredientOrderByRelationAggregateInput
    crewRecipeBook?: CrewRecipeBookOrderByRelationAggregateInput
    crewBuild?: CrewBuildOrderByRelationAggregateInput
  }

  export type CrewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CrewWhereInput | CrewWhereInput[]
    OR?: CrewWhereInput[]
    NOT?: CrewWhereInput | CrewWhereInput[]
    name?: StringFilter<"Crew"> | string
    description?: StringFilter<"Crew"> | string
    createdAt?: DateTimeFilter<"Crew"> | Date | string
    editedAt?: DateTimeFilter<"Crew"> | Date | string
    createdById?: StringFilter<"Crew"> | string
    editedById?: StringFilter<"Crew"> | string
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    editedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    crewUser?: CrewUserListRelationFilter
    crewInventory?: CrewInventoryListRelationFilter
    crewStorage?: CrewStorageListRelationFilter
    crewIngredient?: CrewIngredientListRelationFilter
    crewRecipeBook?: CrewRecipeBookListRelationFilter
    crewBuild?: CrewBuildListRelationFilter
  }, "id">

  export type CrewOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    _count?: CrewCountOrderByAggregateInput
    _max?: CrewMaxOrderByAggregateInput
    _min?: CrewMinOrderByAggregateInput
  }

  export type CrewScalarWhereWithAggregatesInput = {
    AND?: CrewScalarWhereWithAggregatesInput | CrewScalarWhereWithAggregatesInput[]
    OR?: CrewScalarWhereWithAggregatesInput[]
    NOT?: CrewScalarWhereWithAggregatesInput | CrewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Crew"> | string
    name?: StringWithAggregatesFilter<"Crew"> | string
    description?: StringWithAggregatesFilter<"Crew"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Crew"> | Date | string
    editedAt?: DateTimeWithAggregatesFilter<"Crew"> | Date | string
    createdById?: StringWithAggregatesFilter<"Crew"> | string
    editedById?: StringWithAggregatesFilter<"Crew"> | string
  }

  export type CrewUserWhereInput = {
    AND?: CrewUserWhereInput | CrewUserWhereInput[]
    OR?: CrewUserWhereInput[]
    NOT?: CrewUserWhereInput | CrewUserWhereInput[]
    userId?: StringFilter<"CrewUser"> | string
    crewId?: StringFilter<"CrewUser"> | string
    permission?: StringFilter<"CrewUser"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    crew?: XOR<CrewRelationFilter, CrewWhereInput>
  }

  export type CrewUserOrderByWithRelationInput = {
    userId?: SortOrder
    crewId?: SortOrder
    permission?: SortOrder
    user?: UserOrderByWithRelationInput
    crew?: CrewOrderByWithRelationInput
  }

  export type CrewUserWhereUniqueInput = Prisma.AtLeast<{
    userId_crewId?: CrewUserUserIdCrewIdCompoundUniqueInput
    AND?: CrewUserWhereInput | CrewUserWhereInput[]
    OR?: CrewUserWhereInput[]
    NOT?: CrewUserWhereInput | CrewUserWhereInput[]
    userId?: StringFilter<"CrewUser"> | string
    crewId?: StringFilter<"CrewUser"> | string
    permission?: StringFilter<"CrewUser"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    crew?: XOR<CrewRelationFilter, CrewWhereInput>
  }, "userId_crewId">

  export type CrewUserOrderByWithAggregationInput = {
    userId?: SortOrder
    crewId?: SortOrder
    permission?: SortOrder
    _count?: CrewUserCountOrderByAggregateInput
    _max?: CrewUserMaxOrderByAggregateInput
    _min?: CrewUserMinOrderByAggregateInput
  }

  export type CrewUserScalarWhereWithAggregatesInput = {
    AND?: CrewUserScalarWhereWithAggregatesInput | CrewUserScalarWhereWithAggregatesInput[]
    OR?: CrewUserScalarWhereWithAggregatesInput[]
    NOT?: CrewUserScalarWhereWithAggregatesInput | CrewUserScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"CrewUser"> | string
    crewId?: StringWithAggregatesFilter<"CrewUser"> | string
    permission?: StringWithAggregatesFilter<"CrewUser"> | string
  }

  export type CrewInventoryWhereInput = {
    AND?: CrewInventoryWhereInput | CrewInventoryWhereInput[]
    OR?: CrewInventoryWhereInput[]
    NOT?: CrewInventoryWhereInput | CrewInventoryWhereInput[]
    inventoryId?: StringFilter<"CrewInventory"> | string
    crewId?: StringFilter<"CrewInventory"> | string
    inventory?: XOR<InventoryRelationFilter, InventoryWhereInput>
    crew?: XOR<CrewRelationFilter, CrewWhereInput>
  }

  export type CrewInventoryOrderByWithRelationInput = {
    inventoryId?: SortOrder
    crewId?: SortOrder
    inventory?: InventoryOrderByWithRelationInput
    crew?: CrewOrderByWithRelationInput
  }

  export type CrewInventoryWhereUniqueInput = Prisma.AtLeast<{
    inventoryId_crewId?: CrewInventoryInventoryIdCrewIdCompoundUniqueInput
    AND?: CrewInventoryWhereInput | CrewInventoryWhereInput[]
    OR?: CrewInventoryWhereInput[]
    NOT?: CrewInventoryWhereInput | CrewInventoryWhereInput[]
    inventoryId?: StringFilter<"CrewInventory"> | string
    crewId?: StringFilter<"CrewInventory"> | string
    inventory?: XOR<InventoryRelationFilter, InventoryWhereInput>
    crew?: XOR<CrewRelationFilter, CrewWhereInput>
  }, "inventoryId_crewId">

  export type CrewInventoryOrderByWithAggregationInput = {
    inventoryId?: SortOrder
    crewId?: SortOrder
    _count?: CrewInventoryCountOrderByAggregateInput
    _max?: CrewInventoryMaxOrderByAggregateInput
    _min?: CrewInventoryMinOrderByAggregateInput
  }

  export type CrewInventoryScalarWhereWithAggregatesInput = {
    AND?: CrewInventoryScalarWhereWithAggregatesInput | CrewInventoryScalarWhereWithAggregatesInput[]
    OR?: CrewInventoryScalarWhereWithAggregatesInput[]
    NOT?: CrewInventoryScalarWhereWithAggregatesInput | CrewInventoryScalarWhereWithAggregatesInput[]
    inventoryId?: StringWithAggregatesFilter<"CrewInventory"> | string
    crewId?: StringWithAggregatesFilter<"CrewInventory"> | string
  }

  export type CrewStorageWhereInput = {
    AND?: CrewStorageWhereInput | CrewStorageWhereInput[]
    OR?: CrewStorageWhereInput[]
    NOT?: CrewStorageWhereInput | CrewStorageWhereInput[]
    storageId?: StringFilter<"CrewStorage"> | string
    crewId?: StringFilter<"CrewStorage"> | string
    storage?: XOR<StorageRelationFilter, StorageWhereInput>
    crew?: XOR<CrewRelationFilter, CrewWhereInput>
  }

  export type CrewStorageOrderByWithRelationInput = {
    storageId?: SortOrder
    crewId?: SortOrder
    storage?: StorageOrderByWithRelationInput
    crew?: CrewOrderByWithRelationInput
  }

  export type CrewStorageWhereUniqueInput = Prisma.AtLeast<{
    storageId_crewId?: CrewStorageStorageIdCrewIdCompoundUniqueInput
    AND?: CrewStorageWhereInput | CrewStorageWhereInput[]
    OR?: CrewStorageWhereInput[]
    NOT?: CrewStorageWhereInput | CrewStorageWhereInput[]
    storageId?: StringFilter<"CrewStorage"> | string
    crewId?: StringFilter<"CrewStorage"> | string
    storage?: XOR<StorageRelationFilter, StorageWhereInput>
    crew?: XOR<CrewRelationFilter, CrewWhereInput>
  }, "storageId_crewId">

  export type CrewStorageOrderByWithAggregationInput = {
    storageId?: SortOrder
    crewId?: SortOrder
    _count?: CrewStorageCountOrderByAggregateInput
    _max?: CrewStorageMaxOrderByAggregateInput
    _min?: CrewStorageMinOrderByAggregateInput
  }

  export type CrewStorageScalarWhereWithAggregatesInput = {
    AND?: CrewStorageScalarWhereWithAggregatesInput | CrewStorageScalarWhereWithAggregatesInput[]
    OR?: CrewStorageScalarWhereWithAggregatesInput[]
    NOT?: CrewStorageScalarWhereWithAggregatesInput | CrewStorageScalarWhereWithAggregatesInput[]
    storageId?: StringWithAggregatesFilter<"CrewStorage"> | string
    crewId?: StringWithAggregatesFilter<"CrewStorage"> | string
  }

  export type CrewIngredientWhereInput = {
    AND?: CrewIngredientWhereInput | CrewIngredientWhereInput[]
    OR?: CrewIngredientWhereInput[]
    NOT?: CrewIngredientWhereInput | CrewIngredientWhereInput[]
    ingredientId?: StringFilter<"CrewIngredient"> | string
    crewId?: StringFilter<"CrewIngredient"> | string
    ingredient?: XOR<IngredientRelationFilter, IngredientWhereInput>
    crew?: XOR<CrewRelationFilter, CrewWhereInput>
  }

  export type CrewIngredientOrderByWithRelationInput = {
    ingredientId?: SortOrder
    crewId?: SortOrder
    ingredient?: IngredientOrderByWithRelationInput
    crew?: CrewOrderByWithRelationInput
  }

  export type CrewIngredientWhereUniqueInput = Prisma.AtLeast<{
    ingredientId_crewId?: CrewIngredientIngredientIdCrewIdCompoundUniqueInput
    AND?: CrewIngredientWhereInput | CrewIngredientWhereInput[]
    OR?: CrewIngredientWhereInput[]
    NOT?: CrewIngredientWhereInput | CrewIngredientWhereInput[]
    ingredientId?: StringFilter<"CrewIngredient"> | string
    crewId?: StringFilter<"CrewIngredient"> | string
    ingredient?: XOR<IngredientRelationFilter, IngredientWhereInput>
    crew?: XOR<CrewRelationFilter, CrewWhereInput>
  }, "ingredientId_crewId">

  export type CrewIngredientOrderByWithAggregationInput = {
    ingredientId?: SortOrder
    crewId?: SortOrder
    _count?: CrewIngredientCountOrderByAggregateInput
    _max?: CrewIngredientMaxOrderByAggregateInput
    _min?: CrewIngredientMinOrderByAggregateInput
  }

  export type CrewIngredientScalarWhereWithAggregatesInput = {
    AND?: CrewIngredientScalarWhereWithAggregatesInput | CrewIngredientScalarWhereWithAggregatesInput[]
    OR?: CrewIngredientScalarWhereWithAggregatesInput[]
    NOT?: CrewIngredientScalarWhereWithAggregatesInput | CrewIngredientScalarWhereWithAggregatesInput[]
    ingredientId?: StringWithAggregatesFilter<"CrewIngredient"> | string
    crewId?: StringWithAggregatesFilter<"CrewIngredient"> | string
  }

  export type CrewRecipeBookWhereInput = {
    AND?: CrewRecipeBookWhereInput | CrewRecipeBookWhereInput[]
    OR?: CrewRecipeBookWhereInput[]
    NOT?: CrewRecipeBookWhereInput | CrewRecipeBookWhereInput[]
    recipeBookId?: StringFilter<"CrewRecipeBook"> | string
    crewId?: StringFilter<"CrewRecipeBook"> | string
    recipeBook?: XOR<RecipeBookRelationFilter, RecipeBookWhereInput>
    crew?: XOR<CrewRelationFilter, CrewWhereInput>
  }

  export type CrewRecipeBookOrderByWithRelationInput = {
    recipeBookId?: SortOrder
    crewId?: SortOrder
    recipeBook?: RecipeBookOrderByWithRelationInput
    crew?: CrewOrderByWithRelationInput
  }

  export type CrewRecipeBookWhereUniqueInput = Prisma.AtLeast<{
    recipeBookId_crewId?: CrewRecipeBookRecipeBookIdCrewIdCompoundUniqueInput
    AND?: CrewRecipeBookWhereInput | CrewRecipeBookWhereInput[]
    OR?: CrewRecipeBookWhereInput[]
    NOT?: CrewRecipeBookWhereInput | CrewRecipeBookWhereInput[]
    recipeBookId?: StringFilter<"CrewRecipeBook"> | string
    crewId?: StringFilter<"CrewRecipeBook"> | string
    recipeBook?: XOR<RecipeBookRelationFilter, RecipeBookWhereInput>
    crew?: XOR<CrewRelationFilter, CrewWhereInput>
  }, "recipeBookId_crewId">

  export type CrewRecipeBookOrderByWithAggregationInput = {
    recipeBookId?: SortOrder
    crewId?: SortOrder
    _count?: CrewRecipeBookCountOrderByAggregateInput
    _max?: CrewRecipeBookMaxOrderByAggregateInput
    _min?: CrewRecipeBookMinOrderByAggregateInput
  }

  export type CrewRecipeBookScalarWhereWithAggregatesInput = {
    AND?: CrewRecipeBookScalarWhereWithAggregatesInput | CrewRecipeBookScalarWhereWithAggregatesInput[]
    OR?: CrewRecipeBookScalarWhereWithAggregatesInput[]
    NOT?: CrewRecipeBookScalarWhereWithAggregatesInput | CrewRecipeBookScalarWhereWithAggregatesInput[]
    recipeBookId?: StringWithAggregatesFilter<"CrewRecipeBook"> | string
    crewId?: StringWithAggregatesFilter<"CrewRecipeBook"> | string
  }

  export type CrewBuildWhereInput = {
    AND?: CrewBuildWhereInput | CrewBuildWhereInput[]
    OR?: CrewBuildWhereInput[]
    NOT?: CrewBuildWhereInput | CrewBuildWhereInput[]
    buildId?: StringFilter<"CrewBuild"> | string
    crewId?: StringFilter<"CrewBuild"> | string
    build?: XOR<BuildRelationFilter, BuildWhereInput>
    crew?: XOR<CrewRelationFilter, CrewWhereInput>
  }

  export type CrewBuildOrderByWithRelationInput = {
    buildId?: SortOrder
    crewId?: SortOrder
    build?: BuildOrderByWithRelationInput
    crew?: CrewOrderByWithRelationInput
  }

  export type CrewBuildWhereUniqueInput = Prisma.AtLeast<{
    buildId_crewId?: CrewBuildBuildIdCrewIdCompoundUniqueInput
    AND?: CrewBuildWhereInput | CrewBuildWhereInput[]
    OR?: CrewBuildWhereInput[]
    NOT?: CrewBuildWhereInput | CrewBuildWhereInput[]
    buildId?: StringFilter<"CrewBuild"> | string
    crewId?: StringFilter<"CrewBuild"> | string
    build?: XOR<BuildRelationFilter, BuildWhereInput>
    crew?: XOR<CrewRelationFilter, CrewWhereInput>
  }, "buildId_crewId">

  export type CrewBuildOrderByWithAggregationInput = {
    buildId?: SortOrder
    crewId?: SortOrder
    _count?: CrewBuildCountOrderByAggregateInput
    _max?: CrewBuildMaxOrderByAggregateInput
    _min?: CrewBuildMinOrderByAggregateInput
  }

  export type CrewBuildScalarWhereWithAggregatesInput = {
    AND?: CrewBuildScalarWhereWithAggregatesInput | CrewBuildScalarWhereWithAggregatesInput[]
    OR?: CrewBuildScalarWhereWithAggregatesInput[]
    NOT?: CrewBuildScalarWhereWithAggregatesInput | CrewBuildScalarWhereWithAggregatesInput[]
    buildId?: StringWithAggregatesFilter<"CrewBuild"> | string
    crewId?: StringWithAggregatesFilter<"CrewBuild"> | string
  }

  export type UserCreateInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type FollowCreateInput = {
    relationship: string
    followedBy: UserCreateNestedOneWithoutFollowedByInput
    following: UserCreateNestedOneWithoutFollowingInput
  }

  export type FollowUncheckedCreateInput = {
    followedById: string
    followingId: string
    relationship: string
  }

  export type FollowUpdateInput = {
    relationship?: StringFieldUpdateOperationsInput | string
    followedBy?: UserUpdateOneRequiredWithoutFollowedByNestedInput
    following?: UserUpdateOneRequiredWithoutFollowingNestedInput
  }

  export type FollowUncheckedUpdateInput = {
    followedById?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
  }

  export type FollowCreateManyInput = {
    followedById: string
    followingId: string
    relationship: string
  }

  export type FollowUpdateManyMutationInput = {
    relationship?: StringFieldUpdateOperationsInput | string
  }

  export type FollowUncheckedUpdateManyInput = {
    followedById?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileCreateInput = {
    id?: string
    photo: string
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: string
    userId: string
    photo: string
  }

  export type ProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileCreateManyInput = {
    id?: string
    userId: string
    photo: string
  }

  export type ProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutRecipeBookInput
    editedBy?: UserCreateNestedOneWithoutRecipeBookEditedByInput
    recipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutRecipeBookInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutRecipeBookInput
    crewRecipeBook?: CrewRecipeBookCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    editedById?: string | null
    recipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutRecipeBookInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutRecipeBookInput
    crewRecipeBook?: CrewRecipeBookUncheckedCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutRecipeBookNestedInput
    editedBy?: UserUpdateOneWithoutRecipeBookEditedByNestedInput
    recipeBookBuild?: RecipeBookBuildUpdateManyWithoutRecipeBookNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutRecipeBookNestedInput
    crewRecipeBook?: CrewRecipeBookUpdateManyWithoutRecipeBookNestedInput
  }

  export type RecipeBookUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutRecipeBookNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutRecipeBookNestedInput
    crewRecipeBook?: CrewRecipeBookUncheckedUpdateManyWithoutRecipeBookNestedInput
  }

  export type RecipeBookCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    editedById?: string | null
  }

  export type RecipeBookUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipeBookUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeBookUserCreateInput = {
    permission: string
    recipeBook: RecipeBookCreateNestedOneWithoutRecipeBookUserInput
    user: UserCreateNestedOneWithoutRecipeBookUserInput
  }

  export type RecipeBookUserUncheckedCreateInput = {
    userId: string
    recipeBookId: string
    permission: string
  }

  export type RecipeBookUserUpdateInput = {
    permission?: StringFieldUpdateOperationsInput | string
    recipeBook?: RecipeBookUpdateOneRequiredWithoutRecipeBookUserNestedInput
    user?: UserUpdateOneRequiredWithoutRecipeBookUserNestedInput
  }

  export type RecipeBookUserUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    recipeBookId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookUserCreateManyInput = {
    userId: string
    recipeBookId: string
    permission: string
  }

  export type RecipeBookUserUpdateManyMutationInput = {
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookUserUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    recipeBookId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type BuildCreateInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version?: number
    createdBy?: UserCreateNestedOneWithoutBuildInput
    editedBy?: UserCreateNestedOneWithoutBuildEditedByInput
    recipe?: RecipeCreateNestedOneWithoutBuildInput
    touch?: TouchCreateNestedManyWithoutBuildInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserCreateNestedManyWithoutBuildInput
    crewBuild?: CrewBuildCreateNestedManyWithoutBuildInput
  }

  export type BuildUncheckedCreateInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    editedById?: string | null
    recipeId?: string | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version?: number
    touch?: TouchUncheckedCreateNestedManyWithoutBuildInput
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutBuildInput
    crewBuild?: CrewBuildUncheckedCreateNestedManyWithoutBuildInput
  }

  export type BuildUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdBy?: UserUpdateOneWithoutBuildNestedInput
    editedBy?: UserUpdateOneWithoutBuildEditedByNestedInput
    recipe?: RecipeUpdateOneWithoutBuildNestedInput
    touch?: TouchUpdateManyWithoutBuildNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUpdateManyWithoutBuildNestedInput
    crewBuild?: CrewBuildUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeId?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    touch?: TouchUncheckedUpdateManyWithoutBuildNestedInput
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutBuildNestedInput
    crewBuild?: CrewBuildUncheckedUpdateManyWithoutBuildNestedInput
  }

  export type BuildCreateManyInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    editedById?: string | null
    recipeId?: string | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version?: number
  }

  export type BuildUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
  }

  export type BuildUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeId?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
  }

  export type ArchivedBuildCreateInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version: number
    createdBy?: UserCreateNestedOneWithoutArchivedBuildInput
    build: BuildCreateNestedOneWithoutArchivedBuildInput
    recipe?: RecipeCreateNestedOneWithoutArchivedBuildInput
    archivedTouch?: ArchivedTouchCreateNestedManyWithoutArchivedBuildInput
  }

  export type ArchivedBuildUncheckedCreateInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    createdById?: string | null
    buildId: string
    recipeId?: string | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version: number
    archivedTouch?: ArchivedTouchUncheckedCreateNestedManyWithoutArchivedBuildInput
  }

  export type ArchivedBuildUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdBy?: UserUpdateOneWithoutArchivedBuildNestedInput
    build?: BuildUpdateOneRequiredWithoutArchivedBuildNestedInput
    recipe?: RecipeUpdateOneWithoutArchivedBuildNestedInput
    archivedTouch?: ArchivedTouchUpdateManyWithoutArchivedBuildNestedInput
  }

  export type ArchivedBuildUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    buildId?: StringFieldUpdateOperationsInput | string
    recipeId?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    archivedTouch?: ArchivedTouchUncheckedUpdateManyWithoutArchivedBuildNestedInput
  }

  export type ArchivedBuildCreateManyInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    createdById?: string | null
    buildId: string
    recipeId?: string | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version: number
  }

  export type ArchivedBuildUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
  }

  export type ArchivedBuildUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    buildId?: StringFieldUpdateOperationsInput | string
    recipeId?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
  }

  export type BuildUserCreateInput = {
    permission: string
    user?: UserCreateNestedOneWithoutBuildUserInput
    build?: BuildCreateNestedOneWithoutBuildUserInput
  }

  export type BuildUserUncheckedCreateInput = {
    userId: string
    buildId: string
    permission: string
  }

  export type BuildUserUpdateInput = {
    permission?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneWithoutBuildUserNestedInput
    build?: BuildUpdateOneWithoutBuildUserNestedInput
  }

  export type BuildUserUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    buildId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type BuildUserCreateManyInput = {
    userId: string
    buildId: string
    permission: string
  }

  export type BuildUserUpdateManyMutationInput = {
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type BuildUserUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    buildId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeCreateInput = {
    id?: string
    createdAt?: Date | string
    editedAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    createdBy?: UserCreateNestedOneWithoutRecipeInput
    editedBy?: UserCreateNestedOneWithoutRecipeEditedByInput
    build?: BuildCreateNestedManyWithoutRecipeInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    editedAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    createdById?: string | null
    editedById?: string | null
    build?: BuildUncheckedCreateNestedManyWithoutRecipeInput
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutRecipeNestedInput
    editedBy?: UserUpdateOneWithoutRecipeEditedByNestedInput
    build?: BuildUpdateManyWithoutRecipeNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    build?: BuildUncheckedUpdateManyWithoutRecipeNestedInput
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeCreateManyInput = {
    id?: string
    createdAt?: Date | string
    editedAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    createdById?: string | null
    editedById?: string | null
  }

  export type RecipeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeBookBuildCreateInput = {
    recipeBook: RecipeBookCreateNestedOneWithoutRecipeBookBuildInput
    build: BuildCreateNestedOneWithoutRecipeBookBuildInput
  }

  export type RecipeBookBuildUncheckedCreateInput = {
    buildId: string
    recipeBookId: string
  }

  export type RecipeBookBuildUpdateInput = {
    recipeBook?: RecipeBookUpdateOneRequiredWithoutRecipeBookBuildNestedInput
    build?: BuildUpdateOneRequiredWithoutRecipeBookBuildNestedInput
  }

  export type RecipeBookBuildUncheckedUpdateInput = {
    buildId?: StringFieldUpdateOperationsInput | string
    recipeBookId?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookBuildCreateManyInput = {
    buildId: string
    recipeBookId: string
  }

  export type RecipeBookBuildUpdateManyMutationInput = {

  }

  export type RecipeBookBuildUncheckedUpdateManyInput = {
    buildId?: StringFieldUpdateOperationsInput | string
    recipeBookId?: StringFieldUpdateOperationsInput | string
  }

  export type TouchCreateInput = {
    id?: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    version?: number | null
    build: BuildCreateNestedOneWithoutTouchInput
    ingredientType: IngredientTypeCreateNestedOneWithoutTouchInput
    ingredient?: IngredientCreateNestedOneWithoutTouchInput
  }

  export type TouchUncheckedCreateInput = {
    id?: string
    buildId: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    ingredientTypeId: string
    ingredientId?: string | null
    version?: number | null
  }

  export type TouchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    build?: BuildUpdateOneRequiredWithoutTouchNestedInput
    ingredientType?: IngredientTypeUpdateOneRequiredWithoutTouchNestedInput
    ingredient?: IngredientUpdateOneWithoutTouchNestedInput
  }

  export type TouchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientTypeId?: StringFieldUpdateOperationsInput | string
    ingredientId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TouchCreateManyInput = {
    id?: string
    buildId: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    ingredientTypeId: string
    ingredientId?: string | null
    version?: number | null
  }

  export type TouchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TouchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientTypeId?: StringFieldUpdateOperationsInput | string
    ingredientId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ArchivedTouchCreateInput = {
    id?: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    version?: number | null
    archivedBuild: ArchivedBuildCreateNestedOneWithoutArchivedTouchInput
    ingredientType: IngredientTypeCreateNestedOneWithoutArchivedTouchInput
    ingredient?: IngredientCreateNestedOneWithoutArchivedTouchInput
  }

  export type ArchivedTouchUncheckedCreateInput = {
    id?: string
    archivedBuildId: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    ingredientTypeId: string
    ingredientId?: string | null
    version?: number | null
  }

  export type ArchivedTouchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    archivedBuild?: ArchivedBuildUpdateOneRequiredWithoutArchivedTouchNestedInput
    ingredientType?: IngredientTypeUpdateOneRequiredWithoutArchivedTouchNestedInput
    ingredient?: IngredientUpdateOneWithoutArchivedTouchNestedInput
  }

  export type ArchivedTouchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    archivedBuildId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientTypeId?: StringFieldUpdateOperationsInput | string
    ingredientId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ArchivedTouchCreateManyInput = {
    id?: string
    archivedBuildId: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    ingredientTypeId: string
    ingredientId?: string | null
    version?: number | null
  }

  export type ArchivedTouchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ArchivedTouchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    archivedBuildId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientTypeId?: StringFieldUpdateOperationsInput | string
    ingredientId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type IngredientTypeCreateInput = {
    id?: string
    name: string
    description?: string | null
    touch?: TouchCreateNestedManyWithoutIngredientTypeInput
    archivedTouch?: ArchivedTouchCreateNestedManyWithoutIngredientTypeInput
    ingredient?: IngredientCreateNestedManyWithoutIngredientTypeInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutIngredientTypeInput
  }

  export type IngredientTypeUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutIngredientTypeInput
    archivedTouch?: ArchivedTouchUncheckedCreateNestedManyWithoutIngredientTypeInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutIngredientTypeInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutIngredientTypeInput
  }

  export type IngredientTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUpdateManyWithoutIngredientTypeNestedInput
    archivedTouch?: ArchivedTouchUpdateManyWithoutIngredientTypeNestedInput
    ingredient?: IngredientUpdateManyWithoutIngredientTypeNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutIngredientTypeNestedInput
  }

  export type IngredientTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutIngredientTypeNestedInput
    archivedTouch?: ArchivedTouchUncheckedUpdateManyWithoutIngredientTypeNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutIngredientTypeNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutIngredientTypeNestedInput
  }

  export type IngredientTypeCreateManyInput = {
    id?: string
    name: string
    description?: string | null
  }

  export type IngredientTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IngredientTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IngredientCreateInput = {
    id?: string
    dateCreated?: Date | string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    createdBy?: UserCreateNestedOneWithoutIngredientInput
    ingredientType: IngredientTypeCreateNestedOneWithoutIngredientInput
    touch?: TouchCreateNestedManyWithoutIngredientInput
    archivedTouch?: ArchivedTouchCreateNestedManyWithoutIngredientInput
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutIngredientInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutIngredientInput
    crewIngredient?: CrewIngredientCreateNestedManyWithoutIngredientInput
  }

  export type IngredientUncheckedCreateInput = {
    id?: string
    dateCreated?: Date | string
    createdById?: string | null
    ingredientTypeId: string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutIngredientInput
    archivedTouch?: ArchivedTouchUncheckedCreateNestedManyWithoutIngredientInput
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutIngredientInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutIngredientInput
    crewIngredient?: CrewIngredientUncheckedCreateNestedManyWithoutIngredientInput
  }

  export type IngredientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutIngredientNestedInput
    ingredientType?: IngredientTypeUpdateOneRequiredWithoutIngredientNestedInput
    touch?: TouchUpdateManyWithoutIngredientNestedInput
    archivedTouch?: ArchivedTouchUpdateManyWithoutIngredientNestedInput
    ingredientStorage?: IngredientStorageUpdateManyWithoutIngredientNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutIngredientNestedInput
    crewIngredient?: CrewIngredientUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientTypeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutIngredientNestedInput
    archivedTouch?: ArchivedTouchUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutIngredientNestedInput
    crewIngredient?: CrewIngredientUncheckedUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientCreateManyInput = {
    id?: string
    dateCreated?: Date | string
    createdById?: string | null
    ingredientTypeId: string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
  }

  export type IngredientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IngredientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientTypeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IngredientUserCreateInput = {
    permission: string
    user: UserCreateNestedOneWithoutIngredientUserInput
    ingredient: IngredientCreateNestedOneWithoutIngredientUserInput
  }

  export type IngredientUserUncheckedCreateInput = {
    ingredientId: string
    userId: string
    permission: string
  }

  export type IngredientUserUpdateInput = {
    permission?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutIngredientUserNestedInput
    ingredient?: IngredientUpdateOneRequiredWithoutIngredientUserNestedInput
  }

  export type IngredientUserUncheckedUpdateInput = {
    ingredientId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type IngredientUserCreateManyInput = {
    ingredientId: string
    userId: string
    permission: string
  }

  export type IngredientUserUpdateManyMutationInput = {
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type IngredientUserUncheckedUpdateManyInput = {
    ingredientId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type IngredientPreferenceCreateInput = {
    ingredientType: IngredientTypeCreateNestedOneWithoutIngredientPreferenceInput
    ingredient: IngredientCreateNestedOneWithoutIngredientPreferenceInput
    user: UserCreateNestedOneWithoutIngredientPreferenceInput
  }

  export type IngredientPreferenceUncheckedCreateInput = {
    ingredientTypeId: string
    ingredientId: string
    userId: string
  }

  export type IngredientPreferenceUpdateInput = {
    ingredientType?: IngredientTypeUpdateOneRequiredWithoutIngredientPreferenceNestedInput
    ingredient?: IngredientUpdateOneRequiredWithoutIngredientPreferenceNestedInput
    user?: UserUpdateOneRequiredWithoutIngredientPreferenceNestedInput
  }

  export type IngredientPreferenceUncheckedUpdateInput = {
    ingredientTypeId?: StringFieldUpdateOperationsInput | string
    ingredientId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type IngredientPreferenceCreateManyInput = {
    ingredientTypeId: string
    ingredientId: string
    userId: string
  }

  export type IngredientPreferenceUpdateManyMutationInput = {

  }

  export type IngredientPreferenceUncheckedUpdateManyInput = {
    ingredientTypeId?: StringFieldUpdateOperationsInput | string
    ingredientId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryCreateInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutInventoryInput
    editedBy?: UserCreateNestedOneWithoutInventoryEditedByInput
    inventoryStorage?: InventoryStorageCreateNestedManyWithoutInventoryInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutInventoryInput
    crewInventory?: CrewInventoryCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    inventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutInventoryInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutInventoryInput
    crewInventory?: CrewInventoryUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutInventoryNestedInput
    editedBy?: UserUpdateOneWithoutInventoryEditedByNestedInput
    inventoryStorage?: InventoryStorageUpdateManyWithoutInventoryNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutInventoryNestedInput
    crewInventory?: CrewInventoryUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    inventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutInventoryNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutInventoryNestedInput
    crewInventory?: CrewInventoryUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryCreateManyInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
  }

  export type InventoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryUserCreateInput = {
    permission: string
    user: UserCreateNestedOneWithoutInventoryUserInput
    inventory: InventoryCreateNestedOneWithoutInventoryUserInput
  }

  export type InventoryUserUncheckedCreateInput = {
    userId: string
    inventoryId: string
    permission: string
  }

  export type InventoryUserUpdateInput = {
    permission?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutInventoryUserNestedInput
    inventory?: InventoryUpdateOneRequiredWithoutInventoryUserNestedInput
  }

  export type InventoryUserUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    inventoryId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryUserCreateManyInput = {
    userId: string
    inventoryId: string
    permission: string
  }

  export type InventoryUserUpdateManyMutationInput = {
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryUserUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    inventoryId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type StorageCreateInput = {
    id?: string
    name: string
    description?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutStorageInput
    editedBy?: UserCreateNestedOneWithoutStorageEditedByInput
    inventoryStorage?: InventoryStorageCreateNestedManyWithoutStorageInput
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutStorageInput
    storageUser?: StorageUserCreateNestedManyWithoutStorageInput
    crewStorage?: CrewStorageCreateNestedManyWithoutStorageInput
  }

  export type StorageUncheckedCreateInput = {
    id?: string
    name: string
    description?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    inventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutStorageInput
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutStorageInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutStorageInput
    crewStorage?: CrewStorageUncheckedCreateNestedManyWithoutStorageInput
  }

  export type StorageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutStorageNestedInput
    editedBy?: UserUpdateOneWithoutStorageEditedByNestedInput
    inventoryStorage?: InventoryStorageUpdateManyWithoutStorageNestedInput
    ingredientStorage?: IngredientStorageUpdateManyWithoutStorageNestedInput
    storageUser?: StorageUserUpdateManyWithoutStorageNestedInput
    crewStorage?: CrewStorageUpdateManyWithoutStorageNestedInput
  }

  export type StorageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    inventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutStorageNestedInput
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutStorageNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutStorageNestedInput
    crewStorage?: CrewStorageUncheckedUpdateManyWithoutStorageNestedInput
  }

  export type StorageCreateManyInput = {
    id?: string
    name: string
    description?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
  }

  export type StorageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryStorageCreateInput = {
    storage: StorageCreateNestedOneWithoutInventoryStorageInput
    inventory: InventoryCreateNestedOneWithoutInventoryStorageInput
  }

  export type InventoryStorageUncheckedCreateInput = {
    inventoryId: string
    storageId: string
  }

  export type InventoryStorageUpdateInput = {
    storage?: StorageUpdateOneRequiredWithoutInventoryStorageNestedInput
    inventory?: InventoryUpdateOneRequiredWithoutInventoryStorageNestedInput
  }

  export type InventoryStorageUncheckedUpdateInput = {
    inventoryId?: StringFieldUpdateOperationsInput | string
    storageId?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryStorageCreateManyInput = {
    inventoryId: string
    storageId: string
  }

  export type InventoryStorageUpdateManyMutationInput = {

  }

  export type InventoryStorageUncheckedUpdateManyInput = {
    inventoryId?: StringFieldUpdateOperationsInput | string
    storageId?: StringFieldUpdateOperationsInput | string
  }

  export type IngredientStorageCreateInput = {
    quantity?: number | null
    ingredient: IngredientCreateNestedOneWithoutIngredientStorageInput
    Storage: StorageCreateNestedOneWithoutIngredientStorageInput
  }

  export type IngredientStorageUncheckedCreateInput = {
    ingredientId: string
    storageId: string
    quantity?: number | null
  }

  export type IngredientStorageUpdateInput = {
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    ingredient?: IngredientUpdateOneRequiredWithoutIngredientStorageNestedInput
    Storage?: StorageUpdateOneRequiredWithoutIngredientStorageNestedInput
  }

  export type IngredientStorageUncheckedUpdateInput = {
    ingredientId?: StringFieldUpdateOperationsInput | string
    storageId?: StringFieldUpdateOperationsInput | string
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type IngredientStorageCreateManyInput = {
    ingredientId: string
    storageId: string
    quantity?: number | null
  }

  export type IngredientStorageUpdateManyMutationInput = {
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type IngredientStorageUncheckedUpdateManyInput = {
    ingredientId?: StringFieldUpdateOperationsInput | string
    storageId?: StringFieldUpdateOperationsInput | string
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type StorageUserCreateInput = {
    permission: string
    user: UserCreateNestedOneWithoutStorageUserInput
    Storage: StorageCreateNestedOneWithoutStorageUserInput
  }

  export type StorageUserUncheckedCreateInput = {
    userId: string
    storageId: string
    permission: string
  }

  export type StorageUserUpdateInput = {
    permission?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutStorageUserNestedInput
    Storage?: StorageUpdateOneRequiredWithoutStorageUserNestedInput
  }

  export type StorageUserUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    storageId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type StorageUserCreateManyInput = {
    userId: string
    storageId: string
    permission: string
  }

  export type StorageUserUpdateManyMutationInput = {
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type StorageUserUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    storageId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type CrewCreateInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCrewInput
    editedBy?: UserCreateNestedOneWithoutCrewEditedByInput
    crewUser?: CrewUserCreateNestedManyWithoutCrewInput
    crewInventory?: CrewInventoryCreateNestedManyWithoutCrewInput
    crewStorage?: CrewStorageCreateNestedManyWithoutCrewInput
    crewIngredient?: CrewIngredientCreateNestedManyWithoutCrewInput
    crewRecipeBook?: CrewRecipeBookCreateNestedManyWithoutCrewInput
    crewBuild?: CrewBuildCreateNestedManyWithoutCrewInput
  }

  export type CrewUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    crewUser?: CrewUserUncheckedCreateNestedManyWithoutCrewInput
    crewInventory?: CrewInventoryUncheckedCreateNestedManyWithoutCrewInput
    crewStorage?: CrewStorageUncheckedCreateNestedManyWithoutCrewInput
    crewIngredient?: CrewIngredientUncheckedCreateNestedManyWithoutCrewInput
    crewRecipeBook?: CrewRecipeBookUncheckedCreateNestedManyWithoutCrewInput
    crewBuild?: CrewBuildUncheckedCreateNestedManyWithoutCrewInput
  }

  export type CrewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCrewNestedInput
    editedBy?: UserUpdateOneWithoutCrewEditedByNestedInput
    crewUser?: CrewUserUpdateManyWithoutCrewNestedInput
    crewInventory?: CrewInventoryUpdateManyWithoutCrewNestedInput
    crewStorage?: CrewStorageUpdateManyWithoutCrewNestedInput
    crewIngredient?: CrewIngredientUpdateManyWithoutCrewNestedInput
    crewRecipeBook?: CrewRecipeBookUpdateManyWithoutCrewNestedInput
    crewBuild?: CrewBuildUpdateManyWithoutCrewNestedInput
  }

  export type CrewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    crewUser?: CrewUserUncheckedUpdateManyWithoutCrewNestedInput
    crewInventory?: CrewInventoryUncheckedUpdateManyWithoutCrewNestedInput
    crewStorage?: CrewStorageUncheckedUpdateManyWithoutCrewNestedInput
    crewIngredient?: CrewIngredientUncheckedUpdateManyWithoutCrewNestedInput
    crewRecipeBook?: CrewRecipeBookUncheckedUpdateManyWithoutCrewNestedInput
    crewBuild?: CrewBuildUncheckedUpdateManyWithoutCrewNestedInput
  }

  export type CrewCreateManyInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
  }

  export type CrewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
  }

  export type CrewUserCreateInput = {
    permission: string
    user: UserCreateNestedOneWithoutCrewUserInput
    crew: CrewCreateNestedOneWithoutCrewUserInput
  }

  export type CrewUserUncheckedCreateInput = {
    userId: string
    crewId: string
    permission: string
  }

  export type CrewUserUpdateInput = {
    permission?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutCrewUserNestedInput
    crew?: CrewUpdateOneRequiredWithoutCrewUserNestedInput
  }

  export type CrewUserUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type CrewUserCreateManyInput = {
    userId: string
    crewId: string
    permission: string
  }

  export type CrewUserUpdateManyMutationInput = {
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type CrewUserUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type CrewInventoryCreateInput = {
    inventory: InventoryCreateNestedOneWithoutCrewInventoryInput
    crew: CrewCreateNestedOneWithoutCrewInventoryInput
  }

  export type CrewInventoryUncheckedCreateInput = {
    inventoryId: string
    crewId: string
  }

  export type CrewInventoryUpdateInput = {
    inventory?: InventoryUpdateOneRequiredWithoutCrewInventoryNestedInput
    crew?: CrewUpdateOneRequiredWithoutCrewInventoryNestedInput
  }

  export type CrewInventoryUncheckedUpdateInput = {
    inventoryId?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
  }

  export type CrewInventoryCreateManyInput = {
    inventoryId: string
    crewId: string
  }

  export type CrewInventoryUpdateManyMutationInput = {

  }

  export type CrewInventoryUncheckedUpdateManyInput = {
    inventoryId?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
  }

  export type CrewStorageCreateInput = {
    storage: StorageCreateNestedOneWithoutCrewStorageInput
    crew: CrewCreateNestedOneWithoutCrewStorageInput
  }

  export type CrewStorageUncheckedCreateInput = {
    storageId: string
    crewId: string
  }

  export type CrewStorageUpdateInput = {
    storage?: StorageUpdateOneRequiredWithoutCrewStorageNestedInput
    crew?: CrewUpdateOneRequiredWithoutCrewStorageNestedInput
  }

  export type CrewStorageUncheckedUpdateInput = {
    storageId?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
  }

  export type CrewStorageCreateManyInput = {
    storageId: string
    crewId: string
  }

  export type CrewStorageUpdateManyMutationInput = {

  }

  export type CrewStorageUncheckedUpdateManyInput = {
    storageId?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
  }

  export type CrewIngredientCreateInput = {
    ingredient: IngredientCreateNestedOneWithoutCrewIngredientInput
    crew: CrewCreateNestedOneWithoutCrewIngredientInput
  }

  export type CrewIngredientUncheckedCreateInput = {
    ingredientId: string
    crewId: string
  }

  export type CrewIngredientUpdateInput = {
    ingredient?: IngredientUpdateOneRequiredWithoutCrewIngredientNestedInput
    crew?: CrewUpdateOneRequiredWithoutCrewIngredientNestedInput
  }

  export type CrewIngredientUncheckedUpdateInput = {
    ingredientId?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
  }

  export type CrewIngredientCreateManyInput = {
    ingredientId: string
    crewId: string
  }

  export type CrewIngredientUpdateManyMutationInput = {

  }

  export type CrewIngredientUncheckedUpdateManyInput = {
    ingredientId?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
  }

  export type CrewRecipeBookCreateInput = {
    recipeBook: RecipeBookCreateNestedOneWithoutCrewRecipeBookInput
    crew: CrewCreateNestedOneWithoutCrewRecipeBookInput
  }

  export type CrewRecipeBookUncheckedCreateInput = {
    recipeBookId: string
    crewId: string
  }

  export type CrewRecipeBookUpdateInput = {
    recipeBook?: RecipeBookUpdateOneRequiredWithoutCrewRecipeBookNestedInput
    crew?: CrewUpdateOneRequiredWithoutCrewRecipeBookNestedInput
  }

  export type CrewRecipeBookUncheckedUpdateInput = {
    recipeBookId?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
  }

  export type CrewRecipeBookCreateManyInput = {
    recipeBookId: string
    crewId: string
  }

  export type CrewRecipeBookUpdateManyMutationInput = {

  }

  export type CrewRecipeBookUncheckedUpdateManyInput = {
    recipeBookId?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
  }

  export type CrewBuildCreateInput = {
    build: BuildCreateNestedOneWithoutCrewBuildInput
    crew: CrewCreateNestedOneWithoutCrewBuildInput
  }

  export type CrewBuildUncheckedCreateInput = {
    buildId: string
    crewId: string
  }

  export type CrewBuildUpdateInput = {
    build?: BuildUpdateOneRequiredWithoutCrewBuildNestedInput
    crew?: CrewUpdateOneRequiredWithoutCrewBuildNestedInput
  }

  export type CrewBuildUncheckedUpdateInput = {
    buildId?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
  }

  export type CrewBuildCreateManyInput = {
    buildId: string
    crewId: string
  }

  export type CrewBuildUpdateManyMutationInput = {

  }

  export type CrewBuildUncheckedUpdateManyInput = {
    buildId?: StringFieldUpdateOperationsInput | string
    crewId?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ProfileNullableRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type RecipeBookUserListRelationFilter = {
    every?: RecipeBookUserWhereInput
    some?: RecipeBookUserWhereInput
    none?: RecipeBookUserWhereInput
  }

  export type RecipeBookListRelationFilter = {
    every?: RecipeBookWhereInput
    some?: RecipeBookWhereInput
    none?: RecipeBookWhereInput
  }

  export type RecipeListRelationFilter = {
    every?: RecipeWhereInput
    some?: RecipeWhereInput
    none?: RecipeWhereInput
  }

  export type BuildUserListRelationFilter = {
    every?: BuildUserWhereInput
    some?: BuildUserWhereInput
    none?: BuildUserWhereInput
  }

  export type BuildListRelationFilter = {
    every?: BuildWhereInput
    some?: BuildWhereInput
    none?: BuildWhereInput
  }

  export type ArchivedBuildListRelationFilter = {
    every?: ArchivedBuildWhereInput
    some?: ArchivedBuildWhereInput
    none?: ArchivedBuildWhereInput
  }

  export type CrewUserListRelationFilter = {
    every?: CrewUserWhereInput
    some?: CrewUserWhereInput
    none?: CrewUserWhereInput
  }

  export type CrewListRelationFilter = {
    every?: CrewWhereInput
    some?: CrewWhereInput
    none?: CrewWhereInput
  }

  export type IngredientListRelationFilter = {
    every?: IngredientWhereInput
    some?: IngredientWhereInput
    none?: IngredientWhereInput
  }

  export type IngredientPreferenceListRelationFilter = {
    every?: IngredientPreferenceWhereInput
    some?: IngredientPreferenceWhereInput
    none?: IngredientPreferenceWhereInput
  }

  export type IngredientUserListRelationFilter = {
    every?: IngredientUserWhereInput
    some?: IngredientUserWhereInput
    none?: IngredientUserWhereInput
  }

  export type StorageUserListRelationFilter = {
    every?: StorageUserWhereInput
    some?: StorageUserWhereInput
    none?: StorageUserWhereInput
  }

  export type StorageListRelationFilter = {
    every?: StorageWhereInput
    some?: StorageWhereInput
    none?: StorageWhereInput
  }

  export type InventoryListRelationFilter = {
    every?: InventoryWhereInput
    some?: InventoryWhereInput
    none?: InventoryWhereInput
  }

  export type InventoryUserListRelationFilter = {
    every?: InventoryUserWhereInput
    some?: InventoryUserWhereInput
    none?: InventoryUserWhereInput
  }

  export type FollowListRelationFilter = {
    every?: FollowWhereInput
    some?: FollowWhereInput
    none?: FollowWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type RecipeBookUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipeBookOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BuildUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BuildOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArchivedBuildOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CrewUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CrewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IngredientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IngredientPreferenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IngredientUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StorageUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StorageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FollowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    userName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateJoined?: SortOrder
    lastEdited?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    userName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateJoined?: SortOrder
    lastEdited?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    userName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateJoined?: SortOrder
    lastEdited?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type FollowFollowingIdFollowedByIdCompoundUniqueInput = {
    followingId: string
    followedById: string
  }

  export type FollowCountOrderByAggregateInput = {
    followedById?: SortOrder
    followingId?: SortOrder
    relationship?: SortOrder
  }

  export type FollowMaxOrderByAggregateInput = {
    followedById?: SortOrder
    followingId?: SortOrder
    relationship?: SortOrder
  }

  export type FollowMinOrderByAggregateInput = {
    followedById?: SortOrder
    followingId?: SortOrder
    relationship?: SortOrder
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    photo?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    photo?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    photo?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type RecipeBookBuildListRelationFilter = {
    every?: RecipeBookBuildWhereInput
    some?: RecipeBookBuildWhereInput
    none?: RecipeBookBuildWhereInput
  }

  export type CrewRecipeBookListRelationFilter = {
    every?: CrewRecipeBookWhereInput
    some?: CrewRecipeBookWhereInput
    none?: CrewRecipeBookWhereInput
  }

  export type RecipeBookBuildOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CrewRecipeBookOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipeBookCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type RecipeBookMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type RecipeBookMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type RecipeBookRelationFilter = {
    is?: RecipeBookWhereInput
    isNot?: RecipeBookWhereInput
  }

  export type RecipeBookUserUserIdRecipeBookIdCompoundUniqueInput = {
    userId: string
    recipeBookId: string
  }

  export type RecipeBookUserCountOrderByAggregateInput = {
    userId?: SortOrder
    recipeBookId?: SortOrder
    permission?: SortOrder
  }

  export type RecipeBookUserMaxOrderByAggregateInput = {
    userId?: SortOrder
    recipeBookId?: SortOrder
    permission?: SortOrder
  }

  export type RecipeBookUserMinOrderByAggregateInput = {
    userId?: SortOrder
    recipeBookId?: SortOrder
    permission?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type RecipeNullableRelationFilter = {
    is?: RecipeWhereInput | null
    isNot?: RecipeWhereInput | null
  }

  export type TouchListRelationFilter = {
    every?: TouchWhereInput
    some?: TouchWhereInput
    none?: TouchWhereInput
  }

  export type CrewBuildListRelationFilter = {
    every?: CrewBuildWhereInput
    some?: CrewBuildWhereInput
    none?: CrewBuildWhereInput
  }

  export type TouchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CrewBuildOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BuildCountOrderByAggregateInput = {
    id?: SortOrder
    buildName?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    recipeId?: SortOrder
    instructions?: SortOrder
    notes?: SortOrder
    glassware?: SortOrder
    ice?: SortOrder
    version?: SortOrder
  }

  export type BuildAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type BuildMaxOrderByAggregateInput = {
    id?: SortOrder
    buildName?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    recipeId?: SortOrder
    instructions?: SortOrder
    notes?: SortOrder
    glassware?: SortOrder
    ice?: SortOrder
    version?: SortOrder
  }

  export type BuildMinOrderByAggregateInput = {
    id?: SortOrder
    buildName?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
    recipeId?: SortOrder
    instructions?: SortOrder
    notes?: SortOrder
    glassware?: SortOrder
    ice?: SortOrder
    version?: SortOrder
  }

  export type BuildSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BuildRelationFilter = {
    is?: BuildWhereInput
    isNot?: BuildWhereInput
  }

  export type ArchivedTouchListRelationFilter = {
    every?: ArchivedTouchWhereInput
    some?: ArchivedTouchWhereInput
    none?: ArchivedTouchWhereInput
  }

  export type ArchivedTouchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArchivedBuildCountOrderByAggregateInput = {
    id?: SortOrder
    buildName?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
    buildId?: SortOrder
    recipeId?: SortOrder
    instructions?: SortOrder
    notes?: SortOrder
    glassware?: SortOrder
    ice?: SortOrder
    version?: SortOrder
  }

  export type ArchivedBuildAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type ArchivedBuildMaxOrderByAggregateInput = {
    id?: SortOrder
    buildName?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
    buildId?: SortOrder
    recipeId?: SortOrder
    instructions?: SortOrder
    notes?: SortOrder
    glassware?: SortOrder
    ice?: SortOrder
    version?: SortOrder
  }

  export type ArchivedBuildMinOrderByAggregateInput = {
    id?: SortOrder
    buildName?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
    buildId?: SortOrder
    recipeId?: SortOrder
    instructions?: SortOrder
    notes?: SortOrder
    glassware?: SortOrder
    ice?: SortOrder
    version?: SortOrder
  }

  export type ArchivedBuildSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type BuildNullableRelationFilter = {
    is?: BuildWhereInput | null
    isNot?: BuildWhereInput | null
  }

  export type BuildUserUserIdBuildIdCompoundUniqueInput = {
    userId: string
    buildId: string
  }

  export type BuildUserCountOrderByAggregateInput = {
    userId?: SortOrder
    buildId?: SortOrder
    permission?: SortOrder
  }

  export type BuildUserMaxOrderByAggregateInput = {
    userId?: SortOrder
    buildId?: SortOrder
    permission?: SortOrder
  }

  export type BuildUserMinOrderByAggregateInput = {
    userId?: SortOrder
    buildId?: SortOrder
    permission?: SortOrder
  }

  export type RecipeCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    name?: SortOrder
    origin?: SortOrder
    history?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type RecipeMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    name?: SortOrder
    origin?: SortOrder
    history?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type RecipeMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    name?: SortOrder
    origin?: SortOrder
    history?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type RecipeBookBuildBuildIdRecipeBookIdCompoundUniqueInput = {
    buildId: string
    recipeBookId: string
  }

  export type RecipeBookBuildCountOrderByAggregateInput = {
    buildId?: SortOrder
    recipeBookId?: SortOrder
  }

  export type RecipeBookBuildMaxOrderByAggregateInput = {
    buildId?: SortOrder
    recipeBookId?: SortOrder
  }

  export type RecipeBookBuildMinOrderByAggregateInput = {
    buildId?: SortOrder
    recipeBookId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IngredientTypeRelationFilter = {
    is?: IngredientTypeWhereInput
    isNot?: IngredientTypeWhereInput
  }

  export type IngredientNullableRelationFilter = {
    is?: IngredientWhereInput | null
    isNot?: IngredientWhereInput | null
  }

  export type TouchCountOrderByAggregateInput = {
    id?: SortOrder
    buildId?: SortOrder
    order?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    ingredientTypeId?: SortOrder
    ingredientId?: SortOrder
    version?: SortOrder
  }

  export type TouchAvgOrderByAggregateInput = {
    order?: SortOrder
    amount?: SortOrder
    version?: SortOrder
  }

  export type TouchMaxOrderByAggregateInput = {
    id?: SortOrder
    buildId?: SortOrder
    order?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    ingredientTypeId?: SortOrder
    ingredientId?: SortOrder
    version?: SortOrder
  }

  export type TouchMinOrderByAggregateInput = {
    id?: SortOrder
    buildId?: SortOrder
    order?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    ingredientTypeId?: SortOrder
    ingredientId?: SortOrder
    version?: SortOrder
  }

  export type TouchSumOrderByAggregateInput = {
    order?: SortOrder
    amount?: SortOrder
    version?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ArchivedBuildRelationFilter = {
    is?: ArchivedBuildWhereInput
    isNot?: ArchivedBuildWhereInput
  }

  export type ArchivedTouchCountOrderByAggregateInput = {
    id?: SortOrder
    archivedBuildId?: SortOrder
    order?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    ingredientTypeId?: SortOrder
    ingredientId?: SortOrder
    version?: SortOrder
  }

  export type ArchivedTouchAvgOrderByAggregateInput = {
    order?: SortOrder
    amount?: SortOrder
    version?: SortOrder
  }

  export type ArchivedTouchMaxOrderByAggregateInput = {
    id?: SortOrder
    archivedBuildId?: SortOrder
    order?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    ingredientTypeId?: SortOrder
    ingredientId?: SortOrder
    version?: SortOrder
  }

  export type ArchivedTouchMinOrderByAggregateInput = {
    id?: SortOrder
    archivedBuildId?: SortOrder
    order?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    ingredientTypeId?: SortOrder
    ingredientId?: SortOrder
    version?: SortOrder
  }

  export type ArchivedTouchSumOrderByAggregateInput = {
    order?: SortOrder
    amount?: SortOrder
    version?: SortOrder
  }

  export type IngredientTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type IngredientTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type IngredientTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type IngredientStorageListRelationFilter = {
    every?: IngredientStorageWhereInput
    some?: IngredientStorageWhereInput
    none?: IngredientStorageWhereInput
  }

  export type CrewIngredientListRelationFilter = {
    every?: CrewIngredientWhereInput
    some?: CrewIngredientWhereInput
    none?: CrewIngredientWhereInput
  }

  export type IngredientStorageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CrewIngredientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IngredientCountOrderByAggregateInput = {
    id?: SortOrder
    dateCreated?: SortOrder
    createdById?: SortOrder
    ingredientTypeId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    source?: SortOrder
  }

  export type IngredientAvgOrderByAggregateInput = {
    price?: SortOrder
    amount?: SortOrder
  }

  export type IngredientMaxOrderByAggregateInput = {
    id?: SortOrder
    dateCreated?: SortOrder
    createdById?: SortOrder
    ingredientTypeId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    source?: SortOrder
  }

  export type IngredientMinOrderByAggregateInput = {
    id?: SortOrder
    dateCreated?: SortOrder
    createdById?: SortOrder
    ingredientTypeId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    source?: SortOrder
  }

  export type IngredientSumOrderByAggregateInput = {
    price?: SortOrder
    amount?: SortOrder
  }

  export type IngredientRelationFilter = {
    is?: IngredientWhereInput
    isNot?: IngredientWhereInput
  }

  export type IngredientUserIngredientIdUserIdCompoundUniqueInput = {
    ingredientId: string
    userId: string
  }

  export type IngredientUserCountOrderByAggregateInput = {
    ingredientId?: SortOrder
    userId?: SortOrder
    permission?: SortOrder
  }

  export type IngredientUserMaxOrderByAggregateInput = {
    ingredientId?: SortOrder
    userId?: SortOrder
    permission?: SortOrder
  }

  export type IngredientUserMinOrderByAggregateInput = {
    ingredientId?: SortOrder
    userId?: SortOrder
    permission?: SortOrder
  }

  export type IngredientPreferenceIngredientTypeIdIngredientIdCompoundUniqueInput = {
    ingredientTypeId: string
    ingredientId: string
  }

  export type IngredientPreferenceCountOrderByAggregateInput = {
    ingredientTypeId?: SortOrder
    ingredientId?: SortOrder
    userId?: SortOrder
  }

  export type IngredientPreferenceMaxOrderByAggregateInput = {
    ingredientTypeId?: SortOrder
    ingredientId?: SortOrder
    userId?: SortOrder
  }

  export type IngredientPreferenceMinOrderByAggregateInput = {
    ingredientTypeId?: SortOrder
    ingredientId?: SortOrder
    userId?: SortOrder
  }

  export type InventoryStorageListRelationFilter = {
    every?: InventoryStorageWhereInput
    some?: InventoryStorageWhereInput
    none?: InventoryStorageWhereInput
  }

  export type CrewInventoryListRelationFilter = {
    every?: CrewInventoryWhereInput
    some?: CrewInventoryWhereInput
    none?: CrewInventoryWhereInput
  }

  export type InventoryStorageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CrewInventoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type InventoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type InventoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type InventoryRelationFilter = {
    is?: InventoryWhereInput
    isNot?: InventoryWhereInput
  }

  export type InventoryUserUserIdInventoryIdCompoundUniqueInput = {
    userId: string
    inventoryId: string
  }

  export type InventoryUserCountOrderByAggregateInput = {
    userId?: SortOrder
    inventoryId?: SortOrder
    permission?: SortOrder
  }

  export type InventoryUserMaxOrderByAggregateInput = {
    userId?: SortOrder
    inventoryId?: SortOrder
    permission?: SortOrder
  }

  export type InventoryUserMinOrderByAggregateInput = {
    userId?: SortOrder
    inventoryId?: SortOrder
    permission?: SortOrder
  }

  export type CrewStorageListRelationFilter = {
    every?: CrewStorageWhereInput
    some?: CrewStorageWhereInput
    none?: CrewStorageWhereInput
  }

  export type CrewStorageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StorageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type StorageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type StorageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type StorageRelationFilter = {
    is?: StorageWhereInput
    isNot?: StorageWhereInput
  }

  export type InventoryStorageInventoryIdStorageIdCompoundUniqueInput = {
    inventoryId: string
    storageId: string
  }

  export type InventoryStorageCountOrderByAggregateInput = {
    inventoryId?: SortOrder
    storageId?: SortOrder
  }

  export type InventoryStorageMaxOrderByAggregateInput = {
    inventoryId?: SortOrder
    storageId?: SortOrder
  }

  export type InventoryStorageMinOrderByAggregateInput = {
    inventoryId?: SortOrder
    storageId?: SortOrder
  }

  export type IngredientStorageIngredientIdStorageIdCompoundUniqueInput = {
    ingredientId: string
    storageId: string
  }

  export type IngredientStorageCountOrderByAggregateInput = {
    ingredientId?: SortOrder
    storageId?: SortOrder
    quantity?: SortOrder
  }

  export type IngredientStorageAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type IngredientStorageMaxOrderByAggregateInput = {
    ingredientId?: SortOrder
    storageId?: SortOrder
    quantity?: SortOrder
  }

  export type IngredientStorageMinOrderByAggregateInput = {
    ingredientId?: SortOrder
    storageId?: SortOrder
    quantity?: SortOrder
  }

  export type IngredientStorageSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type StorageUserUserIdStorageIdCompoundUniqueInput = {
    userId: string
    storageId: string
  }

  export type StorageUserCountOrderByAggregateInput = {
    userId?: SortOrder
    storageId?: SortOrder
    permission?: SortOrder
  }

  export type StorageUserMaxOrderByAggregateInput = {
    userId?: SortOrder
    storageId?: SortOrder
    permission?: SortOrder
  }

  export type StorageUserMinOrderByAggregateInput = {
    userId?: SortOrder
    storageId?: SortOrder
    permission?: SortOrder
  }

  export type CrewCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type CrewMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type CrewMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    createdById?: SortOrder
    editedById?: SortOrder
  }

  export type CrewRelationFilter = {
    is?: CrewWhereInput
    isNot?: CrewWhereInput
  }

  export type CrewUserUserIdCrewIdCompoundUniqueInput = {
    userId: string
    crewId: string
  }

  export type CrewUserCountOrderByAggregateInput = {
    userId?: SortOrder
    crewId?: SortOrder
    permission?: SortOrder
  }

  export type CrewUserMaxOrderByAggregateInput = {
    userId?: SortOrder
    crewId?: SortOrder
    permission?: SortOrder
  }

  export type CrewUserMinOrderByAggregateInput = {
    userId?: SortOrder
    crewId?: SortOrder
    permission?: SortOrder
  }

  export type CrewInventoryInventoryIdCrewIdCompoundUniqueInput = {
    inventoryId: string
    crewId: string
  }

  export type CrewInventoryCountOrderByAggregateInput = {
    inventoryId?: SortOrder
    crewId?: SortOrder
  }

  export type CrewInventoryMaxOrderByAggregateInput = {
    inventoryId?: SortOrder
    crewId?: SortOrder
  }

  export type CrewInventoryMinOrderByAggregateInput = {
    inventoryId?: SortOrder
    crewId?: SortOrder
  }

  export type CrewStorageStorageIdCrewIdCompoundUniqueInput = {
    storageId: string
    crewId: string
  }

  export type CrewStorageCountOrderByAggregateInput = {
    storageId?: SortOrder
    crewId?: SortOrder
  }

  export type CrewStorageMaxOrderByAggregateInput = {
    storageId?: SortOrder
    crewId?: SortOrder
  }

  export type CrewStorageMinOrderByAggregateInput = {
    storageId?: SortOrder
    crewId?: SortOrder
  }

  export type CrewIngredientIngredientIdCrewIdCompoundUniqueInput = {
    ingredientId: string
    crewId: string
  }

  export type CrewIngredientCountOrderByAggregateInput = {
    ingredientId?: SortOrder
    crewId?: SortOrder
  }

  export type CrewIngredientMaxOrderByAggregateInput = {
    ingredientId?: SortOrder
    crewId?: SortOrder
  }

  export type CrewIngredientMinOrderByAggregateInput = {
    ingredientId?: SortOrder
    crewId?: SortOrder
  }

  export type CrewRecipeBookRecipeBookIdCrewIdCompoundUniqueInput = {
    recipeBookId: string
    crewId: string
  }

  export type CrewRecipeBookCountOrderByAggregateInput = {
    recipeBookId?: SortOrder
    crewId?: SortOrder
  }

  export type CrewRecipeBookMaxOrderByAggregateInput = {
    recipeBookId?: SortOrder
    crewId?: SortOrder
  }

  export type CrewRecipeBookMinOrderByAggregateInput = {
    recipeBookId?: SortOrder
    crewId?: SortOrder
  }

  export type CrewBuildBuildIdCrewIdCompoundUniqueInput = {
    buildId: string
    crewId: string
  }

  export type CrewBuildCountOrderByAggregateInput = {
    buildId?: SortOrder
    crewId?: SortOrder
  }

  export type CrewBuildMaxOrderByAggregateInput = {
    buildId?: SortOrder
    crewId?: SortOrder
  }

  export type CrewBuildMinOrderByAggregateInput = {
    buildId?: SortOrder
    crewId?: SortOrder
  }

  export type ProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type RecipeBookUserCreateNestedManyWithoutUserInput = {
    create?: XOR<RecipeBookUserCreateWithoutUserInput, RecipeBookUserUncheckedCreateWithoutUserInput> | RecipeBookUserCreateWithoutUserInput[] | RecipeBookUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecipeBookUserCreateOrConnectWithoutUserInput | RecipeBookUserCreateOrConnectWithoutUserInput[]
    createMany?: RecipeBookUserCreateManyUserInputEnvelope
    connect?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
  }

  export type RecipeBookCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<RecipeBookCreateWithoutCreatedByInput, RecipeBookUncheckedCreateWithoutCreatedByInput> | RecipeBookCreateWithoutCreatedByInput[] | RecipeBookUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RecipeBookCreateOrConnectWithoutCreatedByInput | RecipeBookCreateOrConnectWithoutCreatedByInput[]
    createMany?: RecipeBookCreateManyCreatedByInputEnvelope
    connect?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
  }

  export type RecipeBookCreateNestedManyWithoutEditedByInput = {
    create?: XOR<RecipeBookCreateWithoutEditedByInput, RecipeBookUncheckedCreateWithoutEditedByInput> | RecipeBookCreateWithoutEditedByInput[] | RecipeBookUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: RecipeBookCreateOrConnectWithoutEditedByInput | RecipeBookCreateOrConnectWithoutEditedByInput[]
    createMany?: RecipeBookCreateManyEditedByInputEnvelope
    connect?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
  }

  export type RecipeCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<RecipeCreateWithoutCreatedByInput, RecipeUncheckedCreateWithoutCreatedByInput> | RecipeCreateWithoutCreatedByInput[] | RecipeUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutCreatedByInput | RecipeCreateOrConnectWithoutCreatedByInput[]
    createMany?: RecipeCreateManyCreatedByInputEnvelope
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
  }

  export type RecipeCreateNestedManyWithoutEditedByInput = {
    create?: XOR<RecipeCreateWithoutEditedByInput, RecipeUncheckedCreateWithoutEditedByInput> | RecipeCreateWithoutEditedByInput[] | RecipeUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutEditedByInput | RecipeCreateOrConnectWithoutEditedByInput[]
    createMany?: RecipeCreateManyEditedByInputEnvelope
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
  }

  export type BuildUserCreateNestedManyWithoutUserInput = {
    create?: XOR<BuildUserCreateWithoutUserInput, BuildUserUncheckedCreateWithoutUserInput> | BuildUserCreateWithoutUserInput[] | BuildUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BuildUserCreateOrConnectWithoutUserInput | BuildUserCreateOrConnectWithoutUserInput[]
    createMany?: BuildUserCreateManyUserInputEnvelope
    connect?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
  }

  export type BuildCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<BuildCreateWithoutCreatedByInput, BuildUncheckedCreateWithoutCreatedByInput> | BuildCreateWithoutCreatedByInput[] | BuildUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BuildCreateOrConnectWithoutCreatedByInput | BuildCreateOrConnectWithoutCreatedByInput[]
    createMany?: BuildCreateManyCreatedByInputEnvelope
    connect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
  }

  export type BuildCreateNestedManyWithoutEditedByInput = {
    create?: XOR<BuildCreateWithoutEditedByInput, BuildUncheckedCreateWithoutEditedByInput> | BuildCreateWithoutEditedByInput[] | BuildUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: BuildCreateOrConnectWithoutEditedByInput | BuildCreateOrConnectWithoutEditedByInput[]
    createMany?: BuildCreateManyEditedByInputEnvelope
    connect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
  }

  export type ArchivedBuildCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ArchivedBuildCreateWithoutCreatedByInput, ArchivedBuildUncheckedCreateWithoutCreatedByInput> | ArchivedBuildCreateWithoutCreatedByInput[] | ArchivedBuildUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ArchivedBuildCreateOrConnectWithoutCreatedByInput | ArchivedBuildCreateOrConnectWithoutCreatedByInput[]
    createMany?: ArchivedBuildCreateManyCreatedByInputEnvelope
    connect?: ArchivedBuildWhereUniqueInput | ArchivedBuildWhereUniqueInput[]
  }

  export type CrewUserCreateNestedManyWithoutUserInput = {
    create?: XOR<CrewUserCreateWithoutUserInput, CrewUserUncheckedCreateWithoutUserInput> | CrewUserCreateWithoutUserInput[] | CrewUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CrewUserCreateOrConnectWithoutUserInput | CrewUserCreateOrConnectWithoutUserInput[]
    createMany?: CrewUserCreateManyUserInputEnvelope
    connect?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
  }

  export type CrewCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<CrewCreateWithoutCreatedByInput, CrewUncheckedCreateWithoutCreatedByInput> | CrewCreateWithoutCreatedByInput[] | CrewUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutCreatedByInput | CrewCreateOrConnectWithoutCreatedByInput[]
    createMany?: CrewCreateManyCreatedByInputEnvelope
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
  }

  export type CrewCreateNestedManyWithoutEditedByInput = {
    create?: XOR<CrewCreateWithoutEditedByInput, CrewUncheckedCreateWithoutEditedByInput> | CrewCreateWithoutEditedByInput[] | CrewUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutEditedByInput | CrewCreateOrConnectWithoutEditedByInput[]
    createMany?: CrewCreateManyEditedByInputEnvelope
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
  }

  export type IngredientCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<IngredientCreateWithoutCreatedByInput, IngredientUncheckedCreateWithoutCreatedByInput> | IngredientCreateWithoutCreatedByInput[] | IngredientUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: IngredientCreateOrConnectWithoutCreatedByInput | IngredientCreateOrConnectWithoutCreatedByInput[]
    createMany?: IngredientCreateManyCreatedByInputEnvelope
    connect?: IngredientWhereUniqueInput | IngredientWhereUniqueInput[]
  }

  export type IngredientPreferenceCreateNestedManyWithoutUserInput = {
    create?: XOR<IngredientPreferenceCreateWithoutUserInput, IngredientPreferenceUncheckedCreateWithoutUserInput> | IngredientPreferenceCreateWithoutUserInput[] | IngredientPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IngredientPreferenceCreateOrConnectWithoutUserInput | IngredientPreferenceCreateOrConnectWithoutUserInput[]
    createMany?: IngredientPreferenceCreateManyUserInputEnvelope
    connect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
  }

  export type IngredientUserCreateNestedManyWithoutUserInput = {
    create?: XOR<IngredientUserCreateWithoutUserInput, IngredientUserUncheckedCreateWithoutUserInput> | IngredientUserCreateWithoutUserInput[] | IngredientUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IngredientUserCreateOrConnectWithoutUserInput | IngredientUserCreateOrConnectWithoutUserInput[]
    createMany?: IngredientUserCreateManyUserInputEnvelope
    connect?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
  }

  export type StorageUserCreateNestedManyWithoutUserInput = {
    create?: XOR<StorageUserCreateWithoutUserInput, StorageUserUncheckedCreateWithoutUserInput> | StorageUserCreateWithoutUserInput[] | StorageUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StorageUserCreateOrConnectWithoutUserInput | StorageUserCreateOrConnectWithoutUserInput[]
    createMany?: StorageUserCreateManyUserInputEnvelope
    connect?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
  }

  export type StorageCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<StorageCreateWithoutCreatedByInput, StorageUncheckedCreateWithoutCreatedByInput> | StorageCreateWithoutCreatedByInput[] | StorageUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StorageCreateOrConnectWithoutCreatedByInput | StorageCreateOrConnectWithoutCreatedByInput[]
    createMany?: StorageCreateManyCreatedByInputEnvelope
    connect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
  }

  export type StorageCreateNestedManyWithoutEditedByInput = {
    create?: XOR<StorageCreateWithoutEditedByInput, StorageUncheckedCreateWithoutEditedByInput> | StorageCreateWithoutEditedByInput[] | StorageUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: StorageCreateOrConnectWithoutEditedByInput | StorageCreateOrConnectWithoutEditedByInput[]
    createMany?: StorageCreateManyEditedByInputEnvelope
    connect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
  }

  export type InventoryCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<InventoryCreateWithoutCreatedByInput, InventoryUncheckedCreateWithoutCreatedByInput> | InventoryCreateWithoutCreatedByInput[] | InventoryUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutCreatedByInput | InventoryCreateOrConnectWithoutCreatedByInput[]
    createMany?: InventoryCreateManyCreatedByInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type InventoryCreateNestedManyWithoutEditedByInput = {
    create?: XOR<InventoryCreateWithoutEditedByInput, InventoryUncheckedCreateWithoutEditedByInput> | InventoryCreateWithoutEditedByInput[] | InventoryUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutEditedByInput | InventoryCreateOrConnectWithoutEditedByInput[]
    createMany?: InventoryCreateManyEditedByInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type InventoryUserCreateNestedManyWithoutUserInput = {
    create?: XOR<InventoryUserCreateWithoutUserInput, InventoryUserUncheckedCreateWithoutUserInput> | InventoryUserCreateWithoutUserInput[] | InventoryUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryUserCreateOrConnectWithoutUserInput | InventoryUserCreateOrConnectWithoutUserInput[]
    createMany?: InventoryUserCreateManyUserInputEnvelope
    connect?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
  }

  export type FollowCreateNestedManyWithoutFollowedByInput = {
    create?: XOR<FollowCreateWithoutFollowedByInput, FollowUncheckedCreateWithoutFollowedByInput> | FollowCreateWithoutFollowedByInput[] | FollowUncheckedCreateWithoutFollowedByInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowedByInput | FollowCreateOrConnectWithoutFollowedByInput[]
    createMany?: FollowCreateManyFollowedByInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type FollowCreateNestedManyWithoutFollowingInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type RecipeBookUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RecipeBookUserCreateWithoutUserInput, RecipeBookUserUncheckedCreateWithoutUserInput> | RecipeBookUserCreateWithoutUserInput[] | RecipeBookUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecipeBookUserCreateOrConnectWithoutUserInput | RecipeBookUserCreateOrConnectWithoutUserInput[]
    createMany?: RecipeBookUserCreateManyUserInputEnvelope
    connect?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
  }

  export type RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<RecipeBookCreateWithoutCreatedByInput, RecipeBookUncheckedCreateWithoutCreatedByInput> | RecipeBookCreateWithoutCreatedByInput[] | RecipeBookUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RecipeBookCreateOrConnectWithoutCreatedByInput | RecipeBookCreateOrConnectWithoutCreatedByInput[]
    createMany?: RecipeBookCreateManyCreatedByInputEnvelope
    connect?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
  }

  export type RecipeBookUncheckedCreateNestedManyWithoutEditedByInput = {
    create?: XOR<RecipeBookCreateWithoutEditedByInput, RecipeBookUncheckedCreateWithoutEditedByInput> | RecipeBookCreateWithoutEditedByInput[] | RecipeBookUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: RecipeBookCreateOrConnectWithoutEditedByInput | RecipeBookCreateOrConnectWithoutEditedByInput[]
    createMany?: RecipeBookCreateManyEditedByInputEnvelope
    connect?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
  }

  export type RecipeUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<RecipeCreateWithoutCreatedByInput, RecipeUncheckedCreateWithoutCreatedByInput> | RecipeCreateWithoutCreatedByInput[] | RecipeUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutCreatedByInput | RecipeCreateOrConnectWithoutCreatedByInput[]
    createMany?: RecipeCreateManyCreatedByInputEnvelope
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
  }

  export type RecipeUncheckedCreateNestedManyWithoutEditedByInput = {
    create?: XOR<RecipeCreateWithoutEditedByInput, RecipeUncheckedCreateWithoutEditedByInput> | RecipeCreateWithoutEditedByInput[] | RecipeUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutEditedByInput | RecipeCreateOrConnectWithoutEditedByInput[]
    createMany?: RecipeCreateManyEditedByInputEnvelope
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
  }

  export type BuildUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BuildUserCreateWithoutUserInput, BuildUserUncheckedCreateWithoutUserInput> | BuildUserCreateWithoutUserInput[] | BuildUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BuildUserCreateOrConnectWithoutUserInput | BuildUserCreateOrConnectWithoutUserInput[]
    createMany?: BuildUserCreateManyUserInputEnvelope
    connect?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
  }

  export type BuildUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<BuildCreateWithoutCreatedByInput, BuildUncheckedCreateWithoutCreatedByInput> | BuildCreateWithoutCreatedByInput[] | BuildUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BuildCreateOrConnectWithoutCreatedByInput | BuildCreateOrConnectWithoutCreatedByInput[]
    createMany?: BuildCreateManyCreatedByInputEnvelope
    connect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
  }

  export type BuildUncheckedCreateNestedManyWithoutEditedByInput = {
    create?: XOR<BuildCreateWithoutEditedByInput, BuildUncheckedCreateWithoutEditedByInput> | BuildCreateWithoutEditedByInput[] | BuildUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: BuildCreateOrConnectWithoutEditedByInput | BuildCreateOrConnectWithoutEditedByInput[]
    createMany?: BuildCreateManyEditedByInputEnvelope
    connect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
  }

  export type ArchivedBuildUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ArchivedBuildCreateWithoutCreatedByInput, ArchivedBuildUncheckedCreateWithoutCreatedByInput> | ArchivedBuildCreateWithoutCreatedByInput[] | ArchivedBuildUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ArchivedBuildCreateOrConnectWithoutCreatedByInput | ArchivedBuildCreateOrConnectWithoutCreatedByInput[]
    createMany?: ArchivedBuildCreateManyCreatedByInputEnvelope
    connect?: ArchivedBuildWhereUniqueInput | ArchivedBuildWhereUniqueInput[]
  }

  export type CrewUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CrewUserCreateWithoutUserInput, CrewUserUncheckedCreateWithoutUserInput> | CrewUserCreateWithoutUserInput[] | CrewUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CrewUserCreateOrConnectWithoutUserInput | CrewUserCreateOrConnectWithoutUserInput[]
    createMany?: CrewUserCreateManyUserInputEnvelope
    connect?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
  }

  export type CrewUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<CrewCreateWithoutCreatedByInput, CrewUncheckedCreateWithoutCreatedByInput> | CrewCreateWithoutCreatedByInput[] | CrewUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutCreatedByInput | CrewCreateOrConnectWithoutCreatedByInput[]
    createMany?: CrewCreateManyCreatedByInputEnvelope
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
  }

  export type CrewUncheckedCreateNestedManyWithoutEditedByInput = {
    create?: XOR<CrewCreateWithoutEditedByInput, CrewUncheckedCreateWithoutEditedByInput> | CrewCreateWithoutEditedByInput[] | CrewUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutEditedByInput | CrewCreateOrConnectWithoutEditedByInput[]
    createMany?: CrewCreateManyEditedByInputEnvelope
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
  }

  export type IngredientUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<IngredientCreateWithoutCreatedByInput, IngredientUncheckedCreateWithoutCreatedByInput> | IngredientCreateWithoutCreatedByInput[] | IngredientUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: IngredientCreateOrConnectWithoutCreatedByInput | IngredientCreateOrConnectWithoutCreatedByInput[]
    createMany?: IngredientCreateManyCreatedByInputEnvelope
    connect?: IngredientWhereUniqueInput | IngredientWhereUniqueInput[]
  }

  export type IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<IngredientPreferenceCreateWithoutUserInput, IngredientPreferenceUncheckedCreateWithoutUserInput> | IngredientPreferenceCreateWithoutUserInput[] | IngredientPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IngredientPreferenceCreateOrConnectWithoutUserInput | IngredientPreferenceCreateOrConnectWithoutUserInput[]
    createMany?: IngredientPreferenceCreateManyUserInputEnvelope
    connect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
  }

  export type IngredientUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<IngredientUserCreateWithoutUserInput, IngredientUserUncheckedCreateWithoutUserInput> | IngredientUserCreateWithoutUserInput[] | IngredientUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IngredientUserCreateOrConnectWithoutUserInput | IngredientUserCreateOrConnectWithoutUserInput[]
    createMany?: IngredientUserCreateManyUserInputEnvelope
    connect?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
  }

  export type StorageUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StorageUserCreateWithoutUserInput, StorageUserUncheckedCreateWithoutUserInput> | StorageUserCreateWithoutUserInput[] | StorageUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StorageUserCreateOrConnectWithoutUserInput | StorageUserCreateOrConnectWithoutUserInput[]
    createMany?: StorageUserCreateManyUserInputEnvelope
    connect?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
  }

  export type StorageUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<StorageCreateWithoutCreatedByInput, StorageUncheckedCreateWithoutCreatedByInput> | StorageCreateWithoutCreatedByInput[] | StorageUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StorageCreateOrConnectWithoutCreatedByInput | StorageCreateOrConnectWithoutCreatedByInput[]
    createMany?: StorageCreateManyCreatedByInputEnvelope
    connect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
  }

  export type StorageUncheckedCreateNestedManyWithoutEditedByInput = {
    create?: XOR<StorageCreateWithoutEditedByInput, StorageUncheckedCreateWithoutEditedByInput> | StorageCreateWithoutEditedByInput[] | StorageUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: StorageCreateOrConnectWithoutEditedByInput | StorageCreateOrConnectWithoutEditedByInput[]
    createMany?: StorageCreateManyEditedByInputEnvelope
    connect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
  }

  export type InventoryUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<InventoryCreateWithoutCreatedByInput, InventoryUncheckedCreateWithoutCreatedByInput> | InventoryCreateWithoutCreatedByInput[] | InventoryUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutCreatedByInput | InventoryCreateOrConnectWithoutCreatedByInput[]
    createMany?: InventoryCreateManyCreatedByInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type InventoryUncheckedCreateNestedManyWithoutEditedByInput = {
    create?: XOR<InventoryCreateWithoutEditedByInput, InventoryUncheckedCreateWithoutEditedByInput> | InventoryCreateWithoutEditedByInput[] | InventoryUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutEditedByInput | InventoryCreateOrConnectWithoutEditedByInput[]
    createMany?: InventoryCreateManyEditedByInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type InventoryUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InventoryUserCreateWithoutUserInput, InventoryUserUncheckedCreateWithoutUserInput> | InventoryUserCreateWithoutUserInput[] | InventoryUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryUserCreateOrConnectWithoutUserInput | InventoryUserCreateOrConnectWithoutUserInput[]
    createMany?: InventoryUserCreateManyUserInputEnvelope
    connect?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
  }

  export type FollowUncheckedCreateNestedManyWithoutFollowedByInput = {
    create?: XOR<FollowCreateWithoutFollowedByInput, FollowUncheckedCreateWithoutFollowedByInput> | FollowCreateWithoutFollowedByInput[] | FollowUncheckedCreateWithoutFollowedByInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowedByInput | FollowCreateOrConnectWithoutFollowedByInput[]
    createMany?: FollowCreateManyFollowedByInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type FollowUncheckedCreateNestedManyWithoutFollowingInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type RecipeBookUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<RecipeBookUserCreateWithoutUserInput, RecipeBookUserUncheckedCreateWithoutUserInput> | RecipeBookUserCreateWithoutUserInput[] | RecipeBookUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecipeBookUserCreateOrConnectWithoutUserInput | RecipeBookUserCreateOrConnectWithoutUserInput[]
    upsert?: RecipeBookUserUpsertWithWhereUniqueWithoutUserInput | RecipeBookUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RecipeBookUserCreateManyUserInputEnvelope
    set?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
    disconnect?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
    delete?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
    connect?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
    update?: RecipeBookUserUpdateWithWhereUniqueWithoutUserInput | RecipeBookUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RecipeBookUserUpdateManyWithWhereWithoutUserInput | RecipeBookUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RecipeBookUserScalarWhereInput | RecipeBookUserScalarWhereInput[]
  }

  export type RecipeBookUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<RecipeBookCreateWithoutCreatedByInput, RecipeBookUncheckedCreateWithoutCreatedByInput> | RecipeBookCreateWithoutCreatedByInput[] | RecipeBookUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RecipeBookCreateOrConnectWithoutCreatedByInput | RecipeBookCreateOrConnectWithoutCreatedByInput[]
    upsert?: RecipeBookUpsertWithWhereUniqueWithoutCreatedByInput | RecipeBookUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: RecipeBookCreateManyCreatedByInputEnvelope
    set?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
    disconnect?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
    delete?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
    connect?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
    update?: RecipeBookUpdateWithWhereUniqueWithoutCreatedByInput | RecipeBookUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: RecipeBookUpdateManyWithWhereWithoutCreatedByInput | RecipeBookUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: RecipeBookScalarWhereInput | RecipeBookScalarWhereInput[]
  }

  export type RecipeBookUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<RecipeBookCreateWithoutEditedByInput, RecipeBookUncheckedCreateWithoutEditedByInput> | RecipeBookCreateWithoutEditedByInput[] | RecipeBookUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: RecipeBookCreateOrConnectWithoutEditedByInput | RecipeBookCreateOrConnectWithoutEditedByInput[]
    upsert?: RecipeBookUpsertWithWhereUniqueWithoutEditedByInput | RecipeBookUpsertWithWhereUniqueWithoutEditedByInput[]
    createMany?: RecipeBookCreateManyEditedByInputEnvelope
    set?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
    disconnect?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
    delete?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
    connect?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
    update?: RecipeBookUpdateWithWhereUniqueWithoutEditedByInput | RecipeBookUpdateWithWhereUniqueWithoutEditedByInput[]
    updateMany?: RecipeBookUpdateManyWithWhereWithoutEditedByInput | RecipeBookUpdateManyWithWhereWithoutEditedByInput[]
    deleteMany?: RecipeBookScalarWhereInput | RecipeBookScalarWhereInput[]
  }

  export type RecipeUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<RecipeCreateWithoutCreatedByInput, RecipeUncheckedCreateWithoutCreatedByInput> | RecipeCreateWithoutCreatedByInput[] | RecipeUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutCreatedByInput | RecipeCreateOrConnectWithoutCreatedByInput[]
    upsert?: RecipeUpsertWithWhereUniqueWithoutCreatedByInput | RecipeUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: RecipeCreateManyCreatedByInputEnvelope
    set?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    disconnect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    delete?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    update?: RecipeUpdateWithWhereUniqueWithoutCreatedByInput | RecipeUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: RecipeUpdateManyWithWhereWithoutCreatedByInput | RecipeUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
  }

  export type RecipeUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<RecipeCreateWithoutEditedByInput, RecipeUncheckedCreateWithoutEditedByInput> | RecipeCreateWithoutEditedByInput[] | RecipeUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutEditedByInput | RecipeCreateOrConnectWithoutEditedByInput[]
    upsert?: RecipeUpsertWithWhereUniqueWithoutEditedByInput | RecipeUpsertWithWhereUniqueWithoutEditedByInput[]
    createMany?: RecipeCreateManyEditedByInputEnvelope
    set?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    disconnect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    delete?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    update?: RecipeUpdateWithWhereUniqueWithoutEditedByInput | RecipeUpdateWithWhereUniqueWithoutEditedByInput[]
    updateMany?: RecipeUpdateManyWithWhereWithoutEditedByInput | RecipeUpdateManyWithWhereWithoutEditedByInput[]
    deleteMany?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
  }

  export type BuildUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<BuildUserCreateWithoutUserInput, BuildUserUncheckedCreateWithoutUserInput> | BuildUserCreateWithoutUserInput[] | BuildUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BuildUserCreateOrConnectWithoutUserInput | BuildUserCreateOrConnectWithoutUserInput[]
    upsert?: BuildUserUpsertWithWhereUniqueWithoutUserInput | BuildUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BuildUserCreateManyUserInputEnvelope
    set?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
    disconnect?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
    delete?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
    connect?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
    update?: BuildUserUpdateWithWhereUniqueWithoutUserInput | BuildUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BuildUserUpdateManyWithWhereWithoutUserInput | BuildUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BuildUserScalarWhereInput | BuildUserScalarWhereInput[]
  }

  export type BuildUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<BuildCreateWithoutCreatedByInput, BuildUncheckedCreateWithoutCreatedByInput> | BuildCreateWithoutCreatedByInput[] | BuildUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BuildCreateOrConnectWithoutCreatedByInput | BuildCreateOrConnectWithoutCreatedByInput[]
    upsert?: BuildUpsertWithWhereUniqueWithoutCreatedByInput | BuildUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: BuildCreateManyCreatedByInputEnvelope
    set?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    disconnect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    delete?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    connect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    update?: BuildUpdateWithWhereUniqueWithoutCreatedByInput | BuildUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: BuildUpdateManyWithWhereWithoutCreatedByInput | BuildUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: BuildScalarWhereInput | BuildScalarWhereInput[]
  }

  export type BuildUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<BuildCreateWithoutEditedByInput, BuildUncheckedCreateWithoutEditedByInput> | BuildCreateWithoutEditedByInput[] | BuildUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: BuildCreateOrConnectWithoutEditedByInput | BuildCreateOrConnectWithoutEditedByInput[]
    upsert?: BuildUpsertWithWhereUniqueWithoutEditedByInput | BuildUpsertWithWhereUniqueWithoutEditedByInput[]
    createMany?: BuildCreateManyEditedByInputEnvelope
    set?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    disconnect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    delete?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    connect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    update?: BuildUpdateWithWhereUniqueWithoutEditedByInput | BuildUpdateWithWhereUniqueWithoutEditedByInput[]
    updateMany?: BuildUpdateManyWithWhereWithoutEditedByInput | BuildUpdateManyWithWhereWithoutEditedByInput[]
    deleteMany?: BuildScalarWhereInput | BuildScalarWhereInput[]
  }

  export type ArchivedBuildUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ArchivedBuildCreateWithoutCreatedByInput, ArchivedBuildUncheckedCreateWithoutCreatedByInput> | ArchivedBuildCreateWithoutCreatedByInput[] | ArchivedBuildUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ArchivedBuildCreateOrConnectWithoutCreatedByInput | ArchivedBuildCreateOrConnectWithoutCreatedByInput[]
    upsert?: ArchivedBuildUpsertWithWhereUniqueWithoutCreatedByInput | ArchivedBuildUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ArchivedBuildCreateManyCreatedByInputEnvelope
    set?: ArchivedBuildWhereUniqueInput | ArchivedBuildWhereUniqueInput[]
    disconnect?: ArchivedBuildWhereUniqueInput | ArchivedBuildWhereUniqueInput[]
    delete?: ArchivedBuildWhereUniqueInput | ArchivedBuildWhereUniqueInput[]
    connect?: ArchivedBuildWhereUniqueInput | ArchivedBuildWhereUniqueInput[]
    update?: ArchivedBuildUpdateWithWhereUniqueWithoutCreatedByInput | ArchivedBuildUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ArchivedBuildUpdateManyWithWhereWithoutCreatedByInput | ArchivedBuildUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ArchivedBuildScalarWhereInput | ArchivedBuildScalarWhereInput[]
  }

  export type CrewUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<CrewUserCreateWithoutUserInput, CrewUserUncheckedCreateWithoutUserInput> | CrewUserCreateWithoutUserInput[] | CrewUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CrewUserCreateOrConnectWithoutUserInput | CrewUserCreateOrConnectWithoutUserInput[]
    upsert?: CrewUserUpsertWithWhereUniqueWithoutUserInput | CrewUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CrewUserCreateManyUserInputEnvelope
    set?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
    disconnect?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
    delete?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
    connect?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
    update?: CrewUserUpdateWithWhereUniqueWithoutUserInput | CrewUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CrewUserUpdateManyWithWhereWithoutUserInput | CrewUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CrewUserScalarWhereInput | CrewUserScalarWhereInput[]
  }

  export type CrewUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<CrewCreateWithoutCreatedByInput, CrewUncheckedCreateWithoutCreatedByInput> | CrewCreateWithoutCreatedByInput[] | CrewUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutCreatedByInput | CrewCreateOrConnectWithoutCreatedByInput[]
    upsert?: CrewUpsertWithWhereUniqueWithoutCreatedByInput | CrewUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: CrewCreateManyCreatedByInputEnvelope
    set?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    disconnect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    delete?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    update?: CrewUpdateWithWhereUniqueWithoutCreatedByInput | CrewUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: CrewUpdateManyWithWhereWithoutCreatedByInput | CrewUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: CrewScalarWhereInput | CrewScalarWhereInput[]
  }

  export type CrewUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<CrewCreateWithoutEditedByInput, CrewUncheckedCreateWithoutEditedByInput> | CrewCreateWithoutEditedByInput[] | CrewUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutEditedByInput | CrewCreateOrConnectWithoutEditedByInput[]
    upsert?: CrewUpsertWithWhereUniqueWithoutEditedByInput | CrewUpsertWithWhereUniqueWithoutEditedByInput[]
    createMany?: CrewCreateManyEditedByInputEnvelope
    set?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    disconnect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    delete?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    update?: CrewUpdateWithWhereUniqueWithoutEditedByInput | CrewUpdateWithWhereUniqueWithoutEditedByInput[]
    updateMany?: CrewUpdateManyWithWhereWithoutEditedByInput | CrewUpdateManyWithWhereWithoutEditedByInput[]
    deleteMany?: CrewScalarWhereInput | CrewScalarWhereInput[]
  }

  export type IngredientUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<IngredientCreateWithoutCreatedByInput, IngredientUncheckedCreateWithoutCreatedByInput> | IngredientCreateWithoutCreatedByInput[] | IngredientUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: IngredientCreateOrConnectWithoutCreatedByInput | IngredientCreateOrConnectWithoutCreatedByInput[]
    upsert?: IngredientUpsertWithWhereUniqueWithoutCreatedByInput | IngredientUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: IngredientCreateManyCreatedByInputEnvelope
    set?: IngredientWhereUniqueInput | IngredientWhereUniqueInput[]
    disconnect?: IngredientWhereUniqueInput | IngredientWhereUniqueInput[]
    delete?: IngredientWhereUniqueInput | IngredientWhereUniqueInput[]
    connect?: IngredientWhereUniqueInput | IngredientWhereUniqueInput[]
    update?: IngredientUpdateWithWhereUniqueWithoutCreatedByInput | IngredientUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: IngredientUpdateManyWithWhereWithoutCreatedByInput | IngredientUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: IngredientScalarWhereInput | IngredientScalarWhereInput[]
  }

  export type IngredientPreferenceUpdateManyWithoutUserNestedInput = {
    create?: XOR<IngredientPreferenceCreateWithoutUserInput, IngredientPreferenceUncheckedCreateWithoutUserInput> | IngredientPreferenceCreateWithoutUserInput[] | IngredientPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IngredientPreferenceCreateOrConnectWithoutUserInput | IngredientPreferenceCreateOrConnectWithoutUserInput[]
    upsert?: IngredientPreferenceUpsertWithWhereUniqueWithoutUserInput | IngredientPreferenceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IngredientPreferenceCreateManyUserInputEnvelope
    set?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    disconnect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    delete?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    connect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    update?: IngredientPreferenceUpdateWithWhereUniqueWithoutUserInput | IngredientPreferenceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IngredientPreferenceUpdateManyWithWhereWithoutUserInput | IngredientPreferenceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IngredientPreferenceScalarWhereInput | IngredientPreferenceScalarWhereInput[]
  }

  export type IngredientUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<IngredientUserCreateWithoutUserInput, IngredientUserUncheckedCreateWithoutUserInput> | IngredientUserCreateWithoutUserInput[] | IngredientUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IngredientUserCreateOrConnectWithoutUserInput | IngredientUserCreateOrConnectWithoutUserInput[]
    upsert?: IngredientUserUpsertWithWhereUniqueWithoutUserInput | IngredientUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IngredientUserCreateManyUserInputEnvelope
    set?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
    disconnect?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
    delete?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
    connect?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
    update?: IngredientUserUpdateWithWhereUniqueWithoutUserInput | IngredientUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IngredientUserUpdateManyWithWhereWithoutUserInput | IngredientUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IngredientUserScalarWhereInput | IngredientUserScalarWhereInput[]
  }

  export type StorageUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<StorageUserCreateWithoutUserInput, StorageUserUncheckedCreateWithoutUserInput> | StorageUserCreateWithoutUserInput[] | StorageUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StorageUserCreateOrConnectWithoutUserInput | StorageUserCreateOrConnectWithoutUserInput[]
    upsert?: StorageUserUpsertWithWhereUniqueWithoutUserInput | StorageUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StorageUserCreateManyUserInputEnvelope
    set?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
    disconnect?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
    delete?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
    connect?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
    update?: StorageUserUpdateWithWhereUniqueWithoutUserInput | StorageUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StorageUserUpdateManyWithWhereWithoutUserInput | StorageUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StorageUserScalarWhereInput | StorageUserScalarWhereInput[]
  }

  export type StorageUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<StorageCreateWithoutCreatedByInput, StorageUncheckedCreateWithoutCreatedByInput> | StorageCreateWithoutCreatedByInput[] | StorageUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StorageCreateOrConnectWithoutCreatedByInput | StorageCreateOrConnectWithoutCreatedByInput[]
    upsert?: StorageUpsertWithWhereUniqueWithoutCreatedByInput | StorageUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: StorageCreateManyCreatedByInputEnvelope
    set?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    disconnect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    delete?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    connect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    update?: StorageUpdateWithWhereUniqueWithoutCreatedByInput | StorageUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: StorageUpdateManyWithWhereWithoutCreatedByInput | StorageUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: StorageScalarWhereInput | StorageScalarWhereInput[]
  }

  export type StorageUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<StorageCreateWithoutEditedByInput, StorageUncheckedCreateWithoutEditedByInput> | StorageCreateWithoutEditedByInput[] | StorageUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: StorageCreateOrConnectWithoutEditedByInput | StorageCreateOrConnectWithoutEditedByInput[]
    upsert?: StorageUpsertWithWhereUniqueWithoutEditedByInput | StorageUpsertWithWhereUniqueWithoutEditedByInput[]
    createMany?: StorageCreateManyEditedByInputEnvelope
    set?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    disconnect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    delete?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    connect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    update?: StorageUpdateWithWhereUniqueWithoutEditedByInput | StorageUpdateWithWhereUniqueWithoutEditedByInput[]
    updateMany?: StorageUpdateManyWithWhereWithoutEditedByInput | StorageUpdateManyWithWhereWithoutEditedByInput[]
    deleteMany?: StorageScalarWhereInput | StorageScalarWhereInput[]
  }

  export type InventoryUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<InventoryCreateWithoutCreatedByInput, InventoryUncheckedCreateWithoutCreatedByInput> | InventoryCreateWithoutCreatedByInput[] | InventoryUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutCreatedByInput | InventoryCreateOrConnectWithoutCreatedByInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutCreatedByInput | InventoryUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: InventoryCreateManyCreatedByInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutCreatedByInput | InventoryUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutCreatedByInput | InventoryUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type InventoryUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<InventoryCreateWithoutEditedByInput, InventoryUncheckedCreateWithoutEditedByInput> | InventoryCreateWithoutEditedByInput[] | InventoryUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutEditedByInput | InventoryCreateOrConnectWithoutEditedByInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutEditedByInput | InventoryUpsertWithWhereUniqueWithoutEditedByInput[]
    createMany?: InventoryCreateManyEditedByInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutEditedByInput | InventoryUpdateWithWhereUniqueWithoutEditedByInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutEditedByInput | InventoryUpdateManyWithWhereWithoutEditedByInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type InventoryUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<InventoryUserCreateWithoutUserInput, InventoryUserUncheckedCreateWithoutUserInput> | InventoryUserCreateWithoutUserInput[] | InventoryUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryUserCreateOrConnectWithoutUserInput | InventoryUserCreateOrConnectWithoutUserInput[]
    upsert?: InventoryUserUpsertWithWhereUniqueWithoutUserInput | InventoryUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InventoryUserCreateManyUserInputEnvelope
    set?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
    disconnect?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
    delete?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
    connect?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
    update?: InventoryUserUpdateWithWhereUniqueWithoutUserInput | InventoryUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InventoryUserUpdateManyWithWhereWithoutUserInput | InventoryUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InventoryUserScalarWhereInput | InventoryUserScalarWhereInput[]
  }

  export type FollowUpdateManyWithoutFollowedByNestedInput = {
    create?: XOR<FollowCreateWithoutFollowedByInput, FollowUncheckedCreateWithoutFollowedByInput> | FollowCreateWithoutFollowedByInput[] | FollowUncheckedCreateWithoutFollowedByInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowedByInput | FollowCreateOrConnectWithoutFollowedByInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowedByInput | FollowUpsertWithWhereUniqueWithoutFollowedByInput[]
    createMany?: FollowCreateManyFollowedByInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowedByInput | FollowUpdateWithWhereUniqueWithoutFollowedByInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowedByInput | FollowUpdateManyWithWhereWithoutFollowedByInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type FollowUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowingInput | FollowUpsertWithWhereUniqueWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowingInput | FollowUpdateWithWhereUniqueWithoutFollowingInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowingInput | FollowUpdateManyWithWhereWithoutFollowingInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type ProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RecipeBookUserCreateWithoutUserInput, RecipeBookUserUncheckedCreateWithoutUserInput> | RecipeBookUserCreateWithoutUserInput[] | RecipeBookUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecipeBookUserCreateOrConnectWithoutUserInput | RecipeBookUserCreateOrConnectWithoutUserInput[]
    upsert?: RecipeBookUserUpsertWithWhereUniqueWithoutUserInput | RecipeBookUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RecipeBookUserCreateManyUserInputEnvelope
    set?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
    disconnect?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
    delete?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
    connect?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
    update?: RecipeBookUserUpdateWithWhereUniqueWithoutUserInput | RecipeBookUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RecipeBookUserUpdateManyWithWhereWithoutUserInput | RecipeBookUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RecipeBookUserScalarWhereInput | RecipeBookUserScalarWhereInput[]
  }

  export type RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<RecipeBookCreateWithoutCreatedByInput, RecipeBookUncheckedCreateWithoutCreatedByInput> | RecipeBookCreateWithoutCreatedByInput[] | RecipeBookUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RecipeBookCreateOrConnectWithoutCreatedByInput | RecipeBookCreateOrConnectWithoutCreatedByInput[]
    upsert?: RecipeBookUpsertWithWhereUniqueWithoutCreatedByInput | RecipeBookUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: RecipeBookCreateManyCreatedByInputEnvelope
    set?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
    disconnect?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
    delete?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
    connect?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
    update?: RecipeBookUpdateWithWhereUniqueWithoutCreatedByInput | RecipeBookUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: RecipeBookUpdateManyWithWhereWithoutCreatedByInput | RecipeBookUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: RecipeBookScalarWhereInput | RecipeBookScalarWhereInput[]
  }

  export type RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<RecipeBookCreateWithoutEditedByInput, RecipeBookUncheckedCreateWithoutEditedByInput> | RecipeBookCreateWithoutEditedByInput[] | RecipeBookUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: RecipeBookCreateOrConnectWithoutEditedByInput | RecipeBookCreateOrConnectWithoutEditedByInput[]
    upsert?: RecipeBookUpsertWithWhereUniqueWithoutEditedByInput | RecipeBookUpsertWithWhereUniqueWithoutEditedByInput[]
    createMany?: RecipeBookCreateManyEditedByInputEnvelope
    set?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
    disconnect?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
    delete?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
    connect?: RecipeBookWhereUniqueInput | RecipeBookWhereUniqueInput[]
    update?: RecipeBookUpdateWithWhereUniqueWithoutEditedByInput | RecipeBookUpdateWithWhereUniqueWithoutEditedByInput[]
    updateMany?: RecipeBookUpdateManyWithWhereWithoutEditedByInput | RecipeBookUpdateManyWithWhereWithoutEditedByInput[]
    deleteMany?: RecipeBookScalarWhereInput | RecipeBookScalarWhereInput[]
  }

  export type RecipeUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<RecipeCreateWithoutCreatedByInput, RecipeUncheckedCreateWithoutCreatedByInput> | RecipeCreateWithoutCreatedByInput[] | RecipeUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutCreatedByInput | RecipeCreateOrConnectWithoutCreatedByInput[]
    upsert?: RecipeUpsertWithWhereUniqueWithoutCreatedByInput | RecipeUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: RecipeCreateManyCreatedByInputEnvelope
    set?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    disconnect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    delete?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    update?: RecipeUpdateWithWhereUniqueWithoutCreatedByInput | RecipeUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: RecipeUpdateManyWithWhereWithoutCreatedByInput | RecipeUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
  }

  export type RecipeUncheckedUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<RecipeCreateWithoutEditedByInput, RecipeUncheckedCreateWithoutEditedByInput> | RecipeCreateWithoutEditedByInput[] | RecipeUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutEditedByInput | RecipeCreateOrConnectWithoutEditedByInput[]
    upsert?: RecipeUpsertWithWhereUniqueWithoutEditedByInput | RecipeUpsertWithWhereUniqueWithoutEditedByInput[]
    createMany?: RecipeCreateManyEditedByInputEnvelope
    set?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    disconnect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    delete?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    update?: RecipeUpdateWithWhereUniqueWithoutEditedByInput | RecipeUpdateWithWhereUniqueWithoutEditedByInput[]
    updateMany?: RecipeUpdateManyWithWhereWithoutEditedByInput | RecipeUpdateManyWithWhereWithoutEditedByInput[]
    deleteMany?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
  }

  export type BuildUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BuildUserCreateWithoutUserInput, BuildUserUncheckedCreateWithoutUserInput> | BuildUserCreateWithoutUserInput[] | BuildUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BuildUserCreateOrConnectWithoutUserInput | BuildUserCreateOrConnectWithoutUserInput[]
    upsert?: BuildUserUpsertWithWhereUniqueWithoutUserInput | BuildUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BuildUserCreateManyUserInputEnvelope
    set?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
    disconnect?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
    delete?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
    connect?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
    update?: BuildUserUpdateWithWhereUniqueWithoutUserInput | BuildUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BuildUserUpdateManyWithWhereWithoutUserInput | BuildUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BuildUserScalarWhereInput | BuildUserScalarWhereInput[]
  }

  export type BuildUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<BuildCreateWithoutCreatedByInput, BuildUncheckedCreateWithoutCreatedByInput> | BuildCreateWithoutCreatedByInput[] | BuildUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BuildCreateOrConnectWithoutCreatedByInput | BuildCreateOrConnectWithoutCreatedByInput[]
    upsert?: BuildUpsertWithWhereUniqueWithoutCreatedByInput | BuildUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: BuildCreateManyCreatedByInputEnvelope
    set?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    disconnect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    delete?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    connect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    update?: BuildUpdateWithWhereUniqueWithoutCreatedByInput | BuildUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: BuildUpdateManyWithWhereWithoutCreatedByInput | BuildUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: BuildScalarWhereInput | BuildScalarWhereInput[]
  }

  export type BuildUncheckedUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<BuildCreateWithoutEditedByInput, BuildUncheckedCreateWithoutEditedByInput> | BuildCreateWithoutEditedByInput[] | BuildUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: BuildCreateOrConnectWithoutEditedByInput | BuildCreateOrConnectWithoutEditedByInput[]
    upsert?: BuildUpsertWithWhereUniqueWithoutEditedByInput | BuildUpsertWithWhereUniqueWithoutEditedByInput[]
    createMany?: BuildCreateManyEditedByInputEnvelope
    set?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    disconnect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    delete?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    connect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    update?: BuildUpdateWithWhereUniqueWithoutEditedByInput | BuildUpdateWithWhereUniqueWithoutEditedByInput[]
    updateMany?: BuildUpdateManyWithWhereWithoutEditedByInput | BuildUpdateManyWithWhereWithoutEditedByInput[]
    deleteMany?: BuildScalarWhereInput | BuildScalarWhereInput[]
  }

  export type ArchivedBuildUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ArchivedBuildCreateWithoutCreatedByInput, ArchivedBuildUncheckedCreateWithoutCreatedByInput> | ArchivedBuildCreateWithoutCreatedByInput[] | ArchivedBuildUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ArchivedBuildCreateOrConnectWithoutCreatedByInput | ArchivedBuildCreateOrConnectWithoutCreatedByInput[]
    upsert?: ArchivedBuildUpsertWithWhereUniqueWithoutCreatedByInput | ArchivedBuildUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ArchivedBuildCreateManyCreatedByInputEnvelope
    set?: ArchivedBuildWhereUniqueInput | ArchivedBuildWhereUniqueInput[]
    disconnect?: ArchivedBuildWhereUniqueInput | ArchivedBuildWhereUniqueInput[]
    delete?: ArchivedBuildWhereUniqueInput | ArchivedBuildWhereUniqueInput[]
    connect?: ArchivedBuildWhereUniqueInput | ArchivedBuildWhereUniqueInput[]
    update?: ArchivedBuildUpdateWithWhereUniqueWithoutCreatedByInput | ArchivedBuildUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ArchivedBuildUpdateManyWithWhereWithoutCreatedByInput | ArchivedBuildUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ArchivedBuildScalarWhereInput | ArchivedBuildScalarWhereInput[]
  }

  export type CrewUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CrewUserCreateWithoutUserInput, CrewUserUncheckedCreateWithoutUserInput> | CrewUserCreateWithoutUserInput[] | CrewUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CrewUserCreateOrConnectWithoutUserInput | CrewUserCreateOrConnectWithoutUserInput[]
    upsert?: CrewUserUpsertWithWhereUniqueWithoutUserInput | CrewUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CrewUserCreateManyUserInputEnvelope
    set?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
    disconnect?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
    delete?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
    connect?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
    update?: CrewUserUpdateWithWhereUniqueWithoutUserInput | CrewUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CrewUserUpdateManyWithWhereWithoutUserInput | CrewUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CrewUserScalarWhereInput | CrewUserScalarWhereInput[]
  }

  export type CrewUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<CrewCreateWithoutCreatedByInput, CrewUncheckedCreateWithoutCreatedByInput> | CrewCreateWithoutCreatedByInput[] | CrewUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutCreatedByInput | CrewCreateOrConnectWithoutCreatedByInput[]
    upsert?: CrewUpsertWithWhereUniqueWithoutCreatedByInput | CrewUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: CrewCreateManyCreatedByInputEnvelope
    set?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    disconnect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    delete?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    update?: CrewUpdateWithWhereUniqueWithoutCreatedByInput | CrewUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: CrewUpdateManyWithWhereWithoutCreatedByInput | CrewUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: CrewScalarWhereInput | CrewScalarWhereInput[]
  }

  export type CrewUncheckedUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<CrewCreateWithoutEditedByInput, CrewUncheckedCreateWithoutEditedByInput> | CrewCreateWithoutEditedByInput[] | CrewUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutEditedByInput | CrewCreateOrConnectWithoutEditedByInput[]
    upsert?: CrewUpsertWithWhereUniqueWithoutEditedByInput | CrewUpsertWithWhereUniqueWithoutEditedByInput[]
    createMany?: CrewCreateManyEditedByInputEnvelope
    set?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    disconnect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    delete?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    update?: CrewUpdateWithWhereUniqueWithoutEditedByInput | CrewUpdateWithWhereUniqueWithoutEditedByInput[]
    updateMany?: CrewUpdateManyWithWhereWithoutEditedByInput | CrewUpdateManyWithWhereWithoutEditedByInput[]
    deleteMany?: CrewScalarWhereInput | CrewScalarWhereInput[]
  }

  export type IngredientUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<IngredientCreateWithoutCreatedByInput, IngredientUncheckedCreateWithoutCreatedByInput> | IngredientCreateWithoutCreatedByInput[] | IngredientUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: IngredientCreateOrConnectWithoutCreatedByInput | IngredientCreateOrConnectWithoutCreatedByInput[]
    upsert?: IngredientUpsertWithWhereUniqueWithoutCreatedByInput | IngredientUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: IngredientCreateManyCreatedByInputEnvelope
    set?: IngredientWhereUniqueInput | IngredientWhereUniqueInput[]
    disconnect?: IngredientWhereUniqueInput | IngredientWhereUniqueInput[]
    delete?: IngredientWhereUniqueInput | IngredientWhereUniqueInput[]
    connect?: IngredientWhereUniqueInput | IngredientWhereUniqueInput[]
    update?: IngredientUpdateWithWhereUniqueWithoutCreatedByInput | IngredientUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: IngredientUpdateManyWithWhereWithoutCreatedByInput | IngredientUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: IngredientScalarWhereInput | IngredientScalarWhereInput[]
  }

  export type IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<IngredientPreferenceCreateWithoutUserInput, IngredientPreferenceUncheckedCreateWithoutUserInput> | IngredientPreferenceCreateWithoutUserInput[] | IngredientPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IngredientPreferenceCreateOrConnectWithoutUserInput | IngredientPreferenceCreateOrConnectWithoutUserInput[]
    upsert?: IngredientPreferenceUpsertWithWhereUniqueWithoutUserInput | IngredientPreferenceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IngredientPreferenceCreateManyUserInputEnvelope
    set?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    disconnect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    delete?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    connect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    update?: IngredientPreferenceUpdateWithWhereUniqueWithoutUserInput | IngredientPreferenceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IngredientPreferenceUpdateManyWithWhereWithoutUserInput | IngredientPreferenceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IngredientPreferenceScalarWhereInput | IngredientPreferenceScalarWhereInput[]
  }

  export type IngredientUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<IngredientUserCreateWithoutUserInput, IngredientUserUncheckedCreateWithoutUserInput> | IngredientUserCreateWithoutUserInput[] | IngredientUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IngredientUserCreateOrConnectWithoutUserInput | IngredientUserCreateOrConnectWithoutUserInput[]
    upsert?: IngredientUserUpsertWithWhereUniqueWithoutUserInput | IngredientUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IngredientUserCreateManyUserInputEnvelope
    set?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
    disconnect?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
    delete?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
    connect?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
    update?: IngredientUserUpdateWithWhereUniqueWithoutUserInput | IngredientUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IngredientUserUpdateManyWithWhereWithoutUserInput | IngredientUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IngredientUserScalarWhereInput | IngredientUserScalarWhereInput[]
  }

  export type StorageUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StorageUserCreateWithoutUserInput, StorageUserUncheckedCreateWithoutUserInput> | StorageUserCreateWithoutUserInput[] | StorageUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StorageUserCreateOrConnectWithoutUserInput | StorageUserCreateOrConnectWithoutUserInput[]
    upsert?: StorageUserUpsertWithWhereUniqueWithoutUserInput | StorageUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StorageUserCreateManyUserInputEnvelope
    set?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
    disconnect?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
    delete?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
    connect?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
    update?: StorageUserUpdateWithWhereUniqueWithoutUserInput | StorageUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StorageUserUpdateManyWithWhereWithoutUserInput | StorageUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StorageUserScalarWhereInput | StorageUserScalarWhereInput[]
  }

  export type StorageUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<StorageCreateWithoutCreatedByInput, StorageUncheckedCreateWithoutCreatedByInput> | StorageCreateWithoutCreatedByInput[] | StorageUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StorageCreateOrConnectWithoutCreatedByInput | StorageCreateOrConnectWithoutCreatedByInput[]
    upsert?: StorageUpsertWithWhereUniqueWithoutCreatedByInput | StorageUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: StorageCreateManyCreatedByInputEnvelope
    set?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    disconnect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    delete?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    connect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    update?: StorageUpdateWithWhereUniqueWithoutCreatedByInput | StorageUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: StorageUpdateManyWithWhereWithoutCreatedByInput | StorageUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: StorageScalarWhereInput | StorageScalarWhereInput[]
  }

  export type StorageUncheckedUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<StorageCreateWithoutEditedByInput, StorageUncheckedCreateWithoutEditedByInput> | StorageCreateWithoutEditedByInput[] | StorageUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: StorageCreateOrConnectWithoutEditedByInput | StorageCreateOrConnectWithoutEditedByInput[]
    upsert?: StorageUpsertWithWhereUniqueWithoutEditedByInput | StorageUpsertWithWhereUniqueWithoutEditedByInput[]
    createMany?: StorageCreateManyEditedByInputEnvelope
    set?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    disconnect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    delete?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    connect?: StorageWhereUniqueInput | StorageWhereUniqueInput[]
    update?: StorageUpdateWithWhereUniqueWithoutEditedByInput | StorageUpdateWithWhereUniqueWithoutEditedByInput[]
    updateMany?: StorageUpdateManyWithWhereWithoutEditedByInput | StorageUpdateManyWithWhereWithoutEditedByInput[]
    deleteMany?: StorageScalarWhereInput | StorageScalarWhereInput[]
  }

  export type InventoryUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<InventoryCreateWithoutCreatedByInput, InventoryUncheckedCreateWithoutCreatedByInput> | InventoryCreateWithoutCreatedByInput[] | InventoryUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutCreatedByInput | InventoryCreateOrConnectWithoutCreatedByInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutCreatedByInput | InventoryUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: InventoryCreateManyCreatedByInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutCreatedByInput | InventoryUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutCreatedByInput | InventoryUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type InventoryUncheckedUpdateManyWithoutEditedByNestedInput = {
    create?: XOR<InventoryCreateWithoutEditedByInput, InventoryUncheckedCreateWithoutEditedByInput> | InventoryCreateWithoutEditedByInput[] | InventoryUncheckedCreateWithoutEditedByInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutEditedByInput | InventoryCreateOrConnectWithoutEditedByInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutEditedByInput | InventoryUpsertWithWhereUniqueWithoutEditedByInput[]
    createMany?: InventoryCreateManyEditedByInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutEditedByInput | InventoryUpdateWithWhereUniqueWithoutEditedByInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutEditedByInput | InventoryUpdateManyWithWhereWithoutEditedByInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type InventoryUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InventoryUserCreateWithoutUserInput, InventoryUserUncheckedCreateWithoutUserInput> | InventoryUserCreateWithoutUserInput[] | InventoryUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryUserCreateOrConnectWithoutUserInput | InventoryUserCreateOrConnectWithoutUserInput[]
    upsert?: InventoryUserUpsertWithWhereUniqueWithoutUserInput | InventoryUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InventoryUserCreateManyUserInputEnvelope
    set?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
    disconnect?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
    delete?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
    connect?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
    update?: InventoryUserUpdateWithWhereUniqueWithoutUserInput | InventoryUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InventoryUserUpdateManyWithWhereWithoutUserInput | InventoryUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InventoryUserScalarWhereInput | InventoryUserScalarWhereInput[]
  }

  export type FollowUncheckedUpdateManyWithoutFollowedByNestedInput = {
    create?: XOR<FollowCreateWithoutFollowedByInput, FollowUncheckedCreateWithoutFollowedByInput> | FollowCreateWithoutFollowedByInput[] | FollowUncheckedCreateWithoutFollowedByInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowedByInput | FollowCreateOrConnectWithoutFollowedByInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowedByInput | FollowUpsertWithWhereUniqueWithoutFollowedByInput[]
    createMany?: FollowCreateManyFollowedByInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowedByInput | FollowUpdateWithWhereUniqueWithoutFollowedByInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowedByInput | FollowUpdateManyWithWhereWithoutFollowedByInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type FollowUncheckedUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowingInput | FollowUpsertWithWhereUniqueWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowingInput | FollowUpdateWithWhereUniqueWithoutFollowingInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowingInput | FollowUpdateManyWithWhereWithoutFollowingInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutFollowedByInput = {
    create?: XOR<UserCreateWithoutFollowedByInput, UserUncheckedCreateWithoutFollowedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowedByInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFollowingInput = {
    create?: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFollowedByNestedInput = {
    create?: XOR<UserCreateWithoutFollowedByInput, UserUncheckedCreateWithoutFollowedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowedByInput
    upsert?: UserUpsertWithoutFollowedByInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFollowedByInput, UserUpdateWithoutFollowedByInput>, UserUncheckedUpdateWithoutFollowedByInput>
  }

  export type UserUpdateOneRequiredWithoutFollowingNestedInput = {
    create?: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingInput
    upsert?: UserUpsertWithoutFollowingInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFollowingInput, UserUpdateWithoutFollowingInput>, UserUncheckedUpdateWithoutFollowingInput>
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileInput, UserUpdateWithoutProfileInput>, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserCreateNestedOneWithoutRecipeBookInput = {
    create?: XOR<UserCreateWithoutRecipeBookInput, UserUncheckedCreateWithoutRecipeBookInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeBookInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRecipeBookEditedByInput = {
    create?: XOR<UserCreateWithoutRecipeBookEditedByInput, UserUncheckedCreateWithoutRecipeBookEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeBookEditedByInput
    connect?: UserWhereUniqueInput
  }

  export type RecipeBookBuildCreateNestedManyWithoutRecipeBookInput = {
    create?: XOR<RecipeBookBuildCreateWithoutRecipeBookInput, RecipeBookBuildUncheckedCreateWithoutRecipeBookInput> | RecipeBookBuildCreateWithoutRecipeBookInput[] | RecipeBookBuildUncheckedCreateWithoutRecipeBookInput[]
    connectOrCreate?: RecipeBookBuildCreateOrConnectWithoutRecipeBookInput | RecipeBookBuildCreateOrConnectWithoutRecipeBookInput[]
    createMany?: RecipeBookBuildCreateManyRecipeBookInputEnvelope
    connect?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
  }

  export type RecipeBookUserCreateNestedManyWithoutRecipeBookInput = {
    create?: XOR<RecipeBookUserCreateWithoutRecipeBookInput, RecipeBookUserUncheckedCreateWithoutRecipeBookInput> | RecipeBookUserCreateWithoutRecipeBookInput[] | RecipeBookUserUncheckedCreateWithoutRecipeBookInput[]
    connectOrCreate?: RecipeBookUserCreateOrConnectWithoutRecipeBookInput | RecipeBookUserCreateOrConnectWithoutRecipeBookInput[]
    createMany?: RecipeBookUserCreateManyRecipeBookInputEnvelope
    connect?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
  }

  export type CrewRecipeBookCreateNestedManyWithoutRecipeBookInput = {
    create?: XOR<CrewRecipeBookCreateWithoutRecipeBookInput, CrewRecipeBookUncheckedCreateWithoutRecipeBookInput> | CrewRecipeBookCreateWithoutRecipeBookInput[] | CrewRecipeBookUncheckedCreateWithoutRecipeBookInput[]
    connectOrCreate?: CrewRecipeBookCreateOrConnectWithoutRecipeBookInput | CrewRecipeBookCreateOrConnectWithoutRecipeBookInput[]
    createMany?: CrewRecipeBookCreateManyRecipeBookInputEnvelope
    connect?: CrewRecipeBookWhereUniqueInput | CrewRecipeBookWhereUniqueInput[]
  }

  export type RecipeBookBuildUncheckedCreateNestedManyWithoutRecipeBookInput = {
    create?: XOR<RecipeBookBuildCreateWithoutRecipeBookInput, RecipeBookBuildUncheckedCreateWithoutRecipeBookInput> | RecipeBookBuildCreateWithoutRecipeBookInput[] | RecipeBookBuildUncheckedCreateWithoutRecipeBookInput[]
    connectOrCreate?: RecipeBookBuildCreateOrConnectWithoutRecipeBookInput | RecipeBookBuildCreateOrConnectWithoutRecipeBookInput[]
    createMany?: RecipeBookBuildCreateManyRecipeBookInputEnvelope
    connect?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
  }

  export type RecipeBookUserUncheckedCreateNestedManyWithoutRecipeBookInput = {
    create?: XOR<RecipeBookUserCreateWithoutRecipeBookInput, RecipeBookUserUncheckedCreateWithoutRecipeBookInput> | RecipeBookUserCreateWithoutRecipeBookInput[] | RecipeBookUserUncheckedCreateWithoutRecipeBookInput[]
    connectOrCreate?: RecipeBookUserCreateOrConnectWithoutRecipeBookInput | RecipeBookUserCreateOrConnectWithoutRecipeBookInput[]
    createMany?: RecipeBookUserCreateManyRecipeBookInputEnvelope
    connect?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
  }

  export type CrewRecipeBookUncheckedCreateNestedManyWithoutRecipeBookInput = {
    create?: XOR<CrewRecipeBookCreateWithoutRecipeBookInput, CrewRecipeBookUncheckedCreateWithoutRecipeBookInput> | CrewRecipeBookCreateWithoutRecipeBookInput[] | CrewRecipeBookUncheckedCreateWithoutRecipeBookInput[]
    connectOrCreate?: CrewRecipeBookCreateOrConnectWithoutRecipeBookInput | CrewRecipeBookCreateOrConnectWithoutRecipeBookInput[]
    createMany?: CrewRecipeBookCreateManyRecipeBookInputEnvelope
    connect?: CrewRecipeBookWhereUniqueInput | CrewRecipeBookWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutRecipeBookNestedInput = {
    create?: XOR<UserCreateWithoutRecipeBookInput, UserUncheckedCreateWithoutRecipeBookInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeBookInput
    upsert?: UserUpsertWithoutRecipeBookInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRecipeBookInput, UserUpdateWithoutRecipeBookInput>, UserUncheckedUpdateWithoutRecipeBookInput>
  }

  export type UserUpdateOneWithoutRecipeBookEditedByNestedInput = {
    create?: XOR<UserCreateWithoutRecipeBookEditedByInput, UserUncheckedCreateWithoutRecipeBookEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeBookEditedByInput
    upsert?: UserUpsertWithoutRecipeBookEditedByInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRecipeBookEditedByInput, UserUpdateWithoutRecipeBookEditedByInput>, UserUncheckedUpdateWithoutRecipeBookEditedByInput>
  }

  export type RecipeBookBuildUpdateManyWithoutRecipeBookNestedInput = {
    create?: XOR<RecipeBookBuildCreateWithoutRecipeBookInput, RecipeBookBuildUncheckedCreateWithoutRecipeBookInput> | RecipeBookBuildCreateWithoutRecipeBookInput[] | RecipeBookBuildUncheckedCreateWithoutRecipeBookInput[]
    connectOrCreate?: RecipeBookBuildCreateOrConnectWithoutRecipeBookInput | RecipeBookBuildCreateOrConnectWithoutRecipeBookInput[]
    upsert?: RecipeBookBuildUpsertWithWhereUniqueWithoutRecipeBookInput | RecipeBookBuildUpsertWithWhereUniqueWithoutRecipeBookInput[]
    createMany?: RecipeBookBuildCreateManyRecipeBookInputEnvelope
    set?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
    disconnect?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
    delete?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
    connect?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
    update?: RecipeBookBuildUpdateWithWhereUniqueWithoutRecipeBookInput | RecipeBookBuildUpdateWithWhereUniqueWithoutRecipeBookInput[]
    updateMany?: RecipeBookBuildUpdateManyWithWhereWithoutRecipeBookInput | RecipeBookBuildUpdateManyWithWhereWithoutRecipeBookInput[]
    deleteMany?: RecipeBookBuildScalarWhereInput | RecipeBookBuildScalarWhereInput[]
  }

  export type RecipeBookUserUpdateManyWithoutRecipeBookNestedInput = {
    create?: XOR<RecipeBookUserCreateWithoutRecipeBookInput, RecipeBookUserUncheckedCreateWithoutRecipeBookInput> | RecipeBookUserCreateWithoutRecipeBookInput[] | RecipeBookUserUncheckedCreateWithoutRecipeBookInput[]
    connectOrCreate?: RecipeBookUserCreateOrConnectWithoutRecipeBookInput | RecipeBookUserCreateOrConnectWithoutRecipeBookInput[]
    upsert?: RecipeBookUserUpsertWithWhereUniqueWithoutRecipeBookInput | RecipeBookUserUpsertWithWhereUniqueWithoutRecipeBookInput[]
    createMany?: RecipeBookUserCreateManyRecipeBookInputEnvelope
    set?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
    disconnect?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
    delete?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
    connect?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
    update?: RecipeBookUserUpdateWithWhereUniqueWithoutRecipeBookInput | RecipeBookUserUpdateWithWhereUniqueWithoutRecipeBookInput[]
    updateMany?: RecipeBookUserUpdateManyWithWhereWithoutRecipeBookInput | RecipeBookUserUpdateManyWithWhereWithoutRecipeBookInput[]
    deleteMany?: RecipeBookUserScalarWhereInput | RecipeBookUserScalarWhereInput[]
  }

  export type CrewRecipeBookUpdateManyWithoutRecipeBookNestedInput = {
    create?: XOR<CrewRecipeBookCreateWithoutRecipeBookInput, CrewRecipeBookUncheckedCreateWithoutRecipeBookInput> | CrewRecipeBookCreateWithoutRecipeBookInput[] | CrewRecipeBookUncheckedCreateWithoutRecipeBookInput[]
    connectOrCreate?: CrewRecipeBookCreateOrConnectWithoutRecipeBookInput | CrewRecipeBookCreateOrConnectWithoutRecipeBookInput[]
    upsert?: CrewRecipeBookUpsertWithWhereUniqueWithoutRecipeBookInput | CrewRecipeBookUpsertWithWhereUniqueWithoutRecipeBookInput[]
    createMany?: CrewRecipeBookCreateManyRecipeBookInputEnvelope
    set?: CrewRecipeBookWhereUniqueInput | CrewRecipeBookWhereUniqueInput[]
    disconnect?: CrewRecipeBookWhereUniqueInput | CrewRecipeBookWhereUniqueInput[]
    delete?: CrewRecipeBookWhereUniqueInput | CrewRecipeBookWhereUniqueInput[]
    connect?: CrewRecipeBookWhereUniqueInput | CrewRecipeBookWhereUniqueInput[]
    update?: CrewRecipeBookUpdateWithWhereUniqueWithoutRecipeBookInput | CrewRecipeBookUpdateWithWhereUniqueWithoutRecipeBookInput[]
    updateMany?: CrewRecipeBookUpdateManyWithWhereWithoutRecipeBookInput | CrewRecipeBookUpdateManyWithWhereWithoutRecipeBookInput[]
    deleteMany?: CrewRecipeBookScalarWhereInput | CrewRecipeBookScalarWhereInput[]
  }

  export type RecipeBookBuildUncheckedUpdateManyWithoutRecipeBookNestedInput = {
    create?: XOR<RecipeBookBuildCreateWithoutRecipeBookInput, RecipeBookBuildUncheckedCreateWithoutRecipeBookInput> | RecipeBookBuildCreateWithoutRecipeBookInput[] | RecipeBookBuildUncheckedCreateWithoutRecipeBookInput[]
    connectOrCreate?: RecipeBookBuildCreateOrConnectWithoutRecipeBookInput | RecipeBookBuildCreateOrConnectWithoutRecipeBookInput[]
    upsert?: RecipeBookBuildUpsertWithWhereUniqueWithoutRecipeBookInput | RecipeBookBuildUpsertWithWhereUniqueWithoutRecipeBookInput[]
    createMany?: RecipeBookBuildCreateManyRecipeBookInputEnvelope
    set?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
    disconnect?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
    delete?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
    connect?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
    update?: RecipeBookBuildUpdateWithWhereUniqueWithoutRecipeBookInput | RecipeBookBuildUpdateWithWhereUniqueWithoutRecipeBookInput[]
    updateMany?: RecipeBookBuildUpdateManyWithWhereWithoutRecipeBookInput | RecipeBookBuildUpdateManyWithWhereWithoutRecipeBookInput[]
    deleteMany?: RecipeBookBuildScalarWhereInput | RecipeBookBuildScalarWhereInput[]
  }

  export type RecipeBookUserUncheckedUpdateManyWithoutRecipeBookNestedInput = {
    create?: XOR<RecipeBookUserCreateWithoutRecipeBookInput, RecipeBookUserUncheckedCreateWithoutRecipeBookInput> | RecipeBookUserCreateWithoutRecipeBookInput[] | RecipeBookUserUncheckedCreateWithoutRecipeBookInput[]
    connectOrCreate?: RecipeBookUserCreateOrConnectWithoutRecipeBookInput | RecipeBookUserCreateOrConnectWithoutRecipeBookInput[]
    upsert?: RecipeBookUserUpsertWithWhereUniqueWithoutRecipeBookInput | RecipeBookUserUpsertWithWhereUniqueWithoutRecipeBookInput[]
    createMany?: RecipeBookUserCreateManyRecipeBookInputEnvelope
    set?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
    disconnect?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
    delete?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
    connect?: RecipeBookUserWhereUniqueInput | RecipeBookUserWhereUniqueInput[]
    update?: RecipeBookUserUpdateWithWhereUniqueWithoutRecipeBookInput | RecipeBookUserUpdateWithWhereUniqueWithoutRecipeBookInput[]
    updateMany?: RecipeBookUserUpdateManyWithWhereWithoutRecipeBookInput | RecipeBookUserUpdateManyWithWhereWithoutRecipeBookInput[]
    deleteMany?: RecipeBookUserScalarWhereInput | RecipeBookUserScalarWhereInput[]
  }

  export type CrewRecipeBookUncheckedUpdateManyWithoutRecipeBookNestedInput = {
    create?: XOR<CrewRecipeBookCreateWithoutRecipeBookInput, CrewRecipeBookUncheckedCreateWithoutRecipeBookInput> | CrewRecipeBookCreateWithoutRecipeBookInput[] | CrewRecipeBookUncheckedCreateWithoutRecipeBookInput[]
    connectOrCreate?: CrewRecipeBookCreateOrConnectWithoutRecipeBookInput | CrewRecipeBookCreateOrConnectWithoutRecipeBookInput[]
    upsert?: CrewRecipeBookUpsertWithWhereUniqueWithoutRecipeBookInput | CrewRecipeBookUpsertWithWhereUniqueWithoutRecipeBookInput[]
    createMany?: CrewRecipeBookCreateManyRecipeBookInputEnvelope
    set?: CrewRecipeBookWhereUniqueInput | CrewRecipeBookWhereUniqueInput[]
    disconnect?: CrewRecipeBookWhereUniqueInput | CrewRecipeBookWhereUniqueInput[]
    delete?: CrewRecipeBookWhereUniqueInput | CrewRecipeBookWhereUniqueInput[]
    connect?: CrewRecipeBookWhereUniqueInput | CrewRecipeBookWhereUniqueInput[]
    update?: CrewRecipeBookUpdateWithWhereUniqueWithoutRecipeBookInput | CrewRecipeBookUpdateWithWhereUniqueWithoutRecipeBookInput[]
    updateMany?: CrewRecipeBookUpdateManyWithWhereWithoutRecipeBookInput | CrewRecipeBookUpdateManyWithWhereWithoutRecipeBookInput[]
    deleteMany?: CrewRecipeBookScalarWhereInput | CrewRecipeBookScalarWhereInput[]
  }

  export type RecipeBookCreateNestedOneWithoutRecipeBookUserInput = {
    create?: XOR<RecipeBookCreateWithoutRecipeBookUserInput, RecipeBookUncheckedCreateWithoutRecipeBookUserInput>
    connectOrCreate?: RecipeBookCreateOrConnectWithoutRecipeBookUserInput
    connect?: RecipeBookWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRecipeBookUserInput = {
    create?: XOR<UserCreateWithoutRecipeBookUserInput, UserUncheckedCreateWithoutRecipeBookUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeBookUserInput
    connect?: UserWhereUniqueInput
  }

  export type RecipeBookUpdateOneRequiredWithoutRecipeBookUserNestedInput = {
    create?: XOR<RecipeBookCreateWithoutRecipeBookUserInput, RecipeBookUncheckedCreateWithoutRecipeBookUserInput>
    connectOrCreate?: RecipeBookCreateOrConnectWithoutRecipeBookUserInput
    upsert?: RecipeBookUpsertWithoutRecipeBookUserInput
    connect?: RecipeBookWhereUniqueInput
    update?: XOR<XOR<RecipeBookUpdateToOneWithWhereWithoutRecipeBookUserInput, RecipeBookUpdateWithoutRecipeBookUserInput>, RecipeBookUncheckedUpdateWithoutRecipeBookUserInput>
  }

  export type UserUpdateOneRequiredWithoutRecipeBookUserNestedInput = {
    create?: XOR<UserCreateWithoutRecipeBookUserInput, UserUncheckedCreateWithoutRecipeBookUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeBookUserInput
    upsert?: UserUpsertWithoutRecipeBookUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRecipeBookUserInput, UserUpdateWithoutRecipeBookUserInput>, UserUncheckedUpdateWithoutRecipeBookUserInput>
  }

  export type UserCreateNestedOneWithoutBuildInput = {
    create?: XOR<UserCreateWithoutBuildInput, UserUncheckedCreateWithoutBuildInput>
    connectOrCreate?: UserCreateOrConnectWithoutBuildInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBuildEditedByInput = {
    create?: XOR<UserCreateWithoutBuildEditedByInput, UserUncheckedCreateWithoutBuildEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutBuildEditedByInput
    connect?: UserWhereUniqueInput
  }

  export type RecipeCreateNestedOneWithoutBuildInput = {
    create?: XOR<RecipeCreateWithoutBuildInput, RecipeUncheckedCreateWithoutBuildInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutBuildInput
    connect?: RecipeWhereUniqueInput
  }

  export type TouchCreateNestedManyWithoutBuildInput = {
    create?: XOR<TouchCreateWithoutBuildInput, TouchUncheckedCreateWithoutBuildInput> | TouchCreateWithoutBuildInput[] | TouchUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: TouchCreateOrConnectWithoutBuildInput | TouchCreateOrConnectWithoutBuildInput[]
    createMany?: TouchCreateManyBuildInputEnvelope
    connect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
  }

  export type ArchivedBuildCreateNestedManyWithoutBuildInput = {
    create?: XOR<ArchivedBuildCreateWithoutBuildInput, ArchivedBuildUncheckedCreateWithoutBuildInput> | ArchivedBuildCreateWithoutBuildInput[] | ArchivedBuildUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: ArchivedBuildCreateOrConnectWithoutBuildInput | ArchivedBuildCreateOrConnectWithoutBuildInput[]
    createMany?: ArchivedBuildCreateManyBuildInputEnvelope
    connect?: ArchivedBuildWhereUniqueInput | ArchivedBuildWhereUniqueInput[]
  }

  export type RecipeBookBuildCreateNestedManyWithoutBuildInput = {
    create?: XOR<RecipeBookBuildCreateWithoutBuildInput, RecipeBookBuildUncheckedCreateWithoutBuildInput> | RecipeBookBuildCreateWithoutBuildInput[] | RecipeBookBuildUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: RecipeBookBuildCreateOrConnectWithoutBuildInput | RecipeBookBuildCreateOrConnectWithoutBuildInput[]
    createMany?: RecipeBookBuildCreateManyBuildInputEnvelope
    connect?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
  }

  export type BuildUserCreateNestedManyWithoutBuildInput = {
    create?: XOR<BuildUserCreateWithoutBuildInput, BuildUserUncheckedCreateWithoutBuildInput> | BuildUserCreateWithoutBuildInput[] | BuildUserUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: BuildUserCreateOrConnectWithoutBuildInput | BuildUserCreateOrConnectWithoutBuildInput[]
    createMany?: BuildUserCreateManyBuildInputEnvelope
    connect?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
  }

  export type CrewBuildCreateNestedManyWithoutBuildInput = {
    create?: XOR<CrewBuildCreateWithoutBuildInput, CrewBuildUncheckedCreateWithoutBuildInput> | CrewBuildCreateWithoutBuildInput[] | CrewBuildUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: CrewBuildCreateOrConnectWithoutBuildInput | CrewBuildCreateOrConnectWithoutBuildInput[]
    createMany?: CrewBuildCreateManyBuildInputEnvelope
    connect?: CrewBuildWhereUniqueInput | CrewBuildWhereUniqueInput[]
  }

  export type TouchUncheckedCreateNestedManyWithoutBuildInput = {
    create?: XOR<TouchCreateWithoutBuildInput, TouchUncheckedCreateWithoutBuildInput> | TouchCreateWithoutBuildInput[] | TouchUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: TouchCreateOrConnectWithoutBuildInput | TouchCreateOrConnectWithoutBuildInput[]
    createMany?: TouchCreateManyBuildInputEnvelope
    connect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
  }

  export type ArchivedBuildUncheckedCreateNestedManyWithoutBuildInput = {
    create?: XOR<ArchivedBuildCreateWithoutBuildInput, ArchivedBuildUncheckedCreateWithoutBuildInput> | ArchivedBuildCreateWithoutBuildInput[] | ArchivedBuildUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: ArchivedBuildCreateOrConnectWithoutBuildInput | ArchivedBuildCreateOrConnectWithoutBuildInput[]
    createMany?: ArchivedBuildCreateManyBuildInputEnvelope
    connect?: ArchivedBuildWhereUniqueInput | ArchivedBuildWhereUniqueInput[]
  }

  export type RecipeBookBuildUncheckedCreateNestedManyWithoutBuildInput = {
    create?: XOR<RecipeBookBuildCreateWithoutBuildInput, RecipeBookBuildUncheckedCreateWithoutBuildInput> | RecipeBookBuildCreateWithoutBuildInput[] | RecipeBookBuildUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: RecipeBookBuildCreateOrConnectWithoutBuildInput | RecipeBookBuildCreateOrConnectWithoutBuildInput[]
    createMany?: RecipeBookBuildCreateManyBuildInputEnvelope
    connect?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
  }

  export type BuildUserUncheckedCreateNestedManyWithoutBuildInput = {
    create?: XOR<BuildUserCreateWithoutBuildInput, BuildUserUncheckedCreateWithoutBuildInput> | BuildUserCreateWithoutBuildInput[] | BuildUserUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: BuildUserCreateOrConnectWithoutBuildInput | BuildUserCreateOrConnectWithoutBuildInput[]
    createMany?: BuildUserCreateManyBuildInputEnvelope
    connect?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
  }

  export type CrewBuildUncheckedCreateNestedManyWithoutBuildInput = {
    create?: XOR<CrewBuildCreateWithoutBuildInput, CrewBuildUncheckedCreateWithoutBuildInput> | CrewBuildCreateWithoutBuildInput[] | CrewBuildUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: CrewBuildCreateOrConnectWithoutBuildInput | CrewBuildCreateOrConnectWithoutBuildInput[]
    createMany?: CrewBuildCreateManyBuildInputEnvelope
    connect?: CrewBuildWhereUniqueInput | CrewBuildWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutBuildNestedInput = {
    create?: XOR<UserCreateWithoutBuildInput, UserUncheckedCreateWithoutBuildInput>
    connectOrCreate?: UserCreateOrConnectWithoutBuildInput
    upsert?: UserUpsertWithoutBuildInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBuildInput, UserUpdateWithoutBuildInput>, UserUncheckedUpdateWithoutBuildInput>
  }

  export type UserUpdateOneWithoutBuildEditedByNestedInput = {
    create?: XOR<UserCreateWithoutBuildEditedByInput, UserUncheckedCreateWithoutBuildEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutBuildEditedByInput
    upsert?: UserUpsertWithoutBuildEditedByInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBuildEditedByInput, UserUpdateWithoutBuildEditedByInput>, UserUncheckedUpdateWithoutBuildEditedByInput>
  }

  export type RecipeUpdateOneWithoutBuildNestedInput = {
    create?: XOR<RecipeCreateWithoutBuildInput, RecipeUncheckedCreateWithoutBuildInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutBuildInput
    upsert?: RecipeUpsertWithoutBuildInput
    disconnect?: RecipeWhereInput | boolean
    delete?: RecipeWhereInput | boolean
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutBuildInput, RecipeUpdateWithoutBuildInput>, RecipeUncheckedUpdateWithoutBuildInput>
  }

  export type TouchUpdateManyWithoutBuildNestedInput = {
    create?: XOR<TouchCreateWithoutBuildInput, TouchUncheckedCreateWithoutBuildInput> | TouchCreateWithoutBuildInput[] | TouchUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: TouchCreateOrConnectWithoutBuildInput | TouchCreateOrConnectWithoutBuildInput[]
    upsert?: TouchUpsertWithWhereUniqueWithoutBuildInput | TouchUpsertWithWhereUniqueWithoutBuildInput[]
    createMany?: TouchCreateManyBuildInputEnvelope
    set?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    disconnect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    delete?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    connect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    update?: TouchUpdateWithWhereUniqueWithoutBuildInput | TouchUpdateWithWhereUniqueWithoutBuildInput[]
    updateMany?: TouchUpdateManyWithWhereWithoutBuildInput | TouchUpdateManyWithWhereWithoutBuildInput[]
    deleteMany?: TouchScalarWhereInput | TouchScalarWhereInput[]
  }

  export type ArchivedBuildUpdateManyWithoutBuildNestedInput = {
    create?: XOR<ArchivedBuildCreateWithoutBuildInput, ArchivedBuildUncheckedCreateWithoutBuildInput> | ArchivedBuildCreateWithoutBuildInput[] | ArchivedBuildUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: ArchivedBuildCreateOrConnectWithoutBuildInput | ArchivedBuildCreateOrConnectWithoutBuildInput[]
    upsert?: ArchivedBuildUpsertWithWhereUniqueWithoutBuildInput | ArchivedBuildUpsertWithWhereUniqueWithoutBuildInput[]
    createMany?: ArchivedBuildCreateManyBuildInputEnvelope
    set?: ArchivedBuildWhereUniqueInput | ArchivedBuildWhereUniqueInput[]
    disconnect?: ArchivedBuildWhereUniqueInput | ArchivedBuildWhereUniqueInput[]
    delete?: ArchivedBuildWhereUniqueInput | ArchivedBuildWhereUniqueInput[]
    connect?: ArchivedBuildWhereUniqueInput | ArchivedBuildWhereUniqueInput[]
    update?: ArchivedBuildUpdateWithWhereUniqueWithoutBuildInput | ArchivedBuildUpdateWithWhereUniqueWithoutBuildInput[]
    updateMany?: ArchivedBuildUpdateManyWithWhereWithoutBuildInput | ArchivedBuildUpdateManyWithWhereWithoutBuildInput[]
    deleteMany?: ArchivedBuildScalarWhereInput | ArchivedBuildScalarWhereInput[]
  }

  export type RecipeBookBuildUpdateManyWithoutBuildNestedInput = {
    create?: XOR<RecipeBookBuildCreateWithoutBuildInput, RecipeBookBuildUncheckedCreateWithoutBuildInput> | RecipeBookBuildCreateWithoutBuildInput[] | RecipeBookBuildUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: RecipeBookBuildCreateOrConnectWithoutBuildInput | RecipeBookBuildCreateOrConnectWithoutBuildInput[]
    upsert?: RecipeBookBuildUpsertWithWhereUniqueWithoutBuildInput | RecipeBookBuildUpsertWithWhereUniqueWithoutBuildInput[]
    createMany?: RecipeBookBuildCreateManyBuildInputEnvelope
    set?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
    disconnect?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
    delete?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
    connect?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
    update?: RecipeBookBuildUpdateWithWhereUniqueWithoutBuildInput | RecipeBookBuildUpdateWithWhereUniqueWithoutBuildInput[]
    updateMany?: RecipeBookBuildUpdateManyWithWhereWithoutBuildInput | RecipeBookBuildUpdateManyWithWhereWithoutBuildInput[]
    deleteMany?: RecipeBookBuildScalarWhereInput | RecipeBookBuildScalarWhereInput[]
  }

  export type BuildUserUpdateManyWithoutBuildNestedInput = {
    create?: XOR<BuildUserCreateWithoutBuildInput, BuildUserUncheckedCreateWithoutBuildInput> | BuildUserCreateWithoutBuildInput[] | BuildUserUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: BuildUserCreateOrConnectWithoutBuildInput | BuildUserCreateOrConnectWithoutBuildInput[]
    upsert?: BuildUserUpsertWithWhereUniqueWithoutBuildInput | BuildUserUpsertWithWhereUniqueWithoutBuildInput[]
    createMany?: BuildUserCreateManyBuildInputEnvelope
    set?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
    disconnect?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
    delete?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
    connect?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
    update?: BuildUserUpdateWithWhereUniqueWithoutBuildInput | BuildUserUpdateWithWhereUniqueWithoutBuildInput[]
    updateMany?: BuildUserUpdateManyWithWhereWithoutBuildInput | BuildUserUpdateManyWithWhereWithoutBuildInput[]
    deleteMany?: BuildUserScalarWhereInput | BuildUserScalarWhereInput[]
  }

  export type CrewBuildUpdateManyWithoutBuildNestedInput = {
    create?: XOR<CrewBuildCreateWithoutBuildInput, CrewBuildUncheckedCreateWithoutBuildInput> | CrewBuildCreateWithoutBuildInput[] | CrewBuildUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: CrewBuildCreateOrConnectWithoutBuildInput | CrewBuildCreateOrConnectWithoutBuildInput[]
    upsert?: CrewBuildUpsertWithWhereUniqueWithoutBuildInput | CrewBuildUpsertWithWhereUniqueWithoutBuildInput[]
    createMany?: CrewBuildCreateManyBuildInputEnvelope
    set?: CrewBuildWhereUniqueInput | CrewBuildWhereUniqueInput[]
    disconnect?: CrewBuildWhereUniqueInput | CrewBuildWhereUniqueInput[]
    delete?: CrewBuildWhereUniqueInput | CrewBuildWhereUniqueInput[]
    connect?: CrewBuildWhereUniqueInput | CrewBuildWhereUniqueInput[]
    update?: CrewBuildUpdateWithWhereUniqueWithoutBuildInput | CrewBuildUpdateWithWhereUniqueWithoutBuildInput[]
    updateMany?: CrewBuildUpdateManyWithWhereWithoutBuildInput | CrewBuildUpdateManyWithWhereWithoutBuildInput[]
    deleteMany?: CrewBuildScalarWhereInput | CrewBuildScalarWhereInput[]
  }

  export type TouchUncheckedUpdateManyWithoutBuildNestedInput = {
    create?: XOR<TouchCreateWithoutBuildInput, TouchUncheckedCreateWithoutBuildInput> | TouchCreateWithoutBuildInput[] | TouchUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: TouchCreateOrConnectWithoutBuildInput | TouchCreateOrConnectWithoutBuildInput[]
    upsert?: TouchUpsertWithWhereUniqueWithoutBuildInput | TouchUpsertWithWhereUniqueWithoutBuildInput[]
    createMany?: TouchCreateManyBuildInputEnvelope
    set?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    disconnect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    delete?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    connect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    update?: TouchUpdateWithWhereUniqueWithoutBuildInput | TouchUpdateWithWhereUniqueWithoutBuildInput[]
    updateMany?: TouchUpdateManyWithWhereWithoutBuildInput | TouchUpdateManyWithWhereWithoutBuildInput[]
    deleteMany?: TouchScalarWhereInput | TouchScalarWhereInput[]
  }

  export type ArchivedBuildUncheckedUpdateManyWithoutBuildNestedInput = {
    create?: XOR<ArchivedBuildCreateWithoutBuildInput, ArchivedBuildUncheckedCreateWithoutBuildInput> | ArchivedBuildCreateWithoutBuildInput[] | ArchivedBuildUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: ArchivedBuildCreateOrConnectWithoutBuildInput | ArchivedBuildCreateOrConnectWithoutBuildInput[]
    upsert?: ArchivedBuildUpsertWithWhereUniqueWithoutBuildInput | ArchivedBuildUpsertWithWhereUniqueWithoutBuildInput[]
    createMany?: ArchivedBuildCreateManyBuildInputEnvelope
    set?: ArchivedBuildWhereUniqueInput | ArchivedBuildWhereUniqueInput[]
    disconnect?: ArchivedBuildWhereUniqueInput | ArchivedBuildWhereUniqueInput[]
    delete?: ArchivedBuildWhereUniqueInput | ArchivedBuildWhereUniqueInput[]
    connect?: ArchivedBuildWhereUniqueInput | ArchivedBuildWhereUniqueInput[]
    update?: ArchivedBuildUpdateWithWhereUniqueWithoutBuildInput | ArchivedBuildUpdateWithWhereUniqueWithoutBuildInput[]
    updateMany?: ArchivedBuildUpdateManyWithWhereWithoutBuildInput | ArchivedBuildUpdateManyWithWhereWithoutBuildInput[]
    deleteMany?: ArchivedBuildScalarWhereInput | ArchivedBuildScalarWhereInput[]
  }

  export type RecipeBookBuildUncheckedUpdateManyWithoutBuildNestedInput = {
    create?: XOR<RecipeBookBuildCreateWithoutBuildInput, RecipeBookBuildUncheckedCreateWithoutBuildInput> | RecipeBookBuildCreateWithoutBuildInput[] | RecipeBookBuildUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: RecipeBookBuildCreateOrConnectWithoutBuildInput | RecipeBookBuildCreateOrConnectWithoutBuildInput[]
    upsert?: RecipeBookBuildUpsertWithWhereUniqueWithoutBuildInput | RecipeBookBuildUpsertWithWhereUniqueWithoutBuildInput[]
    createMany?: RecipeBookBuildCreateManyBuildInputEnvelope
    set?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
    disconnect?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
    delete?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
    connect?: RecipeBookBuildWhereUniqueInput | RecipeBookBuildWhereUniqueInput[]
    update?: RecipeBookBuildUpdateWithWhereUniqueWithoutBuildInput | RecipeBookBuildUpdateWithWhereUniqueWithoutBuildInput[]
    updateMany?: RecipeBookBuildUpdateManyWithWhereWithoutBuildInput | RecipeBookBuildUpdateManyWithWhereWithoutBuildInput[]
    deleteMany?: RecipeBookBuildScalarWhereInput | RecipeBookBuildScalarWhereInput[]
  }

  export type BuildUserUncheckedUpdateManyWithoutBuildNestedInput = {
    create?: XOR<BuildUserCreateWithoutBuildInput, BuildUserUncheckedCreateWithoutBuildInput> | BuildUserCreateWithoutBuildInput[] | BuildUserUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: BuildUserCreateOrConnectWithoutBuildInput | BuildUserCreateOrConnectWithoutBuildInput[]
    upsert?: BuildUserUpsertWithWhereUniqueWithoutBuildInput | BuildUserUpsertWithWhereUniqueWithoutBuildInput[]
    createMany?: BuildUserCreateManyBuildInputEnvelope
    set?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
    disconnect?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
    delete?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
    connect?: BuildUserWhereUniqueInput | BuildUserWhereUniqueInput[]
    update?: BuildUserUpdateWithWhereUniqueWithoutBuildInput | BuildUserUpdateWithWhereUniqueWithoutBuildInput[]
    updateMany?: BuildUserUpdateManyWithWhereWithoutBuildInput | BuildUserUpdateManyWithWhereWithoutBuildInput[]
    deleteMany?: BuildUserScalarWhereInput | BuildUserScalarWhereInput[]
  }

  export type CrewBuildUncheckedUpdateManyWithoutBuildNestedInput = {
    create?: XOR<CrewBuildCreateWithoutBuildInput, CrewBuildUncheckedCreateWithoutBuildInput> | CrewBuildCreateWithoutBuildInput[] | CrewBuildUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: CrewBuildCreateOrConnectWithoutBuildInput | CrewBuildCreateOrConnectWithoutBuildInput[]
    upsert?: CrewBuildUpsertWithWhereUniqueWithoutBuildInput | CrewBuildUpsertWithWhereUniqueWithoutBuildInput[]
    createMany?: CrewBuildCreateManyBuildInputEnvelope
    set?: CrewBuildWhereUniqueInput | CrewBuildWhereUniqueInput[]
    disconnect?: CrewBuildWhereUniqueInput | CrewBuildWhereUniqueInput[]
    delete?: CrewBuildWhereUniqueInput | CrewBuildWhereUniqueInput[]
    connect?: CrewBuildWhereUniqueInput | CrewBuildWhereUniqueInput[]
    update?: CrewBuildUpdateWithWhereUniqueWithoutBuildInput | CrewBuildUpdateWithWhereUniqueWithoutBuildInput[]
    updateMany?: CrewBuildUpdateManyWithWhereWithoutBuildInput | CrewBuildUpdateManyWithWhereWithoutBuildInput[]
    deleteMany?: CrewBuildScalarWhereInput | CrewBuildScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutArchivedBuildInput = {
    create?: XOR<UserCreateWithoutArchivedBuildInput, UserUncheckedCreateWithoutArchivedBuildInput>
    connectOrCreate?: UserCreateOrConnectWithoutArchivedBuildInput
    connect?: UserWhereUniqueInput
  }

  export type BuildCreateNestedOneWithoutArchivedBuildInput = {
    create?: XOR<BuildCreateWithoutArchivedBuildInput, BuildUncheckedCreateWithoutArchivedBuildInput>
    connectOrCreate?: BuildCreateOrConnectWithoutArchivedBuildInput
    connect?: BuildWhereUniqueInput
  }

  export type RecipeCreateNestedOneWithoutArchivedBuildInput = {
    create?: XOR<RecipeCreateWithoutArchivedBuildInput, RecipeUncheckedCreateWithoutArchivedBuildInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutArchivedBuildInput
    connect?: RecipeWhereUniqueInput
  }

  export type ArchivedTouchCreateNestedManyWithoutArchivedBuildInput = {
    create?: XOR<ArchivedTouchCreateWithoutArchivedBuildInput, ArchivedTouchUncheckedCreateWithoutArchivedBuildInput> | ArchivedTouchCreateWithoutArchivedBuildInput[] | ArchivedTouchUncheckedCreateWithoutArchivedBuildInput[]
    connectOrCreate?: ArchivedTouchCreateOrConnectWithoutArchivedBuildInput | ArchivedTouchCreateOrConnectWithoutArchivedBuildInput[]
    createMany?: ArchivedTouchCreateManyArchivedBuildInputEnvelope
    connect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
  }

  export type ArchivedTouchUncheckedCreateNestedManyWithoutArchivedBuildInput = {
    create?: XOR<ArchivedTouchCreateWithoutArchivedBuildInput, ArchivedTouchUncheckedCreateWithoutArchivedBuildInput> | ArchivedTouchCreateWithoutArchivedBuildInput[] | ArchivedTouchUncheckedCreateWithoutArchivedBuildInput[]
    connectOrCreate?: ArchivedTouchCreateOrConnectWithoutArchivedBuildInput | ArchivedTouchCreateOrConnectWithoutArchivedBuildInput[]
    createMany?: ArchivedTouchCreateManyArchivedBuildInputEnvelope
    connect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutArchivedBuildNestedInput = {
    create?: XOR<UserCreateWithoutArchivedBuildInput, UserUncheckedCreateWithoutArchivedBuildInput>
    connectOrCreate?: UserCreateOrConnectWithoutArchivedBuildInput
    upsert?: UserUpsertWithoutArchivedBuildInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutArchivedBuildInput, UserUpdateWithoutArchivedBuildInput>, UserUncheckedUpdateWithoutArchivedBuildInput>
  }

  export type BuildUpdateOneRequiredWithoutArchivedBuildNestedInput = {
    create?: XOR<BuildCreateWithoutArchivedBuildInput, BuildUncheckedCreateWithoutArchivedBuildInput>
    connectOrCreate?: BuildCreateOrConnectWithoutArchivedBuildInput
    upsert?: BuildUpsertWithoutArchivedBuildInput
    connect?: BuildWhereUniqueInput
    update?: XOR<XOR<BuildUpdateToOneWithWhereWithoutArchivedBuildInput, BuildUpdateWithoutArchivedBuildInput>, BuildUncheckedUpdateWithoutArchivedBuildInput>
  }

  export type RecipeUpdateOneWithoutArchivedBuildNestedInput = {
    create?: XOR<RecipeCreateWithoutArchivedBuildInput, RecipeUncheckedCreateWithoutArchivedBuildInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutArchivedBuildInput
    upsert?: RecipeUpsertWithoutArchivedBuildInput
    disconnect?: RecipeWhereInput | boolean
    delete?: RecipeWhereInput | boolean
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutArchivedBuildInput, RecipeUpdateWithoutArchivedBuildInput>, RecipeUncheckedUpdateWithoutArchivedBuildInput>
  }

  export type ArchivedTouchUpdateManyWithoutArchivedBuildNestedInput = {
    create?: XOR<ArchivedTouchCreateWithoutArchivedBuildInput, ArchivedTouchUncheckedCreateWithoutArchivedBuildInput> | ArchivedTouchCreateWithoutArchivedBuildInput[] | ArchivedTouchUncheckedCreateWithoutArchivedBuildInput[]
    connectOrCreate?: ArchivedTouchCreateOrConnectWithoutArchivedBuildInput | ArchivedTouchCreateOrConnectWithoutArchivedBuildInput[]
    upsert?: ArchivedTouchUpsertWithWhereUniqueWithoutArchivedBuildInput | ArchivedTouchUpsertWithWhereUniqueWithoutArchivedBuildInput[]
    createMany?: ArchivedTouchCreateManyArchivedBuildInputEnvelope
    set?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    disconnect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    delete?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    connect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    update?: ArchivedTouchUpdateWithWhereUniqueWithoutArchivedBuildInput | ArchivedTouchUpdateWithWhereUniqueWithoutArchivedBuildInput[]
    updateMany?: ArchivedTouchUpdateManyWithWhereWithoutArchivedBuildInput | ArchivedTouchUpdateManyWithWhereWithoutArchivedBuildInput[]
    deleteMany?: ArchivedTouchScalarWhereInput | ArchivedTouchScalarWhereInput[]
  }

  export type ArchivedTouchUncheckedUpdateManyWithoutArchivedBuildNestedInput = {
    create?: XOR<ArchivedTouchCreateWithoutArchivedBuildInput, ArchivedTouchUncheckedCreateWithoutArchivedBuildInput> | ArchivedTouchCreateWithoutArchivedBuildInput[] | ArchivedTouchUncheckedCreateWithoutArchivedBuildInput[]
    connectOrCreate?: ArchivedTouchCreateOrConnectWithoutArchivedBuildInput | ArchivedTouchCreateOrConnectWithoutArchivedBuildInput[]
    upsert?: ArchivedTouchUpsertWithWhereUniqueWithoutArchivedBuildInput | ArchivedTouchUpsertWithWhereUniqueWithoutArchivedBuildInput[]
    createMany?: ArchivedTouchCreateManyArchivedBuildInputEnvelope
    set?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    disconnect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    delete?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    connect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    update?: ArchivedTouchUpdateWithWhereUniqueWithoutArchivedBuildInput | ArchivedTouchUpdateWithWhereUniqueWithoutArchivedBuildInput[]
    updateMany?: ArchivedTouchUpdateManyWithWhereWithoutArchivedBuildInput | ArchivedTouchUpdateManyWithWhereWithoutArchivedBuildInput[]
    deleteMany?: ArchivedTouchScalarWhereInput | ArchivedTouchScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBuildUserInput = {
    create?: XOR<UserCreateWithoutBuildUserInput, UserUncheckedCreateWithoutBuildUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutBuildUserInput
    connect?: UserWhereUniqueInput
  }

  export type BuildCreateNestedOneWithoutBuildUserInput = {
    create?: XOR<BuildCreateWithoutBuildUserInput, BuildUncheckedCreateWithoutBuildUserInput>
    connectOrCreate?: BuildCreateOrConnectWithoutBuildUserInput
    connect?: BuildWhereUniqueInput
  }

  export type UserUpdateOneWithoutBuildUserNestedInput = {
    create?: XOR<UserCreateWithoutBuildUserInput, UserUncheckedCreateWithoutBuildUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutBuildUserInput
    upsert?: UserUpsertWithoutBuildUserInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBuildUserInput, UserUpdateWithoutBuildUserInput>, UserUncheckedUpdateWithoutBuildUserInput>
  }

  export type BuildUpdateOneWithoutBuildUserNestedInput = {
    create?: XOR<BuildCreateWithoutBuildUserInput, BuildUncheckedCreateWithoutBuildUserInput>
    connectOrCreate?: BuildCreateOrConnectWithoutBuildUserInput
    upsert?: BuildUpsertWithoutBuildUserInput
    disconnect?: BuildWhereInput | boolean
    delete?: BuildWhereInput | boolean
    connect?: BuildWhereUniqueInput
    update?: XOR<XOR<BuildUpdateToOneWithWhereWithoutBuildUserInput, BuildUpdateWithoutBuildUserInput>, BuildUncheckedUpdateWithoutBuildUserInput>
  }

  export type UserCreateNestedOneWithoutRecipeInput = {
    create?: XOR<UserCreateWithoutRecipeInput, UserUncheckedCreateWithoutRecipeInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRecipeEditedByInput = {
    create?: XOR<UserCreateWithoutRecipeEditedByInput, UserUncheckedCreateWithoutRecipeEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeEditedByInput
    connect?: UserWhereUniqueInput
  }

  export type BuildCreateNestedManyWithoutRecipeInput = {
    create?: XOR<BuildCreateWithoutRecipeInput, BuildUncheckedCreateWithoutRecipeInput> | BuildCreateWithoutRecipeInput[] | BuildUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: BuildCreateOrConnectWithoutRecipeInput | BuildCreateOrConnectWithoutRecipeInput[]
    createMany?: BuildCreateManyRecipeInputEnvelope
    connect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
  }

  export type ArchivedBuildCreateNestedManyWithoutRecipeInput = {
    create?: XOR<ArchivedBuildCreateWithoutRecipeInput, ArchivedBuildUncheckedCreateWithoutRecipeInput> | ArchivedBuildCreateWithoutRecipeInput[] | ArchivedBuildUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: ArchivedBuildCreateOrConnectWithoutRecipeInput | ArchivedBuildCreateOrConnectWithoutRecipeInput[]
    createMany?: ArchivedBuildCreateManyRecipeInputEnvelope
    connect?: ArchivedBuildWhereUniqueInput | ArchivedBuildWhereUniqueInput[]
  }

  export type BuildUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<BuildCreateWithoutRecipeInput, BuildUncheckedCreateWithoutRecipeInput> | BuildCreateWithoutRecipeInput[] | BuildUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: BuildCreateOrConnectWithoutRecipeInput | BuildCreateOrConnectWithoutRecipeInput[]
    createMany?: BuildCreateManyRecipeInputEnvelope
    connect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
  }

  export type ArchivedBuildUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<ArchivedBuildCreateWithoutRecipeInput, ArchivedBuildUncheckedCreateWithoutRecipeInput> | ArchivedBuildCreateWithoutRecipeInput[] | ArchivedBuildUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: ArchivedBuildCreateOrConnectWithoutRecipeInput | ArchivedBuildCreateOrConnectWithoutRecipeInput[]
    createMany?: ArchivedBuildCreateManyRecipeInputEnvelope
    connect?: ArchivedBuildWhereUniqueInput | ArchivedBuildWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutRecipeNestedInput = {
    create?: XOR<UserCreateWithoutRecipeInput, UserUncheckedCreateWithoutRecipeInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeInput
    upsert?: UserUpsertWithoutRecipeInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRecipeInput, UserUpdateWithoutRecipeInput>, UserUncheckedUpdateWithoutRecipeInput>
  }

  export type UserUpdateOneWithoutRecipeEditedByNestedInput = {
    create?: XOR<UserCreateWithoutRecipeEditedByInput, UserUncheckedCreateWithoutRecipeEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeEditedByInput
    upsert?: UserUpsertWithoutRecipeEditedByInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRecipeEditedByInput, UserUpdateWithoutRecipeEditedByInput>, UserUncheckedUpdateWithoutRecipeEditedByInput>
  }

  export type BuildUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<BuildCreateWithoutRecipeInput, BuildUncheckedCreateWithoutRecipeInput> | BuildCreateWithoutRecipeInput[] | BuildUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: BuildCreateOrConnectWithoutRecipeInput | BuildCreateOrConnectWithoutRecipeInput[]
    upsert?: BuildUpsertWithWhereUniqueWithoutRecipeInput | BuildUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: BuildCreateManyRecipeInputEnvelope
    set?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    disconnect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    delete?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    connect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    update?: BuildUpdateWithWhereUniqueWithoutRecipeInput | BuildUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: BuildUpdateManyWithWhereWithoutRecipeInput | BuildUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: BuildScalarWhereInput | BuildScalarWhereInput[]
  }

  export type ArchivedBuildUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<ArchivedBuildCreateWithoutRecipeInput, ArchivedBuildUncheckedCreateWithoutRecipeInput> | ArchivedBuildCreateWithoutRecipeInput[] | ArchivedBuildUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: ArchivedBuildCreateOrConnectWithoutRecipeInput | ArchivedBuildCreateOrConnectWithoutRecipeInput[]
    upsert?: ArchivedBuildUpsertWithWhereUniqueWithoutRecipeInput | ArchivedBuildUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: ArchivedBuildCreateManyRecipeInputEnvelope
    set?: ArchivedBuildWhereUniqueInput | ArchivedBuildWhereUniqueInput[]
    disconnect?: ArchivedBuildWhereUniqueInput | ArchivedBuildWhereUniqueInput[]
    delete?: ArchivedBuildWhereUniqueInput | ArchivedBuildWhereUniqueInput[]
    connect?: ArchivedBuildWhereUniqueInput | ArchivedBuildWhereUniqueInput[]
    update?: ArchivedBuildUpdateWithWhereUniqueWithoutRecipeInput | ArchivedBuildUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: ArchivedBuildUpdateManyWithWhereWithoutRecipeInput | ArchivedBuildUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: ArchivedBuildScalarWhereInput | ArchivedBuildScalarWhereInput[]
  }

  export type BuildUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<BuildCreateWithoutRecipeInput, BuildUncheckedCreateWithoutRecipeInput> | BuildCreateWithoutRecipeInput[] | BuildUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: BuildCreateOrConnectWithoutRecipeInput | BuildCreateOrConnectWithoutRecipeInput[]
    upsert?: BuildUpsertWithWhereUniqueWithoutRecipeInput | BuildUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: BuildCreateManyRecipeInputEnvelope
    set?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    disconnect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    delete?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    connect?: BuildWhereUniqueInput | BuildWhereUniqueInput[]
    update?: BuildUpdateWithWhereUniqueWithoutRecipeInput | BuildUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: BuildUpdateManyWithWhereWithoutRecipeInput | BuildUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: BuildScalarWhereInput | BuildScalarWhereInput[]
  }

  export type ArchivedBuildUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<ArchivedBuildCreateWithoutRecipeInput, ArchivedBuildUncheckedCreateWithoutRecipeInput> | ArchivedBuildCreateWithoutRecipeInput[] | ArchivedBuildUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: ArchivedBuildCreateOrConnectWithoutRecipeInput | ArchivedBuildCreateOrConnectWithoutRecipeInput[]
    upsert?: ArchivedBuildUpsertWithWhereUniqueWithoutRecipeInput | ArchivedBuildUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: ArchivedBuildCreateManyRecipeInputEnvelope
    set?: ArchivedBuildWhereUniqueInput | ArchivedBuildWhereUniqueInput[]
    disconnect?: ArchivedBuildWhereUniqueInput | ArchivedBuildWhereUniqueInput[]
    delete?: ArchivedBuildWhereUniqueInput | ArchivedBuildWhereUniqueInput[]
    connect?: ArchivedBuildWhereUniqueInput | ArchivedBuildWhereUniqueInput[]
    update?: ArchivedBuildUpdateWithWhereUniqueWithoutRecipeInput | ArchivedBuildUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: ArchivedBuildUpdateManyWithWhereWithoutRecipeInput | ArchivedBuildUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: ArchivedBuildScalarWhereInput | ArchivedBuildScalarWhereInput[]
  }

  export type RecipeBookCreateNestedOneWithoutRecipeBookBuildInput = {
    create?: XOR<RecipeBookCreateWithoutRecipeBookBuildInput, RecipeBookUncheckedCreateWithoutRecipeBookBuildInput>
    connectOrCreate?: RecipeBookCreateOrConnectWithoutRecipeBookBuildInput
    connect?: RecipeBookWhereUniqueInput
  }

  export type BuildCreateNestedOneWithoutRecipeBookBuildInput = {
    create?: XOR<BuildCreateWithoutRecipeBookBuildInput, BuildUncheckedCreateWithoutRecipeBookBuildInput>
    connectOrCreate?: BuildCreateOrConnectWithoutRecipeBookBuildInput
    connect?: BuildWhereUniqueInput
  }

  export type RecipeBookUpdateOneRequiredWithoutRecipeBookBuildNestedInput = {
    create?: XOR<RecipeBookCreateWithoutRecipeBookBuildInput, RecipeBookUncheckedCreateWithoutRecipeBookBuildInput>
    connectOrCreate?: RecipeBookCreateOrConnectWithoutRecipeBookBuildInput
    upsert?: RecipeBookUpsertWithoutRecipeBookBuildInput
    connect?: RecipeBookWhereUniqueInput
    update?: XOR<XOR<RecipeBookUpdateToOneWithWhereWithoutRecipeBookBuildInput, RecipeBookUpdateWithoutRecipeBookBuildInput>, RecipeBookUncheckedUpdateWithoutRecipeBookBuildInput>
  }

  export type BuildUpdateOneRequiredWithoutRecipeBookBuildNestedInput = {
    create?: XOR<BuildCreateWithoutRecipeBookBuildInput, BuildUncheckedCreateWithoutRecipeBookBuildInput>
    connectOrCreate?: BuildCreateOrConnectWithoutRecipeBookBuildInput
    upsert?: BuildUpsertWithoutRecipeBookBuildInput
    connect?: BuildWhereUniqueInput
    update?: XOR<XOR<BuildUpdateToOneWithWhereWithoutRecipeBookBuildInput, BuildUpdateWithoutRecipeBookBuildInput>, BuildUncheckedUpdateWithoutRecipeBookBuildInput>
  }

  export type BuildCreateNestedOneWithoutTouchInput = {
    create?: XOR<BuildCreateWithoutTouchInput, BuildUncheckedCreateWithoutTouchInput>
    connectOrCreate?: BuildCreateOrConnectWithoutTouchInput
    connect?: BuildWhereUniqueInput
  }

  export type IngredientTypeCreateNestedOneWithoutTouchInput = {
    create?: XOR<IngredientTypeCreateWithoutTouchInput, IngredientTypeUncheckedCreateWithoutTouchInput>
    connectOrCreate?: IngredientTypeCreateOrConnectWithoutTouchInput
    connect?: IngredientTypeWhereUniqueInput
  }

  export type IngredientCreateNestedOneWithoutTouchInput = {
    create?: XOR<IngredientCreateWithoutTouchInput, IngredientUncheckedCreateWithoutTouchInput>
    connectOrCreate?: IngredientCreateOrConnectWithoutTouchInput
    connect?: IngredientWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BuildUpdateOneRequiredWithoutTouchNestedInput = {
    create?: XOR<BuildCreateWithoutTouchInput, BuildUncheckedCreateWithoutTouchInput>
    connectOrCreate?: BuildCreateOrConnectWithoutTouchInput
    upsert?: BuildUpsertWithoutTouchInput
    connect?: BuildWhereUniqueInput
    update?: XOR<XOR<BuildUpdateToOneWithWhereWithoutTouchInput, BuildUpdateWithoutTouchInput>, BuildUncheckedUpdateWithoutTouchInput>
  }

  export type IngredientTypeUpdateOneRequiredWithoutTouchNestedInput = {
    create?: XOR<IngredientTypeCreateWithoutTouchInput, IngredientTypeUncheckedCreateWithoutTouchInput>
    connectOrCreate?: IngredientTypeCreateOrConnectWithoutTouchInput
    upsert?: IngredientTypeUpsertWithoutTouchInput
    connect?: IngredientTypeWhereUniqueInput
    update?: XOR<XOR<IngredientTypeUpdateToOneWithWhereWithoutTouchInput, IngredientTypeUpdateWithoutTouchInput>, IngredientTypeUncheckedUpdateWithoutTouchInput>
  }

  export type IngredientUpdateOneWithoutTouchNestedInput = {
    create?: XOR<IngredientCreateWithoutTouchInput, IngredientUncheckedCreateWithoutTouchInput>
    connectOrCreate?: IngredientCreateOrConnectWithoutTouchInput
    upsert?: IngredientUpsertWithoutTouchInput
    disconnect?: IngredientWhereInput | boolean
    delete?: IngredientWhereInput | boolean
    connect?: IngredientWhereUniqueInput
    update?: XOR<XOR<IngredientUpdateToOneWithWhereWithoutTouchInput, IngredientUpdateWithoutTouchInput>, IngredientUncheckedUpdateWithoutTouchInput>
  }

  export type ArchivedBuildCreateNestedOneWithoutArchivedTouchInput = {
    create?: XOR<ArchivedBuildCreateWithoutArchivedTouchInput, ArchivedBuildUncheckedCreateWithoutArchivedTouchInput>
    connectOrCreate?: ArchivedBuildCreateOrConnectWithoutArchivedTouchInput
    connect?: ArchivedBuildWhereUniqueInput
  }

  export type IngredientTypeCreateNestedOneWithoutArchivedTouchInput = {
    create?: XOR<IngredientTypeCreateWithoutArchivedTouchInput, IngredientTypeUncheckedCreateWithoutArchivedTouchInput>
    connectOrCreate?: IngredientTypeCreateOrConnectWithoutArchivedTouchInput
    connect?: IngredientTypeWhereUniqueInput
  }

  export type IngredientCreateNestedOneWithoutArchivedTouchInput = {
    create?: XOR<IngredientCreateWithoutArchivedTouchInput, IngredientUncheckedCreateWithoutArchivedTouchInput>
    connectOrCreate?: IngredientCreateOrConnectWithoutArchivedTouchInput
    connect?: IngredientWhereUniqueInput
  }

  export type ArchivedBuildUpdateOneRequiredWithoutArchivedTouchNestedInput = {
    create?: XOR<ArchivedBuildCreateWithoutArchivedTouchInput, ArchivedBuildUncheckedCreateWithoutArchivedTouchInput>
    connectOrCreate?: ArchivedBuildCreateOrConnectWithoutArchivedTouchInput
    upsert?: ArchivedBuildUpsertWithoutArchivedTouchInput
    connect?: ArchivedBuildWhereUniqueInput
    update?: XOR<XOR<ArchivedBuildUpdateToOneWithWhereWithoutArchivedTouchInput, ArchivedBuildUpdateWithoutArchivedTouchInput>, ArchivedBuildUncheckedUpdateWithoutArchivedTouchInput>
  }

  export type IngredientTypeUpdateOneRequiredWithoutArchivedTouchNestedInput = {
    create?: XOR<IngredientTypeCreateWithoutArchivedTouchInput, IngredientTypeUncheckedCreateWithoutArchivedTouchInput>
    connectOrCreate?: IngredientTypeCreateOrConnectWithoutArchivedTouchInput
    upsert?: IngredientTypeUpsertWithoutArchivedTouchInput
    connect?: IngredientTypeWhereUniqueInput
    update?: XOR<XOR<IngredientTypeUpdateToOneWithWhereWithoutArchivedTouchInput, IngredientTypeUpdateWithoutArchivedTouchInput>, IngredientTypeUncheckedUpdateWithoutArchivedTouchInput>
  }

  export type IngredientUpdateOneWithoutArchivedTouchNestedInput = {
    create?: XOR<IngredientCreateWithoutArchivedTouchInput, IngredientUncheckedCreateWithoutArchivedTouchInput>
    connectOrCreate?: IngredientCreateOrConnectWithoutArchivedTouchInput
    upsert?: IngredientUpsertWithoutArchivedTouchInput
    disconnect?: IngredientWhereInput | boolean
    delete?: IngredientWhereInput | boolean
    connect?: IngredientWhereUniqueInput
    update?: XOR<XOR<IngredientUpdateToOneWithWhereWithoutArchivedTouchInput, IngredientUpdateWithoutArchivedTouchInput>, IngredientUncheckedUpdateWithoutArchivedTouchInput>
  }

  export type TouchCreateNestedManyWithoutIngredientTypeInput = {
    create?: XOR<TouchCreateWithoutIngredientTypeInput, TouchUncheckedCreateWithoutIngredientTypeInput> | TouchCreateWithoutIngredientTypeInput[] | TouchUncheckedCreateWithoutIngredientTypeInput[]
    connectOrCreate?: TouchCreateOrConnectWithoutIngredientTypeInput | TouchCreateOrConnectWithoutIngredientTypeInput[]
    createMany?: TouchCreateManyIngredientTypeInputEnvelope
    connect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
  }

  export type ArchivedTouchCreateNestedManyWithoutIngredientTypeInput = {
    create?: XOR<ArchivedTouchCreateWithoutIngredientTypeInput, ArchivedTouchUncheckedCreateWithoutIngredientTypeInput> | ArchivedTouchCreateWithoutIngredientTypeInput[] | ArchivedTouchUncheckedCreateWithoutIngredientTypeInput[]
    connectOrCreate?: ArchivedTouchCreateOrConnectWithoutIngredientTypeInput | ArchivedTouchCreateOrConnectWithoutIngredientTypeInput[]
    createMany?: ArchivedTouchCreateManyIngredientTypeInputEnvelope
    connect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
  }

  export type IngredientCreateNestedManyWithoutIngredientTypeInput = {
    create?: XOR<IngredientCreateWithoutIngredientTypeInput, IngredientUncheckedCreateWithoutIngredientTypeInput> | IngredientCreateWithoutIngredientTypeInput[] | IngredientUncheckedCreateWithoutIngredientTypeInput[]
    connectOrCreate?: IngredientCreateOrConnectWithoutIngredientTypeInput | IngredientCreateOrConnectWithoutIngredientTypeInput[]
    createMany?: IngredientCreateManyIngredientTypeInputEnvelope
    connect?: IngredientWhereUniqueInput | IngredientWhereUniqueInput[]
  }

  export type IngredientPreferenceCreateNestedManyWithoutIngredientTypeInput = {
    create?: XOR<IngredientPreferenceCreateWithoutIngredientTypeInput, IngredientPreferenceUncheckedCreateWithoutIngredientTypeInput> | IngredientPreferenceCreateWithoutIngredientTypeInput[] | IngredientPreferenceUncheckedCreateWithoutIngredientTypeInput[]
    connectOrCreate?: IngredientPreferenceCreateOrConnectWithoutIngredientTypeInput | IngredientPreferenceCreateOrConnectWithoutIngredientTypeInput[]
    createMany?: IngredientPreferenceCreateManyIngredientTypeInputEnvelope
    connect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
  }

  export type TouchUncheckedCreateNestedManyWithoutIngredientTypeInput = {
    create?: XOR<TouchCreateWithoutIngredientTypeInput, TouchUncheckedCreateWithoutIngredientTypeInput> | TouchCreateWithoutIngredientTypeInput[] | TouchUncheckedCreateWithoutIngredientTypeInput[]
    connectOrCreate?: TouchCreateOrConnectWithoutIngredientTypeInput | TouchCreateOrConnectWithoutIngredientTypeInput[]
    createMany?: TouchCreateManyIngredientTypeInputEnvelope
    connect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
  }

  export type ArchivedTouchUncheckedCreateNestedManyWithoutIngredientTypeInput = {
    create?: XOR<ArchivedTouchCreateWithoutIngredientTypeInput, ArchivedTouchUncheckedCreateWithoutIngredientTypeInput> | ArchivedTouchCreateWithoutIngredientTypeInput[] | ArchivedTouchUncheckedCreateWithoutIngredientTypeInput[]
    connectOrCreate?: ArchivedTouchCreateOrConnectWithoutIngredientTypeInput | ArchivedTouchCreateOrConnectWithoutIngredientTypeInput[]
    createMany?: ArchivedTouchCreateManyIngredientTypeInputEnvelope
    connect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
  }

  export type IngredientUncheckedCreateNestedManyWithoutIngredientTypeInput = {
    create?: XOR<IngredientCreateWithoutIngredientTypeInput, IngredientUncheckedCreateWithoutIngredientTypeInput> | IngredientCreateWithoutIngredientTypeInput[] | IngredientUncheckedCreateWithoutIngredientTypeInput[]
    connectOrCreate?: IngredientCreateOrConnectWithoutIngredientTypeInput | IngredientCreateOrConnectWithoutIngredientTypeInput[]
    createMany?: IngredientCreateManyIngredientTypeInputEnvelope
    connect?: IngredientWhereUniqueInput | IngredientWhereUniqueInput[]
  }

  export type IngredientPreferenceUncheckedCreateNestedManyWithoutIngredientTypeInput = {
    create?: XOR<IngredientPreferenceCreateWithoutIngredientTypeInput, IngredientPreferenceUncheckedCreateWithoutIngredientTypeInput> | IngredientPreferenceCreateWithoutIngredientTypeInput[] | IngredientPreferenceUncheckedCreateWithoutIngredientTypeInput[]
    connectOrCreate?: IngredientPreferenceCreateOrConnectWithoutIngredientTypeInput | IngredientPreferenceCreateOrConnectWithoutIngredientTypeInput[]
    createMany?: IngredientPreferenceCreateManyIngredientTypeInputEnvelope
    connect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
  }

  export type TouchUpdateManyWithoutIngredientTypeNestedInput = {
    create?: XOR<TouchCreateWithoutIngredientTypeInput, TouchUncheckedCreateWithoutIngredientTypeInput> | TouchCreateWithoutIngredientTypeInput[] | TouchUncheckedCreateWithoutIngredientTypeInput[]
    connectOrCreate?: TouchCreateOrConnectWithoutIngredientTypeInput | TouchCreateOrConnectWithoutIngredientTypeInput[]
    upsert?: TouchUpsertWithWhereUniqueWithoutIngredientTypeInput | TouchUpsertWithWhereUniqueWithoutIngredientTypeInput[]
    createMany?: TouchCreateManyIngredientTypeInputEnvelope
    set?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    disconnect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    delete?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    connect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    update?: TouchUpdateWithWhereUniqueWithoutIngredientTypeInput | TouchUpdateWithWhereUniqueWithoutIngredientTypeInput[]
    updateMany?: TouchUpdateManyWithWhereWithoutIngredientTypeInput | TouchUpdateManyWithWhereWithoutIngredientTypeInput[]
    deleteMany?: TouchScalarWhereInput | TouchScalarWhereInput[]
  }

  export type ArchivedTouchUpdateManyWithoutIngredientTypeNestedInput = {
    create?: XOR<ArchivedTouchCreateWithoutIngredientTypeInput, ArchivedTouchUncheckedCreateWithoutIngredientTypeInput> | ArchivedTouchCreateWithoutIngredientTypeInput[] | ArchivedTouchUncheckedCreateWithoutIngredientTypeInput[]
    connectOrCreate?: ArchivedTouchCreateOrConnectWithoutIngredientTypeInput | ArchivedTouchCreateOrConnectWithoutIngredientTypeInput[]
    upsert?: ArchivedTouchUpsertWithWhereUniqueWithoutIngredientTypeInput | ArchivedTouchUpsertWithWhereUniqueWithoutIngredientTypeInput[]
    createMany?: ArchivedTouchCreateManyIngredientTypeInputEnvelope
    set?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    disconnect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    delete?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    connect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    update?: ArchivedTouchUpdateWithWhereUniqueWithoutIngredientTypeInput | ArchivedTouchUpdateWithWhereUniqueWithoutIngredientTypeInput[]
    updateMany?: ArchivedTouchUpdateManyWithWhereWithoutIngredientTypeInput | ArchivedTouchUpdateManyWithWhereWithoutIngredientTypeInput[]
    deleteMany?: ArchivedTouchScalarWhereInput | ArchivedTouchScalarWhereInput[]
  }

  export type IngredientUpdateManyWithoutIngredientTypeNestedInput = {
    create?: XOR<IngredientCreateWithoutIngredientTypeInput, IngredientUncheckedCreateWithoutIngredientTypeInput> | IngredientCreateWithoutIngredientTypeInput[] | IngredientUncheckedCreateWithoutIngredientTypeInput[]
    connectOrCreate?: IngredientCreateOrConnectWithoutIngredientTypeInput | IngredientCreateOrConnectWithoutIngredientTypeInput[]
    upsert?: IngredientUpsertWithWhereUniqueWithoutIngredientTypeInput | IngredientUpsertWithWhereUniqueWithoutIngredientTypeInput[]
    createMany?: IngredientCreateManyIngredientTypeInputEnvelope
    set?: IngredientWhereUniqueInput | IngredientWhereUniqueInput[]
    disconnect?: IngredientWhereUniqueInput | IngredientWhereUniqueInput[]
    delete?: IngredientWhereUniqueInput | IngredientWhereUniqueInput[]
    connect?: IngredientWhereUniqueInput | IngredientWhereUniqueInput[]
    update?: IngredientUpdateWithWhereUniqueWithoutIngredientTypeInput | IngredientUpdateWithWhereUniqueWithoutIngredientTypeInput[]
    updateMany?: IngredientUpdateManyWithWhereWithoutIngredientTypeInput | IngredientUpdateManyWithWhereWithoutIngredientTypeInput[]
    deleteMany?: IngredientScalarWhereInput | IngredientScalarWhereInput[]
  }

  export type IngredientPreferenceUpdateManyWithoutIngredientTypeNestedInput = {
    create?: XOR<IngredientPreferenceCreateWithoutIngredientTypeInput, IngredientPreferenceUncheckedCreateWithoutIngredientTypeInput> | IngredientPreferenceCreateWithoutIngredientTypeInput[] | IngredientPreferenceUncheckedCreateWithoutIngredientTypeInput[]
    connectOrCreate?: IngredientPreferenceCreateOrConnectWithoutIngredientTypeInput | IngredientPreferenceCreateOrConnectWithoutIngredientTypeInput[]
    upsert?: IngredientPreferenceUpsertWithWhereUniqueWithoutIngredientTypeInput | IngredientPreferenceUpsertWithWhereUniqueWithoutIngredientTypeInput[]
    createMany?: IngredientPreferenceCreateManyIngredientTypeInputEnvelope
    set?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    disconnect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    delete?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    connect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    update?: IngredientPreferenceUpdateWithWhereUniqueWithoutIngredientTypeInput | IngredientPreferenceUpdateWithWhereUniqueWithoutIngredientTypeInput[]
    updateMany?: IngredientPreferenceUpdateManyWithWhereWithoutIngredientTypeInput | IngredientPreferenceUpdateManyWithWhereWithoutIngredientTypeInput[]
    deleteMany?: IngredientPreferenceScalarWhereInput | IngredientPreferenceScalarWhereInput[]
  }

  export type TouchUncheckedUpdateManyWithoutIngredientTypeNestedInput = {
    create?: XOR<TouchCreateWithoutIngredientTypeInput, TouchUncheckedCreateWithoutIngredientTypeInput> | TouchCreateWithoutIngredientTypeInput[] | TouchUncheckedCreateWithoutIngredientTypeInput[]
    connectOrCreate?: TouchCreateOrConnectWithoutIngredientTypeInput | TouchCreateOrConnectWithoutIngredientTypeInput[]
    upsert?: TouchUpsertWithWhereUniqueWithoutIngredientTypeInput | TouchUpsertWithWhereUniqueWithoutIngredientTypeInput[]
    createMany?: TouchCreateManyIngredientTypeInputEnvelope
    set?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    disconnect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    delete?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    connect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    update?: TouchUpdateWithWhereUniqueWithoutIngredientTypeInput | TouchUpdateWithWhereUniqueWithoutIngredientTypeInput[]
    updateMany?: TouchUpdateManyWithWhereWithoutIngredientTypeInput | TouchUpdateManyWithWhereWithoutIngredientTypeInput[]
    deleteMany?: TouchScalarWhereInput | TouchScalarWhereInput[]
  }

  export type ArchivedTouchUncheckedUpdateManyWithoutIngredientTypeNestedInput = {
    create?: XOR<ArchivedTouchCreateWithoutIngredientTypeInput, ArchivedTouchUncheckedCreateWithoutIngredientTypeInput> | ArchivedTouchCreateWithoutIngredientTypeInput[] | ArchivedTouchUncheckedCreateWithoutIngredientTypeInput[]
    connectOrCreate?: ArchivedTouchCreateOrConnectWithoutIngredientTypeInput | ArchivedTouchCreateOrConnectWithoutIngredientTypeInput[]
    upsert?: ArchivedTouchUpsertWithWhereUniqueWithoutIngredientTypeInput | ArchivedTouchUpsertWithWhereUniqueWithoutIngredientTypeInput[]
    createMany?: ArchivedTouchCreateManyIngredientTypeInputEnvelope
    set?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    disconnect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    delete?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    connect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    update?: ArchivedTouchUpdateWithWhereUniqueWithoutIngredientTypeInput | ArchivedTouchUpdateWithWhereUniqueWithoutIngredientTypeInput[]
    updateMany?: ArchivedTouchUpdateManyWithWhereWithoutIngredientTypeInput | ArchivedTouchUpdateManyWithWhereWithoutIngredientTypeInput[]
    deleteMany?: ArchivedTouchScalarWhereInput | ArchivedTouchScalarWhereInput[]
  }

  export type IngredientUncheckedUpdateManyWithoutIngredientTypeNestedInput = {
    create?: XOR<IngredientCreateWithoutIngredientTypeInput, IngredientUncheckedCreateWithoutIngredientTypeInput> | IngredientCreateWithoutIngredientTypeInput[] | IngredientUncheckedCreateWithoutIngredientTypeInput[]
    connectOrCreate?: IngredientCreateOrConnectWithoutIngredientTypeInput | IngredientCreateOrConnectWithoutIngredientTypeInput[]
    upsert?: IngredientUpsertWithWhereUniqueWithoutIngredientTypeInput | IngredientUpsertWithWhereUniqueWithoutIngredientTypeInput[]
    createMany?: IngredientCreateManyIngredientTypeInputEnvelope
    set?: IngredientWhereUniqueInput | IngredientWhereUniqueInput[]
    disconnect?: IngredientWhereUniqueInput | IngredientWhereUniqueInput[]
    delete?: IngredientWhereUniqueInput | IngredientWhereUniqueInput[]
    connect?: IngredientWhereUniqueInput | IngredientWhereUniqueInput[]
    update?: IngredientUpdateWithWhereUniqueWithoutIngredientTypeInput | IngredientUpdateWithWhereUniqueWithoutIngredientTypeInput[]
    updateMany?: IngredientUpdateManyWithWhereWithoutIngredientTypeInput | IngredientUpdateManyWithWhereWithoutIngredientTypeInput[]
    deleteMany?: IngredientScalarWhereInput | IngredientScalarWhereInput[]
  }

  export type IngredientPreferenceUncheckedUpdateManyWithoutIngredientTypeNestedInput = {
    create?: XOR<IngredientPreferenceCreateWithoutIngredientTypeInput, IngredientPreferenceUncheckedCreateWithoutIngredientTypeInput> | IngredientPreferenceCreateWithoutIngredientTypeInput[] | IngredientPreferenceUncheckedCreateWithoutIngredientTypeInput[]
    connectOrCreate?: IngredientPreferenceCreateOrConnectWithoutIngredientTypeInput | IngredientPreferenceCreateOrConnectWithoutIngredientTypeInput[]
    upsert?: IngredientPreferenceUpsertWithWhereUniqueWithoutIngredientTypeInput | IngredientPreferenceUpsertWithWhereUniqueWithoutIngredientTypeInput[]
    createMany?: IngredientPreferenceCreateManyIngredientTypeInputEnvelope
    set?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    disconnect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    delete?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    connect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    update?: IngredientPreferenceUpdateWithWhereUniqueWithoutIngredientTypeInput | IngredientPreferenceUpdateWithWhereUniqueWithoutIngredientTypeInput[]
    updateMany?: IngredientPreferenceUpdateManyWithWhereWithoutIngredientTypeInput | IngredientPreferenceUpdateManyWithWhereWithoutIngredientTypeInput[]
    deleteMany?: IngredientPreferenceScalarWhereInput | IngredientPreferenceScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutIngredientInput = {
    create?: XOR<UserCreateWithoutIngredientInput, UserUncheckedCreateWithoutIngredientInput>
    connectOrCreate?: UserCreateOrConnectWithoutIngredientInput
    connect?: UserWhereUniqueInput
  }

  export type IngredientTypeCreateNestedOneWithoutIngredientInput = {
    create?: XOR<IngredientTypeCreateWithoutIngredientInput, IngredientTypeUncheckedCreateWithoutIngredientInput>
    connectOrCreate?: IngredientTypeCreateOrConnectWithoutIngredientInput
    connect?: IngredientTypeWhereUniqueInput
  }

  export type TouchCreateNestedManyWithoutIngredientInput = {
    create?: XOR<TouchCreateWithoutIngredientInput, TouchUncheckedCreateWithoutIngredientInput> | TouchCreateWithoutIngredientInput[] | TouchUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: TouchCreateOrConnectWithoutIngredientInput | TouchCreateOrConnectWithoutIngredientInput[]
    createMany?: TouchCreateManyIngredientInputEnvelope
    connect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
  }

  export type ArchivedTouchCreateNestedManyWithoutIngredientInput = {
    create?: XOR<ArchivedTouchCreateWithoutIngredientInput, ArchivedTouchUncheckedCreateWithoutIngredientInput> | ArchivedTouchCreateWithoutIngredientInput[] | ArchivedTouchUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: ArchivedTouchCreateOrConnectWithoutIngredientInput | ArchivedTouchCreateOrConnectWithoutIngredientInput[]
    createMany?: ArchivedTouchCreateManyIngredientInputEnvelope
    connect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
  }

  export type IngredientStorageCreateNestedManyWithoutIngredientInput = {
    create?: XOR<IngredientStorageCreateWithoutIngredientInput, IngredientStorageUncheckedCreateWithoutIngredientInput> | IngredientStorageCreateWithoutIngredientInput[] | IngredientStorageUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: IngredientStorageCreateOrConnectWithoutIngredientInput | IngredientStorageCreateOrConnectWithoutIngredientInput[]
    createMany?: IngredientStorageCreateManyIngredientInputEnvelope
    connect?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
  }

  export type IngredientUserCreateNestedManyWithoutIngredientInput = {
    create?: XOR<IngredientUserCreateWithoutIngredientInput, IngredientUserUncheckedCreateWithoutIngredientInput> | IngredientUserCreateWithoutIngredientInput[] | IngredientUserUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: IngredientUserCreateOrConnectWithoutIngredientInput | IngredientUserCreateOrConnectWithoutIngredientInput[]
    createMany?: IngredientUserCreateManyIngredientInputEnvelope
    connect?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
  }

  export type IngredientPreferenceCreateNestedManyWithoutIngredientInput = {
    create?: XOR<IngredientPreferenceCreateWithoutIngredientInput, IngredientPreferenceUncheckedCreateWithoutIngredientInput> | IngredientPreferenceCreateWithoutIngredientInput[] | IngredientPreferenceUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: IngredientPreferenceCreateOrConnectWithoutIngredientInput | IngredientPreferenceCreateOrConnectWithoutIngredientInput[]
    createMany?: IngredientPreferenceCreateManyIngredientInputEnvelope
    connect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
  }

  export type CrewIngredientCreateNestedManyWithoutIngredientInput = {
    create?: XOR<CrewIngredientCreateWithoutIngredientInput, CrewIngredientUncheckedCreateWithoutIngredientInput> | CrewIngredientCreateWithoutIngredientInput[] | CrewIngredientUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: CrewIngredientCreateOrConnectWithoutIngredientInput | CrewIngredientCreateOrConnectWithoutIngredientInput[]
    createMany?: CrewIngredientCreateManyIngredientInputEnvelope
    connect?: CrewIngredientWhereUniqueInput | CrewIngredientWhereUniqueInput[]
  }

  export type TouchUncheckedCreateNestedManyWithoutIngredientInput = {
    create?: XOR<TouchCreateWithoutIngredientInput, TouchUncheckedCreateWithoutIngredientInput> | TouchCreateWithoutIngredientInput[] | TouchUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: TouchCreateOrConnectWithoutIngredientInput | TouchCreateOrConnectWithoutIngredientInput[]
    createMany?: TouchCreateManyIngredientInputEnvelope
    connect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
  }

  export type ArchivedTouchUncheckedCreateNestedManyWithoutIngredientInput = {
    create?: XOR<ArchivedTouchCreateWithoutIngredientInput, ArchivedTouchUncheckedCreateWithoutIngredientInput> | ArchivedTouchCreateWithoutIngredientInput[] | ArchivedTouchUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: ArchivedTouchCreateOrConnectWithoutIngredientInput | ArchivedTouchCreateOrConnectWithoutIngredientInput[]
    createMany?: ArchivedTouchCreateManyIngredientInputEnvelope
    connect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
  }

  export type IngredientStorageUncheckedCreateNestedManyWithoutIngredientInput = {
    create?: XOR<IngredientStorageCreateWithoutIngredientInput, IngredientStorageUncheckedCreateWithoutIngredientInput> | IngredientStorageCreateWithoutIngredientInput[] | IngredientStorageUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: IngredientStorageCreateOrConnectWithoutIngredientInput | IngredientStorageCreateOrConnectWithoutIngredientInput[]
    createMany?: IngredientStorageCreateManyIngredientInputEnvelope
    connect?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
  }

  export type IngredientUserUncheckedCreateNestedManyWithoutIngredientInput = {
    create?: XOR<IngredientUserCreateWithoutIngredientInput, IngredientUserUncheckedCreateWithoutIngredientInput> | IngredientUserCreateWithoutIngredientInput[] | IngredientUserUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: IngredientUserCreateOrConnectWithoutIngredientInput | IngredientUserCreateOrConnectWithoutIngredientInput[]
    createMany?: IngredientUserCreateManyIngredientInputEnvelope
    connect?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
  }

  export type IngredientPreferenceUncheckedCreateNestedManyWithoutIngredientInput = {
    create?: XOR<IngredientPreferenceCreateWithoutIngredientInput, IngredientPreferenceUncheckedCreateWithoutIngredientInput> | IngredientPreferenceCreateWithoutIngredientInput[] | IngredientPreferenceUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: IngredientPreferenceCreateOrConnectWithoutIngredientInput | IngredientPreferenceCreateOrConnectWithoutIngredientInput[]
    createMany?: IngredientPreferenceCreateManyIngredientInputEnvelope
    connect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
  }

  export type CrewIngredientUncheckedCreateNestedManyWithoutIngredientInput = {
    create?: XOR<CrewIngredientCreateWithoutIngredientInput, CrewIngredientUncheckedCreateWithoutIngredientInput> | CrewIngredientCreateWithoutIngredientInput[] | CrewIngredientUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: CrewIngredientCreateOrConnectWithoutIngredientInput | CrewIngredientCreateOrConnectWithoutIngredientInput[]
    createMany?: CrewIngredientCreateManyIngredientInputEnvelope
    connect?: CrewIngredientWhereUniqueInput | CrewIngredientWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutIngredientNestedInput = {
    create?: XOR<UserCreateWithoutIngredientInput, UserUncheckedCreateWithoutIngredientInput>
    connectOrCreate?: UserCreateOrConnectWithoutIngredientInput
    upsert?: UserUpsertWithoutIngredientInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIngredientInput, UserUpdateWithoutIngredientInput>, UserUncheckedUpdateWithoutIngredientInput>
  }

  export type IngredientTypeUpdateOneRequiredWithoutIngredientNestedInput = {
    create?: XOR<IngredientTypeCreateWithoutIngredientInput, IngredientTypeUncheckedCreateWithoutIngredientInput>
    connectOrCreate?: IngredientTypeCreateOrConnectWithoutIngredientInput
    upsert?: IngredientTypeUpsertWithoutIngredientInput
    connect?: IngredientTypeWhereUniqueInput
    update?: XOR<XOR<IngredientTypeUpdateToOneWithWhereWithoutIngredientInput, IngredientTypeUpdateWithoutIngredientInput>, IngredientTypeUncheckedUpdateWithoutIngredientInput>
  }

  export type TouchUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<TouchCreateWithoutIngredientInput, TouchUncheckedCreateWithoutIngredientInput> | TouchCreateWithoutIngredientInput[] | TouchUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: TouchCreateOrConnectWithoutIngredientInput | TouchCreateOrConnectWithoutIngredientInput[]
    upsert?: TouchUpsertWithWhereUniqueWithoutIngredientInput | TouchUpsertWithWhereUniqueWithoutIngredientInput[]
    createMany?: TouchCreateManyIngredientInputEnvelope
    set?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    disconnect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    delete?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    connect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    update?: TouchUpdateWithWhereUniqueWithoutIngredientInput | TouchUpdateWithWhereUniqueWithoutIngredientInput[]
    updateMany?: TouchUpdateManyWithWhereWithoutIngredientInput | TouchUpdateManyWithWhereWithoutIngredientInput[]
    deleteMany?: TouchScalarWhereInput | TouchScalarWhereInput[]
  }

  export type ArchivedTouchUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<ArchivedTouchCreateWithoutIngredientInput, ArchivedTouchUncheckedCreateWithoutIngredientInput> | ArchivedTouchCreateWithoutIngredientInput[] | ArchivedTouchUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: ArchivedTouchCreateOrConnectWithoutIngredientInput | ArchivedTouchCreateOrConnectWithoutIngredientInput[]
    upsert?: ArchivedTouchUpsertWithWhereUniqueWithoutIngredientInput | ArchivedTouchUpsertWithWhereUniqueWithoutIngredientInput[]
    createMany?: ArchivedTouchCreateManyIngredientInputEnvelope
    set?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    disconnect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    delete?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    connect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    update?: ArchivedTouchUpdateWithWhereUniqueWithoutIngredientInput | ArchivedTouchUpdateWithWhereUniqueWithoutIngredientInput[]
    updateMany?: ArchivedTouchUpdateManyWithWhereWithoutIngredientInput | ArchivedTouchUpdateManyWithWhereWithoutIngredientInput[]
    deleteMany?: ArchivedTouchScalarWhereInput | ArchivedTouchScalarWhereInput[]
  }

  export type IngredientStorageUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<IngredientStorageCreateWithoutIngredientInput, IngredientStorageUncheckedCreateWithoutIngredientInput> | IngredientStorageCreateWithoutIngredientInput[] | IngredientStorageUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: IngredientStorageCreateOrConnectWithoutIngredientInput | IngredientStorageCreateOrConnectWithoutIngredientInput[]
    upsert?: IngredientStorageUpsertWithWhereUniqueWithoutIngredientInput | IngredientStorageUpsertWithWhereUniqueWithoutIngredientInput[]
    createMany?: IngredientStorageCreateManyIngredientInputEnvelope
    set?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
    disconnect?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
    delete?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
    connect?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
    update?: IngredientStorageUpdateWithWhereUniqueWithoutIngredientInput | IngredientStorageUpdateWithWhereUniqueWithoutIngredientInput[]
    updateMany?: IngredientStorageUpdateManyWithWhereWithoutIngredientInput | IngredientStorageUpdateManyWithWhereWithoutIngredientInput[]
    deleteMany?: IngredientStorageScalarWhereInput | IngredientStorageScalarWhereInput[]
  }

  export type IngredientUserUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<IngredientUserCreateWithoutIngredientInput, IngredientUserUncheckedCreateWithoutIngredientInput> | IngredientUserCreateWithoutIngredientInput[] | IngredientUserUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: IngredientUserCreateOrConnectWithoutIngredientInput | IngredientUserCreateOrConnectWithoutIngredientInput[]
    upsert?: IngredientUserUpsertWithWhereUniqueWithoutIngredientInput | IngredientUserUpsertWithWhereUniqueWithoutIngredientInput[]
    createMany?: IngredientUserCreateManyIngredientInputEnvelope
    set?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
    disconnect?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
    delete?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
    connect?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
    update?: IngredientUserUpdateWithWhereUniqueWithoutIngredientInput | IngredientUserUpdateWithWhereUniqueWithoutIngredientInput[]
    updateMany?: IngredientUserUpdateManyWithWhereWithoutIngredientInput | IngredientUserUpdateManyWithWhereWithoutIngredientInput[]
    deleteMany?: IngredientUserScalarWhereInput | IngredientUserScalarWhereInput[]
  }

  export type IngredientPreferenceUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<IngredientPreferenceCreateWithoutIngredientInput, IngredientPreferenceUncheckedCreateWithoutIngredientInput> | IngredientPreferenceCreateWithoutIngredientInput[] | IngredientPreferenceUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: IngredientPreferenceCreateOrConnectWithoutIngredientInput | IngredientPreferenceCreateOrConnectWithoutIngredientInput[]
    upsert?: IngredientPreferenceUpsertWithWhereUniqueWithoutIngredientInput | IngredientPreferenceUpsertWithWhereUniqueWithoutIngredientInput[]
    createMany?: IngredientPreferenceCreateManyIngredientInputEnvelope
    set?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    disconnect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    delete?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    connect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    update?: IngredientPreferenceUpdateWithWhereUniqueWithoutIngredientInput | IngredientPreferenceUpdateWithWhereUniqueWithoutIngredientInput[]
    updateMany?: IngredientPreferenceUpdateManyWithWhereWithoutIngredientInput | IngredientPreferenceUpdateManyWithWhereWithoutIngredientInput[]
    deleteMany?: IngredientPreferenceScalarWhereInput | IngredientPreferenceScalarWhereInput[]
  }

  export type CrewIngredientUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<CrewIngredientCreateWithoutIngredientInput, CrewIngredientUncheckedCreateWithoutIngredientInput> | CrewIngredientCreateWithoutIngredientInput[] | CrewIngredientUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: CrewIngredientCreateOrConnectWithoutIngredientInput | CrewIngredientCreateOrConnectWithoutIngredientInput[]
    upsert?: CrewIngredientUpsertWithWhereUniqueWithoutIngredientInput | CrewIngredientUpsertWithWhereUniqueWithoutIngredientInput[]
    createMany?: CrewIngredientCreateManyIngredientInputEnvelope
    set?: CrewIngredientWhereUniqueInput | CrewIngredientWhereUniqueInput[]
    disconnect?: CrewIngredientWhereUniqueInput | CrewIngredientWhereUniqueInput[]
    delete?: CrewIngredientWhereUniqueInput | CrewIngredientWhereUniqueInput[]
    connect?: CrewIngredientWhereUniqueInput | CrewIngredientWhereUniqueInput[]
    update?: CrewIngredientUpdateWithWhereUniqueWithoutIngredientInput | CrewIngredientUpdateWithWhereUniqueWithoutIngredientInput[]
    updateMany?: CrewIngredientUpdateManyWithWhereWithoutIngredientInput | CrewIngredientUpdateManyWithWhereWithoutIngredientInput[]
    deleteMany?: CrewIngredientScalarWhereInput | CrewIngredientScalarWhereInput[]
  }

  export type TouchUncheckedUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<TouchCreateWithoutIngredientInput, TouchUncheckedCreateWithoutIngredientInput> | TouchCreateWithoutIngredientInput[] | TouchUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: TouchCreateOrConnectWithoutIngredientInput | TouchCreateOrConnectWithoutIngredientInput[]
    upsert?: TouchUpsertWithWhereUniqueWithoutIngredientInput | TouchUpsertWithWhereUniqueWithoutIngredientInput[]
    createMany?: TouchCreateManyIngredientInputEnvelope
    set?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    disconnect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    delete?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    connect?: TouchWhereUniqueInput | TouchWhereUniqueInput[]
    update?: TouchUpdateWithWhereUniqueWithoutIngredientInput | TouchUpdateWithWhereUniqueWithoutIngredientInput[]
    updateMany?: TouchUpdateManyWithWhereWithoutIngredientInput | TouchUpdateManyWithWhereWithoutIngredientInput[]
    deleteMany?: TouchScalarWhereInput | TouchScalarWhereInput[]
  }

  export type ArchivedTouchUncheckedUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<ArchivedTouchCreateWithoutIngredientInput, ArchivedTouchUncheckedCreateWithoutIngredientInput> | ArchivedTouchCreateWithoutIngredientInput[] | ArchivedTouchUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: ArchivedTouchCreateOrConnectWithoutIngredientInput | ArchivedTouchCreateOrConnectWithoutIngredientInput[]
    upsert?: ArchivedTouchUpsertWithWhereUniqueWithoutIngredientInput | ArchivedTouchUpsertWithWhereUniqueWithoutIngredientInput[]
    createMany?: ArchivedTouchCreateManyIngredientInputEnvelope
    set?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    disconnect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    delete?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    connect?: ArchivedTouchWhereUniqueInput | ArchivedTouchWhereUniqueInput[]
    update?: ArchivedTouchUpdateWithWhereUniqueWithoutIngredientInput | ArchivedTouchUpdateWithWhereUniqueWithoutIngredientInput[]
    updateMany?: ArchivedTouchUpdateManyWithWhereWithoutIngredientInput | ArchivedTouchUpdateManyWithWhereWithoutIngredientInput[]
    deleteMany?: ArchivedTouchScalarWhereInput | ArchivedTouchScalarWhereInput[]
  }

  export type IngredientStorageUncheckedUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<IngredientStorageCreateWithoutIngredientInput, IngredientStorageUncheckedCreateWithoutIngredientInput> | IngredientStorageCreateWithoutIngredientInput[] | IngredientStorageUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: IngredientStorageCreateOrConnectWithoutIngredientInput | IngredientStorageCreateOrConnectWithoutIngredientInput[]
    upsert?: IngredientStorageUpsertWithWhereUniqueWithoutIngredientInput | IngredientStorageUpsertWithWhereUniqueWithoutIngredientInput[]
    createMany?: IngredientStorageCreateManyIngredientInputEnvelope
    set?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
    disconnect?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
    delete?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
    connect?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
    update?: IngredientStorageUpdateWithWhereUniqueWithoutIngredientInput | IngredientStorageUpdateWithWhereUniqueWithoutIngredientInput[]
    updateMany?: IngredientStorageUpdateManyWithWhereWithoutIngredientInput | IngredientStorageUpdateManyWithWhereWithoutIngredientInput[]
    deleteMany?: IngredientStorageScalarWhereInput | IngredientStorageScalarWhereInput[]
  }

  export type IngredientUserUncheckedUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<IngredientUserCreateWithoutIngredientInput, IngredientUserUncheckedCreateWithoutIngredientInput> | IngredientUserCreateWithoutIngredientInput[] | IngredientUserUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: IngredientUserCreateOrConnectWithoutIngredientInput | IngredientUserCreateOrConnectWithoutIngredientInput[]
    upsert?: IngredientUserUpsertWithWhereUniqueWithoutIngredientInput | IngredientUserUpsertWithWhereUniqueWithoutIngredientInput[]
    createMany?: IngredientUserCreateManyIngredientInputEnvelope
    set?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
    disconnect?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
    delete?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
    connect?: IngredientUserWhereUniqueInput | IngredientUserWhereUniqueInput[]
    update?: IngredientUserUpdateWithWhereUniqueWithoutIngredientInput | IngredientUserUpdateWithWhereUniqueWithoutIngredientInput[]
    updateMany?: IngredientUserUpdateManyWithWhereWithoutIngredientInput | IngredientUserUpdateManyWithWhereWithoutIngredientInput[]
    deleteMany?: IngredientUserScalarWhereInput | IngredientUserScalarWhereInput[]
  }

  export type IngredientPreferenceUncheckedUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<IngredientPreferenceCreateWithoutIngredientInput, IngredientPreferenceUncheckedCreateWithoutIngredientInput> | IngredientPreferenceCreateWithoutIngredientInput[] | IngredientPreferenceUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: IngredientPreferenceCreateOrConnectWithoutIngredientInput | IngredientPreferenceCreateOrConnectWithoutIngredientInput[]
    upsert?: IngredientPreferenceUpsertWithWhereUniqueWithoutIngredientInput | IngredientPreferenceUpsertWithWhereUniqueWithoutIngredientInput[]
    createMany?: IngredientPreferenceCreateManyIngredientInputEnvelope
    set?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    disconnect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    delete?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    connect?: IngredientPreferenceWhereUniqueInput | IngredientPreferenceWhereUniqueInput[]
    update?: IngredientPreferenceUpdateWithWhereUniqueWithoutIngredientInput | IngredientPreferenceUpdateWithWhereUniqueWithoutIngredientInput[]
    updateMany?: IngredientPreferenceUpdateManyWithWhereWithoutIngredientInput | IngredientPreferenceUpdateManyWithWhereWithoutIngredientInput[]
    deleteMany?: IngredientPreferenceScalarWhereInput | IngredientPreferenceScalarWhereInput[]
  }

  export type CrewIngredientUncheckedUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<CrewIngredientCreateWithoutIngredientInput, CrewIngredientUncheckedCreateWithoutIngredientInput> | CrewIngredientCreateWithoutIngredientInput[] | CrewIngredientUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: CrewIngredientCreateOrConnectWithoutIngredientInput | CrewIngredientCreateOrConnectWithoutIngredientInput[]
    upsert?: CrewIngredientUpsertWithWhereUniqueWithoutIngredientInput | CrewIngredientUpsertWithWhereUniqueWithoutIngredientInput[]
    createMany?: CrewIngredientCreateManyIngredientInputEnvelope
    set?: CrewIngredientWhereUniqueInput | CrewIngredientWhereUniqueInput[]
    disconnect?: CrewIngredientWhereUniqueInput | CrewIngredientWhereUniqueInput[]
    delete?: CrewIngredientWhereUniqueInput | CrewIngredientWhereUniqueInput[]
    connect?: CrewIngredientWhereUniqueInput | CrewIngredientWhereUniqueInput[]
    update?: CrewIngredientUpdateWithWhereUniqueWithoutIngredientInput | CrewIngredientUpdateWithWhereUniqueWithoutIngredientInput[]
    updateMany?: CrewIngredientUpdateManyWithWhereWithoutIngredientInput | CrewIngredientUpdateManyWithWhereWithoutIngredientInput[]
    deleteMany?: CrewIngredientScalarWhereInput | CrewIngredientScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutIngredientUserInput = {
    create?: XOR<UserCreateWithoutIngredientUserInput, UserUncheckedCreateWithoutIngredientUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutIngredientUserInput
    connect?: UserWhereUniqueInput
  }

  export type IngredientCreateNestedOneWithoutIngredientUserInput = {
    create?: XOR<IngredientCreateWithoutIngredientUserInput, IngredientUncheckedCreateWithoutIngredientUserInput>
    connectOrCreate?: IngredientCreateOrConnectWithoutIngredientUserInput
    connect?: IngredientWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutIngredientUserNestedInput = {
    create?: XOR<UserCreateWithoutIngredientUserInput, UserUncheckedCreateWithoutIngredientUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutIngredientUserInput
    upsert?: UserUpsertWithoutIngredientUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIngredientUserInput, UserUpdateWithoutIngredientUserInput>, UserUncheckedUpdateWithoutIngredientUserInput>
  }

  export type IngredientUpdateOneRequiredWithoutIngredientUserNestedInput = {
    create?: XOR<IngredientCreateWithoutIngredientUserInput, IngredientUncheckedCreateWithoutIngredientUserInput>
    connectOrCreate?: IngredientCreateOrConnectWithoutIngredientUserInput
    upsert?: IngredientUpsertWithoutIngredientUserInput
    connect?: IngredientWhereUniqueInput
    update?: XOR<XOR<IngredientUpdateToOneWithWhereWithoutIngredientUserInput, IngredientUpdateWithoutIngredientUserInput>, IngredientUncheckedUpdateWithoutIngredientUserInput>
  }

  export type IngredientTypeCreateNestedOneWithoutIngredientPreferenceInput = {
    create?: XOR<IngredientTypeCreateWithoutIngredientPreferenceInput, IngredientTypeUncheckedCreateWithoutIngredientPreferenceInput>
    connectOrCreate?: IngredientTypeCreateOrConnectWithoutIngredientPreferenceInput
    connect?: IngredientTypeWhereUniqueInput
  }

  export type IngredientCreateNestedOneWithoutIngredientPreferenceInput = {
    create?: XOR<IngredientCreateWithoutIngredientPreferenceInput, IngredientUncheckedCreateWithoutIngredientPreferenceInput>
    connectOrCreate?: IngredientCreateOrConnectWithoutIngredientPreferenceInput
    connect?: IngredientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutIngredientPreferenceInput = {
    create?: XOR<UserCreateWithoutIngredientPreferenceInput, UserUncheckedCreateWithoutIngredientPreferenceInput>
    connectOrCreate?: UserCreateOrConnectWithoutIngredientPreferenceInput
    connect?: UserWhereUniqueInput
  }

  export type IngredientTypeUpdateOneRequiredWithoutIngredientPreferenceNestedInput = {
    create?: XOR<IngredientTypeCreateWithoutIngredientPreferenceInput, IngredientTypeUncheckedCreateWithoutIngredientPreferenceInput>
    connectOrCreate?: IngredientTypeCreateOrConnectWithoutIngredientPreferenceInput
    upsert?: IngredientTypeUpsertWithoutIngredientPreferenceInput
    connect?: IngredientTypeWhereUniqueInput
    update?: XOR<XOR<IngredientTypeUpdateToOneWithWhereWithoutIngredientPreferenceInput, IngredientTypeUpdateWithoutIngredientPreferenceInput>, IngredientTypeUncheckedUpdateWithoutIngredientPreferenceInput>
  }

  export type IngredientUpdateOneRequiredWithoutIngredientPreferenceNestedInput = {
    create?: XOR<IngredientCreateWithoutIngredientPreferenceInput, IngredientUncheckedCreateWithoutIngredientPreferenceInput>
    connectOrCreate?: IngredientCreateOrConnectWithoutIngredientPreferenceInput
    upsert?: IngredientUpsertWithoutIngredientPreferenceInput
    connect?: IngredientWhereUniqueInput
    update?: XOR<XOR<IngredientUpdateToOneWithWhereWithoutIngredientPreferenceInput, IngredientUpdateWithoutIngredientPreferenceInput>, IngredientUncheckedUpdateWithoutIngredientPreferenceInput>
  }

  export type UserUpdateOneRequiredWithoutIngredientPreferenceNestedInput = {
    create?: XOR<UserCreateWithoutIngredientPreferenceInput, UserUncheckedCreateWithoutIngredientPreferenceInput>
    connectOrCreate?: UserCreateOrConnectWithoutIngredientPreferenceInput
    upsert?: UserUpsertWithoutIngredientPreferenceInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIngredientPreferenceInput, UserUpdateWithoutIngredientPreferenceInput>, UserUncheckedUpdateWithoutIngredientPreferenceInput>
  }

  export type UserCreateNestedOneWithoutInventoryInput = {
    create?: XOR<UserCreateWithoutInventoryInput, UserUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInventoryEditedByInput = {
    create?: XOR<UserCreateWithoutInventoryEditedByInput, UserUncheckedCreateWithoutInventoryEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryEditedByInput
    connect?: UserWhereUniqueInput
  }

  export type InventoryStorageCreateNestedManyWithoutInventoryInput = {
    create?: XOR<InventoryStorageCreateWithoutInventoryInput, InventoryStorageUncheckedCreateWithoutInventoryInput> | InventoryStorageCreateWithoutInventoryInput[] | InventoryStorageUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryStorageCreateOrConnectWithoutInventoryInput | InventoryStorageCreateOrConnectWithoutInventoryInput[]
    createMany?: InventoryStorageCreateManyInventoryInputEnvelope
    connect?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
  }

  export type InventoryUserCreateNestedManyWithoutInventoryInput = {
    create?: XOR<InventoryUserCreateWithoutInventoryInput, InventoryUserUncheckedCreateWithoutInventoryInput> | InventoryUserCreateWithoutInventoryInput[] | InventoryUserUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryUserCreateOrConnectWithoutInventoryInput | InventoryUserCreateOrConnectWithoutInventoryInput[]
    createMany?: InventoryUserCreateManyInventoryInputEnvelope
    connect?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
  }

  export type CrewInventoryCreateNestedManyWithoutInventoryInput = {
    create?: XOR<CrewInventoryCreateWithoutInventoryInput, CrewInventoryUncheckedCreateWithoutInventoryInput> | CrewInventoryCreateWithoutInventoryInput[] | CrewInventoryUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: CrewInventoryCreateOrConnectWithoutInventoryInput | CrewInventoryCreateOrConnectWithoutInventoryInput[]
    createMany?: CrewInventoryCreateManyInventoryInputEnvelope
    connect?: CrewInventoryWhereUniqueInput | CrewInventoryWhereUniqueInput[]
  }

  export type InventoryStorageUncheckedCreateNestedManyWithoutInventoryInput = {
    create?: XOR<InventoryStorageCreateWithoutInventoryInput, InventoryStorageUncheckedCreateWithoutInventoryInput> | InventoryStorageCreateWithoutInventoryInput[] | InventoryStorageUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryStorageCreateOrConnectWithoutInventoryInput | InventoryStorageCreateOrConnectWithoutInventoryInput[]
    createMany?: InventoryStorageCreateManyInventoryInputEnvelope
    connect?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
  }

  export type InventoryUserUncheckedCreateNestedManyWithoutInventoryInput = {
    create?: XOR<InventoryUserCreateWithoutInventoryInput, InventoryUserUncheckedCreateWithoutInventoryInput> | InventoryUserCreateWithoutInventoryInput[] | InventoryUserUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryUserCreateOrConnectWithoutInventoryInput | InventoryUserCreateOrConnectWithoutInventoryInput[]
    createMany?: InventoryUserCreateManyInventoryInputEnvelope
    connect?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
  }

  export type CrewInventoryUncheckedCreateNestedManyWithoutInventoryInput = {
    create?: XOR<CrewInventoryCreateWithoutInventoryInput, CrewInventoryUncheckedCreateWithoutInventoryInput> | CrewInventoryCreateWithoutInventoryInput[] | CrewInventoryUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: CrewInventoryCreateOrConnectWithoutInventoryInput | CrewInventoryCreateOrConnectWithoutInventoryInput[]
    createMany?: CrewInventoryCreateManyInventoryInputEnvelope
    connect?: CrewInventoryWhereUniqueInput | CrewInventoryWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutInventoryNestedInput = {
    create?: XOR<UserCreateWithoutInventoryInput, UserUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryInput
    upsert?: UserUpsertWithoutInventoryInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInventoryInput, UserUpdateWithoutInventoryInput>, UserUncheckedUpdateWithoutInventoryInput>
  }

  export type UserUpdateOneWithoutInventoryEditedByNestedInput = {
    create?: XOR<UserCreateWithoutInventoryEditedByInput, UserUncheckedCreateWithoutInventoryEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryEditedByInput
    upsert?: UserUpsertWithoutInventoryEditedByInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInventoryEditedByInput, UserUpdateWithoutInventoryEditedByInput>, UserUncheckedUpdateWithoutInventoryEditedByInput>
  }

  export type InventoryStorageUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<InventoryStorageCreateWithoutInventoryInput, InventoryStorageUncheckedCreateWithoutInventoryInput> | InventoryStorageCreateWithoutInventoryInput[] | InventoryStorageUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryStorageCreateOrConnectWithoutInventoryInput | InventoryStorageCreateOrConnectWithoutInventoryInput[]
    upsert?: InventoryStorageUpsertWithWhereUniqueWithoutInventoryInput | InventoryStorageUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: InventoryStorageCreateManyInventoryInputEnvelope
    set?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
    disconnect?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
    delete?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
    connect?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
    update?: InventoryStorageUpdateWithWhereUniqueWithoutInventoryInput | InventoryStorageUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: InventoryStorageUpdateManyWithWhereWithoutInventoryInput | InventoryStorageUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: InventoryStorageScalarWhereInput | InventoryStorageScalarWhereInput[]
  }

  export type InventoryUserUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<InventoryUserCreateWithoutInventoryInput, InventoryUserUncheckedCreateWithoutInventoryInput> | InventoryUserCreateWithoutInventoryInput[] | InventoryUserUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryUserCreateOrConnectWithoutInventoryInput | InventoryUserCreateOrConnectWithoutInventoryInput[]
    upsert?: InventoryUserUpsertWithWhereUniqueWithoutInventoryInput | InventoryUserUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: InventoryUserCreateManyInventoryInputEnvelope
    set?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
    disconnect?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
    delete?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
    connect?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
    update?: InventoryUserUpdateWithWhereUniqueWithoutInventoryInput | InventoryUserUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: InventoryUserUpdateManyWithWhereWithoutInventoryInput | InventoryUserUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: InventoryUserScalarWhereInput | InventoryUserScalarWhereInput[]
  }

  export type CrewInventoryUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<CrewInventoryCreateWithoutInventoryInput, CrewInventoryUncheckedCreateWithoutInventoryInput> | CrewInventoryCreateWithoutInventoryInput[] | CrewInventoryUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: CrewInventoryCreateOrConnectWithoutInventoryInput | CrewInventoryCreateOrConnectWithoutInventoryInput[]
    upsert?: CrewInventoryUpsertWithWhereUniqueWithoutInventoryInput | CrewInventoryUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: CrewInventoryCreateManyInventoryInputEnvelope
    set?: CrewInventoryWhereUniqueInput | CrewInventoryWhereUniqueInput[]
    disconnect?: CrewInventoryWhereUniqueInput | CrewInventoryWhereUniqueInput[]
    delete?: CrewInventoryWhereUniqueInput | CrewInventoryWhereUniqueInput[]
    connect?: CrewInventoryWhereUniqueInput | CrewInventoryWhereUniqueInput[]
    update?: CrewInventoryUpdateWithWhereUniqueWithoutInventoryInput | CrewInventoryUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: CrewInventoryUpdateManyWithWhereWithoutInventoryInput | CrewInventoryUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: CrewInventoryScalarWhereInput | CrewInventoryScalarWhereInput[]
  }

  export type InventoryStorageUncheckedUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<InventoryStorageCreateWithoutInventoryInput, InventoryStorageUncheckedCreateWithoutInventoryInput> | InventoryStorageCreateWithoutInventoryInput[] | InventoryStorageUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryStorageCreateOrConnectWithoutInventoryInput | InventoryStorageCreateOrConnectWithoutInventoryInput[]
    upsert?: InventoryStorageUpsertWithWhereUniqueWithoutInventoryInput | InventoryStorageUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: InventoryStorageCreateManyInventoryInputEnvelope
    set?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
    disconnect?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
    delete?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
    connect?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
    update?: InventoryStorageUpdateWithWhereUniqueWithoutInventoryInput | InventoryStorageUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: InventoryStorageUpdateManyWithWhereWithoutInventoryInput | InventoryStorageUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: InventoryStorageScalarWhereInput | InventoryStorageScalarWhereInput[]
  }

  export type InventoryUserUncheckedUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<InventoryUserCreateWithoutInventoryInput, InventoryUserUncheckedCreateWithoutInventoryInput> | InventoryUserCreateWithoutInventoryInput[] | InventoryUserUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryUserCreateOrConnectWithoutInventoryInput | InventoryUserCreateOrConnectWithoutInventoryInput[]
    upsert?: InventoryUserUpsertWithWhereUniqueWithoutInventoryInput | InventoryUserUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: InventoryUserCreateManyInventoryInputEnvelope
    set?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
    disconnect?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
    delete?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
    connect?: InventoryUserWhereUniqueInput | InventoryUserWhereUniqueInput[]
    update?: InventoryUserUpdateWithWhereUniqueWithoutInventoryInput | InventoryUserUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: InventoryUserUpdateManyWithWhereWithoutInventoryInput | InventoryUserUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: InventoryUserScalarWhereInput | InventoryUserScalarWhereInput[]
  }

  export type CrewInventoryUncheckedUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<CrewInventoryCreateWithoutInventoryInput, CrewInventoryUncheckedCreateWithoutInventoryInput> | CrewInventoryCreateWithoutInventoryInput[] | CrewInventoryUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: CrewInventoryCreateOrConnectWithoutInventoryInput | CrewInventoryCreateOrConnectWithoutInventoryInput[]
    upsert?: CrewInventoryUpsertWithWhereUniqueWithoutInventoryInput | CrewInventoryUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: CrewInventoryCreateManyInventoryInputEnvelope
    set?: CrewInventoryWhereUniqueInput | CrewInventoryWhereUniqueInput[]
    disconnect?: CrewInventoryWhereUniqueInput | CrewInventoryWhereUniqueInput[]
    delete?: CrewInventoryWhereUniqueInput | CrewInventoryWhereUniqueInput[]
    connect?: CrewInventoryWhereUniqueInput | CrewInventoryWhereUniqueInput[]
    update?: CrewInventoryUpdateWithWhereUniqueWithoutInventoryInput | CrewInventoryUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: CrewInventoryUpdateManyWithWhereWithoutInventoryInput | CrewInventoryUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: CrewInventoryScalarWhereInput | CrewInventoryScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutInventoryUserInput = {
    create?: XOR<UserCreateWithoutInventoryUserInput, UserUncheckedCreateWithoutInventoryUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryUserInput
    connect?: UserWhereUniqueInput
  }

  export type InventoryCreateNestedOneWithoutInventoryUserInput = {
    create?: XOR<InventoryCreateWithoutInventoryUserInput, InventoryUncheckedCreateWithoutInventoryUserInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutInventoryUserInput
    connect?: InventoryWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutInventoryUserNestedInput = {
    create?: XOR<UserCreateWithoutInventoryUserInput, UserUncheckedCreateWithoutInventoryUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryUserInput
    upsert?: UserUpsertWithoutInventoryUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInventoryUserInput, UserUpdateWithoutInventoryUserInput>, UserUncheckedUpdateWithoutInventoryUserInput>
  }

  export type InventoryUpdateOneRequiredWithoutInventoryUserNestedInput = {
    create?: XOR<InventoryCreateWithoutInventoryUserInput, InventoryUncheckedCreateWithoutInventoryUserInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutInventoryUserInput
    upsert?: InventoryUpsertWithoutInventoryUserInput
    connect?: InventoryWhereUniqueInput
    update?: XOR<XOR<InventoryUpdateToOneWithWhereWithoutInventoryUserInput, InventoryUpdateWithoutInventoryUserInput>, InventoryUncheckedUpdateWithoutInventoryUserInput>
  }

  export type UserCreateNestedOneWithoutStorageInput = {
    create?: XOR<UserCreateWithoutStorageInput, UserUncheckedCreateWithoutStorageInput>
    connectOrCreate?: UserCreateOrConnectWithoutStorageInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStorageEditedByInput = {
    create?: XOR<UserCreateWithoutStorageEditedByInput, UserUncheckedCreateWithoutStorageEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutStorageEditedByInput
    connect?: UserWhereUniqueInput
  }

  export type InventoryStorageCreateNestedManyWithoutStorageInput = {
    create?: XOR<InventoryStorageCreateWithoutStorageInput, InventoryStorageUncheckedCreateWithoutStorageInput> | InventoryStorageCreateWithoutStorageInput[] | InventoryStorageUncheckedCreateWithoutStorageInput[]
    connectOrCreate?: InventoryStorageCreateOrConnectWithoutStorageInput | InventoryStorageCreateOrConnectWithoutStorageInput[]
    createMany?: InventoryStorageCreateManyStorageInputEnvelope
    connect?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
  }

  export type IngredientStorageCreateNestedManyWithoutStorageInput = {
    create?: XOR<IngredientStorageCreateWithoutStorageInput, IngredientStorageUncheckedCreateWithoutStorageInput> | IngredientStorageCreateWithoutStorageInput[] | IngredientStorageUncheckedCreateWithoutStorageInput[]
    connectOrCreate?: IngredientStorageCreateOrConnectWithoutStorageInput | IngredientStorageCreateOrConnectWithoutStorageInput[]
    createMany?: IngredientStorageCreateManyStorageInputEnvelope
    connect?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
  }

  export type StorageUserCreateNestedManyWithoutStorageInput = {
    create?: XOR<StorageUserCreateWithoutStorageInput, StorageUserUncheckedCreateWithoutStorageInput> | StorageUserCreateWithoutStorageInput[] | StorageUserUncheckedCreateWithoutStorageInput[]
    connectOrCreate?: StorageUserCreateOrConnectWithoutStorageInput | StorageUserCreateOrConnectWithoutStorageInput[]
    createMany?: StorageUserCreateManyStorageInputEnvelope
    connect?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
  }

  export type CrewStorageCreateNestedManyWithoutStorageInput = {
    create?: XOR<CrewStorageCreateWithoutStorageInput, CrewStorageUncheckedCreateWithoutStorageInput> | CrewStorageCreateWithoutStorageInput[] | CrewStorageUncheckedCreateWithoutStorageInput[]
    connectOrCreate?: CrewStorageCreateOrConnectWithoutStorageInput | CrewStorageCreateOrConnectWithoutStorageInput[]
    createMany?: CrewStorageCreateManyStorageInputEnvelope
    connect?: CrewStorageWhereUniqueInput | CrewStorageWhereUniqueInput[]
  }

  export type InventoryStorageUncheckedCreateNestedManyWithoutStorageInput = {
    create?: XOR<InventoryStorageCreateWithoutStorageInput, InventoryStorageUncheckedCreateWithoutStorageInput> | InventoryStorageCreateWithoutStorageInput[] | InventoryStorageUncheckedCreateWithoutStorageInput[]
    connectOrCreate?: InventoryStorageCreateOrConnectWithoutStorageInput | InventoryStorageCreateOrConnectWithoutStorageInput[]
    createMany?: InventoryStorageCreateManyStorageInputEnvelope
    connect?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
  }

  export type IngredientStorageUncheckedCreateNestedManyWithoutStorageInput = {
    create?: XOR<IngredientStorageCreateWithoutStorageInput, IngredientStorageUncheckedCreateWithoutStorageInput> | IngredientStorageCreateWithoutStorageInput[] | IngredientStorageUncheckedCreateWithoutStorageInput[]
    connectOrCreate?: IngredientStorageCreateOrConnectWithoutStorageInput | IngredientStorageCreateOrConnectWithoutStorageInput[]
    createMany?: IngredientStorageCreateManyStorageInputEnvelope
    connect?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
  }

  export type StorageUserUncheckedCreateNestedManyWithoutStorageInput = {
    create?: XOR<StorageUserCreateWithoutStorageInput, StorageUserUncheckedCreateWithoutStorageInput> | StorageUserCreateWithoutStorageInput[] | StorageUserUncheckedCreateWithoutStorageInput[]
    connectOrCreate?: StorageUserCreateOrConnectWithoutStorageInput | StorageUserCreateOrConnectWithoutStorageInput[]
    createMany?: StorageUserCreateManyStorageInputEnvelope
    connect?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
  }

  export type CrewStorageUncheckedCreateNestedManyWithoutStorageInput = {
    create?: XOR<CrewStorageCreateWithoutStorageInput, CrewStorageUncheckedCreateWithoutStorageInput> | CrewStorageCreateWithoutStorageInput[] | CrewStorageUncheckedCreateWithoutStorageInput[]
    connectOrCreate?: CrewStorageCreateOrConnectWithoutStorageInput | CrewStorageCreateOrConnectWithoutStorageInput[]
    createMany?: CrewStorageCreateManyStorageInputEnvelope
    connect?: CrewStorageWhereUniqueInput | CrewStorageWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutStorageNestedInput = {
    create?: XOR<UserCreateWithoutStorageInput, UserUncheckedCreateWithoutStorageInput>
    connectOrCreate?: UserCreateOrConnectWithoutStorageInput
    upsert?: UserUpsertWithoutStorageInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStorageInput, UserUpdateWithoutStorageInput>, UserUncheckedUpdateWithoutStorageInput>
  }

  export type UserUpdateOneWithoutStorageEditedByNestedInput = {
    create?: XOR<UserCreateWithoutStorageEditedByInput, UserUncheckedCreateWithoutStorageEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutStorageEditedByInput
    upsert?: UserUpsertWithoutStorageEditedByInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStorageEditedByInput, UserUpdateWithoutStorageEditedByInput>, UserUncheckedUpdateWithoutStorageEditedByInput>
  }

  export type InventoryStorageUpdateManyWithoutStorageNestedInput = {
    create?: XOR<InventoryStorageCreateWithoutStorageInput, InventoryStorageUncheckedCreateWithoutStorageInput> | InventoryStorageCreateWithoutStorageInput[] | InventoryStorageUncheckedCreateWithoutStorageInput[]
    connectOrCreate?: InventoryStorageCreateOrConnectWithoutStorageInput | InventoryStorageCreateOrConnectWithoutStorageInput[]
    upsert?: InventoryStorageUpsertWithWhereUniqueWithoutStorageInput | InventoryStorageUpsertWithWhereUniqueWithoutStorageInput[]
    createMany?: InventoryStorageCreateManyStorageInputEnvelope
    set?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
    disconnect?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
    delete?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
    connect?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
    update?: InventoryStorageUpdateWithWhereUniqueWithoutStorageInput | InventoryStorageUpdateWithWhereUniqueWithoutStorageInput[]
    updateMany?: InventoryStorageUpdateManyWithWhereWithoutStorageInput | InventoryStorageUpdateManyWithWhereWithoutStorageInput[]
    deleteMany?: InventoryStorageScalarWhereInput | InventoryStorageScalarWhereInput[]
  }

  export type IngredientStorageUpdateManyWithoutStorageNestedInput = {
    create?: XOR<IngredientStorageCreateWithoutStorageInput, IngredientStorageUncheckedCreateWithoutStorageInput> | IngredientStorageCreateWithoutStorageInput[] | IngredientStorageUncheckedCreateWithoutStorageInput[]
    connectOrCreate?: IngredientStorageCreateOrConnectWithoutStorageInput | IngredientStorageCreateOrConnectWithoutStorageInput[]
    upsert?: IngredientStorageUpsertWithWhereUniqueWithoutStorageInput | IngredientStorageUpsertWithWhereUniqueWithoutStorageInput[]
    createMany?: IngredientStorageCreateManyStorageInputEnvelope
    set?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
    disconnect?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
    delete?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
    connect?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
    update?: IngredientStorageUpdateWithWhereUniqueWithoutStorageInput | IngredientStorageUpdateWithWhereUniqueWithoutStorageInput[]
    updateMany?: IngredientStorageUpdateManyWithWhereWithoutStorageInput | IngredientStorageUpdateManyWithWhereWithoutStorageInput[]
    deleteMany?: IngredientStorageScalarWhereInput | IngredientStorageScalarWhereInput[]
  }

  export type StorageUserUpdateManyWithoutStorageNestedInput = {
    create?: XOR<StorageUserCreateWithoutStorageInput, StorageUserUncheckedCreateWithoutStorageInput> | StorageUserCreateWithoutStorageInput[] | StorageUserUncheckedCreateWithoutStorageInput[]
    connectOrCreate?: StorageUserCreateOrConnectWithoutStorageInput | StorageUserCreateOrConnectWithoutStorageInput[]
    upsert?: StorageUserUpsertWithWhereUniqueWithoutStorageInput | StorageUserUpsertWithWhereUniqueWithoutStorageInput[]
    createMany?: StorageUserCreateManyStorageInputEnvelope
    set?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
    disconnect?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
    delete?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
    connect?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
    update?: StorageUserUpdateWithWhereUniqueWithoutStorageInput | StorageUserUpdateWithWhereUniqueWithoutStorageInput[]
    updateMany?: StorageUserUpdateManyWithWhereWithoutStorageInput | StorageUserUpdateManyWithWhereWithoutStorageInput[]
    deleteMany?: StorageUserScalarWhereInput | StorageUserScalarWhereInput[]
  }

  export type CrewStorageUpdateManyWithoutStorageNestedInput = {
    create?: XOR<CrewStorageCreateWithoutStorageInput, CrewStorageUncheckedCreateWithoutStorageInput> | CrewStorageCreateWithoutStorageInput[] | CrewStorageUncheckedCreateWithoutStorageInput[]
    connectOrCreate?: CrewStorageCreateOrConnectWithoutStorageInput | CrewStorageCreateOrConnectWithoutStorageInput[]
    upsert?: CrewStorageUpsertWithWhereUniqueWithoutStorageInput | CrewStorageUpsertWithWhereUniqueWithoutStorageInput[]
    createMany?: CrewStorageCreateManyStorageInputEnvelope
    set?: CrewStorageWhereUniqueInput | CrewStorageWhereUniqueInput[]
    disconnect?: CrewStorageWhereUniqueInput | CrewStorageWhereUniqueInput[]
    delete?: CrewStorageWhereUniqueInput | CrewStorageWhereUniqueInput[]
    connect?: CrewStorageWhereUniqueInput | CrewStorageWhereUniqueInput[]
    update?: CrewStorageUpdateWithWhereUniqueWithoutStorageInput | CrewStorageUpdateWithWhereUniqueWithoutStorageInput[]
    updateMany?: CrewStorageUpdateManyWithWhereWithoutStorageInput | CrewStorageUpdateManyWithWhereWithoutStorageInput[]
    deleteMany?: CrewStorageScalarWhereInput | CrewStorageScalarWhereInput[]
  }

  export type InventoryStorageUncheckedUpdateManyWithoutStorageNestedInput = {
    create?: XOR<InventoryStorageCreateWithoutStorageInput, InventoryStorageUncheckedCreateWithoutStorageInput> | InventoryStorageCreateWithoutStorageInput[] | InventoryStorageUncheckedCreateWithoutStorageInput[]
    connectOrCreate?: InventoryStorageCreateOrConnectWithoutStorageInput | InventoryStorageCreateOrConnectWithoutStorageInput[]
    upsert?: InventoryStorageUpsertWithWhereUniqueWithoutStorageInput | InventoryStorageUpsertWithWhereUniqueWithoutStorageInput[]
    createMany?: InventoryStorageCreateManyStorageInputEnvelope
    set?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
    disconnect?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
    delete?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
    connect?: InventoryStorageWhereUniqueInput | InventoryStorageWhereUniqueInput[]
    update?: InventoryStorageUpdateWithWhereUniqueWithoutStorageInput | InventoryStorageUpdateWithWhereUniqueWithoutStorageInput[]
    updateMany?: InventoryStorageUpdateManyWithWhereWithoutStorageInput | InventoryStorageUpdateManyWithWhereWithoutStorageInput[]
    deleteMany?: InventoryStorageScalarWhereInput | InventoryStorageScalarWhereInput[]
  }

  export type IngredientStorageUncheckedUpdateManyWithoutStorageNestedInput = {
    create?: XOR<IngredientStorageCreateWithoutStorageInput, IngredientStorageUncheckedCreateWithoutStorageInput> | IngredientStorageCreateWithoutStorageInput[] | IngredientStorageUncheckedCreateWithoutStorageInput[]
    connectOrCreate?: IngredientStorageCreateOrConnectWithoutStorageInput | IngredientStorageCreateOrConnectWithoutStorageInput[]
    upsert?: IngredientStorageUpsertWithWhereUniqueWithoutStorageInput | IngredientStorageUpsertWithWhereUniqueWithoutStorageInput[]
    createMany?: IngredientStorageCreateManyStorageInputEnvelope
    set?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
    disconnect?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
    delete?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
    connect?: IngredientStorageWhereUniqueInput | IngredientStorageWhereUniqueInput[]
    update?: IngredientStorageUpdateWithWhereUniqueWithoutStorageInput | IngredientStorageUpdateWithWhereUniqueWithoutStorageInput[]
    updateMany?: IngredientStorageUpdateManyWithWhereWithoutStorageInput | IngredientStorageUpdateManyWithWhereWithoutStorageInput[]
    deleteMany?: IngredientStorageScalarWhereInput | IngredientStorageScalarWhereInput[]
  }

  export type StorageUserUncheckedUpdateManyWithoutStorageNestedInput = {
    create?: XOR<StorageUserCreateWithoutStorageInput, StorageUserUncheckedCreateWithoutStorageInput> | StorageUserCreateWithoutStorageInput[] | StorageUserUncheckedCreateWithoutStorageInput[]
    connectOrCreate?: StorageUserCreateOrConnectWithoutStorageInput | StorageUserCreateOrConnectWithoutStorageInput[]
    upsert?: StorageUserUpsertWithWhereUniqueWithoutStorageInput | StorageUserUpsertWithWhereUniqueWithoutStorageInput[]
    createMany?: StorageUserCreateManyStorageInputEnvelope
    set?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
    disconnect?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
    delete?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
    connect?: StorageUserWhereUniqueInput | StorageUserWhereUniqueInput[]
    update?: StorageUserUpdateWithWhereUniqueWithoutStorageInput | StorageUserUpdateWithWhereUniqueWithoutStorageInput[]
    updateMany?: StorageUserUpdateManyWithWhereWithoutStorageInput | StorageUserUpdateManyWithWhereWithoutStorageInput[]
    deleteMany?: StorageUserScalarWhereInput | StorageUserScalarWhereInput[]
  }

  export type CrewStorageUncheckedUpdateManyWithoutStorageNestedInput = {
    create?: XOR<CrewStorageCreateWithoutStorageInput, CrewStorageUncheckedCreateWithoutStorageInput> | CrewStorageCreateWithoutStorageInput[] | CrewStorageUncheckedCreateWithoutStorageInput[]
    connectOrCreate?: CrewStorageCreateOrConnectWithoutStorageInput | CrewStorageCreateOrConnectWithoutStorageInput[]
    upsert?: CrewStorageUpsertWithWhereUniqueWithoutStorageInput | CrewStorageUpsertWithWhereUniqueWithoutStorageInput[]
    createMany?: CrewStorageCreateManyStorageInputEnvelope
    set?: CrewStorageWhereUniqueInput | CrewStorageWhereUniqueInput[]
    disconnect?: CrewStorageWhereUniqueInput | CrewStorageWhereUniqueInput[]
    delete?: CrewStorageWhereUniqueInput | CrewStorageWhereUniqueInput[]
    connect?: CrewStorageWhereUniqueInput | CrewStorageWhereUniqueInput[]
    update?: CrewStorageUpdateWithWhereUniqueWithoutStorageInput | CrewStorageUpdateWithWhereUniqueWithoutStorageInput[]
    updateMany?: CrewStorageUpdateManyWithWhereWithoutStorageInput | CrewStorageUpdateManyWithWhereWithoutStorageInput[]
    deleteMany?: CrewStorageScalarWhereInput | CrewStorageScalarWhereInput[]
  }

  export type StorageCreateNestedOneWithoutInventoryStorageInput = {
    create?: XOR<StorageCreateWithoutInventoryStorageInput, StorageUncheckedCreateWithoutInventoryStorageInput>
    connectOrCreate?: StorageCreateOrConnectWithoutInventoryStorageInput
    connect?: StorageWhereUniqueInput
  }

  export type InventoryCreateNestedOneWithoutInventoryStorageInput = {
    create?: XOR<InventoryCreateWithoutInventoryStorageInput, InventoryUncheckedCreateWithoutInventoryStorageInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutInventoryStorageInput
    connect?: InventoryWhereUniqueInput
  }

  export type StorageUpdateOneRequiredWithoutInventoryStorageNestedInput = {
    create?: XOR<StorageCreateWithoutInventoryStorageInput, StorageUncheckedCreateWithoutInventoryStorageInput>
    connectOrCreate?: StorageCreateOrConnectWithoutInventoryStorageInput
    upsert?: StorageUpsertWithoutInventoryStorageInput
    connect?: StorageWhereUniqueInput
    update?: XOR<XOR<StorageUpdateToOneWithWhereWithoutInventoryStorageInput, StorageUpdateWithoutInventoryStorageInput>, StorageUncheckedUpdateWithoutInventoryStorageInput>
  }

  export type InventoryUpdateOneRequiredWithoutInventoryStorageNestedInput = {
    create?: XOR<InventoryCreateWithoutInventoryStorageInput, InventoryUncheckedCreateWithoutInventoryStorageInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutInventoryStorageInput
    upsert?: InventoryUpsertWithoutInventoryStorageInput
    connect?: InventoryWhereUniqueInput
    update?: XOR<XOR<InventoryUpdateToOneWithWhereWithoutInventoryStorageInput, InventoryUpdateWithoutInventoryStorageInput>, InventoryUncheckedUpdateWithoutInventoryStorageInput>
  }

  export type IngredientCreateNestedOneWithoutIngredientStorageInput = {
    create?: XOR<IngredientCreateWithoutIngredientStorageInput, IngredientUncheckedCreateWithoutIngredientStorageInput>
    connectOrCreate?: IngredientCreateOrConnectWithoutIngredientStorageInput
    connect?: IngredientWhereUniqueInput
  }

  export type StorageCreateNestedOneWithoutIngredientStorageInput = {
    create?: XOR<StorageCreateWithoutIngredientStorageInput, StorageUncheckedCreateWithoutIngredientStorageInput>
    connectOrCreate?: StorageCreateOrConnectWithoutIngredientStorageInput
    connect?: StorageWhereUniqueInput
  }

  export type IngredientUpdateOneRequiredWithoutIngredientStorageNestedInput = {
    create?: XOR<IngredientCreateWithoutIngredientStorageInput, IngredientUncheckedCreateWithoutIngredientStorageInput>
    connectOrCreate?: IngredientCreateOrConnectWithoutIngredientStorageInput
    upsert?: IngredientUpsertWithoutIngredientStorageInput
    connect?: IngredientWhereUniqueInput
    update?: XOR<XOR<IngredientUpdateToOneWithWhereWithoutIngredientStorageInput, IngredientUpdateWithoutIngredientStorageInput>, IngredientUncheckedUpdateWithoutIngredientStorageInput>
  }

  export type StorageUpdateOneRequiredWithoutIngredientStorageNestedInput = {
    create?: XOR<StorageCreateWithoutIngredientStorageInput, StorageUncheckedCreateWithoutIngredientStorageInput>
    connectOrCreate?: StorageCreateOrConnectWithoutIngredientStorageInput
    upsert?: StorageUpsertWithoutIngredientStorageInput
    connect?: StorageWhereUniqueInput
    update?: XOR<XOR<StorageUpdateToOneWithWhereWithoutIngredientStorageInput, StorageUpdateWithoutIngredientStorageInput>, StorageUncheckedUpdateWithoutIngredientStorageInput>
  }

  export type UserCreateNestedOneWithoutStorageUserInput = {
    create?: XOR<UserCreateWithoutStorageUserInput, UserUncheckedCreateWithoutStorageUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutStorageUserInput
    connect?: UserWhereUniqueInput
  }

  export type StorageCreateNestedOneWithoutStorageUserInput = {
    create?: XOR<StorageCreateWithoutStorageUserInput, StorageUncheckedCreateWithoutStorageUserInput>
    connectOrCreate?: StorageCreateOrConnectWithoutStorageUserInput
    connect?: StorageWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutStorageUserNestedInput = {
    create?: XOR<UserCreateWithoutStorageUserInput, UserUncheckedCreateWithoutStorageUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutStorageUserInput
    upsert?: UserUpsertWithoutStorageUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStorageUserInput, UserUpdateWithoutStorageUserInput>, UserUncheckedUpdateWithoutStorageUserInput>
  }

  export type StorageUpdateOneRequiredWithoutStorageUserNestedInput = {
    create?: XOR<StorageCreateWithoutStorageUserInput, StorageUncheckedCreateWithoutStorageUserInput>
    connectOrCreate?: StorageCreateOrConnectWithoutStorageUserInput
    upsert?: StorageUpsertWithoutStorageUserInput
    connect?: StorageWhereUniqueInput
    update?: XOR<XOR<StorageUpdateToOneWithWhereWithoutStorageUserInput, StorageUpdateWithoutStorageUserInput>, StorageUncheckedUpdateWithoutStorageUserInput>
  }

  export type UserCreateNestedOneWithoutCrewInput = {
    create?: XOR<UserCreateWithoutCrewInput, UserUncheckedCreateWithoutCrewInput>
    connectOrCreate?: UserCreateOrConnectWithoutCrewInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCrewEditedByInput = {
    create?: XOR<UserCreateWithoutCrewEditedByInput, UserUncheckedCreateWithoutCrewEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutCrewEditedByInput
    connect?: UserWhereUniqueInput
  }

  export type CrewUserCreateNestedManyWithoutCrewInput = {
    create?: XOR<CrewUserCreateWithoutCrewInput, CrewUserUncheckedCreateWithoutCrewInput> | CrewUserCreateWithoutCrewInput[] | CrewUserUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CrewUserCreateOrConnectWithoutCrewInput | CrewUserCreateOrConnectWithoutCrewInput[]
    createMany?: CrewUserCreateManyCrewInputEnvelope
    connect?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
  }

  export type CrewInventoryCreateNestedManyWithoutCrewInput = {
    create?: XOR<CrewInventoryCreateWithoutCrewInput, CrewInventoryUncheckedCreateWithoutCrewInput> | CrewInventoryCreateWithoutCrewInput[] | CrewInventoryUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CrewInventoryCreateOrConnectWithoutCrewInput | CrewInventoryCreateOrConnectWithoutCrewInput[]
    createMany?: CrewInventoryCreateManyCrewInputEnvelope
    connect?: CrewInventoryWhereUniqueInput | CrewInventoryWhereUniqueInput[]
  }

  export type CrewStorageCreateNestedManyWithoutCrewInput = {
    create?: XOR<CrewStorageCreateWithoutCrewInput, CrewStorageUncheckedCreateWithoutCrewInput> | CrewStorageCreateWithoutCrewInput[] | CrewStorageUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CrewStorageCreateOrConnectWithoutCrewInput | CrewStorageCreateOrConnectWithoutCrewInput[]
    createMany?: CrewStorageCreateManyCrewInputEnvelope
    connect?: CrewStorageWhereUniqueInput | CrewStorageWhereUniqueInput[]
  }

  export type CrewIngredientCreateNestedManyWithoutCrewInput = {
    create?: XOR<CrewIngredientCreateWithoutCrewInput, CrewIngredientUncheckedCreateWithoutCrewInput> | CrewIngredientCreateWithoutCrewInput[] | CrewIngredientUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CrewIngredientCreateOrConnectWithoutCrewInput | CrewIngredientCreateOrConnectWithoutCrewInput[]
    createMany?: CrewIngredientCreateManyCrewInputEnvelope
    connect?: CrewIngredientWhereUniqueInput | CrewIngredientWhereUniqueInput[]
  }

  export type CrewRecipeBookCreateNestedManyWithoutCrewInput = {
    create?: XOR<CrewRecipeBookCreateWithoutCrewInput, CrewRecipeBookUncheckedCreateWithoutCrewInput> | CrewRecipeBookCreateWithoutCrewInput[] | CrewRecipeBookUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CrewRecipeBookCreateOrConnectWithoutCrewInput | CrewRecipeBookCreateOrConnectWithoutCrewInput[]
    createMany?: CrewRecipeBookCreateManyCrewInputEnvelope
    connect?: CrewRecipeBookWhereUniqueInput | CrewRecipeBookWhereUniqueInput[]
  }

  export type CrewBuildCreateNestedManyWithoutCrewInput = {
    create?: XOR<CrewBuildCreateWithoutCrewInput, CrewBuildUncheckedCreateWithoutCrewInput> | CrewBuildCreateWithoutCrewInput[] | CrewBuildUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CrewBuildCreateOrConnectWithoutCrewInput | CrewBuildCreateOrConnectWithoutCrewInput[]
    createMany?: CrewBuildCreateManyCrewInputEnvelope
    connect?: CrewBuildWhereUniqueInput | CrewBuildWhereUniqueInput[]
  }

  export type CrewUserUncheckedCreateNestedManyWithoutCrewInput = {
    create?: XOR<CrewUserCreateWithoutCrewInput, CrewUserUncheckedCreateWithoutCrewInput> | CrewUserCreateWithoutCrewInput[] | CrewUserUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CrewUserCreateOrConnectWithoutCrewInput | CrewUserCreateOrConnectWithoutCrewInput[]
    createMany?: CrewUserCreateManyCrewInputEnvelope
    connect?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
  }

  export type CrewInventoryUncheckedCreateNestedManyWithoutCrewInput = {
    create?: XOR<CrewInventoryCreateWithoutCrewInput, CrewInventoryUncheckedCreateWithoutCrewInput> | CrewInventoryCreateWithoutCrewInput[] | CrewInventoryUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CrewInventoryCreateOrConnectWithoutCrewInput | CrewInventoryCreateOrConnectWithoutCrewInput[]
    createMany?: CrewInventoryCreateManyCrewInputEnvelope
    connect?: CrewInventoryWhereUniqueInput | CrewInventoryWhereUniqueInput[]
  }

  export type CrewStorageUncheckedCreateNestedManyWithoutCrewInput = {
    create?: XOR<CrewStorageCreateWithoutCrewInput, CrewStorageUncheckedCreateWithoutCrewInput> | CrewStorageCreateWithoutCrewInput[] | CrewStorageUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CrewStorageCreateOrConnectWithoutCrewInput | CrewStorageCreateOrConnectWithoutCrewInput[]
    createMany?: CrewStorageCreateManyCrewInputEnvelope
    connect?: CrewStorageWhereUniqueInput | CrewStorageWhereUniqueInput[]
  }

  export type CrewIngredientUncheckedCreateNestedManyWithoutCrewInput = {
    create?: XOR<CrewIngredientCreateWithoutCrewInput, CrewIngredientUncheckedCreateWithoutCrewInput> | CrewIngredientCreateWithoutCrewInput[] | CrewIngredientUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CrewIngredientCreateOrConnectWithoutCrewInput | CrewIngredientCreateOrConnectWithoutCrewInput[]
    createMany?: CrewIngredientCreateManyCrewInputEnvelope
    connect?: CrewIngredientWhereUniqueInput | CrewIngredientWhereUniqueInput[]
  }

  export type CrewRecipeBookUncheckedCreateNestedManyWithoutCrewInput = {
    create?: XOR<CrewRecipeBookCreateWithoutCrewInput, CrewRecipeBookUncheckedCreateWithoutCrewInput> | CrewRecipeBookCreateWithoutCrewInput[] | CrewRecipeBookUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CrewRecipeBookCreateOrConnectWithoutCrewInput | CrewRecipeBookCreateOrConnectWithoutCrewInput[]
    createMany?: CrewRecipeBookCreateManyCrewInputEnvelope
    connect?: CrewRecipeBookWhereUniqueInput | CrewRecipeBookWhereUniqueInput[]
  }

  export type CrewBuildUncheckedCreateNestedManyWithoutCrewInput = {
    create?: XOR<CrewBuildCreateWithoutCrewInput, CrewBuildUncheckedCreateWithoutCrewInput> | CrewBuildCreateWithoutCrewInput[] | CrewBuildUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CrewBuildCreateOrConnectWithoutCrewInput | CrewBuildCreateOrConnectWithoutCrewInput[]
    createMany?: CrewBuildCreateManyCrewInputEnvelope
    connect?: CrewBuildWhereUniqueInput | CrewBuildWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutCrewNestedInput = {
    create?: XOR<UserCreateWithoutCrewInput, UserUncheckedCreateWithoutCrewInput>
    connectOrCreate?: UserCreateOrConnectWithoutCrewInput
    upsert?: UserUpsertWithoutCrewInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCrewInput, UserUpdateWithoutCrewInput>, UserUncheckedUpdateWithoutCrewInput>
  }

  export type UserUpdateOneWithoutCrewEditedByNestedInput = {
    create?: XOR<UserCreateWithoutCrewEditedByInput, UserUncheckedCreateWithoutCrewEditedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutCrewEditedByInput
    upsert?: UserUpsertWithoutCrewEditedByInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCrewEditedByInput, UserUpdateWithoutCrewEditedByInput>, UserUncheckedUpdateWithoutCrewEditedByInput>
  }

  export type CrewUserUpdateManyWithoutCrewNestedInput = {
    create?: XOR<CrewUserCreateWithoutCrewInput, CrewUserUncheckedCreateWithoutCrewInput> | CrewUserCreateWithoutCrewInput[] | CrewUserUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CrewUserCreateOrConnectWithoutCrewInput | CrewUserCreateOrConnectWithoutCrewInput[]
    upsert?: CrewUserUpsertWithWhereUniqueWithoutCrewInput | CrewUserUpsertWithWhereUniqueWithoutCrewInput[]
    createMany?: CrewUserCreateManyCrewInputEnvelope
    set?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
    disconnect?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
    delete?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
    connect?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
    update?: CrewUserUpdateWithWhereUniqueWithoutCrewInput | CrewUserUpdateWithWhereUniqueWithoutCrewInput[]
    updateMany?: CrewUserUpdateManyWithWhereWithoutCrewInput | CrewUserUpdateManyWithWhereWithoutCrewInput[]
    deleteMany?: CrewUserScalarWhereInput | CrewUserScalarWhereInput[]
  }

  export type CrewInventoryUpdateManyWithoutCrewNestedInput = {
    create?: XOR<CrewInventoryCreateWithoutCrewInput, CrewInventoryUncheckedCreateWithoutCrewInput> | CrewInventoryCreateWithoutCrewInput[] | CrewInventoryUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CrewInventoryCreateOrConnectWithoutCrewInput | CrewInventoryCreateOrConnectWithoutCrewInput[]
    upsert?: CrewInventoryUpsertWithWhereUniqueWithoutCrewInput | CrewInventoryUpsertWithWhereUniqueWithoutCrewInput[]
    createMany?: CrewInventoryCreateManyCrewInputEnvelope
    set?: CrewInventoryWhereUniqueInput | CrewInventoryWhereUniqueInput[]
    disconnect?: CrewInventoryWhereUniqueInput | CrewInventoryWhereUniqueInput[]
    delete?: CrewInventoryWhereUniqueInput | CrewInventoryWhereUniqueInput[]
    connect?: CrewInventoryWhereUniqueInput | CrewInventoryWhereUniqueInput[]
    update?: CrewInventoryUpdateWithWhereUniqueWithoutCrewInput | CrewInventoryUpdateWithWhereUniqueWithoutCrewInput[]
    updateMany?: CrewInventoryUpdateManyWithWhereWithoutCrewInput | CrewInventoryUpdateManyWithWhereWithoutCrewInput[]
    deleteMany?: CrewInventoryScalarWhereInput | CrewInventoryScalarWhereInput[]
  }

  export type CrewStorageUpdateManyWithoutCrewNestedInput = {
    create?: XOR<CrewStorageCreateWithoutCrewInput, CrewStorageUncheckedCreateWithoutCrewInput> | CrewStorageCreateWithoutCrewInput[] | CrewStorageUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CrewStorageCreateOrConnectWithoutCrewInput | CrewStorageCreateOrConnectWithoutCrewInput[]
    upsert?: CrewStorageUpsertWithWhereUniqueWithoutCrewInput | CrewStorageUpsertWithWhereUniqueWithoutCrewInput[]
    createMany?: CrewStorageCreateManyCrewInputEnvelope
    set?: CrewStorageWhereUniqueInput | CrewStorageWhereUniqueInput[]
    disconnect?: CrewStorageWhereUniqueInput | CrewStorageWhereUniqueInput[]
    delete?: CrewStorageWhereUniqueInput | CrewStorageWhereUniqueInput[]
    connect?: CrewStorageWhereUniqueInput | CrewStorageWhereUniqueInput[]
    update?: CrewStorageUpdateWithWhereUniqueWithoutCrewInput | CrewStorageUpdateWithWhereUniqueWithoutCrewInput[]
    updateMany?: CrewStorageUpdateManyWithWhereWithoutCrewInput | CrewStorageUpdateManyWithWhereWithoutCrewInput[]
    deleteMany?: CrewStorageScalarWhereInput | CrewStorageScalarWhereInput[]
  }

  export type CrewIngredientUpdateManyWithoutCrewNestedInput = {
    create?: XOR<CrewIngredientCreateWithoutCrewInput, CrewIngredientUncheckedCreateWithoutCrewInput> | CrewIngredientCreateWithoutCrewInput[] | CrewIngredientUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CrewIngredientCreateOrConnectWithoutCrewInput | CrewIngredientCreateOrConnectWithoutCrewInput[]
    upsert?: CrewIngredientUpsertWithWhereUniqueWithoutCrewInput | CrewIngredientUpsertWithWhereUniqueWithoutCrewInput[]
    createMany?: CrewIngredientCreateManyCrewInputEnvelope
    set?: CrewIngredientWhereUniqueInput | CrewIngredientWhereUniqueInput[]
    disconnect?: CrewIngredientWhereUniqueInput | CrewIngredientWhereUniqueInput[]
    delete?: CrewIngredientWhereUniqueInput | CrewIngredientWhereUniqueInput[]
    connect?: CrewIngredientWhereUniqueInput | CrewIngredientWhereUniqueInput[]
    update?: CrewIngredientUpdateWithWhereUniqueWithoutCrewInput | CrewIngredientUpdateWithWhereUniqueWithoutCrewInput[]
    updateMany?: CrewIngredientUpdateManyWithWhereWithoutCrewInput | CrewIngredientUpdateManyWithWhereWithoutCrewInput[]
    deleteMany?: CrewIngredientScalarWhereInput | CrewIngredientScalarWhereInput[]
  }

  export type CrewRecipeBookUpdateManyWithoutCrewNestedInput = {
    create?: XOR<CrewRecipeBookCreateWithoutCrewInput, CrewRecipeBookUncheckedCreateWithoutCrewInput> | CrewRecipeBookCreateWithoutCrewInput[] | CrewRecipeBookUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CrewRecipeBookCreateOrConnectWithoutCrewInput | CrewRecipeBookCreateOrConnectWithoutCrewInput[]
    upsert?: CrewRecipeBookUpsertWithWhereUniqueWithoutCrewInput | CrewRecipeBookUpsertWithWhereUniqueWithoutCrewInput[]
    createMany?: CrewRecipeBookCreateManyCrewInputEnvelope
    set?: CrewRecipeBookWhereUniqueInput | CrewRecipeBookWhereUniqueInput[]
    disconnect?: CrewRecipeBookWhereUniqueInput | CrewRecipeBookWhereUniqueInput[]
    delete?: CrewRecipeBookWhereUniqueInput | CrewRecipeBookWhereUniqueInput[]
    connect?: CrewRecipeBookWhereUniqueInput | CrewRecipeBookWhereUniqueInput[]
    update?: CrewRecipeBookUpdateWithWhereUniqueWithoutCrewInput | CrewRecipeBookUpdateWithWhereUniqueWithoutCrewInput[]
    updateMany?: CrewRecipeBookUpdateManyWithWhereWithoutCrewInput | CrewRecipeBookUpdateManyWithWhereWithoutCrewInput[]
    deleteMany?: CrewRecipeBookScalarWhereInput | CrewRecipeBookScalarWhereInput[]
  }

  export type CrewBuildUpdateManyWithoutCrewNestedInput = {
    create?: XOR<CrewBuildCreateWithoutCrewInput, CrewBuildUncheckedCreateWithoutCrewInput> | CrewBuildCreateWithoutCrewInput[] | CrewBuildUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CrewBuildCreateOrConnectWithoutCrewInput | CrewBuildCreateOrConnectWithoutCrewInput[]
    upsert?: CrewBuildUpsertWithWhereUniqueWithoutCrewInput | CrewBuildUpsertWithWhereUniqueWithoutCrewInput[]
    createMany?: CrewBuildCreateManyCrewInputEnvelope
    set?: CrewBuildWhereUniqueInput | CrewBuildWhereUniqueInput[]
    disconnect?: CrewBuildWhereUniqueInput | CrewBuildWhereUniqueInput[]
    delete?: CrewBuildWhereUniqueInput | CrewBuildWhereUniqueInput[]
    connect?: CrewBuildWhereUniqueInput | CrewBuildWhereUniqueInput[]
    update?: CrewBuildUpdateWithWhereUniqueWithoutCrewInput | CrewBuildUpdateWithWhereUniqueWithoutCrewInput[]
    updateMany?: CrewBuildUpdateManyWithWhereWithoutCrewInput | CrewBuildUpdateManyWithWhereWithoutCrewInput[]
    deleteMany?: CrewBuildScalarWhereInput | CrewBuildScalarWhereInput[]
  }

  export type CrewUserUncheckedUpdateManyWithoutCrewNestedInput = {
    create?: XOR<CrewUserCreateWithoutCrewInput, CrewUserUncheckedCreateWithoutCrewInput> | CrewUserCreateWithoutCrewInput[] | CrewUserUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CrewUserCreateOrConnectWithoutCrewInput | CrewUserCreateOrConnectWithoutCrewInput[]
    upsert?: CrewUserUpsertWithWhereUniqueWithoutCrewInput | CrewUserUpsertWithWhereUniqueWithoutCrewInput[]
    createMany?: CrewUserCreateManyCrewInputEnvelope
    set?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
    disconnect?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
    delete?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
    connect?: CrewUserWhereUniqueInput | CrewUserWhereUniqueInput[]
    update?: CrewUserUpdateWithWhereUniqueWithoutCrewInput | CrewUserUpdateWithWhereUniqueWithoutCrewInput[]
    updateMany?: CrewUserUpdateManyWithWhereWithoutCrewInput | CrewUserUpdateManyWithWhereWithoutCrewInput[]
    deleteMany?: CrewUserScalarWhereInput | CrewUserScalarWhereInput[]
  }

  export type CrewInventoryUncheckedUpdateManyWithoutCrewNestedInput = {
    create?: XOR<CrewInventoryCreateWithoutCrewInput, CrewInventoryUncheckedCreateWithoutCrewInput> | CrewInventoryCreateWithoutCrewInput[] | CrewInventoryUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CrewInventoryCreateOrConnectWithoutCrewInput | CrewInventoryCreateOrConnectWithoutCrewInput[]
    upsert?: CrewInventoryUpsertWithWhereUniqueWithoutCrewInput | CrewInventoryUpsertWithWhereUniqueWithoutCrewInput[]
    createMany?: CrewInventoryCreateManyCrewInputEnvelope
    set?: CrewInventoryWhereUniqueInput | CrewInventoryWhereUniqueInput[]
    disconnect?: CrewInventoryWhereUniqueInput | CrewInventoryWhereUniqueInput[]
    delete?: CrewInventoryWhereUniqueInput | CrewInventoryWhereUniqueInput[]
    connect?: CrewInventoryWhereUniqueInput | CrewInventoryWhereUniqueInput[]
    update?: CrewInventoryUpdateWithWhereUniqueWithoutCrewInput | CrewInventoryUpdateWithWhereUniqueWithoutCrewInput[]
    updateMany?: CrewInventoryUpdateManyWithWhereWithoutCrewInput | CrewInventoryUpdateManyWithWhereWithoutCrewInput[]
    deleteMany?: CrewInventoryScalarWhereInput | CrewInventoryScalarWhereInput[]
  }

  export type CrewStorageUncheckedUpdateManyWithoutCrewNestedInput = {
    create?: XOR<CrewStorageCreateWithoutCrewInput, CrewStorageUncheckedCreateWithoutCrewInput> | CrewStorageCreateWithoutCrewInput[] | CrewStorageUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CrewStorageCreateOrConnectWithoutCrewInput | CrewStorageCreateOrConnectWithoutCrewInput[]
    upsert?: CrewStorageUpsertWithWhereUniqueWithoutCrewInput | CrewStorageUpsertWithWhereUniqueWithoutCrewInput[]
    createMany?: CrewStorageCreateManyCrewInputEnvelope
    set?: CrewStorageWhereUniqueInput | CrewStorageWhereUniqueInput[]
    disconnect?: CrewStorageWhereUniqueInput | CrewStorageWhereUniqueInput[]
    delete?: CrewStorageWhereUniqueInput | CrewStorageWhereUniqueInput[]
    connect?: CrewStorageWhereUniqueInput | CrewStorageWhereUniqueInput[]
    update?: CrewStorageUpdateWithWhereUniqueWithoutCrewInput | CrewStorageUpdateWithWhereUniqueWithoutCrewInput[]
    updateMany?: CrewStorageUpdateManyWithWhereWithoutCrewInput | CrewStorageUpdateManyWithWhereWithoutCrewInput[]
    deleteMany?: CrewStorageScalarWhereInput | CrewStorageScalarWhereInput[]
  }

  export type CrewIngredientUncheckedUpdateManyWithoutCrewNestedInput = {
    create?: XOR<CrewIngredientCreateWithoutCrewInput, CrewIngredientUncheckedCreateWithoutCrewInput> | CrewIngredientCreateWithoutCrewInput[] | CrewIngredientUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CrewIngredientCreateOrConnectWithoutCrewInput | CrewIngredientCreateOrConnectWithoutCrewInput[]
    upsert?: CrewIngredientUpsertWithWhereUniqueWithoutCrewInput | CrewIngredientUpsertWithWhereUniqueWithoutCrewInput[]
    createMany?: CrewIngredientCreateManyCrewInputEnvelope
    set?: CrewIngredientWhereUniqueInput | CrewIngredientWhereUniqueInput[]
    disconnect?: CrewIngredientWhereUniqueInput | CrewIngredientWhereUniqueInput[]
    delete?: CrewIngredientWhereUniqueInput | CrewIngredientWhereUniqueInput[]
    connect?: CrewIngredientWhereUniqueInput | CrewIngredientWhereUniqueInput[]
    update?: CrewIngredientUpdateWithWhereUniqueWithoutCrewInput | CrewIngredientUpdateWithWhereUniqueWithoutCrewInput[]
    updateMany?: CrewIngredientUpdateManyWithWhereWithoutCrewInput | CrewIngredientUpdateManyWithWhereWithoutCrewInput[]
    deleteMany?: CrewIngredientScalarWhereInput | CrewIngredientScalarWhereInput[]
  }

  export type CrewRecipeBookUncheckedUpdateManyWithoutCrewNestedInput = {
    create?: XOR<CrewRecipeBookCreateWithoutCrewInput, CrewRecipeBookUncheckedCreateWithoutCrewInput> | CrewRecipeBookCreateWithoutCrewInput[] | CrewRecipeBookUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CrewRecipeBookCreateOrConnectWithoutCrewInput | CrewRecipeBookCreateOrConnectWithoutCrewInput[]
    upsert?: CrewRecipeBookUpsertWithWhereUniqueWithoutCrewInput | CrewRecipeBookUpsertWithWhereUniqueWithoutCrewInput[]
    createMany?: CrewRecipeBookCreateManyCrewInputEnvelope
    set?: CrewRecipeBookWhereUniqueInput | CrewRecipeBookWhereUniqueInput[]
    disconnect?: CrewRecipeBookWhereUniqueInput | CrewRecipeBookWhereUniqueInput[]
    delete?: CrewRecipeBookWhereUniqueInput | CrewRecipeBookWhereUniqueInput[]
    connect?: CrewRecipeBookWhereUniqueInput | CrewRecipeBookWhereUniqueInput[]
    update?: CrewRecipeBookUpdateWithWhereUniqueWithoutCrewInput | CrewRecipeBookUpdateWithWhereUniqueWithoutCrewInput[]
    updateMany?: CrewRecipeBookUpdateManyWithWhereWithoutCrewInput | CrewRecipeBookUpdateManyWithWhereWithoutCrewInput[]
    deleteMany?: CrewRecipeBookScalarWhereInput | CrewRecipeBookScalarWhereInput[]
  }

  export type CrewBuildUncheckedUpdateManyWithoutCrewNestedInput = {
    create?: XOR<CrewBuildCreateWithoutCrewInput, CrewBuildUncheckedCreateWithoutCrewInput> | CrewBuildCreateWithoutCrewInput[] | CrewBuildUncheckedCreateWithoutCrewInput[]
    connectOrCreate?: CrewBuildCreateOrConnectWithoutCrewInput | CrewBuildCreateOrConnectWithoutCrewInput[]
    upsert?: CrewBuildUpsertWithWhereUniqueWithoutCrewInput | CrewBuildUpsertWithWhereUniqueWithoutCrewInput[]
    createMany?: CrewBuildCreateManyCrewInputEnvelope
    set?: CrewBuildWhereUniqueInput | CrewBuildWhereUniqueInput[]
    disconnect?: CrewBuildWhereUniqueInput | CrewBuildWhereUniqueInput[]
    delete?: CrewBuildWhereUniqueInput | CrewBuildWhereUniqueInput[]
    connect?: CrewBuildWhereUniqueInput | CrewBuildWhereUniqueInput[]
    update?: CrewBuildUpdateWithWhereUniqueWithoutCrewInput | CrewBuildUpdateWithWhereUniqueWithoutCrewInput[]
    updateMany?: CrewBuildUpdateManyWithWhereWithoutCrewInput | CrewBuildUpdateManyWithWhereWithoutCrewInput[]
    deleteMany?: CrewBuildScalarWhereInput | CrewBuildScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCrewUserInput = {
    create?: XOR<UserCreateWithoutCrewUserInput, UserUncheckedCreateWithoutCrewUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutCrewUserInput
    connect?: UserWhereUniqueInput
  }

  export type CrewCreateNestedOneWithoutCrewUserInput = {
    create?: XOR<CrewCreateWithoutCrewUserInput, CrewUncheckedCreateWithoutCrewUserInput>
    connectOrCreate?: CrewCreateOrConnectWithoutCrewUserInput
    connect?: CrewWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCrewUserNestedInput = {
    create?: XOR<UserCreateWithoutCrewUserInput, UserUncheckedCreateWithoutCrewUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutCrewUserInput
    upsert?: UserUpsertWithoutCrewUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCrewUserInput, UserUpdateWithoutCrewUserInput>, UserUncheckedUpdateWithoutCrewUserInput>
  }

  export type CrewUpdateOneRequiredWithoutCrewUserNestedInput = {
    create?: XOR<CrewCreateWithoutCrewUserInput, CrewUncheckedCreateWithoutCrewUserInput>
    connectOrCreate?: CrewCreateOrConnectWithoutCrewUserInput
    upsert?: CrewUpsertWithoutCrewUserInput
    connect?: CrewWhereUniqueInput
    update?: XOR<XOR<CrewUpdateToOneWithWhereWithoutCrewUserInput, CrewUpdateWithoutCrewUserInput>, CrewUncheckedUpdateWithoutCrewUserInput>
  }

  export type InventoryCreateNestedOneWithoutCrewInventoryInput = {
    create?: XOR<InventoryCreateWithoutCrewInventoryInput, InventoryUncheckedCreateWithoutCrewInventoryInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutCrewInventoryInput
    connect?: InventoryWhereUniqueInput
  }

  export type CrewCreateNestedOneWithoutCrewInventoryInput = {
    create?: XOR<CrewCreateWithoutCrewInventoryInput, CrewUncheckedCreateWithoutCrewInventoryInput>
    connectOrCreate?: CrewCreateOrConnectWithoutCrewInventoryInput
    connect?: CrewWhereUniqueInput
  }

  export type InventoryUpdateOneRequiredWithoutCrewInventoryNestedInput = {
    create?: XOR<InventoryCreateWithoutCrewInventoryInput, InventoryUncheckedCreateWithoutCrewInventoryInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutCrewInventoryInput
    upsert?: InventoryUpsertWithoutCrewInventoryInput
    connect?: InventoryWhereUniqueInput
    update?: XOR<XOR<InventoryUpdateToOneWithWhereWithoutCrewInventoryInput, InventoryUpdateWithoutCrewInventoryInput>, InventoryUncheckedUpdateWithoutCrewInventoryInput>
  }

  export type CrewUpdateOneRequiredWithoutCrewInventoryNestedInput = {
    create?: XOR<CrewCreateWithoutCrewInventoryInput, CrewUncheckedCreateWithoutCrewInventoryInput>
    connectOrCreate?: CrewCreateOrConnectWithoutCrewInventoryInput
    upsert?: CrewUpsertWithoutCrewInventoryInput
    connect?: CrewWhereUniqueInput
    update?: XOR<XOR<CrewUpdateToOneWithWhereWithoutCrewInventoryInput, CrewUpdateWithoutCrewInventoryInput>, CrewUncheckedUpdateWithoutCrewInventoryInput>
  }

  export type StorageCreateNestedOneWithoutCrewStorageInput = {
    create?: XOR<StorageCreateWithoutCrewStorageInput, StorageUncheckedCreateWithoutCrewStorageInput>
    connectOrCreate?: StorageCreateOrConnectWithoutCrewStorageInput
    connect?: StorageWhereUniqueInput
  }

  export type CrewCreateNestedOneWithoutCrewStorageInput = {
    create?: XOR<CrewCreateWithoutCrewStorageInput, CrewUncheckedCreateWithoutCrewStorageInput>
    connectOrCreate?: CrewCreateOrConnectWithoutCrewStorageInput
    connect?: CrewWhereUniqueInput
  }

  export type StorageUpdateOneRequiredWithoutCrewStorageNestedInput = {
    create?: XOR<StorageCreateWithoutCrewStorageInput, StorageUncheckedCreateWithoutCrewStorageInput>
    connectOrCreate?: StorageCreateOrConnectWithoutCrewStorageInput
    upsert?: StorageUpsertWithoutCrewStorageInput
    connect?: StorageWhereUniqueInput
    update?: XOR<XOR<StorageUpdateToOneWithWhereWithoutCrewStorageInput, StorageUpdateWithoutCrewStorageInput>, StorageUncheckedUpdateWithoutCrewStorageInput>
  }

  export type CrewUpdateOneRequiredWithoutCrewStorageNestedInput = {
    create?: XOR<CrewCreateWithoutCrewStorageInput, CrewUncheckedCreateWithoutCrewStorageInput>
    connectOrCreate?: CrewCreateOrConnectWithoutCrewStorageInput
    upsert?: CrewUpsertWithoutCrewStorageInput
    connect?: CrewWhereUniqueInput
    update?: XOR<XOR<CrewUpdateToOneWithWhereWithoutCrewStorageInput, CrewUpdateWithoutCrewStorageInput>, CrewUncheckedUpdateWithoutCrewStorageInput>
  }

  export type IngredientCreateNestedOneWithoutCrewIngredientInput = {
    create?: XOR<IngredientCreateWithoutCrewIngredientInput, IngredientUncheckedCreateWithoutCrewIngredientInput>
    connectOrCreate?: IngredientCreateOrConnectWithoutCrewIngredientInput
    connect?: IngredientWhereUniqueInput
  }

  export type CrewCreateNestedOneWithoutCrewIngredientInput = {
    create?: XOR<CrewCreateWithoutCrewIngredientInput, CrewUncheckedCreateWithoutCrewIngredientInput>
    connectOrCreate?: CrewCreateOrConnectWithoutCrewIngredientInput
    connect?: CrewWhereUniqueInput
  }

  export type IngredientUpdateOneRequiredWithoutCrewIngredientNestedInput = {
    create?: XOR<IngredientCreateWithoutCrewIngredientInput, IngredientUncheckedCreateWithoutCrewIngredientInput>
    connectOrCreate?: IngredientCreateOrConnectWithoutCrewIngredientInput
    upsert?: IngredientUpsertWithoutCrewIngredientInput
    connect?: IngredientWhereUniqueInput
    update?: XOR<XOR<IngredientUpdateToOneWithWhereWithoutCrewIngredientInput, IngredientUpdateWithoutCrewIngredientInput>, IngredientUncheckedUpdateWithoutCrewIngredientInput>
  }

  export type CrewUpdateOneRequiredWithoutCrewIngredientNestedInput = {
    create?: XOR<CrewCreateWithoutCrewIngredientInput, CrewUncheckedCreateWithoutCrewIngredientInput>
    connectOrCreate?: CrewCreateOrConnectWithoutCrewIngredientInput
    upsert?: CrewUpsertWithoutCrewIngredientInput
    connect?: CrewWhereUniqueInput
    update?: XOR<XOR<CrewUpdateToOneWithWhereWithoutCrewIngredientInput, CrewUpdateWithoutCrewIngredientInput>, CrewUncheckedUpdateWithoutCrewIngredientInput>
  }

  export type RecipeBookCreateNestedOneWithoutCrewRecipeBookInput = {
    create?: XOR<RecipeBookCreateWithoutCrewRecipeBookInput, RecipeBookUncheckedCreateWithoutCrewRecipeBookInput>
    connectOrCreate?: RecipeBookCreateOrConnectWithoutCrewRecipeBookInput
    connect?: RecipeBookWhereUniqueInput
  }

  export type CrewCreateNestedOneWithoutCrewRecipeBookInput = {
    create?: XOR<CrewCreateWithoutCrewRecipeBookInput, CrewUncheckedCreateWithoutCrewRecipeBookInput>
    connectOrCreate?: CrewCreateOrConnectWithoutCrewRecipeBookInput
    connect?: CrewWhereUniqueInput
  }

  export type RecipeBookUpdateOneRequiredWithoutCrewRecipeBookNestedInput = {
    create?: XOR<RecipeBookCreateWithoutCrewRecipeBookInput, RecipeBookUncheckedCreateWithoutCrewRecipeBookInput>
    connectOrCreate?: RecipeBookCreateOrConnectWithoutCrewRecipeBookInput
    upsert?: RecipeBookUpsertWithoutCrewRecipeBookInput
    connect?: RecipeBookWhereUniqueInput
    update?: XOR<XOR<RecipeBookUpdateToOneWithWhereWithoutCrewRecipeBookInput, RecipeBookUpdateWithoutCrewRecipeBookInput>, RecipeBookUncheckedUpdateWithoutCrewRecipeBookInput>
  }

  export type CrewUpdateOneRequiredWithoutCrewRecipeBookNestedInput = {
    create?: XOR<CrewCreateWithoutCrewRecipeBookInput, CrewUncheckedCreateWithoutCrewRecipeBookInput>
    connectOrCreate?: CrewCreateOrConnectWithoutCrewRecipeBookInput
    upsert?: CrewUpsertWithoutCrewRecipeBookInput
    connect?: CrewWhereUniqueInput
    update?: XOR<XOR<CrewUpdateToOneWithWhereWithoutCrewRecipeBookInput, CrewUpdateWithoutCrewRecipeBookInput>, CrewUncheckedUpdateWithoutCrewRecipeBookInput>
  }

  export type BuildCreateNestedOneWithoutCrewBuildInput = {
    create?: XOR<BuildCreateWithoutCrewBuildInput, BuildUncheckedCreateWithoutCrewBuildInput>
    connectOrCreate?: BuildCreateOrConnectWithoutCrewBuildInput
    connect?: BuildWhereUniqueInput
  }

  export type CrewCreateNestedOneWithoutCrewBuildInput = {
    create?: XOR<CrewCreateWithoutCrewBuildInput, CrewUncheckedCreateWithoutCrewBuildInput>
    connectOrCreate?: CrewCreateOrConnectWithoutCrewBuildInput
    connect?: CrewWhereUniqueInput
  }

  export type BuildUpdateOneRequiredWithoutCrewBuildNestedInput = {
    create?: XOR<BuildCreateWithoutCrewBuildInput, BuildUncheckedCreateWithoutCrewBuildInput>
    connectOrCreate?: BuildCreateOrConnectWithoutCrewBuildInput
    upsert?: BuildUpsertWithoutCrewBuildInput
    connect?: BuildWhereUniqueInput
    update?: XOR<XOR<BuildUpdateToOneWithWhereWithoutCrewBuildInput, BuildUpdateWithoutCrewBuildInput>, BuildUncheckedUpdateWithoutCrewBuildInput>
  }

  export type CrewUpdateOneRequiredWithoutCrewBuildNestedInput = {
    create?: XOR<CrewCreateWithoutCrewBuildInput, CrewUncheckedCreateWithoutCrewBuildInput>
    connectOrCreate?: CrewCreateOrConnectWithoutCrewBuildInput
    upsert?: CrewUpsertWithoutCrewBuildInput
    connect?: CrewWhereUniqueInput
    update?: XOR<XOR<CrewUpdateToOneWithWhereWithoutCrewBuildInput, CrewUpdateWithoutCrewBuildInput>, CrewUncheckedUpdateWithoutCrewBuildInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ProfileCreateWithoutUserInput = {
    id?: string
    photo: string
  }

  export type ProfileUncheckedCreateWithoutUserInput = {
    id?: string
    photo: string
  }

  export type ProfileCreateOrConnectWithoutUserInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type RecipeBookUserCreateWithoutUserInput = {
    permission: string
    recipeBook: RecipeBookCreateNestedOneWithoutRecipeBookUserInput
  }

  export type RecipeBookUserUncheckedCreateWithoutUserInput = {
    recipeBookId: string
    permission: string
  }

  export type RecipeBookUserCreateOrConnectWithoutUserInput = {
    where: RecipeBookUserWhereUniqueInput
    create: XOR<RecipeBookUserCreateWithoutUserInput, RecipeBookUserUncheckedCreateWithoutUserInput>
  }

  export type RecipeBookUserCreateManyUserInputEnvelope = {
    data: RecipeBookUserCreateManyUserInput | RecipeBookUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RecipeBookCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    editedBy?: UserCreateNestedOneWithoutRecipeBookEditedByInput
    recipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutRecipeBookInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutRecipeBookInput
    crewRecipeBook?: CrewRecipeBookCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    editedById?: string | null
    recipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutRecipeBookInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutRecipeBookInput
    crewRecipeBook?: CrewRecipeBookUncheckedCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookCreateOrConnectWithoutCreatedByInput = {
    where: RecipeBookWhereUniqueInput
    create: XOR<RecipeBookCreateWithoutCreatedByInput, RecipeBookUncheckedCreateWithoutCreatedByInput>
  }

  export type RecipeBookCreateManyCreatedByInputEnvelope = {
    data: RecipeBookCreateManyCreatedByInput | RecipeBookCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type RecipeBookCreateWithoutEditedByInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutRecipeBookInput
    recipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutRecipeBookInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutRecipeBookInput
    crewRecipeBook?: CrewRecipeBookCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookUncheckedCreateWithoutEditedByInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    recipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutRecipeBookInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutRecipeBookInput
    crewRecipeBook?: CrewRecipeBookUncheckedCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookCreateOrConnectWithoutEditedByInput = {
    where: RecipeBookWhereUniqueInput
    create: XOR<RecipeBookCreateWithoutEditedByInput, RecipeBookUncheckedCreateWithoutEditedByInput>
  }

  export type RecipeBookCreateManyEditedByInputEnvelope = {
    data: RecipeBookCreateManyEditedByInput | RecipeBookCreateManyEditedByInput[]
    skipDuplicates?: boolean
  }

  export type RecipeCreateWithoutCreatedByInput = {
    id?: string
    createdAt?: Date | string
    editedAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    editedBy?: UserCreateNestedOneWithoutRecipeEditedByInput
    build?: BuildCreateNestedManyWithoutRecipeInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutCreatedByInput = {
    id?: string
    createdAt?: Date | string
    editedAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    editedById?: string | null
    build?: BuildUncheckedCreateNestedManyWithoutRecipeInput
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutCreatedByInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutCreatedByInput, RecipeUncheckedCreateWithoutCreatedByInput>
  }

  export type RecipeCreateManyCreatedByInputEnvelope = {
    data: RecipeCreateManyCreatedByInput | RecipeCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type RecipeCreateWithoutEditedByInput = {
    id?: string
    createdAt?: Date | string
    editedAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    createdBy?: UserCreateNestedOneWithoutRecipeInput
    build?: BuildCreateNestedManyWithoutRecipeInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutEditedByInput = {
    id?: string
    createdAt?: Date | string
    editedAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    createdById?: string | null
    build?: BuildUncheckedCreateNestedManyWithoutRecipeInput
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutEditedByInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutEditedByInput, RecipeUncheckedCreateWithoutEditedByInput>
  }

  export type RecipeCreateManyEditedByInputEnvelope = {
    data: RecipeCreateManyEditedByInput | RecipeCreateManyEditedByInput[]
    skipDuplicates?: boolean
  }

  export type BuildUserCreateWithoutUserInput = {
    permission: string
    build?: BuildCreateNestedOneWithoutBuildUserInput
  }

  export type BuildUserUncheckedCreateWithoutUserInput = {
    buildId: string
    permission: string
  }

  export type BuildUserCreateOrConnectWithoutUserInput = {
    where: BuildUserWhereUniqueInput
    create: XOR<BuildUserCreateWithoutUserInput, BuildUserUncheckedCreateWithoutUserInput>
  }

  export type BuildUserCreateManyUserInputEnvelope = {
    data: BuildUserCreateManyUserInput | BuildUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BuildCreateWithoutCreatedByInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version?: number
    editedBy?: UserCreateNestedOneWithoutBuildEditedByInput
    recipe?: RecipeCreateNestedOneWithoutBuildInput
    touch?: TouchCreateNestedManyWithoutBuildInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserCreateNestedManyWithoutBuildInput
    crewBuild?: CrewBuildCreateNestedManyWithoutBuildInput
  }

  export type BuildUncheckedCreateWithoutCreatedByInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedById?: string | null
    recipeId?: string | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version?: number
    touch?: TouchUncheckedCreateNestedManyWithoutBuildInput
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutBuildInput
    crewBuild?: CrewBuildUncheckedCreateNestedManyWithoutBuildInput
  }

  export type BuildCreateOrConnectWithoutCreatedByInput = {
    where: BuildWhereUniqueInput
    create: XOR<BuildCreateWithoutCreatedByInput, BuildUncheckedCreateWithoutCreatedByInput>
  }

  export type BuildCreateManyCreatedByInputEnvelope = {
    data: BuildCreateManyCreatedByInput | BuildCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type BuildCreateWithoutEditedByInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version?: number
    createdBy?: UserCreateNestedOneWithoutBuildInput
    recipe?: RecipeCreateNestedOneWithoutBuildInput
    touch?: TouchCreateNestedManyWithoutBuildInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserCreateNestedManyWithoutBuildInput
    crewBuild?: CrewBuildCreateNestedManyWithoutBuildInput
  }

  export type BuildUncheckedCreateWithoutEditedByInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    recipeId?: string | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version?: number
    touch?: TouchUncheckedCreateNestedManyWithoutBuildInput
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutBuildInput
    crewBuild?: CrewBuildUncheckedCreateNestedManyWithoutBuildInput
  }

  export type BuildCreateOrConnectWithoutEditedByInput = {
    where: BuildWhereUniqueInput
    create: XOR<BuildCreateWithoutEditedByInput, BuildUncheckedCreateWithoutEditedByInput>
  }

  export type BuildCreateManyEditedByInputEnvelope = {
    data: BuildCreateManyEditedByInput | BuildCreateManyEditedByInput[]
    skipDuplicates?: boolean
  }

  export type ArchivedBuildCreateWithoutCreatedByInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version: number
    build: BuildCreateNestedOneWithoutArchivedBuildInput
    recipe?: RecipeCreateNestedOneWithoutArchivedBuildInput
    archivedTouch?: ArchivedTouchCreateNestedManyWithoutArchivedBuildInput
  }

  export type ArchivedBuildUncheckedCreateWithoutCreatedByInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    buildId: string
    recipeId?: string | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version: number
    archivedTouch?: ArchivedTouchUncheckedCreateNestedManyWithoutArchivedBuildInput
  }

  export type ArchivedBuildCreateOrConnectWithoutCreatedByInput = {
    where: ArchivedBuildWhereUniqueInput
    create: XOR<ArchivedBuildCreateWithoutCreatedByInput, ArchivedBuildUncheckedCreateWithoutCreatedByInput>
  }

  export type ArchivedBuildCreateManyCreatedByInputEnvelope = {
    data: ArchivedBuildCreateManyCreatedByInput | ArchivedBuildCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type CrewUserCreateWithoutUserInput = {
    permission: string
    crew: CrewCreateNestedOneWithoutCrewUserInput
  }

  export type CrewUserUncheckedCreateWithoutUserInput = {
    crewId: string
    permission: string
  }

  export type CrewUserCreateOrConnectWithoutUserInput = {
    where: CrewUserWhereUniqueInput
    create: XOR<CrewUserCreateWithoutUserInput, CrewUserUncheckedCreateWithoutUserInput>
  }

  export type CrewUserCreateManyUserInputEnvelope = {
    data: CrewUserCreateManyUserInput | CrewUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CrewCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedBy?: UserCreateNestedOneWithoutCrewEditedByInput
    crewUser?: CrewUserCreateNestedManyWithoutCrewInput
    crewInventory?: CrewInventoryCreateNestedManyWithoutCrewInput
    crewStorage?: CrewStorageCreateNestedManyWithoutCrewInput
    crewIngredient?: CrewIngredientCreateNestedManyWithoutCrewInput
    crewRecipeBook?: CrewRecipeBookCreateNestedManyWithoutCrewInput
    crewBuild?: CrewBuildCreateNestedManyWithoutCrewInput
  }

  export type CrewUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedById: string
    crewUser?: CrewUserUncheckedCreateNestedManyWithoutCrewInput
    crewInventory?: CrewInventoryUncheckedCreateNestedManyWithoutCrewInput
    crewStorage?: CrewStorageUncheckedCreateNestedManyWithoutCrewInput
    crewIngredient?: CrewIngredientUncheckedCreateNestedManyWithoutCrewInput
    crewRecipeBook?: CrewRecipeBookUncheckedCreateNestedManyWithoutCrewInput
    crewBuild?: CrewBuildUncheckedCreateNestedManyWithoutCrewInput
  }

  export type CrewCreateOrConnectWithoutCreatedByInput = {
    where: CrewWhereUniqueInput
    create: XOR<CrewCreateWithoutCreatedByInput, CrewUncheckedCreateWithoutCreatedByInput>
  }

  export type CrewCreateManyCreatedByInputEnvelope = {
    data: CrewCreateManyCreatedByInput | CrewCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type CrewCreateWithoutEditedByInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCrewInput
    crewUser?: CrewUserCreateNestedManyWithoutCrewInput
    crewInventory?: CrewInventoryCreateNestedManyWithoutCrewInput
    crewStorage?: CrewStorageCreateNestedManyWithoutCrewInput
    crewIngredient?: CrewIngredientCreateNestedManyWithoutCrewInput
    crewRecipeBook?: CrewRecipeBookCreateNestedManyWithoutCrewInput
    crewBuild?: CrewBuildCreateNestedManyWithoutCrewInput
  }

  export type CrewUncheckedCreateWithoutEditedByInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    crewUser?: CrewUserUncheckedCreateNestedManyWithoutCrewInput
    crewInventory?: CrewInventoryUncheckedCreateNestedManyWithoutCrewInput
    crewStorage?: CrewStorageUncheckedCreateNestedManyWithoutCrewInput
    crewIngredient?: CrewIngredientUncheckedCreateNestedManyWithoutCrewInput
    crewRecipeBook?: CrewRecipeBookUncheckedCreateNestedManyWithoutCrewInput
    crewBuild?: CrewBuildUncheckedCreateNestedManyWithoutCrewInput
  }

  export type CrewCreateOrConnectWithoutEditedByInput = {
    where: CrewWhereUniqueInput
    create: XOR<CrewCreateWithoutEditedByInput, CrewUncheckedCreateWithoutEditedByInput>
  }

  export type CrewCreateManyEditedByInputEnvelope = {
    data: CrewCreateManyEditedByInput | CrewCreateManyEditedByInput[]
    skipDuplicates?: boolean
  }

  export type IngredientCreateWithoutCreatedByInput = {
    id?: string
    dateCreated?: Date | string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    ingredientType: IngredientTypeCreateNestedOneWithoutIngredientInput
    touch?: TouchCreateNestedManyWithoutIngredientInput
    archivedTouch?: ArchivedTouchCreateNestedManyWithoutIngredientInput
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutIngredientInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutIngredientInput
    crewIngredient?: CrewIngredientCreateNestedManyWithoutIngredientInput
  }

  export type IngredientUncheckedCreateWithoutCreatedByInput = {
    id?: string
    dateCreated?: Date | string
    ingredientTypeId: string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutIngredientInput
    archivedTouch?: ArchivedTouchUncheckedCreateNestedManyWithoutIngredientInput
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutIngredientInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutIngredientInput
    crewIngredient?: CrewIngredientUncheckedCreateNestedManyWithoutIngredientInput
  }

  export type IngredientCreateOrConnectWithoutCreatedByInput = {
    where: IngredientWhereUniqueInput
    create: XOR<IngredientCreateWithoutCreatedByInput, IngredientUncheckedCreateWithoutCreatedByInput>
  }

  export type IngredientCreateManyCreatedByInputEnvelope = {
    data: IngredientCreateManyCreatedByInput | IngredientCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type IngredientPreferenceCreateWithoutUserInput = {
    ingredientType: IngredientTypeCreateNestedOneWithoutIngredientPreferenceInput
    ingredient: IngredientCreateNestedOneWithoutIngredientPreferenceInput
  }

  export type IngredientPreferenceUncheckedCreateWithoutUserInput = {
    ingredientTypeId: string
    ingredientId: string
  }

  export type IngredientPreferenceCreateOrConnectWithoutUserInput = {
    where: IngredientPreferenceWhereUniqueInput
    create: XOR<IngredientPreferenceCreateWithoutUserInput, IngredientPreferenceUncheckedCreateWithoutUserInput>
  }

  export type IngredientPreferenceCreateManyUserInputEnvelope = {
    data: IngredientPreferenceCreateManyUserInput | IngredientPreferenceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type IngredientUserCreateWithoutUserInput = {
    permission: string
    ingredient: IngredientCreateNestedOneWithoutIngredientUserInput
  }

  export type IngredientUserUncheckedCreateWithoutUserInput = {
    ingredientId: string
    permission: string
  }

  export type IngredientUserCreateOrConnectWithoutUserInput = {
    where: IngredientUserWhereUniqueInput
    create: XOR<IngredientUserCreateWithoutUserInput, IngredientUserUncheckedCreateWithoutUserInput>
  }

  export type IngredientUserCreateManyUserInputEnvelope = {
    data: IngredientUserCreateManyUserInput | IngredientUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StorageUserCreateWithoutUserInput = {
    permission: string
    Storage: StorageCreateNestedOneWithoutStorageUserInput
  }

  export type StorageUserUncheckedCreateWithoutUserInput = {
    storageId: string
    permission: string
  }

  export type StorageUserCreateOrConnectWithoutUserInput = {
    where: StorageUserWhereUniqueInput
    create: XOR<StorageUserCreateWithoutUserInput, StorageUserUncheckedCreateWithoutUserInput>
  }

  export type StorageUserCreateManyUserInputEnvelope = {
    data: StorageUserCreateManyUserInput | StorageUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StorageCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedBy?: UserCreateNestedOneWithoutStorageEditedByInput
    inventoryStorage?: InventoryStorageCreateNestedManyWithoutStorageInput
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutStorageInput
    storageUser?: StorageUserCreateNestedManyWithoutStorageInput
    crewStorage?: CrewStorageCreateNestedManyWithoutStorageInput
  }

  export type StorageUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedById: string
    inventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutStorageInput
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutStorageInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutStorageInput
    crewStorage?: CrewStorageUncheckedCreateNestedManyWithoutStorageInput
  }

  export type StorageCreateOrConnectWithoutCreatedByInput = {
    where: StorageWhereUniqueInput
    create: XOR<StorageCreateWithoutCreatedByInput, StorageUncheckedCreateWithoutCreatedByInput>
  }

  export type StorageCreateManyCreatedByInputEnvelope = {
    data: StorageCreateManyCreatedByInput | StorageCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type StorageCreateWithoutEditedByInput = {
    id?: string
    name: string
    description?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutStorageInput
    inventoryStorage?: InventoryStorageCreateNestedManyWithoutStorageInput
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutStorageInput
    storageUser?: StorageUserCreateNestedManyWithoutStorageInput
    crewStorage?: CrewStorageCreateNestedManyWithoutStorageInput
  }

  export type StorageUncheckedCreateWithoutEditedByInput = {
    id?: string
    name: string
    description?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    inventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutStorageInput
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutStorageInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutStorageInput
    crewStorage?: CrewStorageUncheckedCreateNestedManyWithoutStorageInput
  }

  export type StorageCreateOrConnectWithoutEditedByInput = {
    where: StorageWhereUniqueInput
    create: XOR<StorageCreateWithoutEditedByInput, StorageUncheckedCreateWithoutEditedByInput>
  }

  export type StorageCreateManyEditedByInputEnvelope = {
    data: StorageCreateManyEditedByInput | StorageCreateManyEditedByInput[]
    skipDuplicates?: boolean
  }

  export type InventoryCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedBy?: UserCreateNestedOneWithoutInventoryEditedByInput
    inventoryStorage?: InventoryStorageCreateNestedManyWithoutInventoryInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutInventoryInput
    crewInventory?: CrewInventoryCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedById: string
    inventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutInventoryInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutInventoryInput
    crewInventory?: CrewInventoryUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryCreateOrConnectWithoutCreatedByInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutCreatedByInput, InventoryUncheckedCreateWithoutCreatedByInput>
  }

  export type InventoryCreateManyCreatedByInputEnvelope = {
    data: InventoryCreateManyCreatedByInput | InventoryCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type InventoryCreateWithoutEditedByInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutInventoryInput
    inventoryStorage?: InventoryStorageCreateNestedManyWithoutInventoryInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutInventoryInput
    crewInventory?: CrewInventoryCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutEditedByInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    inventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutInventoryInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutInventoryInput
    crewInventory?: CrewInventoryUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryCreateOrConnectWithoutEditedByInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutEditedByInput, InventoryUncheckedCreateWithoutEditedByInput>
  }

  export type InventoryCreateManyEditedByInputEnvelope = {
    data: InventoryCreateManyEditedByInput | InventoryCreateManyEditedByInput[]
    skipDuplicates?: boolean
  }

  export type InventoryUserCreateWithoutUserInput = {
    permission: string
    inventory: InventoryCreateNestedOneWithoutInventoryUserInput
  }

  export type InventoryUserUncheckedCreateWithoutUserInput = {
    inventoryId: string
    permission: string
  }

  export type InventoryUserCreateOrConnectWithoutUserInput = {
    where: InventoryUserWhereUniqueInput
    create: XOR<InventoryUserCreateWithoutUserInput, InventoryUserUncheckedCreateWithoutUserInput>
  }

  export type InventoryUserCreateManyUserInputEnvelope = {
    data: InventoryUserCreateManyUserInput | InventoryUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FollowCreateWithoutFollowedByInput = {
    relationship: string
    following: UserCreateNestedOneWithoutFollowingInput
  }

  export type FollowUncheckedCreateWithoutFollowedByInput = {
    followingId: string
    relationship: string
  }

  export type FollowCreateOrConnectWithoutFollowedByInput = {
    where: FollowWhereUniqueInput
    create: XOR<FollowCreateWithoutFollowedByInput, FollowUncheckedCreateWithoutFollowedByInput>
  }

  export type FollowCreateManyFollowedByInputEnvelope = {
    data: FollowCreateManyFollowedByInput | FollowCreateManyFollowedByInput[]
    skipDuplicates?: boolean
  }

  export type FollowCreateWithoutFollowingInput = {
    relationship: string
    followedBy: UserCreateNestedOneWithoutFollowedByInput
  }

  export type FollowUncheckedCreateWithoutFollowingInput = {
    followedById: string
    relationship: string
  }

  export type FollowCreateOrConnectWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    create: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput>
  }

  export type FollowCreateManyFollowingInputEnvelope = {
    data: FollowCreateManyFollowingInput | FollowCreateManyFollowingInput[]
    skipDuplicates?: boolean
  }

  export type ProfileUpsertWithoutUserInput = {
    update: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type ProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookUserUpsertWithWhereUniqueWithoutUserInput = {
    where: RecipeBookUserWhereUniqueInput
    update: XOR<RecipeBookUserUpdateWithoutUserInput, RecipeBookUserUncheckedUpdateWithoutUserInput>
    create: XOR<RecipeBookUserCreateWithoutUserInput, RecipeBookUserUncheckedCreateWithoutUserInput>
  }

  export type RecipeBookUserUpdateWithWhereUniqueWithoutUserInput = {
    where: RecipeBookUserWhereUniqueInput
    data: XOR<RecipeBookUserUpdateWithoutUserInput, RecipeBookUserUncheckedUpdateWithoutUserInput>
  }

  export type RecipeBookUserUpdateManyWithWhereWithoutUserInput = {
    where: RecipeBookUserScalarWhereInput
    data: XOR<RecipeBookUserUpdateManyMutationInput, RecipeBookUserUncheckedUpdateManyWithoutUserInput>
  }

  export type RecipeBookUserScalarWhereInput = {
    AND?: RecipeBookUserScalarWhereInput | RecipeBookUserScalarWhereInput[]
    OR?: RecipeBookUserScalarWhereInput[]
    NOT?: RecipeBookUserScalarWhereInput | RecipeBookUserScalarWhereInput[]
    userId?: StringFilter<"RecipeBookUser"> | string
    recipeBookId?: StringFilter<"RecipeBookUser"> | string
    permission?: StringFilter<"RecipeBookUser"> | string
  }

  export type RecipeBookUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: RecipeBookWhereUniqueInput
    update: XOR<RecipeBookUpdateWithoutCreatedByInput, RecipeBookUncheckedUpdateWithoutCreatedByInput>
    create: XOR<RecipeBookCreateWithoutCreatedByInput, RecipeBookUncheckedCreateWithoutCreatedByInput>
  }

  export type RecipeBookUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: RecipeBookWhereUniqueInput
    data: XOR<RecipeBookUpdateWithoutCreatedByInput, RecipeBookUncheckedUpdateWithoutCreatedByInput>
  }

  export type RecipeBookUpdateManyWithWhereWithoutCreatedByInput = {
    where: RecipeBookScalarWhereInput
    data: XOR<RecipeBookUpdateManyMutationInput, RecipeBookUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type RecipeBookScalarWhereInput = {
    AND?: RecipeBookScalarWhereInput | RecipeBookScalarWhereInput[]
    OR?: RecipeBookScalarWhereInput[]
    NOT?: RecipeBookScalarWhereInput | RecipeBookScalarWhereInput[]
    id?: StringFilter<"RecipeBook"> | string
    name?: StringFilter<"RecipeBook"> | string
    description?: StringNullableFilter<"RecipeBook"> | string | null
    createdAt?: DateTimeFilter<"RecipeBook"> | Date | string
    editedAt?: DateTimeFilter<"RecipeBook"> | Date | string
    createdById?: StringNullableFilter<"RecipeBook"> | string | null
    editedById?: StringNullableFilter<"RecipeBook"> | string | null
  }

  export type RecipeBookUpsertWithWhereUniqueWithoutEditedByInput = {
    where: RecipeBookWhereUniqueInput
    update: XOR<RecipeBookUpdateWithoutEditedByInput, RecipeBookUncheckedUpdateWithoutEditedByInput>
    create: XOR<RecipeBookCreateWithoutEditedByInput, RecipeBookUncheckedCreateWithoutEditedByInput>
  }

  export type RecipeBookUpdateWithWhereUniqueWithoutEditedByInput = {
    where: RecipeBookWhereUniqueInput
    data: XOR<RecipeBookUpdateWithoutEditedByInput, RecipeBookUncheckedUpdateWithoutEditedByInput>
  }

  export type RecipeBookUpdateManyWithWhereWithoutEditedByInput = {
    where: RecipeBookScalarWhereInput
    data: XOR<RecipeBookUpdateManyMutationInput, RecipeBookUncheckedUpdateManyWithoutEditedByInput>
  }

  export type RecipeUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: RecipeWhereUniqueInput
    update: XOR<RecipeUpdateWithoutCreatedByInput, RecipeUncheckedUpdateWithoutCreatedByInput>
    create: XOR<RecipeCreateWithoutCreatedByInput, RecipeUncheckedCreateWithoutCreatedByInput>
  }

  export type RecipeUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: RecipeWhereUniqueInput
    data: XOR<RecipeUpdateWithoutCreatedByInput, RecipeUncheckedUpdateWithoutCreatedByInput>
  }

  export type RecipeUpdateManyWithWhereWithoutCreatedByInput = {
    where: RecipeScalarWhereInput
    data: XOR<RecipeUpdateManyMutationInput, RecipeUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type RecipeScalarWhereInput = {
    AND?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
    OR?: RecipeScalarWhereInput[]
    NOT?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
    id?: StringFilter<"Recipe"> | string
    createdAt?: DateTimeFilter<"Recipe"> | Date | string
    editedAt?: DateTimeFilter<"Recipe"> | Date | string
    name?: StringFilter<"Recipe"> | string
    origin?: StringNullableFilter<"Recipe"> | string | null
    history?: StringNullableFilter<"Recipe"> | string | null
    createdById?: StringNullableFilter<"Recipe"> | string | null
    editedById?: StringNullableFilter<"Recipe"> | string | null
  }

  export type RecipeUpsertWithWhereUniqueWithoutEditedByInput = {
    where: RecipeWhereUniqueInput
    update: XOR<RecipeUpdateWithoutEditedByInput, RecipeUncheckedUpdateWithoutEditedByInput>
    create: XOR<RecipeCreateWithoutEditedByInput, RecipeUncheckedCreateWithoutEditedByInput>
  }

  export type RecipeUpdateWithWhereUniqueWithoutEditedByInput = {
    where: RecipeWhereUniqueInput
    data: XOR<RecipeUpdateWithoutEditedByInput, RecipeUncheckedUpdateWithoutEditedByInput>
  }

  export type RecipeUpdateManyWithWhereWithoutEditedByInput = {
    where: RecipeScalarWhereInput
    data: XOR<RecipeUpdateManyMutationInput, RecipeUncheckedUpdateManyWithoutEditedByInput>
  }

  export type BuildUserUpsertWithWhereUniqueWithoutUserInput = {
    where: BuildUserWhereUniqueInput
    update: XOR<BuildUserUpdateWithoutUserInput, BuildUserUncheckedUpdateWithoutUserInput>
    create: XOR<BuildUserCreateWithoutUserInput, BuildUserUncheckedCreateWithoutUserInput>
  }

  export type BuildUserUpdateWithWhereUniqueWithoutUserInput = {
    where: BuildUserWhereUniqueInput
    data: XOR<BuildUserUpdateWithoutUserInput, BuildUserUncheckedUpdateWithoutUserInput>
  }

  export type BuildUserUpdateManyWithWhereWithoutUserInput = {
    where: BuildUserScalarWhereInput
    data: XOR<BuildUserUpdateManyMutationInput, BuildUserUncheckedUpdateManyWithoutUserInput>
  }

  export type BuildUserScalarWhereInput = {
    AND?: BuildUserScalarWhereInput | BuildUserScalarWhereInput[]
    OR?: BuildUserScalarWhereInput[]
    NOT?: BuildUserScalarWhereInput | BuildUserScalarWhereInput[]
    userId?: StringFilter<"BuildUser"> | string
    buildId?: StringFilter<"BuildUser"> | string
    permission?: StringFilter<"BuildUser"> | string
  }

  export type BuildUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: BuildWhereUniqueInput
    update: XOR<BuildUpdateWithoutCreatedByInput, BuildUncheckedUpdateWithoutCreatedByInput>
    create: XOR<BuildCreateWithoutCreatedByInput, BuildUncheckedCreateWithoutCreatedByInput>
  }

  export type BuildUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: BuildWhereUniqueInput
    data: XOR<BuildUpdateWithoutCreatedByInput, BuildUncheckedUpdateWithoutCreatedByInput>
  }

  export type BuildUpdateManyWithWhereWithoutCreatedByInput = {
    where: BuildScalarWhereInput
    data: XOR<BuildUpdateManyMutationInput, BuildUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type BuildScalarWhereInput = {
    AND?: BuildScalarWhereInput | BuildScalarWhereInput[]
    OR?: BuildScalarWhereInput[]
    NOT?: BuildScalarWhereInput | BuildScalarWhereInput[]
    id?: StringFilter<"Build"> | string
    buildName?: StringFilter<"Build"> | string
    createdAt?: DateTimeFilter<"Build"> | Date | string
    editedAt?: DateTimeFilter<"Build"> | Date | string
    createdById?: StringNullableFilter<"Build"> | string | null
    editedById?: StringNullableFilter<"Build"> | string | null
    recipeId?: StringNullableFilter<"Build"> | string | null
    instructions?: StringNullableFilter<"Build"> | string | null
    notes?: StringNullableFilter<"Build"> | string | null
    glassware?: StringNullableFilter<"Build"> | string | null
    ice?: StringNullableFilter<"Build"> | string | null
    version?: IntFilter<"Build"> | number
  }

  export type BuildUpsertWithWhereUniqueWithoutEditedByInput = {
    where: BuildWhereUniqueInput
    update: XOR<BuildUpdateWithoutEditedByInput, BuildUncheckedUpdateWithoutEditedByInput>
    create: XOR<BuildCreateWithoutEditedByInput, BuildUncheckedCreateWithoutEditedByInput>
  }

  export type BuildUpdateWithWhereUniqueWithoutEditedByInput = {
    where: BuildWhereUniqueInput
    data: XOR<BuildUpdateWithoutEditedByInput, BuildUncheckedUpdateWithoutEditedByInput>
  }

  export type BuildUpdateManyWithWhereWithoutEditedByInput = {
    where: BuildScalarWhereInput
    data: XOR<BuildUpdateManyMutationInput, BuildUncheckedUpdateManyWithoutEditedByInput>
  }

  export type ArchivedBuildUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ArchivedBuildWhereUniqueInput
    update: XOR<ArchivedBuildUpdateWithoutCreatedByInput, ArchivedBuildUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ArchivedBuildCreateWithoutCreatedByInput, ArchivedBuildUncheckedCreateWithoutCreatedByInput>
  }

  export type ArchivedBuildUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ArchivedBuildWhereUniqueInput
    data: XOR<ArchivedBuildUpdateWithoutCreatedByInput, ArchivedBuildUncheckedUpdateWithoutCreatedByInput>
  }

  export type ArchivedBuildUpdateManyWithWhereWithoutCreatedByInput = {
    where: ArchivedBuildScalarWhereInput
    data: XOR<ArchivedBuildUpdateManyMutationInput, ArchivedBuildUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ArchivedBuildScalarWhereInput = {
    AND?: ArchivedBuildScalarWhereInput | ArchivedBuildScalarWhereInput[]
    OR?: ArchivedBuildScalarWhereInput[]
    NOT?: ArchivedBuildScalarWhereInput | ArchivedBuildScalarWhereInput[]
    id?: StringFilter<"ArchivedBuild"> | string
    buildName?: StringFilter<"ArchivedBuild"> | string
    createdAt?: DateTimeFilter<"ArchivedBuild"> | Date | string
    createdById?: StringNullableFilter<"ArchivedBuild"> | string | null
    buildId?: StringFilter<"ArchivedBuild"> | string
    recipeId?: StringNullableFilter<"ArchivedBuild"> | string | null
    instructions?: StringNullableFilter<"ArchivedBuild"> | string | null
    notes?: StringNullableFilter<"ArchivedBuild"> | string | null
    glassware?: StringNullableFilter<"ArchivedBuild"> | string | null
    ice?: StringNullableFilter<"ArchivedBuild"> | string | null
    version?: IntFilter<"ArchivedBuild"> | number
  }

  export type CrewUserUpsertWithWhereUniqueWithoutUserInput = {
    where: CrewUserWhereUniqueInput
    update: XOR<CrewUserUpdateWithoutUserInput, CrewUserUncheckedUpdateWithoutUserInput>
    create: XOR<CrewUserCreateWithoutUserInput, CrewUserUncheckedCreateWithoutUserInput>
  }

  export type CrewUserUpdateWithWhereUniqueWithoutUserInput = {
    where: CrewUserWhereUniqueInput
    data: XOR<CrewUserUpdateWithoutUserInput, CrewUserUncheckedUpdateWithoutUserInput>
  }

  export type CrewUserUpdateManyWithWhereWithoutUserInput = {
    where: CrewUserScalarWhereInput
    data: XOR<CrewUserUpdateManyMutationInput, CrewUserUncheckedUpdateManyWithoutUserInput>
  }

  export type CrewUserScalarWhereInput = {
    AND?: CrewUserScalarWhereInput | CrewUserScalarWhereInput[]
    OR?: CrewUserScalarWhereInput[]
    NOT?: CrewUserScalarWhereInput | CrewUserScalarWhereInput[]
    userId?: StringFilter<"CrewUser"> | string
    crewId?: StringFilter<"CrewUser"> | string
    permission?: StringFilter<"CrewUser"> | string
  }

  export type CrewUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: CrewWhereUniqueInput
    update: XOR<CrewUpdateWithoutCreatedByInput, CrewUncheckedUpdateWithoutCreatedByInput>
    create: XOR<CrewCreateWithoutCreatedByInput, CrewUncheckedCreateWithoutCreatedByInput>
  }

  export type CrewUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: CrewWhereUniqueInput
    data: XOR<CrewUpdateWithoutCreatedByInput, CrewUncheckedUpdateWithoutCreatedByInput>
  }

  export type CrewUpdateManyWithWhereWithoutCreatedByInput = {
    where: CrewScalarWhereInput
    data: XOR<CrewUpdateManyMutationInput, CrewUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type CrewScalarWhereInput = {
    AND?: CrewScalarWhereInput | CrewScalarWhereInput[]
    OR?: CrewScalarWhereInput[]
    NOT?: CrewScalarWhereInput | CrewScalarWhereInput[]
    id?: StringFilter<"Crew"> | string
    name?: StringFilter<"Crew"> | string
    description?: StringFilter<"Crew"> | string
    createdAt?: DateTimeFilter<"Crew"> | Date | string
    editedAt?: DateTimeFilter<"Crew"> | Date | string
    createdById?: StringFilter<"Crew"> | string
    editedById?: StringFilter<"Crew"> | string
  }

  export type CrewUpsertWithWhereUniqueWithoutEditedByInput = {
    where: CrewWhereUniqueInput
    update: XOR<CrewUpdateWithoutEditedByInput, CrewUncheckedUpdateWithoutEditedByInput>
    create: XOR<CrewCreateWithoutEditedByInput, CrewUncheckedCreateWithoutEditedByInput>
  }

  export type CrewUpdateWithWhereUniqueWithoutEditedByInput = {
    where: CrewWhereUniqueInput
    data: XOR<CrewUpdateWithoutEditedByInput, CrewUncheckedUpdateWithoutEditedByInput>
  }

  export type CrewUpdateManyWithWhereWithoutEditedByInput = {
    where: CrewScalarWhereInput
    data: XOR<CrewUpdateManyMutationInput, CrewUncheckedUpdateManyWithoutEditedByInput>
  }

  export type IngredientUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: IngredientWhereUniqueInput
    update: XOR<IngredientUpdateWithoutCreatedByInput, IngredientUncheckedUpdateWithoutCreatedByInput>
    create: XOR<IngredientCreateWithoutCreatedByInput, IngredientUncheckedCreateWithoutCreatedByInput>
  }

  export type IngredientUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: IngredientWhereUniqueInput
    data: XOR<IngredientUpdateWithoutCreatedByInput, IngredientUncheckedUpdateWithoutCreatedByInput>
  }

  export type IngredientUpdateManyWithWhereWithoutCreatedByInput = {
    where: IngredientScalarWhereInput
    data: XOR<IngredientUpdateManyMutationInput, IngredientUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type IngredientScalarWhereInput = {
    AND?: IngredientScalarWhereInput | IngredientScalarWhereInput[]
    OR?: IngredientScalarWhereInput[]
    NOT?: IngredientScalarWhereInput | IngredientScalarWhereInput[]
    id?: StringFilter<"Ingredient"> | string
    dateCreated?: DateTimeFilter<"Ingredient"> | Date | string
    createdById?: StringNullableFilter<"Ingredient"> | string | null
    ingredientTypeId?: StringFilter<"Ingredient"> | string
    name?: StringFilter<"Ingredient"> | string
    description?: StringFilter<"Ingredient"> | string
    price?: FloatNullableFilter<"Ingredient"> | number | null
    amount?: FloatNullableFilter<"Ingredient"> | number | null
    unit?: StringNullableFilter<"Ingredient"> | string | null
    source?: StringNullableFilter<"Ingredient"> | string | null
  }

  export type IngredientPreferenceUpsertWithWhereUniqueWithoutUserInput = {
    where: IngredientPreferenceWhereUniqueInput
    update: XOR<IngredientPreferenceUpdateWithoutUserInput, IngredientPreferenceUncheckedUpdateWithoutUserInput>
    create: XOR<IngredientPreferenceCreateWithoutUserInput, IngredientPreferenceUncheckedCreateWithoutUserInput>
  }

  export type IngredientPreferenceUpdateWithWhereUniqueWithoutUserInput = {
    where: IngredientPreferenceWhereUniqueInput
    data: XOR<IngredientPreferenceUpdateWithoutUserInput, IngredientPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type IngredientPreferenceUpdateManyWithWhereWithoutUserInput = {
    where: IngredientPreferenceScalarWhereInput
    data: XOR<IngredientPreferenceUpdateManyMutationInput, IngredientPreferenceUncheckedUpdateManyWithoutUserInput>
  }

  export type IngredientPreferenceScalarWhereInput = {
    AND?: IngredientPreferenceScalarWhereInput | IngredientPreferenceScalarWhereInput[]
    OR?: IngredientPreferenceScalarWhereInput[]
    NOT?: IngredientPreferenceScalarWhereInput | IngredientPreferenceScalarWhereInput[]
    ingredientTypeId?: StringFilter<"IngredientPreference"> | string
    ingredientId?: StringFilter<"IngredientPreference"> | string
    userId?: StringFilter<"IngredientPreference"> | string
  }

  export type IngredientUserUpsertWithWhereUniqueWithoutUserInput = {
    where: IngredientUserWhereUniqueInput
    update: XOR<IngredientUserUpdateWithoutUserInput, IngredientUserUncheckedUpdateWithoutUserInput>
    create: XOR<IngredientUserCreateWithoutUserInput, IngredientUserUncheckedCreateWithoutUserInput>
  }

  export type IngredientUserUpdateWithWhereUniqueWithoutUserInput = {
    where: IngredientUserWhereUniqueInput
    data: XOR<IngredientUserUpdateWithoutUserInput, IngredientUserUncheckedUpdateWithoutUserInput>
  }

  export type IngredientUserUpdateManyWithWhereWithoutUserInput = {
    where: IngredientUserScalarWhereInput
    data: XOR<IngredientUserUpdateManyMutationInput, IngredientUserUncheckedUpdateManyWithoutUserInput>
  }

  export type IngredientUserScalarWhereInput = {
    AND?: IngredientUserScalarWhereInput | IngredientUserScalarWhereInput[]
    OR?: IngredientUserScalarWhereInput[]
    NOT?: IngredientUserScalarWhereInput | IngredientUserScalarWhereInput[]
    ingredientId?: StringFilter<"IngredientUser"> | string
    userId?: StringFilter<"IngredientUser"> | string
    permission?: StringFilter<"IngredientUser"> | string
  }

  export type StorageUserUpsertWithWhereUniqueWithoutUserInput = {
    where: StorageUserWhereUniqueInput
    update: XOR<StorageUserUpdateWithoutUserInput, StorageUserUncheckedUpdateWithoutUserInput>
    create: XOR<StorageUserCreateWithoutUserInput, StorageUserUncheckedCreateWithoutUserInput>
  }

  export type StorageUserUpdateWithWhereUniqueWithoutUserInput = {
    where: StorageUserWhereUniqueInput
    data: XOR<StorageUserUpdateWithoutUserInput, StorageUserUncheckedUpdateWithoutUserInput>
  }

  export type StorageUserUpdateManyWithWhereWithoutUserInput = {
    where: StorageUserScalarWhereInput
    data: XOR<StorageUserUpdateManyMutationInput, StorageUserUncheckedUpdateManyWithoutUserInput>
  }

  export type StorageUserScalarWhereInput = {
    AND?: StorageUserScalarWhereInput | StorageUserScalarWhereInput[]
    OR?: StorageUserScalarWhereInput[]
    NOT?: StorageUserScalarWhereInput | StorageUserScalarWhereInput[]
    userId?: StringFilter<"StorageUser"> | string
    storageId?: StringFilter<"StorageUser"> | string
    permission?: StringFilter<"StorageUser"> | string
  }

  export type StorageUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: StorageWhereUniqueInput
    update: XOR<StorageUpdateWithoutCreatedByInput, StorageUncheckedUpdateWithoutCreatedByInput>
    create: XOR<StorageCreateWithoutCreatedByInput, StorageUncheckedCreateWithoutCreatedByInput>
  }

  export type StorageUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: StorageWhereUniqueInput
    data: XOR<StorageUpdateWithoutCreatedByInput, StorageUncheckedUpdateWithoutCreatedByInput>
  }

  export type StorageUpdateManyWithWhereWithoutCreatedByInput = {
    where: StorageScalarWhereInput
    data: XOR<StorageUpdateManyMutationInput, StorageUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type StorageScalarWhereInput = {
    AND?: StorageScalarWhereInput | StorageScalarWhereInput[]
    OR?: StorageScalarWhereInput[]
    NOT?: StorageScalarWhereInput | StorageScalarWhereInput[]
    id?: StringFilter<"Storage"> | string
    name?: StringFilter<"Storage"> | string
    description?: StringFilter<"Storage"> | string
    createdAt?: DateTimeFilter<"Storage"> | Date | string
    editedAt?: DateTimeFilter<"Storage"> | Date | string
    createdById?: StringFilter<"Storage"> | string
    editedById?: StringFilter<"Storage"> | string
  }

  export type StorageUpsertWithWhereUniqueWithoutEditedByInput = {
    where: StorageWhereUniqueInput
    update: XOR<StorageUpdateWithoutEditedByInput, StorageUncheckedUpdateWithoutEditedByInput>
    create: XOR<StorageCreateWithoutEditedByInput, StorageUncheckedCreateWithoutEditedByInput>
  }

  export type StorageUpdateWithWhereUniqueWithoutEditedByInput = {
    where: StorageWhereUniqueInput
    data: XOR<StorageUpdateWithoutEditedByInput, StorageUncheckedUpdateWithoutEditedByInput>
  }

  export type StorageUpdateManyWithWhereWithoutEditedByInput = {
    where: StorageScalarWhereInput
    data: XOR<StorageUpdateManyMutationInput, StorageUncheckedUpdateManyWithoutEditedByInput>
  }

  export type InventoryUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: InventoryWhereUniqueInput
    update: XOR<InventoryUpdateWithoutCreatedByInput, InventoryUncheckedUpdateWithoutCreatedByInput>
    create: XOR<InventoryCreateWithoutCreatedByInput, InventoryUncheckedCreateWithoutCreatedByInput>
  }

  export type InventoryUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: InventoryWhereUniqueInput
    data: XOR<InventoryUpdateWithoutCreatedByInput, InventoryUncheckedUpdateWithoutCreatedByInput>
  }

  export type InventoryUpdateManyWithWhereWithoutCreatedByInput = {
    where: InventoryScalarWhereInput
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type InventoryScalarWhereInput = {
    AND?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
    OR?: InventoryScalarWhereInput[]
    NOT?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
    id?: StringFilter<"Inventory"> | string
    name?: StringFilter<"Inventory"> | string
    description?: StringFilter<"Inventory"> | string
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    editedAt?: DateTimeFilter<"Inventory"> | Date | string
    createdById?: StringFilter<"Inventory"> | string
    editedById?: StringFilter<"Inventory"> | string
  }

  export type InventoryUpsertWithWhereUniqueWithoutEditedByInput = {
    where: InventoryWhereUniqueInput
    update: XOR<InventoryUpdateWithoutEditedByInput, InventoryUncheckedUpdateWithoutEditedByInput>
    create: XOR<InventoryCreateWithoutEditedByInput, InventoryUncheckedCreateWithoutEditedByInput>
  }

  export type InventoryUpdateWithWhereUniqueWithoutEditedByInput = {
    where: InventoryWhereUniqueInput
    data: XOR<InventoryUpdateWithoutEditedByInput, InventoryUncheckedUpdateWithoutEditedByInput>
  }

  export type InventoryUpdateManyWithWhereWithoutEditedByInput = {
    where: InventoryScalarWhereInput
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyWithoutEditedByInput>
  }

  export type InventoryUserUpsertWithWhereUniqueWithoutUserInput = {
    where: InventoryUserWhereUniqueInput
    update: XOR<InventoryUserUpdateWithoutUserInput, InventoryUserUncheckedUpdateWithoutUserInput>
    create: XOR<InventoryUserCreateWithoutUserInput, InventoryUserUncheckedCreateWithoutUserInput>
  }

  export type InventoryUserUpdateWithWhereUniqueWithoutUserInput = {
    where: InventoryUserWhereUniqueInput
    data: XOR<InventoryUserUpdateWithoutUserInput, InventoryUserUncheckedUpdateWithoutUserInput>
  }

  export type InventoryUserUpdateManyWithWhereWithoutUserInput = {
    where: InventoryUserScalarWhereInput
    data: XOR<InventoryUserUpdateManyMutationInput, InventoryUserUncheckedUpdateManyWithoutUserInput>
  }

  export type InventoryUserScalarWhereInput = {
    AND?: InventoryUserScalarWhereInput | InventoryUserScalarWhereInput[]
    OR?: InventoryUserScalarWhereInput[]
    NOT?: InventoryUserScalarWhereInput | InventoryUserScalarWhereInput[]
    userId?: StringFilter<"InventoryUser"> | string
    inventoryId?: StringFilter<"InventoryUser"> | string
    permission?: StringFilter<"InventoryUser"> | string
  }

  export type FollowUpsertWithWhereUniqueWithoutFollowedByInput = {
    where: FollowWhereUniqueInput
    update: XOR<FollowUpdateWithoutFollowedByInput, FollowUncheckedUpdateWithoutFollowedByInput>
    create: XOR<FollowCreateWithoutFollowedByInput, FollowUncheckedCreateWithoutFollowedByInput>
  }

  export type FollowUpdateWithWhereUniqueWithoutFollowedByInput = {
    where: FollowWhereUniqueInput
    data: XOR<FollowUpdateWithoutFollowedByInput, FollowUncheckedUpdateWithoutFollowedByInput>
  }

  export type FollowUpdateManyWithWhereWithoutFollowedByInput = {
    where: FollowScalarWhereInput
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyWithoutFollowedByInput>
  }

  export type FollowScalarWhereInput = {
    AND?: FollowScalarWhereInput | FollowScalarWhereInput[]
    OR?: FollowScalarWhereInput[]
    NOT?: FollowScalarWhereInput | FollowScalarWhereInput[]
    followedById?: StringFilter<"Follow"> | string
    followingId?: StringFilter<"Follow"> | string
    relationship?: StringFilter<"Follow"> | string
  }

  export type FollowUpsertWithWhereUniqueWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    update: XOR<FollowUpdateWithoutFollowingInput, FollowUncheckedUpdateWithoutFollowingInput>
    create: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput>
  }

  export type FollowUpdateWithWhereUniqueWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    data: XOR<FollowUpdateWithoutFollowingInput, FollowUncheckedUpdateWithoutFollowingInput>
  }

  export type FollowUpdateManyWithWhereWithoutFollowingInput = {
    where: FollowScalarWhereInput
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyWithoutFollowingInput>
  }

  export type UserCreateWithoutFollowedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutFollowedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutFollowedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowedByInput, UserUncheckedCreateWithoutFollowedByInput>
  }

  export type UserCreateWithoutFollowingInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
  }

  export type UserUncheckedCreateWithoutFollowingInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
  }

  export type UserCreateOrConnectWithoutFollowingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
  }

  export type UserUpsertWithoutFollowedByInput = {
    update: XOR<UserUpdateWithoutFollowedByInput, UserUncheckedUpdateWithoutFollowedByInput>
    create: XOR<UserCreateWithoutFollowedByInput, UserUncheckedCreateWithoutFollowedByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFollowedByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFollowedByInput, UserUncheckedUpdateWithoutFollowedByInput>
  }

  export type UserUpdateWithoutFollowedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type UserUpsertWithoutFollowingInput = {
    update: XOR<UserUpdateWithoutFollowingInput, UserUncheckedUpdateWithoutFollowingInput>
    create: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFollowingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFollowingInput, UserUncheckedUpdateWithoutFollowingInput>
  }

  export type UserUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
  }

  export type UserCreateWithoutProfileInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type UserCreateWithoutRecipeBookInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutRecipeBookInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutRecipeBookInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecipeBookInput, UserUncheckedCreateWithoutRecipeBookInput>
  }

  export type UserCreateWithoutRecipeBookEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutRecipeBookEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutRecipeBookEditedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecipeBookEditedByInput, UserUncheckedCreateWithoutRecipeBookEditedByInput>
  }

  export type RecipeBookBuildCreateWithoutRecipeBookInput = {
    build: BuildCreateNestedOneWithoutRecipeBookBuildInput
  }

  export type RecipeBookBuildUncheckedCreateWithoutRecipeBookInput = {
    buildId: string
  }

  export type RecipeBookBuildCreateOrConnectWithoutRecipeBookInput = {
    where: RecipeBookBuildWhereUniqueInput
    create: XOR<RecipeBookBuildCreateWithoutRecipeBookInput, RecipeBookBuildUncheckedCreateWithoutRecipeBookInput>
  }

  export type RecipeBookBuildCreateManyRecipeBookInputEnvelope = {
    data: RecipeBookBuildCreateManyRecipeBookInput | RecipeBookBuildCreateManyRecipeBookInput[]
    skipDuplicates?: boolean
  }

  export type RecipeBookUserCreateWithoutRecipeBookInput = {
    permission: string
    user: UserCreateNestedOneWithoutRecipeBookUserInput
  }

  export type RecipeBookUserUncheckedCreateWithoutRecipeBookInput = {
    userId: string
    permission: string
  }

  export type RecipeBookUserCreateOrConnectWithoutRecipeBookInput = {
    where: RecipeBookUserWhereUniqueInput
    create: XOR<RecipeBookUserCreateWithoutRecipeBookInput, RecipeBookUserUncheckedCreateWithoutRecipeBookInput>
  }

  export type RecipeBookUserCreateManyRecipeBookInputEnvelope = {
    data: RecipeBookUserCreateManyRecipeBookInput | RecipeBookUserCreateManyRecipeBookInput[]
    skipDuplicates?: boolean
  }

  export type CrewRecipeBookCreateWithoutRecipeBookInput = {
    crew: CrewCreateNestedOneWithoutCrewRecipeBookInput
  }

  export type CrewRecipeBookUncheckedCreateWithoutRecipeBookInput = {
    crewId: string
  }

  export type CrewRecipeBookCreateOrConnectWithoutRecipeBookInput = {
    where: CrewRecipeBookWhereUniqueInput
    create: XOR<CrewRecipeBookCreateWithoutRecipeBookInput, CrewRecipeBookUncheckedCreateWithoutRecipeBookInput>
  }

  export type CrewRecipeBookCreateManyRecipeBookInputEnvelope = {
    data: CrewRecipeBookCreateManyRecipeBookInput | CrewRecipeBookCreateManyRecipeBookInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutRecipeBookInput = {
    update: XOR<UserUpdateWithoutRecipeBookInput, UserUncheckedUpdateWithoutRecipeBookInput>
    create: XOR<UserCreateWithoutRecipeBookInput, UserUncheckedCreateWithoutRecipeBookInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRecipeBookInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRecipeBookInput, UserUncheckedUpdateWithoutRecipeBookInput>
  }

  export type UserUpdateWithoutRecipeBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutRecipeBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type UserUpsertWithoutRecipeBookEditedByInput = {
    update: XOR<UserUpdateWithoutRecipeBookEditedByInput, UserUncheckedUpdateWithoutRecipeBookEditedByInput>
    create: XOR<UserCreateWithoutRecipeBookEditedByInput, UserUncheckedCreateWithoutRecipeBookEditedByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRecipeBookEditedByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRecipeBookEditedByInput, UserUncheckedUpdateWithoutRecipeBookEditedByInput>
  }

  export type UserUpdateWithoutRecipeBookEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutRecipeBookEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type RecipeBookBuildUpsertWithWhereUniqueWithoutRecipeBookInput = {
    where: RecipeBookBuildWhereUniqueInput
    update: XOR<RecipeBookBuildUpdateWithoutRecipeBookInput, RecipeBookBuildUncheckedUpdateWithoutRecipeBookInput>
    create: XOR<RecipeBookBuildCreateWithoutRecipeBookInput, RecipeBookBuildUncheckedCreateWithoutRecipeBookInput>
  }

  export type RecipeBookBuildUpdateWithWhereUniqueWithoutRecipeBookInput = {
    where: RecipeBookBuildWhereUniqueInput
    data: XOR<RecipeBookBuildUpdateWithoutRecipeBookInput, RecipeBookBuildUncheckedUpdateWithoutRecipeBookInput>
  }

  export type RecipeBookBuildUpdateManyWithWhereWithoutRecipeBookInput = {
    where: RecipeBookBuildScalarWhereInput
    data: XOR<RecipeBookBuildUpdateManyMutationInput, RecipeBookBuildUncheckedUpdateManyWithoutRecipeBookInput>
  }

  export type RecipeBookBuildScalarWhereInput = {
    AND?: RecipeBookBuildScalarWhereInput | RecipeBookBuildScalarWhereInput[]
    OR?: RecipeBookBuildScalarWhereInput[]
    NOT?: RecipeBookBuildScalarWhereInput | RecipeBookBuildScalarWhereInput[]
    buildId?: StringFilter<"RecipeBookBuild"> | string
    recipeBookId?: StringFilter<"RecipeBookBuild"> | string
  }

  export type RecipeBookUserUpsertWithWhereUniqueWithoutRecipeBookInput = {
    where: RecipeBookUserWhereUniqueInput
    update: XOR<RecipeBookUserUpdateWithoutRecipeBookInput, RecipeBookUserUncheckedUpdateWithoutRecipeBookInput>
    create: XOR<RecipeBookUserCreateWithoutRecipeBookInput, RecipeBookUserUncheckedCreateWithoutRecipeBookInput>
  }

  export type RecipeBookUserUpdateWithWhereUniqueWithoutRecipeBookInput = {
    where: RecipeBookUserWhereUniqueInput
    data: XOR<RecipeBookUserUpdateWithoutRecipeBookInput, RecipeBookUserUncheckedUpdateWithoutRecipeBookInput>
  }

  export type RecipeBookUserUpdateManyWithWhereWithoutRecipeBookInput = {
    where: RecipeBookUserScalarWhereInput
    data: XOR<RecipeBookUserUpdateManyMutationInput, RecipeBookUserUncheckedUpdateManyWithoutRecipeBookInput>
  }

  export type CrewRecipeBookUpsertWithWhereUniqueWithoutRecipeBookInput = {
    where: CrewRecipeBookWhereUniqueInput
    update: XOR<CrewRecipeBookUpdateWithoutRecipeBookInput, CrewRecipeBookUncheckedUpdateWithoutRecipeBookInput>
    create: XOR<CrewRecipeBookCreateWithoutRecipeBookInput, CrewRecipeBookUncheckedCreateWithoutRecipeBookInput>
  }

  export type CrewRecipeBookUpdateWithWhereUniqueWithoutRecipeBookInput = {
    where: CrewRecipeBookWhereUniqueInput
    data: XOR<CrewRecipeBookUpdateWithoutRecipeBookInput, CrewRecipeBookUncheckedUpdateWithoutRecipeBookInput>
  }

  export type CrewRecipeBookUpdateManyWithWhereWithoutRecipeBookInput = {
    where: CrewRecipeBookScalarWhereInput
    data: XOR<CrewRecipeBookUpdateManyMutationInput, CrewRecipeBookUncheckedUpdateManyWithoutRecipeBookInput>
  }

  export type CrewRecipeBookScalarWhereInput = {
    AND?: CrewRecipeBookScalarWhereInput | CrewRecipeBookScalarWhereInput[]
    OR?: CrewRecipeBookScalarWhereInput[]
    NOT?: CrewRecipeBookScalarWhereInput | CrewRecipeBookScalarWhereInput[]
    recipeBookId?: StringFilter<"CrewRecipeBook"> | string
    crewId?: StringFilter<"CrewRecipeBook"> | string
  }

  export type RecipeBookCreateWithoutRecipeBookUserInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutRecipeBookInput
    editedBy?: UserCreateNestedOneWithoutRecipeBookEditedByInput
    recipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutRecipeBookInput
    crewRecipeBook?: CrewRecipeBookCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookUncheckedCreateWithoutRecipeBookUserInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    editedById?: string | null
    recipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutRecipeBookInput
    crewRecipeBook?: CrewRecipeBookUncheckedCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookCreateOrConnectWithoutRecipeBookUserInput = {
    where: RecipeBookWhereUniqueInput
    create: XOR<RecipeBookCreateWithoutRecipeBookUserInput, RecipeBookUncheckedCreateWithoutRecipeBookUserInput>
  }

  export type UserCreateWithoutRecipeBookUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutRecipeBookUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutRecipeBookUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecipeBookUserInput, UserUncheckedCreateWithoutRecipeBookUserInput>
  }

  export type RecipeBookUpsertWithoutRecipeBookUserInput = {
    update: XOR<RecipeBookUpdateWithoutRecipeBookUserInput, RecipeBookUncheckedUpdateWithoutRecipeBookUserInput>
    create: XOR<RecipeBookCreateWithoutRecipeBookUserInput, RecipeBookUncheckedCreateWithoutRecipeBookUserInput>
    where?: RecipeBookWhereInput
  }

  export type RecipeBookUpdateToOneWithWhereWithoutRecipeBookUserInput = {
    where?: RecipeBookWhereInput
    data: XOR<RecipeBookUpdateWithoutRecipeBookUserInput, RecipeBookUncheckedUpdateWithoutRecipeBookUserInput>
  }

  export type RecipeBookUpdateWithoutRecipeBookUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutRecipeBookNestedInput
    editedBy?: UserUpdateOneWithoutRecipeBookEditedByNestedInput
    recipeBookBuild?: RecipeBookBuildUpdateManyWithoutRecipeBookNestedInput
    crewRecipeBook?: CrewRecipeBookUpdateManyWithoutRecipeBookNestedInput
  }

  export type RecipeBookUncheckedUpdateWithoutRecipeBookUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutRecipeBookNestedInput
    crewRecipeBook?: CrewRecipeBookUncheckedUpdateManyWithoutRecipeBookNestedInput
  }

  export type UserUpsertWithoutRecipeBookUserInput = {
    update: XOR<UserUpdateWithoutRecipeBookUserInput, UserUncheckedUpdateWithoutRecipeBookUserInput>
    create: XOR<UserCreateWithoutRecipeBookUserInput, UserUncheckedCreateWithoutRecipeBookUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRecipeBookUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRecipeBookUserInput, UserUncheckedUpdateWithoutRecipeBookUserInput>
  }

  export type UserUpdateWithoutRecipeBookUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutRecipeBookUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type UserCreateWithoutBuildInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutBuildInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutBuildInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBuildInput, UserUncheckedCreateWithoutBuildInput>
  }

  export type UserCreateWithoutBuildEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutBuildEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutBuildEditedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBuildEditedByInput, UserUncheckedCreateWithoutBuildEditedByInput>
  }

  export type RecipeCreateWithoutBuildInput = {
    id?: string
    createdAt?: Date | string
    editedAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    createdBy?: UserCreateNestedOneWithoutRecipeInput
    editedBy?: UserCreateNestedOneWithoutRecipeEditedByInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutBuildInput = {
    id?: string
    createdAt?: Date | string
    editedAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    createdById?: string | null
    editedById?: string | null
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutBuildInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutBuildInput, RecipeUncheckedCreateWithoutBuildInput>
  }

  export type TouchCreateWithoutBuildInput = {
    id?: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    version?: number | null
    ingredientType: IngredientTypeCreateNestedOneWithoutTouchInput
    ingredient?: IngredientCreateNestedOneWithoutTouchInput
  }

  export type TouchUncheckedCreateWithoutBuildInput = {
    id?: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    ingredientTypeId: string
    ingredientId?: string | null
    version?: number | null
  }

  export type TouchCreateOrConnectWithoutBuildInput = {
    where: TouchWhereUniqueInput
    create: XOR<TouchCreateWithoutBuildInput, TouchUncheckedCreateWithoutBuildInput>
  }

  export type TouchCreateManyBuildInputEnvelope = {
    data: TouchCreateManyBuildInput | TouchCreateManyBuildInput[]
    skipDuplicates?: boolean
  }

  export type ArchivedBuildCreateWithoutBuildInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version: number
    createdBy?: UserCreateNestedOneWithoutArchivedBuildInput
    recipe?: RecipeCreateNestedOneWithoutArchivedBuildInput
    archivedTouch?: ArchivedTouchCreateNestedManyWithoutArchivedBuildInput
  }

  export type ArchivedBuildUncheckedCreateWithoutBuildInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    createdById?: string | null
    recipeId?: string | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version: number
    archivedTouch?: ArchivedTouchUncheckedCreateNestedManyWithoutArchivedBuildInput
  }

  export type ArchivedBuildCreateOrConnectWithoutBuildInput = {
    where: ArchivedBuildWhereUniqueInput
    create: XOR<ArchivedBuildCreateWithoutBuildInput, ArchivedBuildUncheckedCreateWithoutBuildInput>
  }

  export type ArchivedBuildCreateManyBuildInputEnvelope = {
    data: ArchivedBuildCreateManyBuildInput | ArchivedBuildCreateManyBuildInput[]
    skipDuplicates?: boolean
  }

  export type RecipeBookBuildCreateWithoutBuildInput = {
    recipeBook: RecipeBookCreateNestedOneWithoutRecipeBookBuildInput
  }

  export type RecipeBookBuildUncheckedCreateWithoutBuildInput = {
    recipeBookId: string
  }

  export type RecipeBookBuildCreateOrConnectWithoutBuildInput = {
    where: RecipeBookBuildWhereUniqueInput
    create: XOR<RecipeBookBuildCreateWithoutBuildInput, RecipeBookBuildUncheckedCreateWithoutBuildInput>
  }

  export type RecipeBookBuildCreateManyBuildInputEnvelope = {
    data: RecipeBookBuildCreateManyBuildInput | RecipeBookBuildCreateManyBuildInput[]
    skipDuplicates?: boolean
  }

  export type BuildUserCreateWithoutBuildInput = {
    permission: string
    user?: UserCreateNestedOneWithoutBuildUserInput
  }

  export type BuildUserUncheckedCreateWithoutBuildInput = {
    userId: string
    permission: string
  }

  export type BuildUserCreateOrConnectWithoutBuildInput = {
    where: BuildUserWhereUniqueInput
    create: XOR<BuildUserCreateWithoutBuildInput, BuildUserUncheckedCreateWithoutBuildInput>
  }

  export type BuildUserCreateManyBuildInputEnvelope = {
    data: BuildUserCreateManyBuildInput | BuildUserCreateManyBuildInput[]
    skipDuplicates?: boolean
  }

  export type CrewBuildCreateWithoutBuildInput = {
    crew: CrewCreateNestedOneWithoutCrewBuildInput
  }

  export type CrewBuildUncheckedCreateWithoutBuildInput = {
    crewId: string
  }

  export type CrewBuildCreateOrConnectWithoutBuildInput = {
    where: CrewBuildWhereUniqueInput
    create: XOR<CrewBuildCreateWithoutBuildInput, CrewBuildUncheckedCreateWithoutBuildInput>
  }

  export type CrewBuildCreateManyBuildInputEnvelope = {
    data: CrewBuildCreateManyBuildInput | CrewBuildCreateManyBuildInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBuildInput = {
    update: XOR<UserUpdateWithoutBuildInput, UserUncheckedUpdateWithoutBuildInput>
    create: XOR<UserCreateWithoutBuildInput, UserUncheckedCreateWithoutBuildInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBuildInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBuildInput, UserUncheckedUpdateWithoutBuildInput>
  }

  export type UserUpdateWithoutBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type UserUpsertWithoutBuildEditedByInput = {
    update: XOR<UserUpdateWithoutBuildEditedByInput, UserUncheckedUpdateWithoutBuildEditedByInput>
    create: XOR<UserCreateWithoutBuildEditedByInput, UserUncheckedCreateWithoutBuildEditedByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBuildEditedByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBuildEditedByInput, UserUncheckedUpdateWithoutBuildEditedByInput>
  }

  export type UserUpdateWithoutBuildEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutBuildEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type RecipeUpsertWithoutBuildInput = {
    update: XOR<RecipeUpdateWithoutBuildInput, RecipeUncheckedUpdateWithoutBuildInput>
    create: XOR<RecipeCreateWithoutBuildInput, RecipeUncheckedCreateWithoutBuildInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutBuildInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutBuildInput, RecipeUncheckedUpdateWithoutBuildInput>
  }

  export type RecipeUpdateWithoutBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutRecipeNestedInput
    editedBy?: UserUpdateOneWithoutRecipeEditedByNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type TouchUpsertWithWhereUniqueWithoutBuildInput = {
    where: TouchWhereUniqueInput
    update: XOR<TouchUpdateWithoutBuildInput, TouchUncheckedUpdateWithoutBuildInput>
    create: XOR<TouchCreateWithoutBuildInput, TouchUncheckedCreateWithoutBuildInput>
  }

  export type TouchUpdateWithWhereUniqueWithoutBuildInput = {
    where: TouchWhereUniqueInput
    data: XOR<TouchUpdateWithoutBuildInput, TouchUncheckedUpdateWithoutBuildInput>
  }

  export type TouchUpdateManyWithWhereWithoutBuildInput = {
    where: TouchScalarWhereInput
    data: XOR<TouchUpdateManyMutationInput, TouchUncheckedUpdateManyWithoutBuildInput>
  }

  export type TouchScalarWhereInput = {
    AND?: TouchScalarWhereInput | TouchScalarWhereInput[]
    OR?: TouchScalarWhereInput[]
    NOT?: TouchScalarWhereInput | TouchScalarWhereInput[]
    id?: StringFilter<"Touch"> | string
    buildId?: StringFilter<"Touch"> | string
    order?: IntNullableFilter<"Touch"> | number | null
    amount?: FloatNullableFilter<"Touch"> | number | null
    unit?: StringNullableFilter<"Touch"> | string | null
    ingredientTypeId?: StringFilter<"Touch"> | string
    ingredientId?: StringNullableFilter<"Touch"> | string | null
    version?: IntNullableFilter<"Touch"> | number | null
  }

  export type ArchivedBuildUpsertWithWhereUniqueWithoutBuildInput = {
    where: ArchivedBuildWhereUniqueInput
    update: XOR<ArchivedBuildUpdateWithoutBuildInput, ArchivedBuildUncheckedUpdateWithoutBuildInput>
    create: XOR<ArchivedBuildCreateWithoutBuildInput, ArchivedBuildUncheckedCreateWithoutBuildInput>
  }

  export type ArchivedBuildUpdateWithWhereUniqueWithoutBuildInput = {
    where: ArchivedBuildWhereUniqueInput
    data: XOR<ArchivedBuildUpdateWithoutBuildInput, ArchivedBuildUncheckedUpdateWithoutBuildInput>
  }

  export type ArchivedBuildUpdateManyWithWhereWithoutBuildInput = {
    where: ArchivedBuildScalarWhereInput
    data: XOR<ArchivedBuildUpdateManyMutationInput, ArchivedBuildUncheckedUpdateManyWithoutBuildInput>
  }

  export type RecipeBookBuildUpsertWithWhereUniqueWithoutBuildInput = {
    where: RecipeBookBuildWhereUniqueInput
    update: XOR<RecipeBookBuildUpdateWithoutBuildInput, RecipeBookBuildUncheckedUpdateWithoutBuildInput>
    create: XOR<RecipeBookBuildCreateWithoutBuildInput, RecipeBookBuildUncheckedCreateWithoutBuildInput>
  }

  export type RecipeBookBuildUpdateWithWhereUniqueWithoutBuildInput = {
    where: RecipeBookBuildWhereUniqueInput
    data: XOR<RecipeBookBuildUpdateWithoutBuildInput, RecipeBookBuildUncheckedUpdateWithoutBuildInput>
  }

  export type RecipeBookBuildUpdateManyWithWhereWithoutBuildInput = {
    where: RecipeBookBuildScalarWhereInput
    data: XOR<RecipeBookBuildUpdateManyMutationInput, RecipeBookBuildUncheckedUpdateManyWithoutBuildInput>
  }

  export type BuildUserUpsertWithWhereUniqueWithoutBuildInput = {
    where: BuildUserWhereUniqueInput
    update: XOR<BuildUserUpdateWithoutBuildInput, BuildUserUncheckedUpdateWithoutBuildInput>
    create: XOR<BuildUserCreateWithoutBuildInput, BuildUserUncheckedCreateWithoutBuildInput>
  }

  export type BuildUserUpdateWithWhereUniqueWithoutBuildInput = {
    where: BuildUserWhereUniqueInput
    data: XOR<BuildUserUpdateWithoutBuildInput, BuildUserUncheckedUpdateWithoutBuildInput>
  }

  export type BuildUserUpdateManyWithWhereWithoutBuildInput = {
    where: BuildUserScalarWhereInput
    data: XOR<BuildUserUpdateManyMutationInput, BuildUserUncheckedUpdateManyWithoutBuildInput>
  }

  export type CrewBuildUpsertWithWhereUniqueWithoutBuildInput = {
    where: CrewBuildWhereUniqueInput
    update: XOR<CrewBuildUpdateWithoutBuildInput, CrewBuildUncheckedUpdateWithoutBuildInput>
    create: XOR<CrewBuildCreateWithoutBuildInput, CrewBuildUncheckedCreateWithoutBuildInput>
  }

  export type CrewBuildUpdateWithWhereUniqueWithoutBuildInput = {
    where: CrewBuildWhereUniqueInput
    data: XOR<CrewBuildUpdateWithoutBuildInput, CrewBuildUncheckedUpdateWithoutBuildInput>
  }

  export type CrewBuildUpdateManyWithWhereWithoutBuildInput = {
    where: CrewBuildScalarWhereInput
    data: XOR<CrewBuildUpdateManyMutationInput, CrewBuildUncheckedUpdateManyWithoutBuildInput>
  }

  export type CrewBuildScalarWhereInput = {
    AND?: CrewBuildScalarWhereInput | CrewBuildScalarWhereInput[]
    OR?: CrewBuildScalarWhereInput[]
    NOT?: CrewBuildScalarWhereInput | CrewBuildScalarWhereInput[]
    buildId?: StringFilter<"CrewBuild"> | string
    crewId?: StringFilter<"CrewBuild"> | string
  }

  export type UserCreateWithoutArchivedBuildInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    crewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutArchivedBuildInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    crewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutArchivedBuildInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutArchivedBuildInput, UserUncheckedCreateWithoutArchivedBuildInput>
  }

  export type BuildCreateWithoutArchivedBuildInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version?: number
    createdBy?: UserCreateNestedOneWithoutBuildInput
    editedBy?: UserCreateNestedOneWithoutBuildEditedByInput
    recipe?: RecipeCreateNestedOneWithoutBuildInput
    touch?: TouchCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserCreateNestedManyWithoutBuildInput
    crewBuild?: CrewBuildCreateNestedManyWithoutBuildInput
  }

  export type BuildUncheckedCreateWithoutArchivedBuildInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    editedById?: string | null
    recipeId?: string | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version?: number
    touch?: TouchUncheckedCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutBuildInput
    crewBuild?: CrewBuildUncheckedCreateNestedManyWithoutBuildInput
  }

  export type BuildCreateOrConnectWithoutArchivedBuildInput = {
    where: BuildWhereUniqueInput
    create: XOR<BuildCreateWithoutArchivedBuildInput, BuildUncheckedCreateWithoutArchivedBuildInput>
  }

  export type RecipeCreateWithoutArchivedBuildInput = {
    id?: string
    createdAt?: Date | string
    editedAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    createdBy?: UserCreateNestedOneWithoutRecipeInput
    editedBy?: UserCreateNestedOneWithoutRecipeEditedByInput
    build?: BuildCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutArchivedBuildInput = {
    id?: string
    createdAt?: Date | string
    editedAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    createdById?: string | null
    editedById?: string | null
    build?: BuildUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutArchivedBuildInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutArchivedBuildInput, RecipeUncheckedCreateWithoutArchivedBuildInput>
  }

  export type ArchivedTouchCreateWithoutArchivedBuildInput = {
    id?: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    version?: number | null
    ingredientType: IngredientTypeCreateNestedOneWithoutArchivedTouchInput
    ingredient?: IngredientCreateNestedOneWithoutArchivedTouchInput
  }

  export type ArchivedTouchUncheckedCreateWithoutArchivedBuildInput = {
    id?: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    ingredientTypeId: string
    ingredientId?: string | null
    version?: number | null
  }

  export type ArchivedTouchCreateOrConnectWithoutArchivedBuildInput = {
    where: ArchivedTouchWhereUniqueInput
    create: XOR<ArchivedTouchCreateWithoutArchivedBuildInput, ArchivedTouchUncheckedCreateWithoutArchivedBuildInput>
  }

  export type ArchivedTouchCreateManyArchivedBuildInputEnvelope = {
    data: ArchivedTouchCreateManyArchivedBuildInput | ArchivedTouchCreateManyArchivedBuildInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutArchivedBuildInput = {
    update: XOR<UserUpdateWithoutArchivedBuildInput, UserUncheckedUpdateWithoutArchivedBuildInput>
    create: XOR<UserCreateWithoutArchivedBuildInput, UserUncheckedCreateWithoutArchivedBuildInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutArchivedBuildInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutArchivedBuildInput, UserUncheckedUpdateWithoutArchivedBuildInput>
  }

  export type UserUpdateWithoutArchivedBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    crewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutArchivedBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    crewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type BuildUpsertWithoutArchivedBuildInput = {
    update: XOR<BuildUpdateWithoutArchivedBuildInput, BuildUncheckedUpdateWithoutArchivedBuildInput>
    create: XOR<BuildCreateWithoutArchivedBuildInput, BuildUncheckedCreateWithoutArchivedBuildInput>
    where?: BuildWhereInput
  }

  export type BuildUpdateToOneWithWhereWithoutArchivedBuildInput = {
    where?: BuildWhereInput
    data: XOR<BuildUpdateWithoutArchivedBuildInput, BuildUncheckedUpdateWithoutArchivedBuildInput>
  }

  export type BuildUpdateWithoutArchivedBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdBy?: UserUpdateOneWithoutBuildNestedInput
    editedBy?: UserUpdateOneWithoutBuildEditedByNestedInput
    recipe?: RecipeUpdateOneWithoutBuildNestedInput
    touch?: TouchUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUpdateManyWithoutBuildNestedInput
    crewBuild?: CrewBuildUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateWithoutArchivedBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeId?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    touch?: TouchUncheckedUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutBuildNestedInput
    crewBuild?: CrewBuildUncheckedUpdateManyWithoutBuildNestedInput
  }

  export type RecipeUpsertWithoutArchivedBuildInput = {
    update: XOR<RecipeUpdateWithoutArchivedBuildInput, RecipeUncheckedUpdateWithoutArchivedBuildInput>
    create: XOR<RecipeCreateWithoutArchivedBuildInput, RecipeUncheckedCreateWithoutArchivedBuildInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutArchivedBuildInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutArchivedBuildInput, RecipeUncheckedUpdateWithoutArchivedBuildInput>
  }

  export type RecipeUpdateWithoutArchivedBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutRecipeNestedInput
    editedBy?: UserUpdateOneWithoutRecipeEditedByNestedInput
    build?: BuildUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutArchivedBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    build?: BuildUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type ArchivedTouchUpsertWithWhereUniqueWithoutArchivedBuildInput = {
    where: ArchivedTouchWhereUniqueInput
    update: XOR<ArchivedTouchUpdateWithoutArchivedBuildInput, ArchivedTouchUncheckedUpdateWithoutArchivedBuildInput>
    create: XOR<ArchivedTouchCreateWithoutArchivedBuildInput, ArchivedTouchUncheckedCreateWithoutArchivedBuildInput>
  }

  export type ArchivedTouchUpdateWithWhereUniqueWithoutArchivedBuildInput = {
    where: ArchivedTouchWhereUniqueInput
    data: XOR<ArchivedTouchUpdateWithoutArchivedBuildInput, ArchivedTouchUncheckedUpdateWithoutArchivedBuildInput>
  }

  export type ArchivedTouchUpdateManyWithWhereWithoutArchivedBuildInput = {
    where: ArchivedTouchScalarWhereInput
    data: XOR<ArchivedTouchUpdateManyMutationInput, ArchivedTouchUncheckedUpdateManyWithoutArchivedBuildInput>
  }

  export type ArchivedTouchScalarWhereInput = {
    AND?: ArchivedTouchScalarWhereInput | ArchivedTouchScalarWhereInput[]
    OR?: ArchivedTouchScalarWhereInput[]
    NOT?: ArchivedTouchScalarWhereInput | ArchivedTouchScalarWhereInput[]
    id?: StringFilter<"ArchivedTouch"> | string
    archivedBuildId?: StringFilter<"ArchivedTouch"> | string
    order?: IntNullableFilter<"ArchivedTouch"> | number | null
    amount?: FloatNullableFilter<"ArchivedTouch"> | number | null
    unit?: StringNullableFilter<"ArchivedTouch"> | string | null
    ingredientTypeId?: StringFilter<"ArchivedTouch"> | string
    ingredientId?: StringNullableFilter<"ArchivedTouch"> | string | null
    version?: IntNullableFilter<"ArchivedTouch"> | number | null
  }

  export type UserCreateWithoutBuildUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutBuildUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutBuildUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBuildUserInput, UserUncheckedCreateWithoutBuildUserInput>
  }

  export type BuildCreateWithoutBuildUserInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version?: number
    createdBy?: UserCreateNestedOneWithoutBuildInput
    editedBy?: UserCreateNestedOneWithoutBuildEditedByInput
    recipe?: RecipeCreateNestedOneWithoutBuildInput
    touch?: TouchCreateNestedManyWithoutBuildInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutBuildInput
    crewBuild?: CrewBuildCreateNestedManyWithoutBuildInput
  }

  export type BuildUncheckedCreateWithoutBuildUserInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    editedById?: string | null
    recipeId?: string | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version?: number
    touch?: TouchUncheckedCreateNestedManyWithoutBuildInput
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutBuildInput
    crewBuild?: CrewBuildUncheckedCreateNestedManyWithoutBuildInput
  }

  export type BuildCreateOrConnectWithoutBuildUserInput = {
    where: BuildWhereUniqueInput
    create: XOR<BuildCreateWithoutBuildUserInput, BuildUncheckedCreateWithoutBuildUserInput>
  }

  export type UserUpsertWithoutBuildUserInput = {
    update: XOR<UserUpdateWithoutBuildUserInput, UserUncheckedUpdateWithoutBuildUserInput>
    create: XOR<UserCreateWithoutBuildUserInput, UserUncheckedCreateWithoutBuildUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBuildUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBuildUserInput, UserUncheckedUpdateWithoutBuildUserInput>
  }

  export type UserUpdateWithoutBuildUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutBuildUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type BuildUpsertWithoutBuildUserInput = {
    update: XOR<BuildUpdateWithoutBuildUserInput, BuildUncheckedUpdateWithoutBuildUserInput>
    create: XOR<BuildCreateWithoutBuildUserInput, BuildUncheckedCreateWithoutBuildUserInput>
    where?: BuildWhereInput
  }

  export type BuildUpdateToOneWithWhereWithoutBuildUserInput = {
    where?: BuildWhereInput
    data: XOR<BuildUpdateWithoutBuildUserInput, BuildUncheckedUpdateWithoutBuildUserInput>
  }

  export type BuildUpdateWithoutBuildUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdBy?: UserUpdateOneWithoutBuildNestedInput
    editedBy?: UserUpdateOneWithoutBuildEditedByNestedInput
    recipe?: RecipeUpdateOneWithoutBuildNestedInput
    touch?: TouchUpdateManyWithoutBuildNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUpdateManyWithoutBuildNestedInput
    crewBuild?: CrewBuildUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateWithoutBuildUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeId?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    touch?: TouchUncheckedUpdateManyWithoutBuildNestedInput
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutBuildNestedInput
    crewBuild?: CrewBuildUncheckedUpdateManyWithoutBuildNestedInput
  }

  export type UserCreateWithoutRecipeInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutRecipeInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutRecipeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecipeInput, UserUncheckedCreateWithoutRecipeInput>
  }

  export type UserCreateWithoutRecipeEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutRecipeEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutRecipeEditedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecipeEditedByInput, UserUncheckedCreateWithoutRecipeEditedByInput>
  }

  export type BuildCreateWithoutRecipeInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version?: number
    createdBy?: UserCreateNestedOneWithoutBuildInput
    editedBy?: UserCreateNestedOneWithoutBuildEditedByInput
    touch?: TouchCreateNestedManyWithoutBuildInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserCreateNestedManyWithoutBuildInput
    crewBuild?: CrewBuildCreateNestedManyWithoutBuildInput
  }

  export type BuildUncheckedCreateWithoutRecipeInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    editedById?: string | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version?: number
    touch?: TouchUncheckedCreateNestedManyWithoutBuildInput
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutBuildInput
    crewBuild?: CrewBuildUncheckedCreateNestedManyWithoutBuildInput
  }

  export type BuildCreateOrConnectWithoutRecipeInput = {
    where: BuildWhereUniqueInput
    create: XOR<BuildCreateWithoutRecipeInput, BuildUncheckedCreateWithoutRecipeInput>
  }

  export type BuildCreateManyRecipeInputEnvelope = {
    data: BuildCreateManyRecipeInput | BuildCreateManyRecipeInput[]
    skipDuplicates?: boolean
  }

  export type ArchivedBuildCreateWithoutRecipeInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version: number
    createdBy?: UserCreateNestedOneWithoutArchivedBuildInput
    build: BuildCreateNestedOneWithoutArchivedBuildInput
    archivedTouch?: ArchivedTouchCreateNestedManyWithoutArchivedBuildInput
  }

  export type ArchivedBuildUncheckedCreateWithoutRecipeInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    createdById?: string | null
    buildId: string
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version: number
    archivedTouch?: ArchivedTouchUncheckedCreateNestedManyWithoutArchivedBuildInput
  }

  export type ArchivedBuildCreateOrConnectWithoutRecipeInput = {
    where: ArchivedBuildWhereUniqueInput
    create: XOR<ArchivedBuildCreateWithoutRecipeInput, ArchivedBuildUncheckedCreateWithoutRecipeInput>
  }

  export type ArchivedBuildCreateManyRecipeInputEnvelope = {
    data: ArchivedBuildCreateManyRecipeInput | ArchivedBuildCreateManyRecipeInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutRecipeInput = {
    update: XOR<UserUpdateWithoutRecipeInput, UserUncheckedUpdateWithoutRecipeInput>
    create: XOR<UserCreateWithoutRecipeInput, UserUncheckedCreateWithoutRecipeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRecipeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRecipeInput, UserUncheckedUpdateWithoutRecipeInput>
  }

  export type UserUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type UserUpsertWithoutRecipeEditedByInput = {
    update: XOR<UserUpdateWithoutRecipeEditedByInput, UserUncheckedUpdateWithoutRecipeEditedByInput>
    create: XOR<UserCreateWithoutRecipeEditedByInput, UserUncheckedCreateWithoutRecipeEditedByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRecipeEditedByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRecipeEditedByInput, UserUncheckedUpdateWithoutRecipeEditedByInput>
  }

  export type UserUpdateWithoutRecipeEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutRecipeEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type BuildUpsertWithWhereUniqueWithoutRecipeInput = {
    where: BuildWhereUniqueInput
    update: XOR<BuildUpdateWithoutRecipeInput, BuildUncheckedUpdateWithoutRecipeInput>
    create: XOR<BuildCreateWithoutRecipeInput, BuildUncheckedCreateWithoutRecipeInput>
  }

  export type BuildUpdateWithWhereUniqueWithoutRecipeInput = {
    where: BuildWhereUniqueInput
    data: XOR<BuildUpdateWithoutRecipeInput, BuildUncheckedUpdateWithoutRecipeInput>
  }

  export type BuildUpdateManyWithWhereWithoutRecipeInput = {
    where: BuildScalarWhereInput
    data: XOR<BuildUpdateManyMutationInput, BuildUncheckedUpdateManyWithoutRecipeInput>
  }

  export type ArchivedBuildUpsertWithWhereUniqueWithoutRecipeInput = {
    where: ArchivedBuildWhereUniqueInput
    update: XOR<ArchivedBuildUpdateWithoutRecipeInput, ArchivedBuildUncheckedUpdateWithoutRecipeInput>
    create: XOR<ArchivedBuildCreateWithoutRecipeInput, ArchivedBuildUncheckedCreateWithoutRecipeInput>
  }

  export type ArchivedBuildUpdateWithWhereUniqueWithoutRecipeInput = {
    where: ArchivedBuildWhereUniqueInput
    data: XOR<ArchivedBuildUpdateWithoutRecipeInput, ArchivedBuildUncheckedUpdateWithoutRecipeInput>
  }

  export type ArchivedBuildUpdateManyWithWhereWithoutRecipeInput = {
    where: ArchivedBuildScalarWhereInput
    data: XOR<ArchivedBuildUpdateManyMutationInput, ArchivedBuildUncheckedUpdateManyWithoutRecipeInput>
  }

  export type RecipeBookCreateWithoutRecipeBookBuildInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutRecipeBookInput
    editedBy?: UserCreateNestedOneWithoutRecipeBookEditedByInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutRecipeBookInput
    crewRecipeBook?: CrewRecipeBookCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookUncheckedCreateWithoutRecipeBookBuildInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    editedById?: string | null
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutRecipeBookInput
    crewRecipeBook?: CrewRecipeBookUncheckedCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookCreateOrConnectWithoutRecipeBookBuildInput = {
    where: RecipeBookWhereUniqueInput
    create: XOR<RecipeBookCreateWithoutRecipeBookBuildInput, RecipeBookUncheckedCreateWithoutRecipeBookBuildInput>
  }

  export type BuildCreateWithoutRecipeBookBuildInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version?: number
    createdBy?: UserCreateNestedOneWithoutBuildInput
    editedBy?: UserCreateNestedOneWithoutBuildEditedByInput
    recipe?: RecipeCreateNestedOneWithoutBuildInput
    touch?: TouchCreateNestedManyWithoutBuildInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserCreateNestedManyWithoutBuildInput
    crewBuild?: CrewBuildCreateNestedManyWithoutBuildInput
  }

  export type BuildUncheckedCreateWithoutRecipeBookBuildInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    editedById?: string | null
    recipeId?: string | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version?: number
    touch?: TouchUncheckedCreateNestedManyWithoutBuildInput
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutBuildInput
    crewBuild?: CrewBuildUncheckedCreateNestedManyWithoutBuildInput
  }

  export type BuildCreateOrConnectWithoutRecipeBookBuildInput = {
    where: BuildWhereUniqueInput
    create: XOR<BuildCreateWithoutRecipeBookBuildInput, BuildUncheckedCreateWithoutRecipeBookBuildInput>
  }

  export type RecipeBookUpsertWithoutRecipeBookBuildInput = {
    update: XOR<RecipeBookUpdateWithoutRecipeBookBuildInput, RecipeBookUncheckedUpdateWithoutRecipeBookBuildInput>
    create: XOR<RecipeBookCreateWithoutRecipeBookBuildInput, RecipeBookUncheckedCreateWithoutRecipeBookBuildInput>
    where?: RecipeBookWhereInput
  }

  export type RecipeBookUpdateToOneWithWhereWithoutRecipeBookBuildInput = {
    where?: RecipeBookWhereInput
    data: XOR<RecipeBookUpdateWithoutRecipeBookBuildInput, RecipeBookUncheckedUpdateWithoutRecipeBookBuildInput>
  }

  export type RecipeBookUpdateWithoutRecipeBookBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutRecipeBookNestedInput
    editedBy?: UserUpdateOneWithoutRecipeBookEditedByNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutRecipeBookNestedInput
    crewRecipeBook?: CrewRecipeBookUpdateManyWithoutRecipeBookNestedInput
  }

  export type RecipeBookUncheckedUpdateWithoutRecipeBookBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutRecipeBookNestedInput
    crewRecipeBook?: CrewRecipeBookUncheckedUpdateManyWithoutRecipeBookNestedInput
  }

  export type BuildUpsertWithoutRecipeBookBuildInput = {
    update: XOR<BuildUpdateWithoutRecipeBookBuildInput, BuildUncheckedUpdateWithoutRecipeBookBuildInput>
    create: XOR<BuildCreateWithoutRecipeBookBuildInput, BuildUncheckedCreateWithoutRecipeBookBuildInput>
    where?: BuildWhereInput
  }

  export type BuildUpdateToOneWithWhereWithoutRecipeBookBuildInput = {
    where?: BuildWhereInput
    data: XOR<BuildUpdateWithoutRecipeBookBuildInput, BuildUncheckedUpdateWithoutRecipeBookBuildInput>
  }

  export type BuildUpdateWithoutRecipeBookBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdBy?: UserUpdateOneWithoutBuildNestedInput
    editedBy?: UserUpdateOneWithoutBuildEditedByNestedInput
    recipe?: RecipeUpdateOneWithoutBuildNestedInput
    touch?: TouchUpdateManyWithoutBuildNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUpdateManyWithoutBuildNestedInput
    crewBuild?: CrewBuildUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateWithoutRecipeBookBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeId?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    touch?: TouchUncheckedUpdateManyWithoutBuildNestedInput
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutBuildNestedInput
    crewBuild?: CrewBuildUncheckedUpdateManyWithoutBuildNestedInput
  }

  export type BuildCreateWithoutTouchInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version?: number
    createdBy?: UserCreateNestedOneWithoutBuildInput
    editedBy?: UserCreateNestedOneWithoutBuildEditedByInput
    recipe?: RecipeCreateNestedOneWithoutBuildInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserCreateNestedManyWithoutBuildInput
    crewBuild?: CrewBuildCreateNestedManyWithoutBuildInput
  }

  export type BuildUncheckedCreateWithoutTouchInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    editedById?: string | null
    recipeId?: string | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version?: number
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutBuildInput
    crewBuild?: CrewBuildUncheckedCreateNestedManyWithoutBuildInput
  }

  export type BuildCreateOrConnectWithoutTouchInput = {
    where: BuildWhereUniqueInput
    create: XOR<BuildCreateWithoutTouchInput, BuildUncheckedCreateWithoutTouchInput>
  }

  export type IngredientTypeCreateWithoutTouchInput = {
    id?: string
    name: string
    description?: string | null
    archivedTouch?: ArchivedTouchCreateNestedManyWithoutIngredientTypeInput
    ingredient?: IngredientCreateNestedManyWithoutIngredientTypeInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutIngredientTypeInput
  }

  export type IngredientTypeUncheckedCreateWithoutTouchInput = {
    id?: string
    name: string
    description?: string | null
    archivedTouch?: ArchivedTouchUncheckedCreateNestedManyWithoutIngredientTypeInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutIngredientTypeInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutIngredientTypeInput
  }

  export type IngredientTypeCreateOrConnectWithoutTouchInput = {
    where: IngredientTypeWhereUniqueInput
    create: XOR<IngredientTypeCreateWithoutTouchInput, IngredientTypeUncheckedCreateWithoutTouchInput>
  }

  export type IngredientCreateWithoutTouchInput = {
    id?: string
    dateCreated?: Date | string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    createdBy?: UserCreateNestedOneWithoutIngredientInput
    ingredientType: IngredientTypeCreateNestedOneWithoutIngredientInput
    archivedTouch?: ArchivedTouchCreateNestedManyWithoutIngredientInput
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutIngredientInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutIngredientInput
    crewIngredient?: CrewIngredientCreateNestedManyWithoutIngredientInput
  }

  export type IngredientUncheckedCreateWithoutTouchInput = {
    id?: string
    dateCreated?: Date | string
    createdById?: string | null
    ingredientTypeId: string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    archivedTouch?: ArchivedTouchUncheckedCreateNestedManyWithoutIngredientInput
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutIngredientInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutIngredientInput
    crewIngredient?: CrewIngredientUncheckedCreateNestedManyWithoutIngredientInput
  }

  export type IngredientCreateOrConnectWithoutTouchInput = {
    where: IngredientWhereUniqueInput
    create: XOR<IngredientCreateWithoutTouchInput, IngredientUncheckedCreateWithoutTouchInput>
  }

  export type BuildUpsertWithoutTouchInput = {
    update: XOR<BuildUpdateWithoutTouchInput, BuildUncheckedUpdateWithoutTouchInput>
    create: XOR<BuildCreateWithoutTouchInput, BuildUncheckedCreateWithoutTouchInput>
    where?: BuildWhereInput
  }

  export type BuildUpdateToOneWithWhereWithoutTouchInput = {
    where?: BuildWhereInput
    data: XOR<BuildUpdateWithoutTouchInput, BuildUncheckedUpdateWithoutTouchInput>
  }

  export type BuildUpdateWithoutTouchInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdBy?: UserUpdateOneWithoutBuildNestedInput
    editedBy?: UserUpdateOneWithoutBuildEditedByNestedInput
    recipe?: RecipeUpdateOneWithoutBuildNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUpdateManyWithoutBuildNestedInput
    crewBuild?: CrewBuildUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateWithoutTouchInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeId?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutBuildNestedInput
    crewBuild?: CrewBuildUncheckedUpdateManyWithoutBuildNestedInput
  }

  export type IngredientTypeUpsertWithoutTouchInput = {
    update: XOR<IngredientTypeUpdateWithoutTouchInput, IngredientTypeUncheckedUpdateWithoutTouchInput>
    create: XOR<IngredientTypeCreateWithoutTouchInput, IngredientTypeUncheckedCreateWithoutTouchInput>
    where?: IngredientTypeWhereInput
  }

  export type IngredientTypeUpdateToOneWithWhereWithoutTouchInput = {
    where?: IngredientTypeWhereInput
    data: XOR<IngredientTypeUpdateWithoutTouchInput, IngredientTypeUncheckedUpdateWithoutTouchInput>
  }

  export type IngredientTypeUpdateWithoutTouchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    archivedTouch?: ArchivedTouchUpdateManyWithoutIngredientTypeNestedInput
    ingredient?: IngredientUpdateManyWithoutIngredientTypeNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutIngredientTypeNestedInput
  }

  export type IngredientTypeUncheckedUpdateWithoutTouchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    archivedTouch?: ArchivedTouchUncheckedUpdateManyWithoutIngredientTypeNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutIngredientTypeNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutIngredientTypeNestedInput
  }

  export type IngredientUpsertWithoutTouchInput = {
    update: XOR<IngredientUpdateWithoutTouchInput, IngredientUncheckedUpdateWithoutTouchInput>
    create: XOR<IngredientCreateWithoutTouchInput, IngredientUncheckedCreateWithoutTouchInput>
    where?: IngredientWhereInput
  }

  export type IngredientUpdateToOneWithWhereWithoutTouchInput = {
    where?: IngredientWhereInput
    data: XOR<IngredientUpdateWithoutTouchInput, IngredientUncheckedUpdateWithoutTouchInput>
  }

  export type IngredientUpdateWithoutTouchInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutIngredientNestedInput
    ingredientType?: IngredientTypeUpdateOneRequiredWithoutIngredientNestedInput
    archivedTouch?: ArchivedTouchUpdateManyWithoutIngredientNestedInput
    ingredientStorage?: IngredientStorageUpdateManyWithoutIngredientNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutIngredientNestedInput
    crewIngredient?: CrewIngredientUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientUncheckedUpdateWithoutTouchInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientTypeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    archivedTouch?: ArchivedTouchUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutIngredientNestedInput
    crewIngredient?: CrewIngredientUncheckedUpdateManyWithoutIngredientNestedInput
  }

  export type ArchivedBuildCreateWithoutArchivedTouchInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version: number
    createdBy?: UserCreateNestedOneWithoutArchivedBuildInput
    build: BuildCreateNestedOneWithoutArchivedBuildInput
    recipe?: RecipeCreateNestedOneWithoutArchivedBuildInput
  }

  export type ArchivedBuildUncheckedCreateWithoutArchivedTouchInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    createdById?: string | null
    buildId: string
    recipeId?: string | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version: number
  }

  export type ArchivedBuildCreateOrConnectWithoutArchivedTouchInput = {
    where: ArchivedBuildWhereUniqueInput
    create: XOR<ArchivedBuildCreateWithoutArchivedTouchInput, ArchivedBuildUncheckedCreateWithoutArchivedTouchInput>
  }

  export type IngredientTypeCreateWithoutArchivedTouchInput = {
    id?: string
    name: string
    description?: string | null
    touch?: TouchCreateNestedManyWithoutIngredientTypeInput
    ingredient?: IngredientCreateNestedManyWithoutIngredientTypeInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutIngredientTypeInput
  }

  export type IngredientTypeUncheckedCreateWithoutArchivedTouchInput = {
    id?: string
    name: string
    description?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutIngredientTypeInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutIngredientTypeInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutIngredientTypeInput
  }

  export type IngredientTypeCreateOrConnectWithoutArchivedTouchInput = {
    where: IngredientTypeWhereUniqueInput
    create: XOR<IngredientTypeCreateWithoutArchivedTouchInput, IngredientTypeUncheckedCreateWithoutArchivedTouchInput>
  }

  export type IngredientCreateWithoutArchivedTouchInput = {
    id?: string
    dateCreated?: Date | string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    createdBy?: UserCreateNestedOneWithoutIngredientInput
    ingredientType: IngredientTypeCreateNestedOneWithoutIngredientInput
    touch?: TouchCreateNestedManyWithoutIngredientInput
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutIngredientInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutIngredientInput
    crewIngredient?: CrewIngredientCreateNestedManyWithoutIngredientInput
  }

  export type IngredientUncheckedCreateWithoutArchivedTouchInput = {
    id?: string
    dateCreated?: Date | string
    createdById?: string | null
    ingredientTypeId: string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutIngredientInput
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutIngredientInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutIngredientInput
    crewIngredient?: CrewIngredientUncheckedCreateNestedManyWithoutIngredientInput
  }

  export type IngredientCreateOrConnectWithoutArchivedTouchInput = {
    where: IngredientWhereUniqueInput
    create: XOR<IngredientCreateWithoutArchivedTouchInput, IngredientUncheckedCreateWithoutArchivedTouchInput>
  }

  export type ArchivedBuildUpsertWithoutArchivedTouchInput = {
    update: XOR<ArchivedBuildUpdateWithoutArchivedTouchInput, ArchivedBuildUncheckedUpdateWithoutArchivedTouchInput>
    create: XOR<ArchivedBuildCreateWithoutArchivedTouchInput, ArchivedBuildUncheckedCreateWithoutArchivedTouchInput>
    where?: ArchivedBuildWhereInput
  }

  export type ArchivedBuildUpdateToOneWithWhereWithoutArchivedTouchInput = {
    where?: ArchivedBuildWhereInput
    data: XOR<ArchivedBuildUpdateWithoutArchivedTouchInput, ArchivedBuildUncheckedUpdateWithoutArchivedTouchInput>
  }

  export type ArchivedBuildUpdateWithoutArchivedTouchInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdBy?: UserUpdateOneWithoutArchivedBuildNestedInput
    build?: BuildUpdateOneRequiredWithoutArchivedBuildNestedInput
    recipe?: RecipeUpdateOneWithoutArchivedBuildNestedInput
  }

  export type ArchivedBuildUncheckedUpdateWithoutArchivedTouchInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    buildId?: StringFieldUpdateOperationsInput | string
    recipeId?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
  }

  export type IngredientTypeUpsertWithoutArchivedTouchInput = {
    update: XOR<IngredientTypeUpdateWithoutArchivedTouchInput, IngredientTypeUncheckedUpdateWithoutArchivedTouchInput>
    create: XOR<IngredientTypeCreateWithoutArchivedTouchInput, IngredientTypeUncheckedCreateWithoutArchivedTouchInput>
    where?: IngredientTypeWhereInput
  }

  export type IngredientTypeUpdateToOneWithWhereWithoutArchivedTouchInput = {
    where?: IngredientTypeWhereInput
    data: XOR<IngredientTypeUpdateWithoutArchivedTouchInput, IngredientTypeUncheckedUpdateWithoutArchivedTouchInput>
  }

  export type IngredientTypeUpdateWithoutArchivedTouchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUpdateManyWithoutIngredientTypeNestedInput
    ingredient?: IngredientUpdateManyWithoutIngredientTypeNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutIngredientTypeNestedInput
  }

  export type IngredientTypeUncheckedUpdateWithoutArchivedTouchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutIngredientTypeNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutIngredientTypeNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutIngredientTypeNestedInput
  }

  export type IngredientUpsertWithoutArchivedTouchInput = {
    update: XOR<IngredientUpdateWithoutArchivedTouchInput, IngredientUncheckedUpdateWithoutArchivedTouchInput>
    create: XOR<IngredientCreateWithoutArchivedTouchInput, IngredientUncheckedCreateWithoutArchivedTouchInput>
    where?: IngredientWhereInput
  }

  export type IngredientUpdateToOneWithWhereWithoutArchivedTouchInput = {
    where?: IngredientWhereInput
    data: XOR<IngredientUpdateWithoutArchivedTouchInput, IngredientUncheckedUpdateWithoutArchivedTouchInput>
  }

  export type IngredientUpdateWithoutArchivedTouchInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutIngredientNestedInput
    ingredientType?: IngredientTypeUpdateOneRequiredWithoutIngredientNestedInput
    touch?: TouchUpdateManyWithoutIngredientNestedInput
    ingredientStorage?: IngredientStorageUpdateManyWithoutIngredientNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutIngredientNestedInput
    crewIngredient?: CrewIngredientUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientUncheckedUpdateWithoutArchivedTouchInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientTypeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutIngredientNestedInput
    crewIngredient?: CrewIngredientUncheckedUpdateManyWithoutIngredientNestedInput
  }

  export type TouchCreateWithoutIngredientTypeInput = {
    id?: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    version?: number | null
    build: BuildCreateNestedOneWithoutTouchInput
    ingredient?: IngredientCreateNestedOneWithoutTouchInput
  }

  export type TouchUncheckedCreateWithoutIngredientTypeInput = {
    id?: string
    buildId: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    ingredientId?: string | null
    version?: number | null
  }

  export type TouchCreateOrConnectWithoutIngredientTypeInput = {
    where: TouchWhereUniqueInput
    create: XOR<TouchCreateWithoutIngredientTypeInput, TouchUncheckedCreateWithoutIngredientTypeInput>
  }

  export type TouchCreateManyIngredientTypeInputEnvelope = {
    data: TouchCreateManyIngredientTypeInput | TouchCreateManyIngredientTypeInput[]
    skipDuplicates?: boolean
  }

  export type ArchivedTouchCreateWithoutIngredientTypeInput = {
    id?: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    version?: number | null
    archivedBuild: ArchivedBuildCreateNestedOneWithoutArchivedTouchInput
    ingredient?: IngredientCreateNestedOneWithoutArchivedTouchInput
  }

  export type ArchivedTouchUncheckedCreateWithoutIngredientTypeInput = {
    id?: string
    archivedBuildId: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    ingredientId?: string | null
    version?: number | null
  }

  export type ArchivedTouchCreateOrConnectWithoutIngredientTypeInput = {
    where: ArchivedTouchWhereUniqueInput
    create: XOR<ArchivedTouchCreateWithoutIngredientTypeInput, ArchivedTouchUncheckedCreateWithoutIngredientTypeInput>
  }

  export type ArchivedTouchCreateManyIngredientTypeInputEnvelope = {
    data: ArchivedTouchCreateManyIngredientTypeInput | ArchivedTouchCreateManyIngredientTypeInput[]
    skipDuplicates?: boolean
  }

  export type IngredientCreateWithoutIngredientTypeInput = {
    id?: string
    dateCreated?: Date | string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    createdBy?: UserCreateNestedOneWithoutIngredientInput
    touch?: TouchCreateNestedManyWithoutIngredientInput
    archivedTouch?: ArchivedTouchCreateNestedManyWithoutIngredientInput
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutIngredientInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutIngredientInput
    crewIngredient?: CrewIngredientCreateNestedManyWithoutIngredientInput
  }

  export type IngredientUncheckedCreateWithoutIngredientTypeInput = {
    id?: string
    dateCreated?: Date | string
    createdById?: string | null
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutIngredientInput
    archivedTouch?: ArchivedTouchUncheckedCreateNestedManyWithoutIngredientInput
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutIngredientInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutIngredientInput
    crewIngredient?: CrewIngredientUncheckedCreateNestedManyWithoutIngredientInput
  }

  export type IngredientCreateOrConnectWithoutIngredientTypeInput = {
    where: IngredientWhereUniqueInput
    create: XOR<IngredientCreateWithoutIngredientTypeInput, IngredientUncheckedCreateWithoutIngredientTypeInput>
  }

  export type IngredientCreateManyIngredientTypeInputEnvelope = {
    data: IngredientCreateManyIngredientTypeInput | IngredientCreateManyIngredientTypeInput[]
    skipDuplicates?: boolean
  }

  export type IngredientPreferenceCreateWithoutIngredientTypeInput = {
    ingredient: IngredientCreateNestedOneWithoutIngredientPreferenceInput
    user: UserCreateNestedOneWithoutIngredientPreferenceInput
  }

  export type IngredientPreferenceUncheckedCreateWithoutIngredientTypeInput = {
    ingredientId: string
    userId: string
  }

  export type IngredientPreferenceCreateOrConnectWithoutIngredientTypeInput = {
    where: IngredientPreferenceWhereUniqueInput
    create: XOR<IngredientPreferenceCreateWithoutIngredientTypeInput, IngredientPreferenceUncheckedCreateWithoutIngredientTypeInput>
  }

  export type IngredientPreferenceCreateManyIngredientTypeInputEnvelope = {
    data: IngredientPreferenceCreateManyIngredientTypeInput | IngredientPreferenceCreateManyIngredientTypeInput[]
    skipDuplicates?: boolean
  }

  export type TouchUpsertWithWhereUniqueWithoutIngredientTypeInput = {
    where: TouchWhereUniqueInput
    update: XOR<TouchUpdateWithoutIngredientTypeInput, TouchUncheckedUpdateWithoutIngredientTypeInput>
    create: XOR<TouchCreateWithoutIngredientTypeInput, TouchUncheckedCreateWithoutIngredientTypeInput>
  }

  export type TouchUpdateWithWhereUniqueWithoutIngredientTypeInput = {
    where: TouchWhereUniqueInput
    data: XOR<TouchUpdateWithoutIngredientTypeInput, TouchUncheckedUpdateWithoutIngredientTypeInput>
  }

  export type TouchUpdateManyWithWhereWithoutIngredientTypeInput = {
    where: TouchScalarWhereInput
    data: XOR<TouchUpdateManyMutationInput, TouchUncheckedUpdateManyWithoutIngredientTypeInput>
  }

  export type ArchivedTouchUpsertWithWhereUniqueWithoutIngredientTypeInput = {
    where: ArchivedTouchWhereUniqueInput
    update: XOR<ArchivedTouchUpdateWithoutIngredientTypeInput, ArchivedTouchUncheckedUpdateWithoutIngredientTypeInput>
    create: XOR<ArchivedTouchCreateWithoutIngredientTypeInput, ArchivedTouchUncheckedCreateWithoutIngredientTypeInput>
  }

  export type ArchivedTouchUpdateWithWhereUniqueWithoutIngredientTypeInput = {
    where: ArchivedTouchWhereUniqueInput
    data: XOR<ArchivedTouchUpdateWithoutIngredientTypeInput, ArchivedTouchUncheckedUpdateWithoutIngredientTypeInput>
  }

  export type ArchivedTouchUpdateManyWithWhereWithoutIngredientTypeInput = {
    where: ArchivedTouchScalarWhereInput
    data: XOR<ArchivedTouchUpdateManyMutationInput, ArchivedTouchUncheckedUpdateManyWithoutIngredientTypeInput>
  }

  export type IngredientUpsertWithWhereUniqueWithoutIngredientTypeInput = {
    where: IngredientWhereUniqueInput
    update: XOR<IngredientUpdateWithoutIngredientTypeInput, IngredientUncheckedUpdateWithoutIngredientTypeInput>
    create: XOR<IngredientCreateWithoutIngredientTypeInput, IngredientUncheckedCreateWithoutIngredientTypeInput>
  }

  export type IngredientUpdateWithWhereUniqueWithoutIngredientTypeInput = {
    where: IngredientWhereUniqueInput
    data: XOR<IngredientUpdateWithoutIngredientTypeInput, IngredientUncheckedUpdateWithoutIngredientTypeInput>
  }

  export type IngredientUpdateManyWithWhereWithoutIngredientTypeInput = {
    where: IngredientScalarWhereInput
    data: XOR<IngredientUpdateManyMutationInput, IngredientUncheckedUpdateManyWithoutIngredientTypeInput>
  }

  export type IngredientPreferenceUpsertWithWhereUniqueWithoutIngredientTypeInput = {
    where: IngredientPreferenceWhereUniqueInput
    update: XOR<IngredientPreferenceUpdateWithoutIngredientTypeInput, IngredientPreferenceUncheckedUpdateWithoutIngredientTypeInput>
    create: XOR<IngredientPreferenceCreateWithoutIngredientTypeInput, IngredientPreferenceUncheckedCreateWithoutIngredientTypeInput>
  }

  export type IngredientPreferenceUpdateWithWhereUniqueWithoutIngredientTypeInput = {
    where: IngredientPreferenceWhereUniqueInput
    data: XOR<IngredientPreferenceUpdateWithoutIngredientTypeInput, IngredientPreferenceUncheckedUpdateWithoutIngredientTypeInput>
  }

  export type IngredientPreferenceUpdateManyWithWhereWithoutIngredientTypeInput = {
    where: IngredientPreferenceScalarWhereInput
    data: XOR<IngredientPreferenceUpdateManyMutationInput, IngredientPreferenceUncheckedUpdateManyWithoutIngredientTypeInput>
  }

  export type UserCreateWithoutIngredientInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutIngredientInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutIngredientInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIngredientInput, UserUncheckedCreateWithoutIngredientInput>
  }

  export type IngredientTypeCreateWithoutIngredientInput = {
    id?: string
    name: string
    description?: string | null
    touch?: TouchCreateNestedManyWithoutIngredientTypeInput
    archivedTouch?: ArchivedTouchCreateNestedManyWithoutIngredientTypeInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutIngredientTypeInput
  }

  export type IngredientTypeUncheckedCreateWithoutIngredientInput = {
    id?: string
    name: string
    description?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutIngredientTypeInput
    archivedTouch?: ArchivedTouchUncheckedCreateNestedManyWithoutIngredientTypeInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutIngredientTypeInput
  }

  export type IngredientTypeCreateOrConnectWithoutIngredientInput = {
    where: IngredientTypeWhereUniqueInput
    create: XOR<IngredientTypeCreateWithoutIngredientInput, IngredientTypeUncheckedCreateWithoutIngredientInput>
  }

  export type TouchCreateWithoutIngredientInput = {
    id?: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    version?: number | null
    build: BuildCreateNestedOneWithoutTouchInput
    ingredientType: IngredientTypeCreateNestedOneWithoutTouchInput
  }

  export type TouchUncheckedCreateWithoutIngredientInput = {
    id?: string
    buildId: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    ingredientTypeId: string
    version?: number | null
  }

  export type TouchCreateOrConnectWithoutIngredientInput = {
    where: TouchWhereUniqueInput
    create: XOR<TouchCreateWithoutIngredientInput, TouchUncheckedCreateWithoutIngredientInput>
  }

  export type TouchCreateManyIngredientInputEnvelope = {
    data: TouchCreateManyIngredientInput | TouchCreateManyIngredientInput[]
    skipDuplicates?: boolean
  }

  export type ArchivedTouchCreateWithoutIngredientInput = {
    id?: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    version?: number | null
    archivedBuild: ArchivedBuildCreateNestedOneWithoutArchivedTouchInput
    ingredientType: IngredientTypeCreateNestedOneWithoutArchivedTouchInput
  }

  export type ArchivedTouchUncheckedCreateWithoutIngredientInput = {
    id?: string
    archivedBuildId: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    ingredientTypeId: string
    version?: number | null
  }

  export type ArchivedTouchCreateOrConnectWithoutIngredientInput = {
    where: ArchivedTouchWhereUniqueInput
    create: XOR<ArchivedTouchCreateWithoutIngredientInput, ArchivedTouchUncheckedCreateWithoutIngredientInput>
  }

  export type ArchivedTouchCreateManyIngredientInputEnvelope = {
    data: ArchivedTouchCreateManyIngredientInput | ArchivedTouchCreateManyIngredientInput[]
    skipDuplicates?: boolean
  }

  export type IngredientStorageCreateWithoutIngredientInput = {
    quantity?: number | null
    Storage: StorageCreateNestedOneWithoutIngredientStorageInput
  }

  export type IngredientStorageUncheckedCreateWithoutIngredientInput = {
    storageId: string
    quantity?: number | null
  }

  export type IngredientStorageCreateOrConnectWithoutIngredientInput = {
    where: IngredientStorageWhereUniqueInput
    create: XOR<IngredientStorageCreateWithoutIngredientInput, IngredientStorageUncheckedCreateWithoutIngredientInput>
  }

  export type IngredientStorageCreateManyIngredientInputEnvelope = {
    data: IngredientStorageCreateManyIngredientInput | IngredientStorageCreateManyIngredientInput[]
    skipDuplicates?: boolean
  }

  export type IngredientUserCreateWithoutIngredientInput = {
    permission: string
    user: UserCreateNestedOneWithoutIngredientUserInput
  }

  export type IngredientUserUncheckedCreateWithoutIngredientInput = {
    userId: string
    permission: string
  }

  export type IngredientUserCreateOrConnectWithoutIngredientInput = {
    where: IngredientUserWhereUniqueInput
    create: XOR<IngredientUserCreateWithoutIngredientInput, IngredientUserUncheckedCreateWithoutIngredientInput>
  }

  export type IngredientUserCreateManyIngredientInputEnvelope = {
    data: IngredientUserCreateManyIngredientInput | IngredientUserCreateManyIngredientInput[]
    skipDuplicates?: boolean
  }

  export type IngredientPreferenceCreateWithoutIngredientInput = {
    ingredientType: IngredientTypeCreateNestedOneWithoutIngredientPreferenceInput
    user: UserCreateNestedOneWithoutIngredientPreferenceInput
  }

  export type IngredientPreferenceUncheckedCreateWithoutIngredientInput = {
    ingredientTypeId: string
    userId: string
  }

  export type IngredientPreferenceCreateOrConnectWithoutIngredientInput = {
    where: IngredientPreferenceWhereUniqueInput
    create: XOR<IngredientPreferenceCreateWithoutIngredientInput, IngredientPreferenceUncheckedCreateWithoutIngredientInput>
  }

  export type IngredientPreferenceCreateManyIngredientInputEnvelope = {
    data: IngredientPreferenceCreateManyIngredientInput | IngredientPreferenceCreateManyIngredientInput[]
    skipDuplicates?: boolean
  }

  export type CrewIngredientCreateWithoutIngredientInput = {
    crew: CrewCreateNestedOneWithoutCrewIngredientInput
  }

  export type CrewIngredientUncheckedCreateWithoutIngredientInput = {
    crewId: string
  }

  export type CrewIngredientCreateOrConnectWithoutIngredientInput = {
    where: CrewIngredientWhereUniqueInput
    create: XOR<CrewIngredientCreateWithoutIngredientInput, CrewIngredientUncheckedCreateWithoutIngredientInput>
  }

  export type CrewIngredientCreateManyIngredientInputEnvelope = {
    data: CrewIngredientCreateManyIngredientInput | CrewIngredientCreateManyIngredientInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutIngredientInput = {
    update: XOR<UserUpdateWithoutIngredientInput, UserUncheckedUpdateWithoutIngredientInput>
    create: XOR<UserCreateWithoutIngredientInput, UserUncheckedCreateWithoutIngredientInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIngredientInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIngredientInput, UserUncheckedUpdateWithoutIngredientInput>
  }

  export type UserUpdateWithoutIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type IngredientTypeUpsertWithoutIngredientInput = {
    update: XOR<IngredientTypeUpdateWithoutIngredientInput, IngredientTypeUncheckedUpdateWithoutIngredientInput>
    create: XOR<IngredientTypeCreateWithoutIngredientInput, IngredientTypeUncheckedCreateWithoutIngredientInput>
    where?: IngredientTypeWhereInput
  }

  export type IngredientTypeUpdateToOneWithWhereWithoutIngredientInput = {
    where?: IngredientTypeWhereInput
    data: XOR<IngredientTypeUpdateWithoutIngredientInput, IngredientTypeUncheckedUpdateWithoutIngredientInput>
  }

  export type IngredientTypeUpdateWithoutIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUpdateManyWithoutIngredientTypeNestedInput
    archivedTouch?: ArchivedTouchUpdateManyWithoutIngredientTypeNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutIngredientTypeNestedInput
  }

  export type IngredientTypeUncheckedUpdateWithoutIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutIngredientTypeNestedInput
    archivedTouch?: ArchivedTouchUncheckedUpdateManyWithoutIngredientTypeNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutIngredientTypeNestedInput
  }

  export type TouchUpsertWithWhereUniqueWithoutIngredientInput = {
    where: TouchWhereUniqueInput
    update: XOR<TouchUpdateWithoutIngredientInput, TouchUncheckedUpdateWithoutIngredientInput>
    create: XOR<TouchCreateWithoutIngredientInput, TouchUncheckedCreateWithoutIngredientInput>
  }

  export type TouchUpdateWithWhereUniqueWithoutIngredientInput = {
    where: TouchWhereUniqueInput
    data: XOR<TouchUpdateWithoutIngredientInput, TouchUncheckedUpdateWithoutIngredientInput>
  }

  export type TouchUpdateManyWithWhereWithoutIngredientInput = {
    where: TouchScalarWhereInput
    data: XOR<TouchUpdateManyMutationInput, TouchUncheckedUpdateManyWithoutIngredientInput>
  }

  export type ArchivedTouchUpsertWithWhereUniqueWithoutIngredientInput = {
    where: ArchivedTouchWhereUniqueInput
    update: XOR<ArchivedTouchUpdateWithoutIngredientInput, ArchivedTouchUncheckedUpdateWithoutIngredientInput>
    create: XOR<ArchivedTouchCreateWithoutIngredientInput, ArchivedTouchUncheckedCreateWithoutIngredientInput>
  }

  export type ArchivedTouchUpdateWithWhereUniqueWithoutIngredientInput = {
    where: ArchivedTouchWhereUniqueInput
    data: XOR<ArchivedTouchUpdateWithoutIngredientInput, ArchivedTouchUncheckedUpdateWithoutIngredientInput>
  }

  export type ArchivedTouchUpdateManyWithWhereWithoutIngredientInput = {
    where: ArchivedTouchScalarWhereInput
    data: XOR<ArchivedTouchUpdateManyMutationInput, ArchivedTouchUncheckedUpdateManyWithoutIngredientInput>
  }

  export type IngredientStorageUpsertWithWhereUniqueWithoutIngredientInput = {
    where: IngredientStorageWhereUniqueInput
    update: XOR<IngredientStorageUpdateWithoutIngredientInput, IngredientStorageUncheckedUpdateWithoutIngredientInput>
    create: XOR<IngredientStorageCreateWithoutIngredientInput, IngredientStorageUncheckedCreateWithoutIngredientInput>
  }

  export type IngredientStorageUpdateWithWhereUniqueWithoutIngredientInput = {
    where: IngredientStorageWhereUniqueInput
    data: XOR<IngredientStorageUpdateWithoutIngredientInput, IngredientStorageUncheckedUpdateWithoutIngredientInput>
  }

  export type IngredientStorageUpdateManyWithWhereWithoutIngredientInput = {
    where: IngredientStorageScalarWhereInput
    data: XOR<IngredientStorageUpdateManyMutationInput, IngredientStorageUncheckedUpdateManyWithoutIngredientInput>
  }

  export type IngredientStorageScalarWhereInput = {
    AND?: IngredientStorageScalarWhereInput | IngredientStorageScalarWhereInput[]
    OR?: IngredientStorageScalarWhereInput[]
    NOT?: IngredientStorageScalarWhereInput | IngredientStorageScalarWhereInput[]
    ingredientId?: StringFilter<"IngredientStorage"> | string
    storageId?: StringFilter<"IngredientStorage"> | string
    quantity?: FloatNullableFilter<"IngredientStorage"> | number | null
  }

  export type IngredientUserUpsertWithWhereUniqueWithoutIngredientInput = {
    where: IngredientUserWhereUniqueInput
    update: XOR<IngredientUserUpdateWithoutIngredientInput, IngredientUserUncheckedUpdateWithoutIngredientInput>
    create: XOR<IngredientUserCreateWithoutIngredientInput, IngredientUserUncheckedCreateWithoutIngredientInput>
  }

  export type IngredientUserUpdateWithWhereUniqueWithoutIngredientInput = {
    where: IngredientUserWhereUniqueInput
    data: XOR<IngredientUserUpdateWithoutIngredientInput, IngredientUserUncheckedUpdateWithoutIngredientInput>
  }

  export type IngredientUserUpdateManyWithWhereWithoutIngredientInput = {
    where: IngredientUserScalarWhereInput
    data: XOR<IngredientUserUpdateManyMutationInput, IngredientUserUncheckedUpdateManyWithoutIngredientInput>
  }

  export type IngredientPreferenceUpsertWithWhereUniqueWithoutIngredientInput = {
    where: IngredientPreferenceWhereUniqueInput
    update: XOR<IngredientPreferenceUpdateWithoutIngredientInput, IngredientPreferenceUncheckedUpdateWithoutIngredientInput>
    create: XOR<IngredientPreferenceCreateWithoutIngredientInput, IngredientPreferenceUncheckedCreateWithoutIngredientInput>
  }

  export type IngredientPreferenceUpdateWithWhereUniqueWithoutIngredientInput = {
    where: IngredientPreferenceWhereUniqueInput
    data: XOR<IngredientPreferenceUpdateWithoutIngredientInput, IngredientPreferenceUncheckedUpdateWithoutIngredientInput>
  }

  export type IngredientPreferenceUpdateManyWithWhereWithoutIngredientInput = {
    where: IngredientPreferenceScalarWhereInput
    data: XOR<IngredientPreferenceUpdateManyMutationInput, IngredientPreferenceUncheckedUpdateManyWithoutIngredientInput>
  }

  export type CrewIngredientUpsertWithWhereUniqueWithoutIngredientInput = {
    where: CrewIngredientWhereUniqueInput
    update: XOR<CrewIngredientUpdateWithoutIngredientInput, CrewIngredientUncheckedUpdateWithoutIngredientInput>
    create: XOR<CrewIngredientCreateWithoutIngredientInput, CrewIngredientUncheckedCreateWithoutIngredientInput>
  }

  export type CrewIngredientUpdateWithWhereUniqueWithoutIngredientInput = {
    where: CrewIngredientWhereUniqueInput
    data: XOR<CrewIngredientUpdateWithoutIngredientInput, CrewIngredientUncheckedUpdateWithoutIngredientInput>
  }

  export type CrewIngredientUpdateManyWithWhereWithoutIngredientInput = {
    where: CrewIngredientScalarWhereInput
    data: XOR<CrewIngredientUpdateManyMutationInput, CrewIngredientUncheckedUpdateManyWithoutIngredientInput>
  }

  export type CrewIngredientScalarWhereInput = {
    AND?: CrewIngredientScalarWhereInput | CrewIngredientScalarWhereInput[]
    OR?: CrewIngredientScalarWhereInput[]
    NOT?: CrewIngredientScalarWhereInput | CrewIngredientScalarWhereInput[]
    ingredientId?: StringFilter<"CrewIngredient"> | string
    crewId?: StringFilter<"CrewIngredient"> | string
  }

  export type UserCreateWithoutIngredientUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutIngredientUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutIngredientUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIngredientUserInput, UserUncheckedCreateWithoutIngredientUserInput>
  }

  export type IngredientCreateWithoutIngredientUserInput = {
    id?: string
    dateCreated?: Date | string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    createdBy?: UserCreateNestedOneWithoutIngredientInput
    ingredientType: IngredientTypeCreateNestedOneWithoutIngredientInput
    touch?: TouchCreateNestedManyWithoutIngredientInput
    archivedTouch?: ArchivedTouchCreateNestedManyWithoutIngredientInput
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutIngredientInput
    crewIngredient?: CrewIngredientCreateNestedManyWithoutIngredientInput
  }

  export type IngredientUncheckedCreateWithoutIngredientUserInput = {
    id?: string
    dateCreated?: Date | string
    createdById?: string | null
    ingredientTypeId: string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutIngredientInput
    archivedTouch?: ArchivedTouchUncheckedCreateNestedManyWithoutIngredientInput
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutIngredientInput
    crewIngredient?: CrewIngredientUncheckedCreateNestedManyWithoutIngredientInput
  }

  export type IngredientCreateOrConnectWithoutIngredientUserInput = {
    where: IngredientWhereUniqueInput
    create: XOR<IngredientCreateWithoutIngredientUserInput, IngredientUncheckedCreateWithoutIngredientUserInput>
  }

  export type UserUpsertWithoutIngredientUserInput = {
    update: XOR<UserUpdateWithoutIngredientUserInput, UserUncheckedUpdateWithoutIngredientUserInput>
    create: XOR<UserCreateWithoutIngredientUserInput, UserUncheckedCreateWithoutIngredientUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIngredientUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIngredientUserInput, UserUncheckedUpdateWithoutIngredientUserInput>
  }

  export type UserUpdateWithoutIngredientUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutIngredientUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type IngredientUpsertWithoutIngredientUserInput = {
    update: XOR<IngredientUpdateWithoutIngredientUserInput, IngredientUncheckedUpdateWithoutIngredientUserInput>
    create: XOR<IngredientCreateWithoutIngredientUserInput, IngredientUncheckedCreateWithoutIngredientUserInput>
    where?: IngredientWhereInput
  }

  export type IngredientUpdateToOneWithWhereWithoutIngredientUserInput = {
    where?: IngredientWhereInput
    data: XOR<IngredientUpdateWithoutIngredientUserInput, IngredientUncheckedUpdateWithoutIngredientUserInput>
  }

  export type IngredientUpdateWithoutIngredientUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutIngredientNestedInput
    ingredientType?: IngredientTypeUpdateOneRequiredWithoutIngredientNestedInput
    touch?: TouchUpdateManyWithoutIngredientNestedInput
    archivedTouch?: ArchivedTouchUpdateManyWithoutIngredientNestedInput
    ingredientStorage?: IngredientStorageUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutIngredientNestedInput
    crewIngredient?: CrewIngredientUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientUncheckedUpdateWithoutIngredientUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientTypeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutIngredientNestedInput
    archivedTouch?: ArchivedTouchUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutIngredientNestedInput
    crewIngredient?: CrewIngredientUncheckedUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientTypeCreateWithoutIngredientPreferenceInput = {
    id?: string
    name: string
    description?: string | null
    touch?: TouchCreateNestedManyWithoutIngredientTypeInput
    archivedTouch?: ArchivedTouchCreateNestedManyWithoutIngredientTypeInput
    ingredient?: IngredientCreateNestedManyWithoutIngredientTypeInput
  }

  export type IngredientTypeUncheckedCreateWithoutIngredientPreferenceInput = {
    id?: string
    name: string
    description?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutIngredientTypeInput
    archivedTouch?: ArchivedTouchUncheckedCreateNestedManyWithoutIngredientTypeInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutIngredientTypeInput
  }

  export type IngredientTypeCreateOrConnectWithoutIngredientPreferenceInput = {
    where: IngredientTypeWhereUniqueInput
    create: XOR<IngredientTypeCreateWithoutIngredientPreferenceInput, IngredientTypeUncheckedCreateWithoutIngredientPreferenceInput>
  }

  export type IngredientCreateWithoutIngredientPreferenceInput = {
    id?: string
    dateCreated?: Date | string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    createdBy?: UserCreateNestedOneWithoutIngredientInput
    ingredientType: IngredientTypeCreateNestedOneWithoutIngredientInput
    touch?: TouchCreateNestedManyWithoutIngredientInput
    archivedTouch?: ArchivedTouchCreateNestedManyWithoutIngredientInput
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutIngredientInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutIngredientInput
    crewIngredient?: CrewIngredientCreateNestedManyWithoutIngredientInput
  }

  export type IngredientUncheckedCreateWithoutIngredientPreferenceInput = {
    id?: string
    dateCreated?: Date | string
    createdById?: string | null
    ingredientTypeId: string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutIngredientInput
    archivedTouch?: ArchivedTouchUncheckedCreateNestedManyWithoutIngredientInput
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutIngredientInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutIngredientInput
    crewIngredient?: CrewIngredientUncheckedCreateNestedManyWithoutIngredientInput
  }

  export type IngredientCreateOrConnectWithoutIngredientPreferenceInput = {
    where: IngredientWhereUniqueInput
    create: XOR<IngredientCreateWithoutIngredientPreferenceInput, IngredientUncheckedCreateWithoutIngredientPreferenceInput>
  }

  export type UserCreateWithoutIngredientPreferenceInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutIngredientPreferenceInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutIngredientPreferenceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIngredientPreferenceInput, UserUncheckedCreateWithoutIngredientPreferenceInput>
  }

  export type IngredientTypeUpsertWithoutIngredientPreferenceInput = {
    update: XOR<IngredientTypeUpdateWithoutIngredientPreferenceInput, IngredientTypeUncheckedUpdateWithoutIngredientPreferenceInput>
    create: XOR<IngredientTypeCreateWithoutIngredientPreferenceInput, IngredientTypeUncheckedCreateWithoutIngredientPreferenceInput>
    where?: IngredientTypeWhereInput
  }

  export type IngredientTypeUpdateToOneWithWhereWithoutIngredientPreferenceInput = {
    where?: IngredientTypeWhereInput
    data: XOR<IngredientTypeUpdateWithoutIngredientPreferenceInput, IngredientTypeUncheckedUpdateWithoutIngredientPreferenceInput>
  }

  export type IngredientTypeUpdateWithoutIngredientPreferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUpdateManyWithoutIngredientTypeNestedInput
    archivedTouch?: ArchivedTouchUpdateManyWithoutIngredientTypeNestedInput
    ingredient?: IngredientUpdateManyWithoutIngredientTypeNestedInput
  }

  export type IngredientTypeUncheckedUpdateWithoutIngredientPreferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutIngredientTypeNestedInput
    archivedTouch?: ArchivedTouchUncheckedUpdateManyWithoutIngredientTypeNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutIngredientTypeNestedInput
  }

  export type IngredientUpsertWithoutIngredientPreferenceInput = {
    update: XOR<IngredientUpdateWithoutIngredientPreferenceInput, IngredientUncheckedUpdateWithoutIngredientPreferenceInput>
    create: XOR<IngredientCreateWithoutIngredientPreferenceInput, IngredientUncheckedCreateWithoutIngredientPreferenceInput>
    where?: IngredientWhereInput
  }

  export type IngredientUpdateToOneWithWhereWithoutIngredientPreferenceInput = {
    where?: IngredientWhereInput
    data: XOR<IngredientUpdateWithoutIngredientPreferenceInput, IngredientUncheckedUpdateWithoutIngredientPreferenceInput>
  }

  export type IngredientUpdateWithoutIngredientPreferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutIngredientNestedInput
    ingredientType?: IngredientTypeUpdateOneRequiredWithoutIngredientNestedInput
    touch?: TouchUpdateManyWithoutIngredientNestedInput
    archivedTouch?: ArchivedTouchUpdateManyWithoutIngredientNestedInput
    ingredientStorage?: IngredientStorageUpdateManyWithoutIngredientNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutIngredientNestedInput
    crewIngredient?: CrewIngredientUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientUncheckedUpdateWithoutIngredientPreferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientTypeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutIngredientNestedInput
    archivedTouch?: ArchivedTouchUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutIngredientNestedInput
    crewIngredient?: CrewIngredientUncheckedUpdateManyWithoutIngredientNestedInput
  }

  export type UserUpsertWithoutIngredientPreferenceInput = {
    update: XOR<UserUpdateWithoutIngredientPreferenceInput, UserUncheckedUpdateWithoutIngredientPreferenceInput>
    create: XOR<UserCreateWithoutIngredientPreferenceInput, UserUncheckedCreateWithoutIngredientPreferenceInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIngredientPreferenceInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIngredientPreferenceInput, UserUncheckedUpdateWithoutIngredientPreferenceInput>
  }

  export type UserUpdateWithoutIngredientPreferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutIngredientPreferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type UserCreateWithoutInventoryInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutInventoryInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutInventoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInventoryInput, UserUncheckedCreateWithoutInventoryInput>
  }

  export type UserCreateWithoutInventoryEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutInventoryEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutInventoryEditedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInventoryEditedByInput, UserUncheckedCreateWithoutInventoryEditedByInput>
  }

  export type InventoryStorageCreateWithoutInventoryInput = {
    storage: StorageCreateNestedOneWithoutInventoryStorageInput
  }

  export type InventoryStorageUncheckedCreateWithoutInventoryInput = {
    storageId: string
  }

  export type InventoryStorageCreateOrConnectWithoutInventoryInput = {
    where: InventoryStorageWhereUniqueInput
    create: XOR<InventoryStorageCreateWithoutInventoryInput, InventoryStorageUncheckedCreateWithoutInventoryInput>
  }

  export type InventoryStorageCreateManyInventoryInputEnvelope = {
    data: InventoryStorageCreateManyInventoryInput | InventoryStorageCreateManyInventoryInput[]
    skipDuplicates?: boolean
  }

  export type InventoryUserCreateWithoutInventoryInput = {
    permission: string
    user: UserCreateNestedOneWithoutInventoryUserInput
  }

  export type InventoryUserUncheckedCreateWithoutInventoryInput = {
    userId: string
    permission: string
  }

  export type InventoryUserCreateOrConnectWithoutInventoryInput = {
    where: InventoryUserWhereUniqueInput
    create: XOR<InventoryUserCreateWithoutInventoryInput, InventoryUserUncheckedCreateWithoutInventoryInput>
  }

  export type InventoryUserCreateManyInventoryInputEnvelope = {
    data: InventoryUserCreateManyInventoryInput | InventoryUserCreateManyInventoryInput[]
    skipDuplicates?: boolean
  }

  export type CrewInventoryCreateWithoutInventoryInput = {
    crew: CrewCreateNestedOneWithoutCrewInventoryInput
  }

  export type CrewInventoryUncheckedCreateWithoutInventoryInput = {
    crewId: string
  }

  export type CrewInventoryCreateOrConnectWithoutInventoryInput = {
    where: CrewInventoryWhereUniqueInput
    create: XOR<CrewInventoryCreateWithoutInventoryInput, CrewInventoryUncheckedCreateWithoutInventoryInput>
  }

  export type CrewInventoryCreateManyInventoryInputEnvelope = {
    data: CrewInventoryCreateManyInventoryInput | CrewInventoryCreateManyInventoryInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutInventoryInput = {
    update: XOR<UserUpdateWithoutInventoryInput, UserUncheckedUpdateWithoutInventoryInput>
    create: XOR<UserCreateWithoutInventoryInput, UserUncheckedCreateWithoutInventoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInventoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInventoryInput, UserUncheckedUpdateWithoutInventoryInput>
  }

  export type UserUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type UserUpsertWithoutInventoryEditedByInput = {
    update: XOR<UserUpdateWithoutInventoryEditedByInput, UserUncheckedUpdateWithoutInventoryEditedByInput>
    create: XOR<UserCreateWithoutInventoryEditedByInput, UserUncheckedCreateWithoutInventoryEditedByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInventoryEditedByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInventoryEditedByInput, UserUncheckedUpdateWithoutInventoryEditedByInput>
  }

  export type UserUpdateWithoutInventoryEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutInventoryEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type InventoryStorageUpsertWithWhereUniqueWithoutInventoryInput = {
    where: InventoryStorageWhereUniqueInput
    update: XOR<InventoryStorageUpdateWithoutInventoryInput, InventoryStorageUncheckedUpdateWithoutInventoryInput>
    create: XOR<InventoryStorageCreateWithoutInventoryInput, InventoryStorageUncheckedCreateWithoutInventoryInput>
  }

  export type InventoryStorageUpdateWithWhereUniqueWithoutInventoryInput = {
    where: InventoryStorageWhereUniqueInput
    data: XOR<InventoryStorageUpdateWithoutInventoryInput, InventoryStorageUncheckedUpdateWithoutInventoryInput>
  }

  export type InventoryStorageUpdateManyWithWhereWithoutInventoryInput = {
    where: InventoryStorageScalarWhereInput
    data: XOR<InventoryStorageUpdateManyMutationInput, InventoryStorageUncheckedUpdateManyWithoutInventoryInput>
  }

  export type InventoryStorageScalarWhereInput = {
    AND?: InventoryStorageScalarWhereInput | InventoryStorageScalarWhereInput[]
    OR?: InventoryStorageScalarWhereInput[]
    NOT?: InventoryStorageScalarWhereInput | InventoryStorageScalarWhereInput[]
    inventoryId?: StringFilter<"InventoryStorage"> | string
    storageId?: StringFilter<"InventoryStorage"> | string
  }

  export type InventoryUserUpsertWithWhereUniqueWithoutInventoryInput = {
    where: InventoryUserWhereUniqueInput
    update: XOR<InventoryUserUpdateWithoutInventoryInput, InventoryUserUncheckedUpdateWithoutInventoryInput>
    create: XOR<InventoryUserCreateWithoutInventoryInput, InventoryUserUncheckedCreateWithoutInventoryInput>
  }

  export type InventoryUserUpdateWithWhereUniqueWithoutInventoryInput = {
    where: InventoryUserWhereUniqueInput
    data: XOR<InventoryUserUpdateWithoutInventoryInput, InventoryUserUncheckedUpdateWithoutInventoryInput>
  }

  export type InventoryUserUpdateManyWithWhereWithoutInventoryInput = {
    where: InventoryUserScalarWhereInput
    data: XOR<InventoryUserUpdateManyMutationInput, InventoryUserUncheckedUpdateManyWithoutInventoryInput>
  }

  export type CrewInventoryUpsertWithWhereUniqueWithoutInventoryInput = {
    where: CrewInventoryWhereUniqueInput
    update: XOR<CrewInventoryUpdateWithoutInventoryInput, CrewInventoryUncheckedUpdateWithoutInventoryInput>
    create: XOR<CrewInventoryCreateWithoutInventoryInput, CrewInventoryUncheckedCreateWithoutInventoryInput>
  }

  export type CrewInventoryUpdateWithWhereUniqueWithoutInventoryInput = {
    where: CrewInventoryWhereUniqueInput
    data: XOR<CrewInventoryUpdateWithoutInventoryInput, CrewInventoryUncheckedUpdateWithoutInventoryInput>
  }

  export type CrewInventoryUpdateManyWithWhereWithoutInventoryInput = {
    where: CrewInventoryScalarWhereInput
    data: XOR<CrewInventoryUpdateManyMutationInput, CrewInventoryUncheckedUpdateManyWithoutInventoryInput>
  }

  export type CrewInventoryScalarWhereInput = {
    AND?: CrewInventoryScalarWhereInput | CrewInventoryScalarWhereInput[]
    OR?: CrewInventoryScalarWhereInput[]
    NOT?: CrewInventoryScalarWhereInput | CrewInventoryScalarWhereInput[]
    inventoryId?: StringFilter<"CrewInventory"> | string
    crewId?: StringFilter<"CrewInventory"> | string
  }

  export type UserCreateWithoutInventoryUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutInventoryUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutInventoryUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInventoryUserInput, UserUncheckedCreateWithoutInventoryUserInput>
  }

  export type InventoryCreateWithoutInventoryUserInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutInventoryInput
    editedBy?: UserCreateNestedOneWithoutInventoryEditedByInput
    inventoryStorage?: InventoryStorageCreateNestedManyWithoutInventoryInput
    crewInventory?: CrewInventoryCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutInventoryUserInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    inventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutInventoryInput
    crewInventory?: CrewInventoryUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryCreateOrConnectWithoutInventoryUserInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutInventoryUserInput, InventoryUncheckedCreateWithoutInventoryUserInput>
  }

  export type UserUpsertWithoutInventoryUserInput = {
    update: XOR<UserUpdateWithoutInventoryUserInput, UserUncheckedUpdateWithoutInventoryUserInput>
    create: XOR<UserCreateWithoutInventoryUserInput, UserUncheckedCreateWithoutInventoryUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInventoryUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInventoryUserInput, UserUncheckedUpdateWithoutInventoryUserInput>
  }

  export type UserUpdateWithoutInventoryUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutInventoryUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type InventoryUpsertWithoutInventoryUserInput = {
    update: XOR<InventoryUpdateWithoutInventoryUserInput, InventoryUncheckedUpdateWithoutInventoryUserInput>
    create: XOR<InventoryCreateWithoutInventoryUserInput, InventoryUncheckedCreateWithoutInventoryUserInput>
    where?: InventoryWhereInput
  }

  export type InventoryUpdateToOneWithWhereWithoutInventoryUserInput = {
    where?: InventoryWhereInput
    data: XOR<InventoryUpdateWithoutInventoryUserInput, InventoryUncheckedUpdateWithoutInventoryUserInput>
  }

  export type InventoryUpdateWithoutInventoryUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutInventoryNestedInput
    editedBy?: UserUpdateOneWithoutInventoryEditedByNestedInput
    inventoryStorage?: InventoryStorageUpdateManyWithoutInventoryNestedInput
    crewInventory?: CrewInventoryUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutInventoryUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    inventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutInventoryNestedInput
    crewInventory?: CrewInventoryUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type UserCreateWithoutStorageInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutStorageInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutStorageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStorageInput, UserUncheckedCreateWithoutStorageInput>
  }

  export type UserCreateWithoutStorageEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutStorageEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutStorageEditedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStorageEditedByInput, UserUncheckedCreateWithoutStorageEditedByInput>
  }

  export type InventoryStorageCreateWithoutStorageInput = {
    inventory: InventoryCreateNestedOneWithoutInventoryStorageInput
  }

  export type InventoryStorageUncheckedCreateWithoutStorageInput = {
    inventoryId: string
  }

  export type InventoryStorageCreateOrConnectWithoutStorageInput = {
    where: InventoryStorageWhereUniqueInput
    create: XOR<InventoryStorageCreateWithoutStorageInput, InventoryStorageUncheckedCreateWithoutStorageInput>
  }

  export type InventoryStorageCreateManyStorageInputEnvelope = {
    data: InventoryStorageCreateManyStorageInput | InventoryStorageCreateManyStorageInput[]
    skipDuplicates?: boolean
  }

  export type IngredientStorageCreateWithoutStorageInput = {
    quantity?: number | null
    ingredient: IngredientCreateNestedOneWithoutIngredientStorageInput
  }

  export type IngredientStorageUncheckedCreateWithoutStorageInput = {
    ingredientId: string
    quantity?: number | null
  }

  export type IngredientStorageCreateOrConnectWithoutStorageInput = {
    where: IngredientStorageWhereUniqueInput
    create: XOR<IngredientStorageCreateWithoutStorageInput, IngredientStorageUncheckedCreateWithoutStorageInput>
  }

  export type IngredientStorageCreateManyStorageInputEnvelope = {
    data: IngredientStorageCreateManyStorageInput | IngredientStorageCreateManyStorageInput[]
    skipDuplicates?: boolean
  }

  export type StorageUserCreateWithoutStorageInput = {
    permission: string
    user: UserCreateNestedOneWithoutStorageUserInput
  }

  export type StorageUserUncheckedCreateWithoutStorageInput = {
    userId: string
    permission: string
  }

  export type StorageUserCreateOrConnectWithoutStorageInput = {
    where: StorageUserWhereUniqueInput
    create: XOR<StorageUserCreateWithoutStorageInput, StorageUserUncheckedCreateWithoutStorageInput>
  }

  export type StorageUserCreateManyStorageInputEnvelope = {
    data: StorageUserCreateManyStorageInput | StorageUserCreateManyStorageInput[]
    skipDuplicates?: boolean
  }

  export type CrewStorageCreateWithoutStorageInput = {
    crew: CrewCreateNestedOneWithoutCrewStorageInput
  }

  export type CrewStorageUncheckedCreateWithoutStorageInput = {
    crewId: string
  }

  export type CrewStorageCreateOrConnectWithoutStorageInput = {
    where: CrewStorageWhereUniqueInput
    create: XOR<CrewStorageCreateWithoutStorageInput, CrewStorageUncheckedCreateWithoutStorageInput>
  }

  export type CrewStorageCreateManyStorageInputEnvelope = {
    data: CrewStorageCreateManyStorageInput | CrewStorageCreateManyStorageInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutStorageInput = {
    update: XOR<UserUpdateWithoutStorageInput, UserUncheckedUpdateWithoutStorageInput>
    create: XOR<UserCreateWithoutStorageInput, UserUncheckedCreateWithoutStorageInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStorageInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStorageInput, UserUncheckedUpdateWithoutStorageInput>
  }

  export type UserUpdateWithoutStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type UserUpsertWithoutStorageEditedByInput = {
    update: XOR<UserUpdateWithoutStorageEditedByInput, UserUncheckedUpdateWithoutStorageEditedByInput>
    create: XOR<UserCreateWithoutStorageEditedByInput, UserUncheckedCreateWithoutStorageEditedByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStorageEditedByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStorageEditedByInput, UserUncheckedUpdateWithoutStorageEditedByInput>
  }

  export type UserUpdateWithoutStorageEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutStorageEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type InventoryStorageUpsertWithWhereUniqueWithoutStorageInput = {
    where: InventoryStorageWhereUniqueInput
    update: XOR<InventoryStorageUpdateWithoutStorageInput, InventoryStorageUncheckedUpdateWithoutStorageInput>
    create: XOR<InventoryStorageCreateWithoutStorageInput, InventoryStorageUncheckedCreateWithoutStorageInput>
  }

  export type InventoryStorageUpdateWithWhereUniqueWithoutStorageInput = {
    where: InventoryStorageWhereUniqueInput
    data: XOR<InventoryStorageUpdateWithoutStorageInput, InventoryStorageUncheckedUpdateWithoutStorageInput>
  }

  export type InventoryStorageUpdateManyWithWhereWithoutStorageInput = {
    where: InventoryStorageScalarWhereInput
    data: XOR<InventoryStorageUpdateManyMutationInput, InventoryStorageUncheckedUpdateManyWithoutStorageInput>
  }

  export type IngredientStorageUpsertWithWhereUniqueWithoutStorageInput = {
    where: IngredientStorageWhereUniqueInput
    update: XOR<IngredientStorageUpdateWithoutStorageInput, IngredientStorageUncheckedUpdateWithoutStorageInput>
    create: XOR<IngredientStorageCreateWithoutStorageInput, IngredientStorageUncheckedCreateWithoutStorageInput>
  }

  export type IngredientStorageUpdateWithWhereUniqueWithoutStorageInput = {
    where: IngredientStorageWhereUniqueInput
    data: XOR<IngredientStorageUpdateWithoutStorageInput, IngredientStorageUncheckedUpdateWithoutStorageInput>
  }

  export type IngredientStorageUpdateManyWithWhereWithoutStorageInput = {
    where: IngredientStorageScalarWhereInput
    data: XOR<IngredientStorageUpdateManyMutationInput, IngredientStorageUncheckedUpdateManyWithoutStorageInput>
  }

  export type StorageUserUpsertWithWhereUniqueWithoutStorageInput = {
    where: StorageUserWhereUniqueInput
    update: XOR<StorageUserUpdateWithoutStorageInput, StorageUserUncheckedUpdateWithoutStorageInput>
    create: XOR<StorageUserCreateWithoutStorageInput, StorageUserUncheckedCreateWithoutStorageInput>
  }

  export type StorageUserUpdateWithWhereUniqueWithoutStorageInput = {
    where: StorageUserWhereUniqueInput
    data: XOR<StorageUserUpdateWithoutStorageInput, StorageUserUncheckedUpdateWithoutStorageInput>
  }

  export type StorageUserUpdateManyWithWhereWithoutStorageInput = {
    where: StorageUserScalarWhereInput
    data: XOR<StorageUserUpdateManyMutationInput, StorageUserUncheckedUpdateManyWithoutStorageInput>
  }

  export type CrewStorageUpsertWithWhereUniqueWithoutStorageInput = {
    where: CrewStorageWhereUniqueInput
    update: XOR<CrewStorageUpdateWithoutStorageInput, CrewStorageUncheckedUpdateWithoutStorageInput>
    create: XOR<CrewStorageCreateWithoutStorageInput, CrewStorageUncheckedCreateWithoutStorageInput>
  }

  export type CrewStorageUpdateWithWhereUniqueWithoutStorageInput = {
    where: CrewStorageWhereUniqueInput
    data: XOR<CrewStorageUpdateWithoutStorageInput, CrewStorageUncheckedUpdateWithoutStorageInput>
  }

  export type CrewStorageUpdateManyWithWhereWithoutStorageInput = {
    where: CrewStorageScalarWhereInput
    data: XOR<CrewStorageUpdateManyMutationInput, CrewStorageUncheckedUpdateManyWithoutStorageInput>
  }

  export type CrewStorageScalarWhereInput = {
    AND?: CrewStorageScalarWhereInput | CrewStorageScalarWhereInput[]
    OR?: CrewStorageScalarWhereInput[]
    NOT?: CrewStorageScalarWhereInput | CrewStorageScalarWhereInput[]
    storageId?: StringFilter<"CrewStorage"> | string
    crewId?: StringFilter<"CrewStorage"> | string
  }

  export type StorageCreateWithoutInventoryStorageInput = {
    id?: string
    name: string
    description?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutStorageInput
    editedBy?: UserCreateNestedOneWithoutStorageEditedByInput
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutStorageInput
    storageUser?: StorageUserCreateNestedManyWithoutStorageInput
    crewStorage?: CrewStorageCreateNestedManyWithoutStorageInput
  }

  export type StorageUncheckedCreateWithoutInventoryStorageInput = {
    id?: string
    name: string
    description?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutStorageInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutStorageInput
    crewStorage?: CrewStorageUncheckedCreateNestedManyWithoutStorageInput
  }

  export type StorageCreateOrConnectWithoutInventoryStorageInput = {
    where: StorageWhereUniqueInput
    create: XOR<StorageCreateWithoutInventoryStorageInput, StorageUncheckedCreateWithoutInventoryStorageInput>
  }

  export type InventoryCreateWithoutInventoryStorageInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutInventoryInput
    editedBy?: UserCreateNestedOneWithoutInventoryEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutInventoryInput
    crewInventory?: CrewInventoryCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutInventoryStorageInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutInventoryInput
    crewInventory?: CrewInventoryUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryCreateOrConnectWithoutInventoryStorageInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutInventoryStorageInput, InventoryUncheckedCreateWithoutInventoryStorageInput>
  }

  export type StorageUpsertWithoutInventoryStorageInput = {
    update: XOR<StorageUpdateWithoutInventoryStorageInput, StorageUncheckedUpdateWithoutInventoryStorageInput>
    create: XOR<StorageCreateWithoutInventoryStorageInput, StorageUncheckedCreateWithoutInventoryStorageInput>
    where?: StorageWhereInput
  }

  export type StorageUpdateToOneWithWhereWithoutInventoryStorageInput = {
    where?: StorageWhereInput
    data: XOR<StorageUpdateWithoutInventoryStorageInput, StorageUncheckedUpdateWithoutInventoryStorageInput>
  }

  export type StorageUpdateWithoutInventoryStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutStorageNestedInput
    editedBy?: UserUpdateOneWithoutStorageEditedByNestedInput
    ingredientStorage?: IngredientStorageUpdateManyWithoutStorageNestedInput
    storageUser?: StorageUserUpdateManyWithoutStorageNestedInput
    crewStorage?: CrewStorageUpdateManyWithoutStorageNestedInput
  }

  export type StorageUncheckedUpdateWithoutInventoryStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutStorageNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutStorageNestedInput
    crewStorage?: CrewStorageUncheckedUpdateManyWithoutStorageNestedInput
  }

  export type InventoryUpsertWithoutInventoryStorageInput = {
    update: XOR<InventoryUpdateWithoutInventoryStorageInput, InventoryUncheckedUpdateWithoutInventoryStorageInput>
    create: XOR<InventoryCreateWithoutInventoryStorageInput, InventoryUncheckedCreateWithoutInventoryStorageInput>
    where?: InventoryWhereInput
  }

  export type InventoryUpdateToOneWithWhereWithoutInventoryStorageInput = {
    where?: InventoryWhereInput
    data: XOR<InventoryUpdateWithoutInventoryStorageInput, InventoryUncheckedUpdateWithoutInventoryStorageInput>
  }

  export type InventoryUpdateWithoutInventoryStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutInventoryNestedInput
    editedBy?: UserUpdateOneWithoutInventoryEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutInventoryNestedInput
    crewInventory?: CrewInventoryUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutInventoryStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutInventoryNestedInput
    crewInventory?: CrewInventoryUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type IngredientCreateWithoutIngredientStorageInput = {
    id?: string
    dateCreated?: Date | string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    createdBy?: UserCreateNestedOneWithoutIngredientInput
    ingredientType: IngredientTypeCreateNestedOneWithoutIngredientInput
    touch?: TouchCreateNestedManyWithoutIngredientInput
    archivedTouch?: ArchivedTouchCreateNestedManyWithoutIngredientInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutIngredientInput
    crewIngredient?: CrewIngredientCreateNestedManyWithoutIngredientInput
  }

  export type IngredientUncheckedCreateWithoutIngredientStorageInput = {
    id?: string
    dateCreated?: Date | string
    createdById?: string | null
    ingredientTypeId: string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutIngredientInput
    archivedTouch?: ArchivedTouchUncheckedCreateNestedManyWithoutIngredientInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutIngredientInput
    crewIngredient?: CrewIngredientUncheckedCreateNestedManyWithoutIngredientInput
  }

  export type IngredientCreateOrConnectWithoutIngredientStorageInput = {
    where: IngredientWhereUniqueInput
    create: XOR<IngredientCreateWithoutIngredientStorageInput, IngredientUncheckedCreateWithoutIngredientStorageInput>
  }

  export type StorageCreateWithoutIngredientStorageInput = {
    id?: string
    name: string
    description?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutStorageInput
    editedBy?: UserCreateNestedOneWithoutStorageEditedByInput
    inventoryStorage?: InventoryStorageCreateNestedManyWithoutStorageInput
    storageUser?: StorageUserCreateNestedManyWithoutStorageInput
    crewStorage?: CrewStorageCreateNestedManyWithoutStorageInput
  }

  export type StorageUncheckedCreateWithoutIngredientStorageInput = {
    id?: string
    name: string
    description?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    inventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutStorageInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutStorageInput
    crewStorage?: CrewStorageUncheckedCreateNestedManyWithoutStorageInput
  }

  export type StorageCreateOrConnectWithoutIngredientStorageInput = {
    where: StorageWhereUniqueInput
    create: XOR<StorageCreateWithoutIngredientStorageInput, StorageUncheckedCreateWithoutIngredientStorageInput>
  }

  export type IngredientUpsertWithoutIngredientStorageInput = {
    update: XOR<IngredientUpdateWithoutIngredientStorageInput, IngredientUncheckedUpdateWithoutIngredientStorageInput>
    create: XOR<IngredientCreateWithoutIngredientStorageInput, IngredientUncheckedCreateWithoutIngredientStorageInput>
    where?: IngredientWhereInput
  }

  export type IngredientUpdateToOneWithWhereWithoutIngredientStorageInput = {
    where?: IngredientWhereInput
    data: XOR<IngredientUpdateWithoutIngredientStorageInput, IngredientUncheckedUpdateWithoutIngredientStorageInput>
  }

  export type IngredientUpdateWithoutIngredientStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutIngredientNestedInput
    ingredientType?: IngredientTypeUpdateOneRequiredWithoutIngredientNestedInput
    touch?: TouchUpdateManyWithoutIngredientNestedInput
    archivedTouch?: ArchivedTouchUpdateManyWithoutIngredientNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutIngredientNestedInput
    crewIngredient?: CrewIngredientUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientUncheckedUpdateWithoutIngredientStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientTypeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutIngredientNestedInput
    archivedTouch?: ArchivedTouchUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutIngredientNestedInput
    crewIngredient?: CrewIngredientUncheckedUpdateManyWithoutIngredientNestedInput
  }

  export type StorageUpsertWithoutIngredientStorageInput = {
    update: XOR<StorageUpdateWithoutIngredientStorageInput, StorageUncheckedUpdateWithoutIngredientStorageInput>
    create: XOR<StorageCreateWithoutIngredientStorageInput, StorageUncheckedCreateWithoutIngredientStorageInput>
    where?: StorageWhereInput
  }

  export type StorageUpdateToOneWithWhereWithoutIngredientStorageInput = {
    where?: StorageWhereInput
    data: XOR<StorageUpdateWithoutIngredientStorageInput, StorageUncheckedUpdateWithoutIngredientStorageInput>
  }

  export type StorageUpdateWithoutIngredientStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutStorageNestedInput
    editedBy?: UserUpdateOneWithoutStorageEditedByNestedInput
    inventoryStorage?: InventoryStorageUpdateManyWithoutStorageNestedInput
    storageUser?: StorageUserUpdateManyWithoutStorageNestedInput
    crewStorage?: CrewStorageUpdateManyWithoutStorageNestedInput
  }

  export type StorageUncheckedUpdateWithoutIngredientStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    inventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutStorageNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutStorageNestedInput
    crewStorage?: CrewStorageUncheckedUpdateManyWithoutStorageNestedInput
  }

  export type UserCreateWithoutStorageUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutStorageUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutStorageUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStorageUserInput, UserUncheckedCreateWithoutStorageUserInput>
  }

  export type StorageCreateWithoutStorageUserInput = {
    id?: string
    name: string
    description?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutStorageInput
    editedBy?: UserCreateNestedOneWithoutStorageEditedByInput
    inventoryStorage?: InventoryStorageCreateNestedManyWithoutStorageInput
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutStorageInput
    crewStorage?: CrewStorageCreateNestedManyWithoutStorageInput
  }

  export type StorageUncheckedCreateWithoutStorageUserInput = {
    id?: string
    name: string
    description?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    inventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutStorageInput
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutStorageInput
    crewStorage?: CrewStorageUncheckedCreateNestedManyWithoutStorageInput
  }

  export type StorageCreateOrConnectWithoutStorageUserInput = {
    where: StorageWhereUniqueInput
    create: XOR<StorageCreateWithoutStorageUserInput, StorageUncheckedCreateWithoutStorageUserInput>
  }

  export type UserUpsertWithoutStorageUserInput = {
    update: XOR<UserUpdateWithoutStorageUserInput, UserUncheckedUpdateWithoutStorageUserInput>
    create: XOR<UserCreateWithoutStorageUserInput, UserUncheckedCreateWithoutStorageUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStorageUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStorageUserInput, UserUncheckedUpdateWithoutStorageUserInput>
  }

  export type UserUpdateWithoutStorageUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutStorageUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type StorageUpsertWithoutStorageUserInput = {
    update: XOR<StorageUpdateWithoutStorageUserInput, StorageUncheckedUpdateWithoutStorageUserInput>
    create: XOR<StorageCreateWithoutStorageUserInput, StorageUncheckedCreateWithoutStorageUserInput>
    where?: StorageWhereInput
  }

  export type StorageUpdateToOneWithWhereWithoutStorageUserInput = {
    where?: StorageWhereInput
    data: XOR<StorageUpdateWithoutStorageUserInput, StorageUncheckedUpdateWithoutStorageUserInput>
  }

  export type StorageUpdateWithoutStorageUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutStorageNestedInput
    editedBy?: UserUpdateOneWithoutStorageEditedByNestedInput
    inventoryStorage?: InventoryStorageUpdateManyWithoutStorageNestedInput
    ingredientStorage?: IngredientStorageUpdateManyWithoutStorageNestedInput
    crewStorage?: CrewStorageUpdateManyWithoutStorageNestedInput
  }

  export type StorageUncheckedUpdateWithoutStorageUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    inventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutStorageNestedInput
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutStorageNestedInput
    crewStorage?: CrewStorageUncheckedUpdateManyWithoutStorageNestedInput
  }

  export type UserCreateWithoutCrewInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserCreateNestedManyWithoutUserInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutCrewInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutCrewInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCrewInput, UserUncheckedCreateWithoutCrewInput>
  }

  export type UserCreateWithoutCrewEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserCreateNestedManyWithoutUserInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutCrewEditedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutCreatedByInput
    crewUser?: CrewUserUncheckedCreateNestedManyWithoutUserInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutCrewEditedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCrewEditedByInput, UserUncheckedCreateWithoutCrewEditedByInput>
  }

  export type CrewUserCreateWithoutCrewInput = {
    permission: string
    user: UserCreateNestedOneWithoutCrewUserInput
  }

  export type CrewUserUncheckedCreateWithoutCrewInput = {
    userId: string
    permission: string
  }

  export type CrewUserCreateOrConnectWithoutCrewInput = {
    where: CrewUserWhereUniqueInput
    create: XOR<CrewUserCreateWithoutCrewInput, CrewUserUncheckedCreateWithoutCrewInput>
  }

  export type CrewUserCreateManyCrewInputEnvelope = {
    data: CrewUserCreateManyCrewInput | CrewUserCreateManyCrewInput[]
    skipDuplicates?: boolean
  }

  export type CrewInventoryCreateWithoutCrewInput = {
    inventory: InventoryCreateNestedOneWithoutCrewInventoryInput
  }

  export type CrewInventoryUncheckedCreateWithoutCrewInput = {
    inventoryId: string
  }

  export type CrewInventoryCreateOrConnectWithoutCrewInput = {
    where: CrewInventoryWhereUniqueInput
    create: XOR<CrewInventoryCreateWithoutCrewInput, CrewInventoryUncheckedCreateWithoutCrewInput>
  }

  export type CrewInventoryCreateManyCrewInputEnvelope = {
    data: CrewInventoryCreateManyCrewInput | CrewInventoryCreateManyCrewInput[]
    skipDuplicates?: boolean
  }

  export type CrewStorageCreateWithoutCrewInput = {
    storage: StorageCreateNestedOneWithoutCrewStorageInput
  }

  export type CrewStorageUncheckedCreateWithoutCrewInput = {
    storageId: string
  }

  export type CrewStorageCreateOrConnectWithoutCrewInput = {
    where: CrewStorageWhereUniqueInput
    create: XOR<CrewStorageCreateWithoutCrewInput, CrewStorageUncheckedCreateWithoutCrewInput>
  }

  export type CrewStorageCreateManyCrewInputEnvelope = {
    data: CrewStorageCreateManyCrewInput | CrewStorageCreateManyCrewInput[]
    skipDuplicates?: boolean
  }

  export type CrewIngredientCreateWithoutCrewInput = {
    ingredient: IngredientCreateNestedOneWithoutCrewIngredientInput
  }

  export type CrewIngredientUncheckedCreateWithoutCrewInput = {
    ingredientId: string
  }

  export type CrewIngredientCreateOrConnectWithoutCrewInput = {
    where: CrewIngredientWhereUniqueInput
    create: XOR<CrewIngredientCreateWithoutCrewInput, CrewIngredientUncheckedCreateWithoutCrewInput>
  }

  export type CrewIngredientCreateManyCrewInputEnvelope = {
    data: CrewIngredientCreateManyCrewInput | CrewIngredientCreateManyCrewInput[]
    skipDuplicates?: boolean
  }

  export type CrewRecipeBookCreateWithoutCrewInput = {
    recipeBook: RecipeBookCreateNestedOneWithoutCrewRecipeBookInput
  }

  export type CrewRecipeBookUncheckedCreateWithoutCrewInput = {
    recipeBookId: string
  }

  export type CrewRecipeBookCreateOrConnectWithoutCrewInput = {
    where: CrewRecipeBookWhereUniqueInput
    create: XOR<CrewRecipeBookCreateWithoutCrewInput, CrewRecipeBookUncheckedCreateWithoutCrewInput>
  }

  export type CrewRecipeBookCreateManyCrewInputEnvelope = {
    data: CrewRecipeBookCreateManyCrewInput | CrewRecipeBookCreateManyCrewInput[]
    skipDuplicates?: boolean
  }

  export type CrewBuildCreateWithoutCrewInput = {
    build: BuildCreateNestedOneWithoutCrewBuildInput
  }

  export type CrewBuildUncheckedCreateWithoutCrewInput = {
    buildId: string
  }

  export type CrewBuildCreateOrConnectWithoutCrewInput = {
    where: CrewBuildWhereUniqueInput
    create: XOR<CrewBuildCreateWithoutCrewInput, CrewBuildUncheckedCreateWithoutCrewInput>
  }

  export type CrewBuildCreateManyCrewInputEnvelope = {
    data: CrewBuildCreateManyCrewInput | CrewBuildCreateManyCrewInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCrewInput = {
    update: XOR<UserUpdateWithoutCrewInput, UserUncheckedUpdateWithoutCrewInput>
    create: XOR<UserCreateWithoutCrewInput, UserUncheckedCreateWithoutCrewInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCrewInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCrewInput, UserUncheckedUpdateWithoutCrewInput>
  }

  export type UserUpdateWithoutCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutCrewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type UserUpsertWithoutCrewEditedByInput = {
    update: XOR<UserUpdateWithoutCrewEditedByInput, UserUncheckedUpdateWithoutCrewEditedByInput>
    create: XOR<UserCreateWithoutCrewEditedByInput, UserUncheckedCreateWithoutCrewEditedByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCrewEditedByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCrewEditedByInput, UserUncheckedUpdateWithoutCrewEditedByInput>
  }

  export type UserUpdateWithoutCrewEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUpdateManyWithoutUserNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutCrewEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutCreatedByNestedInput
    crewUser?: CrewUserUncheckedUpdateManyWithoutUserNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type CrewUserUpsertWithWhereUniqueWithoutCrewInput = {
    where: CrewUserWhereUniqueInput
    update: XOR<CrewUserUpdateWithoutCrewInput, CrewUserUncheckedUpdateWithoutCrewInput>
    create: XOR<CrewUserCreateWithoutCrewInput, CrewUserUncheckedCreateWithoutCrewInput>
  }

  export type CrewUserUpdateWithWhereUniqueWithoutCrewInput = {
    where: CrewUserWhereUniqueInput
    data: XOR<CrewUserUpdateWithoutCrewInput, CrewUserUncheckedUpdateWithoutCrewInput>
  }

  export type CrewUserUpdateManyWithWhereWithoutCrewInput = {
    where: CrewUserScalarWhereInput
    data: XOR<CrewUserUpdateManyMutationInput, CrewUserUncheckedUpdateManyWithoutCrewInput>
  }

  export type CrewInventoryUpsertWithWhereUniqueWithoutCrewInput = {
    where: CrewInventoryWhereUniqueInput
    update: XOR<CrewInventoryUpdateWithoutCrewInput, CrewInventoryUncheckedUpdateWithoutCrewInput>
    create: XOR<CrewInventoryCreateWithoutCrewInput, CrewInventoryUncheckedCreateWithoutCrewInput>
  }

  export type CrewInventoryUpdateWithWhereUniqueWithoutCrewInput = {
    where: CrewInventoryWhereUniqueInput
    data: XOR<CrewInventoryUpdateWithoutCrewInput, CrewInventoryUncheckedUpdateWithoutCrewInput>
  }

  export type CrewInventoryUpdateManyWithWhereWithoutCrewInput = {
    where: CrewInventoryScalarWhereInput
    data: XOR<CrewInventoryUpdateManyMutationInput, CrewInventoryUncheckedUpdateManyWithoutCrewInput>
  }

  export type CrewStorageUpsertWithWhereUniqueWithoutCrewInput = {
    where: CrewStorageWhereUniqueInput
    update: XOR<CrewStorageUpdateWithoutCrewInput, CrewStorageUncheckedUpdateWithoutCrewInput>
    create: XOR<CrewStorageCreateWithoutCrewInput, CrewStorageUncheckedCreateWithoutCrewInput>
  }

  export type CrewStorageUpdateWithWhereUniqueWithoutCrewInput = {
    where: CrewStorageWhereUniqueInput
    data: XOR<CrewStorageUpdateWithoutCrewInput, CrewStorageUncheckedUpdateWithoutCrewInput>
  }

  export type CrewStorageUpdateManyWithWhereWithoutCrewInput = {
    where: CrewStorageScalarWhereInput
    data: XOR<CrewStorageUpdateManyMutationInput, CrewStorageUncheckedUpdateManyWithoutCrewInput>
  }

  export type CrewIngredientUpsertWithWhereUniqueWithoutCrewInput = {
    where: CrewIngredientWhereUniqueInput
    update: XOR<CrewIngredientUpdateWithoutCrewInput, CrewIngredientUncheckedUpdateWithoutCrewInput>
    create: XOR<CrewIngredientCreateWithoutCrewInput, CrewIngredientUncheckedCreateWithoutCrewInput>
  }

  export type CrewIngredientUpdateWithWhereUniqueWithoutCrewInput = {
    where: CrewIngredientWhereUniqueInput
    data: XOR<CrewIngredientUpdateWithoutCrewInput, CrewIngredientUncheckedUpdateWithoutCrewInput>
  }

  export type CrewIngredientUpdateManyWithWhereWithoutCrewInput = {
    where: CrewIngredientScalarWhereInput
    data: XOR<CrewIngredientUpdateManyMutationInput, CrewIngredientUncheckedUpdateManyWithoutCrewInput>
  }

  export type CrewRecipeBookUpsertWithWhereUniqueWithoutCrewInput = {
    where: CrewRecipeBookWhereUniqueInput
    update: XOR<CrewRecipeBookUpdateWithoutCrewInput, CrewRecipeBookUncheckedUpdateWithoutCrewInput>
    create: XOR<CrewRecipeBookCreateWithoutCrewInput, CrewRecipeBookUncheckedCreateWithoutCrewInput>
  }

  export type CrewRecipeBookUpdateWithWhereUniqueWithoutCrewInput = {
    where: CrewRecipeBookWhereUniqueInput
    data: XOR<CrewRecipeBookUpdateWithoutCrewInput, CrewRecipeBookUncheckedUpdateWithoutCrewInput>
  }

  export type CrewRecipeBookUpdateManyWithWhereWithoutCrewInput = {
    where: CrewRecipeBookScalarWhereInput
    data: XOR<CrewRecipeBookUpdateManyMutationInput, CrewRecipeBookUncheckedUpdateManyWithoutCrewInput>
  }

  export type CrewBuildUpsertWithWhereUniqueWithoutCrewInput = {
    where: CrewBuildWhereUniqueInput
    update: XOR<CrewBuildUpdateWithoutCrewInput, CrewBuildUncheckedUpdateWithoutCrewInput>
    create: XOR<CrewBuildCreateWithoutCrewInput, CrewBuildUncheckedCreateWithoutCrewInput>
  }

  export type CrewBuildUpdateWithWhereUniqueWithoutCrewInput = {
    where: CrewBuildWhereUniqueInput
    data: XOR<CrewBuildUpdateWithoutCrewInput, CrewBuildUncheckedUpdateWithoutCrewInput>
  }

  export type CrewBuildUpdateManyWithWhereWithoutCrewInput = {
    where: CrewBuildScalarWhereInput
    data: XOR<CrewBuildUpdateManyMutationInput, CrewBuildUncheckedUpdateManyWithoutCrewInput>
  }

  export type UserCreateWithoutCrewUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookCreateNestedManyWithoutEditedByInput
    recipe?: RecipeCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserCreateNestedManyWithoutUserInput
    build?: BuildCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutCreatedByInput
    crew?: CrewCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutUserInput
    storageUser?: StorageUserCreateNestedManyWithoutUserInput
    storage?: StorageCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageCreateNestedManyWithoutEditedByInput
    inventory?: InventoryCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutUserInput
    followedBy?: FollowCreateNestedManyWithoutFollowedByInput
    following?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutCrewUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    lastEdited?: Date | string
    email: string
    password: string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutUserInput
    recipeBook?: RecipeBookUncheckedCreateNestedManyWithoutCreatedByInput
    recipeBookEditedBy?: RecipeBookUncheckedCreateNestedManyWithoutEditedByInput
    recipe?: RecipeUncheckedCreateNestedManyWithoutCreatedByInput
    recipeEditedBy?: RecipeUncheckedCreateNestedManyWithoutEditedByInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutUserInput
    build?: BuildUncheckedCreateNestedManyWithoutCreatedByInput
    buildEditedBy?: BuildUncheckedCreateNestedManyWithoutEditedByInput
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutCreatedByInput
    crew?: CrewUncheckedCreateNestedManyWithoutCreatedByInput
    crewEditedBy?: CrewUncheckedCreateNestedManyWithoutEditedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutCreatedByInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutUserInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutUserInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutUserInput
    storage?: StorageUncheckedCreateNestedManyWithoutCreatedByInput
    storageEditedBy?: StorageUncheckedCreateNestedManyWithoutEditedByInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCreatedByInput
    inventoryEditedBy?: InventoryUncheckedCreateNestedManyWithoutEditedByInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowUncheckedCreateNestedManyWithoutFollowedByInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutCrewUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCrewUserInput, UserUncheckedCreateWithoutCrewUserInput>
  }

  export type CrewCreateWithoutCrewUserInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCrewInput
    editedBy?: UserCreateNestedOneWithoutCrewEditedByInput
    crewInventory?: CrewInventoryCreateNestedManyWithoutCrewInput
    crewStorage?: CrewStorageCreateNestedManyWithoutCrewInput
    crewIngredient?: CrewIngredientCreateNestedManyWithoutCrewInput
    crewRecipeBook?: CrewRecipeBookCreateNestedManyWithoutCrewInput
    crewBuild?: CrewBuildCreateNestedManyWithoutCrewInput
  }

  export type CrewUncheckedCreateWithoutCrewUserInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    crewInventory?: CrewInventoryUncheckedCreateNestedManyWithoutCrewInput
    crewStorage?: CrewStorageUncheckedCreateNestedManyWithoutCrewInput
    crewIngredient?: CrewIngredientUncheckedCreateNestedManyWithoutCrewInput
    crewRecipeBook?: CrewRecipeBookUncheckedCreateNestedManyWithoutCrewInput
    crewBuild?: CrewBuildUncheckedCreateNestedManyWithoutCrewInput
  }

  export type CrewCreateOrConnectWithoutCrewUserInput = {
    where: CrewWhereUniqueInput
    create: XOR<CrewCreateWithoutCrewUserInput, CrewUncheckedCreateWithoutCrewUserInput>
  }

  export type UserUpsertWithoutCrewUserInput = {
    update: XOR<UserUpdateWithoutCrewUserInput, UserUncheckedUpdateWithoutCrewUserInput>
    create: XOR<UserCreateWithoutCrewUserInput, UserUncheckedCreateWithoutCrewUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCrewUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCrewUserInput, UserUncheckedUpdateWithoutCrewUserInput>
  }

  export type UserUpdateWithoutCrewUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUpdateManyWithoutUserNestedInput
    build?: BuildUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutCreatedByNestedInput
    crew?: CrewUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUpdateManyWithoutUserNestedInput
    storage?: StorageUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutUserNestedInput
    followedBy?: FollowUpdateManyWithoutFollowedByNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutCrewUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastEdited?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutUserNestedInput
    recipeBook?: RecipeBookUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeBookEditedBy?: RecipeBookUncheckedUpdateManyWithoutEditedByNestedInput
    recipe?: RecipeUncheckedUpdateManyWithoutCreatedByNestedInput
    recipeEditedBy?: RecipeUncheckedUpdateManyWithoutEditedByNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutUserNestedInput
    build?: BuildUncheckedUpdateManyWithoutCreatedByNestedInput
    buildEditedBy?: BuildUncheckedUpdateManyWithoutEditedByNestedInput
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutCreatedByNestedInput
    crew?: CrewUncheckedUpdateManyWithoutCreatedByNestedInput
    crewEditedBy?: CrewUncheckedUpdateManyWithoutEditedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutCreatedByNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutUserNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutUserNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutUserNestedInput
    storage?: StorageUncheckedUpdateManyWithoutCreatedByNestedInput
    storageEditedBy?: StorageUncheckedUpdateManyWithoutEditedByNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCreatedByNestedInput
    inventoryEditedBy?: InventoryUncheckedUpdateManyWithoutEditedByNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowUncheckedUpdateManyWithoutFollowedByNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type CrewUpsertWithoutCrewUserInput = {
    update: XOR<CrewUpdateWithoutCrewUserInput, CrewUncheckedUpdateWithoutCrewUserInput>
    create: XOR<CrewCreateWithoutCrewUserInput, CrewUncheckedCreateWithoutCrewUserInput>
    where?: CrewWhereInput
  }

  export type CrewUpdateToOneWithWhereWithoutCrewUserInput = {
    where?: CrewWhereInput
    data: XOR<CrewUpdateWithoutCrewUserInput, CrewUncheckedUpdateWithoutCrewUserInput>
  }

  export type CrewUpdateWithoutCrewUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCrewNestedInput
    editedBy?: UserUpdateOneWithoutCrewEditedByNestedInput
    crewInventory?: CrewInventoryUpdateManyWithoutCrewNestedInput
    crewStorage?: CrewStorageUpdateManyWithoutCrewNestedInput
    crewIngredient?: CrewIngredientUpdateManyWithoutCrewNestedInput
    crewRecipeBook?: CrewRecipeBookUpdateManyWithoutCrewNestedInput
    crewBuild?: CrewBuildUpdateManyWithoutCrewNestedInput
  }

  export type CrewUncheckedUpdateWithoutCrewUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    crewInventory?: CrewInventoryUncheckedUpdateManyWithoutCrewNestedInput
    crewStorage?: CrewStorageUncheckedUpdateManyWithoutCrewNestedInput
    crewIngredient?: CrewIngredientUncheckedUpdateManyWithoutCrewNestedInput
    crewRecipeBook?: CrewRecipeBookUncheckedUpdateManyWithoutCrewNestedInput
    crewBuild?: CrewBuildUncheckedUpdateManyWithoutCrewNestedInput
  }

  export type InventoryCreateWithoutCrewInventoryInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutInventoryInput
    editedBy?: UserCreateNestedOneWithoutInventoryEditedByInput
    inventoryStorage?: InventoryStorageCreateNestedManyWithoutInventoryInput
    inventoryUser?: InventoryUserCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutCrewInventoryInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    inventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutInventoryInput
    inventoryUser?: InventoryUserUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryCreateOrConnectWithoutCrewInventoryInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutCrewInventoryInput, InventoryUncheckedCreateWithoutCrewInventoryInput>
  }

  export type CrewCreateWithoutCrewInventoryInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCrewInput
    editedBy?: UserCreateNestedOneWithoutCrewEditedByInput
    crewUser?: CrewUserCreateNestedManyWithoutCrewInput
    crewStorage?: CrewStorageCreateNestedManyWithoutCrewInput
    crewIngredient?: CrewIngredientCreateNestedManyWithoutCrewInput
    crewRecipeBook?: CrewRecipeBookCreateNestedManyWithoutCrewInput
    crewBuild?: CrewBuildCreateNestedManyWithoutCrewInput
  }

  export type CrewUncheckedCreateWithoutCrewInventoryInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    crewUser?: CrewUserUncheckedCreateNestedManyWithoutCrewInput
    crewStorage?: CrewStorageUncheckedCreateNestedManyWithoutCrewInput
    crewIngredient?: CrewIngredientUncheckedCreateNestedManyWithoutCrewInput
    crewRecipeBook?: CrewRecipeBookUncheckedCreateNestedManyWithoutCrewInput
    crewBuild?: CrewBuildUncheckedCreateNestedManyWithoutCrewInput
  }

  export type CrewCreateOrConnectWithoutCrewInventoryInput = {
    where: CrewWhereUniqueInput
    create: XOR<CrewCreateWithoutCrewInventoryInput, CrewUncheckedCreateWithoutCrewInventoryInput>
  }

  export type InventoryUpsertWithoutCrewInventoryInput = {
    update: XOR<InventoryUpdateWithoutCrewInventoryInput, InventoryUncheckedUpdateWithoutCrewInventoryInput>
    create: XOR<InventoryCreateWithoutCrewInventoryInput, InventoryUncheckedCreateWithoutCrewInventoryInput>
    where?: InventoryWhereInput
  }

  export type InventoryUpdateToOneWithWhereWithoutCrewInventoryInput = {
    where?: InventoryWhereInput
    data: XOR<InventoryUpdateWithoutCrewInventoryInput, InventoryUncheckedUpdateWithoutCrewInventoryInput>
  }

  export type InventoryUpdateWithoutCrewInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutInventoryNestedInput
    editedBy?: UserUpdateOneWithoutInventoryEditedByNestedInput
    inventoryStorage?: InventoryStorageUpdateManyWithoutInventoryNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutCrewInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    inventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutInventoryNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type CrewUpsertWithoutCrewInventoryInput = {
    update: XOR<CrewUpdateWithoutCrewInventoryInput, CrewUncheckedUpdateWithoutCrewInventoryInput>
    create: XOR<CrewCreateWithoutCrewInventoryInput, CrewUncheckedCreateWithoutCrewInventoryInput>
    where?: CrewWhereInput
  }

  export type CrewUpdateToOneWithWhereWithoutCrewInventoryInput = {
    where?: CrewWhereInput
    data: XOR<CrewUpdateWithoutCrewInventoryInput, CrewUncheckedUpdateWithoutCrewInventoryInput>
  }

  export type CrewUpdateWithoutCrewInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCrewNestedInput
    editedBy?: UserUpdateOneWithoutCrewEditedByNestedInput
    crewUser?: CrewUserUpdateManyWithoutCrewNestedInput
    crewStorage?: CrewStorageUpdateManyWithoutCrewNestedInput
    crewIngredient?: CrewIngredientUpdateManyWithoutCrewNestedInput
    crewRecipeBook?: CrewRecipeBookUpdateManyWithoutCrewNestedInput
    crewBuild?: CrewBuildUpdateManyWithoutCrewNestedInput
  }

  export type CrewUncheckedUpdateWithoutCrewInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    crewUser?: CrewUserUncheckedUpdateManyWithoutCrewNestedInput
    crewStorage?: CrewStorageUncheckedUpdateManyWithoutCrewNestedInput
    crewIngredient?: CrewIngredientUncheckedUpdateManyWithoutCrewNestedInput
    crewRecipeBook?: CrewRecipeBookUncheckedUpdateManyWithoutCrewNestedInput
    crewBuild?: CrewBuildUncheckedUpdateManyWithoutCrewNestedInput
  }

  export type StorageCreateWithoutCrewStorageInput = {
    id?: string
    name: string
    description?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutStorageInput
    editedBy?: UserCreateNestedOneWithoutStorageEditedByInput
    inventoryStorage?: InventoryStorageCreateNestedManyWithoutStorageInput
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutStorageInput
    storageUser?: StorageUserCreateNestedManyWithoutStorageInput
  }

  export type StorageUncheckedCreateWithoutCrewStorageInput = {
    id?: string
    name: string
    description?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    inventoryStorage?: InventoryStorageUncheckedCreateNestedManyWithoutStorageInput
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutStorageInput
    storageUser?: StorageUserUncheckedCreateNestedManyWithoutStorageInput
  }

  export type StorageCreateOrConnectWithoutCrewStorageInput = {
    where: StorageWhereUniqueInput
    create: XOR<StorageCreateWithoutCrewStorageInput, StorageUncheckedCreateWithoutCrewStorageInput>
  }

  export type CrewCreateWithoutCrewStorageInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCrewInput
    editedBy?: UserCreateNestedOneWithoutCrewEditedByInput
    crewUser?: CrewUserCreateNestedManyWithoutCrewInput
    crewInventory?: CrewInventoryCreateNestedManyWithoutCrewInput
    crewIngredient?: CrewIngredientCreateNestedManyWithoutCrewInput
    crewRecipeBook?: CrewRecipeBookCreateNestedManyWithoutCrewInput
    crewBuild?: CrewBuildCreateNestedManyWithoutCrewInput
  }

  export type CrewUncheckedCreateWithoutCrewStorageInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    crewUser?: CrewUserUncheckedCreateNestedManyWithoutCrewInput
    crewInventory?: CrewInventoryUncheckedCreateNestedManyWithoutCrewInput
    crewIngredient?: CrewIngredientUncheckedCreateNestedManyWithoutCrewInput
    crewRecipeBook?: CrewRecipeBookUncheckedCreateNestedManyWithoutCrewInput
    crewBuild?: CrewBuildUncheckedCreateNestedManyWithoutCrewInput
  }

  export type CrewCreateOrConnectWithoutCrewStorageInput = {
    where: CrewWhereUniqueInput
    create: XOR<CrewCreateWithoutCrewStorageInput, CrewUncheckedCreateWithoutCrewStorageInput>
  }

  export type StorageUpsertWithoutCrewStorageInput = {
    update: XOR<StorageUpdateWithoutCrewStorageInput, StorageUncheckedUpdateWithoutCrewStorageInput>
    create: XOR<StorageCreateWithoutCrewStorageInput, StorageUncheckedCreateWithoutCrewStorageInput>
    where?: StorageWhereInput
  }

  export type StorageUpdateToOneWithWhereWithoutCrewStorageInput = {
    where?: StorageWhereInput
    data: XOR<StorageUpdateWithoutCrewStorageInput, StorageUncheckedUpdateWithoutCrewStorageInput>
  }

  export type StorageUpdateWithoutCrewStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutStorageNestedInput
    editedBy?: UserUpdateOneWithoutStorageEditedByNestedInput
    inventoryStorage?: InventoryStorageUpdateManyWithoutStorageNestedInput
    ingredientStorage?: IngredientStorageUpdateManyWithoutStorageNestedInput
    storageUser?: StorageUserUpdateManyWithoutStorageNestedInput
  }

  export type StorageUncheckedUpdateWithoutCrewStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    inventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutStorageNestedInput
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutStorageNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutStorageNestedInput
  }

  export type CrewUpsertWithoutCrewStorageInput = {
    update: XOR<CrewUpdateWithoutCrewStorageInput, CrewUncheckedUpdateWithoutCrewStorageInput>
    create: XOR<CrewCreateWithoutCrewStorageInput, CrewUncheckedCreateWithoutCrewStorageInput>
    where?: CrewWhereInput
  }

  export type CrewUpdateToOneWithWhereWithoutCrewStorageInput = {
    where?: CrewWhereInput
    data: XOR<CrewUpdateWithoutCrewStorageInput, CrewUncheckedUpdateWithoutCrewStorageInput>
  }

  export type CrewUpdateWithoutCrewStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCrewNestedInput
    editedBy?: UserUpdateOneWithoutCrewEditedByNestedInput
    crewUser?: CrewUserUpdateManyWithoutCrewNestedInput
    crewInventory?: CrewInventoryUpdateManyWithoutCrewNestedInput
    crewIngredient?: CrewIngredientUpdateManyWithoutCrewNestedInput
    crewRecipeBook?: CrewRecipeBookUpdateManyWithoutCrewNestedInput
    crewBuild?: CrewBuildUpdateManyWithoutCrewNestedInput
  }

  export type CrewUncheckedUpdateWithoutCrewStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    crewUser?: CrewUserUncheckedUpdateManyWithoutCrewNestedInput
    crewInventory?: CrewInventoryUncheckedUpdateManyWithoutCrewNestedInput
    crewIngredient?: CrewIngredientUncheckedUpdateManyWithoutCrewNestedInput
    crewRecipeBook?: CrewRecipeBookUncheckedUpdateManyWithoutCrewNestedInput
    crewBuild?: CrewBuildUncheckedUpdateManyWithoutCrewNestedInput
  }

  export type IngredientCreateWithoutCrewIngredientInput = {
    id?: string
    dateCreated?: Date | string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    createdBy?: UserCreateNestedOneWithoutIngredientInput
    ingredientType: IngredientTypeCreateNestedOneWithoutIngredientInput
    touch?: TouchCreateNestedManyWithoutIngredientInput
    archivedTouch?: ArchivedTouchCreateNestedManyWithoutIngredientInput
    ingredientStorage?: IngredientStorageCreateNestedManyWithoutIngredientInput
    ingredientUser?: IngredientUserCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceCreateNestedManyWithoutIngredientInput
  }

  export type IngredientUncheckedCreateWithoutCrewIngredientInput = {
    id?: string
    dateCreated?: Date | string
    createdById?: string | null
    ingredientTypeId: string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
    touch?: TouchUncheckedCreateNestedManyWithoutIngredientInput
    archivedTouch?: ArchivedTouchUncheckedCreateNestedManyWithoutIngredientInput
    ingredientStorage?: IngredientStorageUncheckedCreateNestedManyWithoutIngredientInput
    ingredientUser?: IngredientUserUncheckedCreateNestedManyWithoutIngredientInput
    ingredientPreference?: IngredientPreferenceUncheckedCreateNestedManyWithoutIngredientInput
  }

  export type IngredientCreateOrConnectWithoutCrewIngredientInput = {
    where: IngredientWhereUniqueInput
    create: XOR<IngredientCreateWithoutCrewIngredientInput, IngredientUncheckedCreateWithoutCrewIngredientInput>
  }

  export type CrewCreateWithoutCrewIngredientInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCrewInput
    editedBy?: UserCreateNestedOneWithoutCrewEditedByInput
    crewUser?: CrewUserCreateNestedManyWithoutCrewInput
    crewInventory?: CrewInventoryCreateNestedManyWithoutCrewInput
    crewStorage?: CrewStorageCreateNestedManyWithoutCrewInput
    crewRecipeBook?: CrewRecipeBookCreateNestedManyWithoutCrewInput
    crewBuild?: CrewBuildCreateNestedManyWithoutCrewInput
  }

  export type CrewUncheckedCreateWithoutCrewIngredientInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    crewUser?: CrewUserUncheckedCreateNestedManyWithoutCrewInput
    crewInventory?: CrewInventoryUncheckedCreateNestedManyWithoutCrewInput
    crewStorage?: CrewStorageUncheckedCreateNestedManyWithoutCrewInput
    crewRecipeBook?: CrewRecipeBookUncheckedCreateNestedManyWithoutCrewInput
    crewBuild?: CrewBuildUncheckedCreateNestedManyWithoutCrewInput
  }

  export type CrewCreateOrConnectWithoutCrewIngredientInput = {
    where: CrewWhereUniqueInput
    create: XOR<CrewCreateWithoutCrewIngredientInput, CrewUncheckedCreateWithoutCrewIngredientInput>
  }

  export type IngredientUpsertWithoutCrewIngredientInput = {
    update: XOR<IngredientUpdateWithoutCrewIngredientInput, IngredientUncheckedUpdateWithoutCrewIngredientInput>
    create: XOR<IngredientCreateWithoutCrewIngredientInput, IngredientUncheckedCreateWithoutCrewIngredientInput>
    where?: IngredientWhereInput
  }

  export type IngredientUpdateToOneWithWhereWithoutCrewIngredientInput = {
    where?: IngredientWhereInput
    data: XOR<IngredientUpdateWithoutCrewIngredientInput, IngredientUncheckedUpdateWithoutCrewIngredientInput>
  }

  export type IngredientUpdateWithoutCrewIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutIngredientNestedInput
    ingredientType?: IngredientTypeUpdateOneRequiredWithoutIngredientNestedInput
    touch?: TouchUpdateManyWithoutIngredientNestedInput
    archivedTouch?: ArchivedTouchUpdateManyWithoutIngredientNestedInput
    ingredientStorage?: IngredientStorageUpdateManyWithoutIngredientNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientUncheckedUpdateWithoutCrewIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientTypeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutIngredientNestedInput
    archivedTouch?: ArchivedTouchUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutIngredientNestedInput
  }

  export type CrewUpsertWithoutCrewIngredientInput = {
    update: XOR<CrewUpdateWithoutCrewIngredientInput, CrewUncheckedUpdateWithoutCrewIngredientInput>
    create: XOR<CrewCreateWithoutCrewIngredientInput, CrewUncheckedCreateWithoutCrewIngredientInput>
    where?: CrewWhereInput
  }

  export type CrewUpdateToOneWithWhereWithoutCrewIngredientInput = {
    where?: CrewWhereInput
    data: XOR<CrewUpdateWithoutCrewIngredientInput, CrewUncheckedUpdateWithoutCrewIngredientInput>
  }

  export type CrewUpdateWithoutCrewIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCrewNestedInput
    editedBy?: UserUpdateOneWithoutCrewEditedByNestedInput
    crewUser?: CrewUserUpdateManyWithoutCrewNestedInput
    crewInventory?: CrewInventoryUpdateManyWithoutCrewNestedInput
    crewStorage?: CrewStorageUpdateManyWithoutCrewNestedInput
    crewRecipeBook?: CrewRecipeBookUpdateManyWithoutCrewNestedInput
    crewBuild?: CrewBuildUpdateManyWithoutCrewNestedInput
  }

  export type CrewUncheckedUpdateWithoutCrewIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    crewUser?: CrewUserUncheckedUpdateManyWithoutCrewNestedInput
    crewInventory?: CrewInventoryUncheckedUpdateManyWithoutCrewNestedInput
    crewStorage?: CrewStorageUncheckedUpdateManyWithoutCrewNestedInput
    crewRecipeBook?: CrewRecipeBookUncheckedUpdateManyWithoutCrewNestedInput
    crewBuild?: CrewBuildUncheckedUpdateManyWithoutCrewNestedInput
  }

  export type RecipeBookCreateWithoutCrewRecipeBookInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutRecipeBookInput
    editedBy?: UserCreateNestedOneWithoutRecipeBookEditedByInput
    recipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutRecipeBookInput
    recipeBookUser?: RecipeBookUserCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookUncheckedCreateWithoutCrewRecipeBookInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    editedById?: string | null
    recipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutRecipeBookInput
    recipeBookUser?: RecipeBookUserUncheckedCreateNestedManyWithoutRecipeBookInput
  }

  export type RecipeBookCreateOrConnectWithoutCrewRecipeBookInput = {
    where: RecipeBookWhereUniqueInput
    create: XOR<RecipeBookCreateWithoutCrewRecipeBookInput, RecipeBookUncheckedCreateWithoutCrewRecipeBookInput>
  }

  export type CrewCreateWithoutCrewRecipeBookInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCrewInput
    editedBy?: UserCreateNestedOneWithoutCrewEditedByInput
    crewUser?: CrewUserCreateNestedManyWithoutCrewInput
    crewInventory?: CrewInventoryCreateNestedManyWithoutCrewInput
    crewStorage?: CrewStorageCreateNestedManyWithoutCrewInput
    crewIngredient?: CrewIngredientCreateNestedManyWithoutCrewInput
    crewBuild?: CrewBuildCreateNestedManyWithoutCrewInput
  }

  export type CrewUncheckedCreateWithoutCrewRecipeBookInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    crewUser?: CrewUserUncheckedCreateNestedManyWithoutCrewInput
    crewInventory?: CrewInventoryUncheckedCreateNestedManyWithoutCrewInput
    crewStorage?: CrewStorageUncheckedCreateNestedManyWithoutCrewInput
    crewIngredient?: CrewIngredientUncheckedCreateNestedManyWithoutCrewInput
    crewBuild?: CrewBuildUncheckedCreateNestedManyWithoutCrewInput
  }

  export type CrewCreateOrConnectWithoutCrewRecipeBookInput = {
    where: CrewWhereUniqueInput
    create: XOR<CrewCreateWithoutCrewRecipeBookInput, CrewUncheckedCreateWithoutCrewRecipeBookInput>
  }

  export type RecipeBookUpsertWithoutCrewRecipeBookInput = {
    update: XOR<RecipeBookUpdateWithoutCrewRecipeBookInput, RecipeBookUncheckedUpdateWithoutCrewRecipeBookInput>
    create: XOR<RecipeBookCreateWithoutCrewRecipeBookInput, RecipeBookUncheckedCreateWithoutCrewRecipeBookInput>
    where?: RecipeBookWhereInput
  }

  export type RecipeBookUpdateToOneWithWhereWithoutCrewRecipeBookInput = {
    where?: RecipeBookWhereInput
    data: XOR<RecipeBookUpdateWithoutCrewRecipeBookInput, RecipeBookUncheckedUpdateWithoutCrewRecipeBookInput>
  }

  export type RecipeBookUpdateWithoutCrewRecipeBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutRecipeBookNestedInput
    editedBy?: UserUpdateOneWithoutRecipeBookEditedByNestedInput
    recipeBookBuild?: RecipeBookBuildUpdateManyWithoutRecipeBookNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutRecipeBookNestedInput
  }

  export type RecipeBookUncheckedUpdateWithoutCrewRecipeBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutRecipeBookNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutRecipeBookNestedInput
  }

  export type CrewUpsertWithoutCrewRecipeBookInput = {
    update: XOR<CrewUpdateWithoutCrewRecipeBookInput, CrewUncheckedUpdateWithoutCrewRecipeBookInput>
    create: XOR<CrewCreateWithoutCrewRecipeBookInput, CrewUncheckedCreateWithoutCrewRecipeBookInput>
    where?: CrewWhereInput
  }

  export type CrewUpdateToOneWithWhereWithoutCrewRecipeBookInput = {
    where?: CrewWhereInput
    data: XOR<CrewUpdateWithoutCrewRecipeBookInput, CrewUncheckedUpdateWithoutCrewRecipeBookInput>
  }

  export type CrewUpdateWithoutCrewRecipeBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCrewNestedInput
    editedBy?: UserUpdateOneWithoutCrewEditedByNestedInput
    crewUser?: CrewUserUpdateManyWithoutCrewNestedInput
    crewInventory?: CrewInventoryUpdateManyWithoutCrewNestedInput
    crewStorage?: CrewStorageUpdateManyWithoutCrewNestedInput
    crewIngredient?: CrewIngredientUpdateManyWithoutCrewNestedInput
    crewBuild?: CrewBuildUpdateManyWithoutCrewNestedInput
  }

  export type CrewUncheckedUpdateWithoutCrewRecipeBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    crewUser?: CrewUserUncheckedUpdateManyWithoutCrewNestedInput
    crewInventory?: CrewInventoryUncheckedUpdateManyWithoutCrewNestedInput
    crewStorage?: CrewStorageUncheckedUpdateManyWithoutCrewNestedInput
    crewIngredient?: CrewIngredientUncheckedUpdateManyWithoutCrewNestedInput
    crewBuild?: CrewBuildUncheckedUpdateManyWithoutCrewNestedInput
  }

  export type BuildCreateWithoutCrewBuildInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version?: number
    createdBy?: UserCreateNestedOneWithoutBuildInput
    editedBy?: UserCreateNestedOneWithoutBuildEditedByInput
    recipe?: RecipeCreateNestedOneWithoutBuildInput
    touch?: TouchCreateNestedManyWithoutBuildInput
    archivedBuild?: ArchivedBuildCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserCreateNestedManyWithoutBuildInput
  }

  export type BuildUncheckedCreateWithoutCrewBuildInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    editedById?: string | null
    recipeId?: string | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version?: number
    touch?: TouchUncheckedCreateNestedManyWithoutBuildInput
    archivedBuild?: ArchivedBuildUncheckedCreateNestedManyWithoutBuildInput
    RecipeBookBuild?: RecipeBookBuildUncheckedCreateNestedManyWithoutBuildInput
    buildUser?: BuildUserUncheckedCreateNestedManyWithoutBuildInput
  }

  export type BuildCreateOrConnectWithoutCrewBuildInput = {
    where: BuildWhereUniqueInput
    create: XOR<BuildCreateWithoutCrewBuildInput, BuildUncheckedCreateWithoutCrewBuildInput>
  }

  export type CrewCreateWithoutCrewBuildInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCrewInput
    editedBy?: UserCreateNestedOneWithoutCrewEditedByInput
    crewUser?: CrewUserCreateNestedManyWithoutCrewInput
    crewInventory?: CrewInventoryCreateNestedManyWithoutCrewInput
    crewStorage?: CrewStorageCreateNestedManyWithoutCrewInput
    crewIngredient?: CrewIngredientCreateNestedManyWithoutCrewInput
    crewRecipeBook?: CrewRecipeBookCreateNestedManyWithoutCrewInput
  }

  export type CrewUncheckedCreateWithoutCrewBuildInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
    editedById: string
    crewUser?: CrewUserUncheckedCreateNestedManyWithoutCrewInput
    crewInventory?: CrewInventoryUncheckedCreateNestedManyWithoutCrewInput
    crewStorage?: CrewStorageUncheckedCreateNestedManyWithoutCrewInput
    crewIngredient?: CrewIngredientUncheckedCreateNestedManyWithoutCrewInput
    crewRecipeBook?: CrewRecipeBookUncheckedCreateNestedManyWithoutCrewInput
  }

  export type CrewCreateOrConnectWithoutCrewBuildInput = {
    where: CrewWhereUniqueInput
    create: XOR<CrewCreateWithoutCrewBuildInput, CrewUncheckedCreateWithoutCrewBuildInput>
  }

  export type BuildUpsertWithoutCrewBuildInput = {
    update: XOR<BuildUpdateWithoutCrewBuildInput, BuildUncheckedUpdateWithoutCrewBuildInput>
    create: XOR<BuildCreateWithoutCrewBuildInput, BuildUncheckedCreateWithoutCrewBuildInput>
    where?: BuildWhereInput
  }

  export type BuildUpdateToOneWithWhereWithoutCrewBuildInput = {
    where?: BuildWhereInput
    data: XOR<BuildUpdateWithoutCrewBuildInput, BuildUncheckedUpdateWithoutCrewBuildInput>
  }

  export type BuildUpdateWithoutCrewBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdBy?: UserUpdateOneWithoutBuildNestedInput
    editedBy?: UserUpdateOneWithoutBuildEditedByNestedInput
    recipe?: RecipeUpdateOneWithoutBuildNestedInput
    touch?: TouchUpdateManyWithoutBuildNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateWithoutCrewBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeId?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    touch?: TouchUncheckedUpdateManyWithoutBuildNestedInput
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutBuildNestedInput
  }

  export type CrewUpsertWithoutCrewBuildInput = {
    update: XOR<CrewUpdateWithoutCrewBuildInput, CrewUncheckedUpdateWithoutCrewBuildInput>
    create: XOR<CrewCreateWithoutCrewBuildInput, CrewUncheckedCreateWithoutCrewBuildInput>
    where?: CrewWhereInput
  }

  export type CrewUpdateToOneWithWhereWithoutCrewBuildInput = {
    where?: CrewWhereInput
    data: XOR<CrewUpdateWithoutCrewBuildInput, CrewUncheckedUpdateWithoutCrewBuildInput>
  }

  export type CrewUpdateWithoutCrewBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCrewNestedInput
    editedBy?: UserUpdateOneWithoutCrewEditedByNestedInput
    crewUser?: CrewUserUpdateManyWithoutCrewNestedInput
    crewInventory?: CrewInventoryUpdateManyWithoutCrewNestedInput
    crewStorage?: CrewStorageUpdateManyWithoutCrewNestedInput
    crewIngredient?: CrewIngredientUpdateManyWithoutCrewNestedInput
    crewRecipeBook?: CrewRecipeBookUpdateManyWithoutCrewNestedInput
  }

  export type CrewUncheckedUpdateWithoutCrewBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    editedById?: StringFieldUpdateOperationsInput | string
    crewUser?: CrewUserUncheckedUpdateManyWithoutCrewNestedInput
    crewInventory?: CrewInventoryUncheckedUpdateManyWithoutCrewNestedInput
    crewStorage?: CrewStorageUncheckedUpdateManyWithoutCrewNestedInput
    crewIngredient?: CrewIngredientUncheckedUpdateManyWithoutCrewNestedInput
    crewRecipeBook?: CrewRecipeBookUncheckedUpdateManyWithoutCrewNestedInput
  }

  export type RecipeBookUserCreateManyUserInput = {
    recipeBookId: string
    permission: string
  }

  export type RecipeBookCreateManyCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    editedById?: string | null
  }

  export type RecipeBookCreateManyEditedByInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
  }

  export type RecipeCreateManyCreatedByInput = {
    id?: string
    createdAt?: Date | string
    editedAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    editedById?: string | null
  }

  export type RecipeCreateManyEditedByInput = {
    id?: string
    createdAt?: Date | string
    editedAt?: Date | string
    name: string
    origin?: string | null
    history?: string | null
    createdById?: string | null
  }

  export type BuildUserCreateManyUserInput = {
    buildId: string
    permission: string
  }

  export type BuildCreateManyCreatedByInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedById?: string | null
    recipeId?: string | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version?: number
  }

  export type BuildCreateManyEditedByInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    recipeId?: string | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version?: number
  }

  export type ArchivedBuildCreateManyCreatedByInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    buildId: string
    recipeId?: string | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version: number
  }

  export type CrewUserCreateManyUserInput = {
    crewId: string
    permission: string
  }

  export type CrewCreateManyCreatedByInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedById: string
  }

  export type CrewCreateManyEditedByInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
  }

  export type IngredientCreateManyCreatedByInput = {
    id?: string
    dateCreated?: Date | string
    ingredientTypeId: string
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
  }

  export type IngredientPreferenceCreateManyUserInput = {
    ingredientTypeId: string
    ingredientId: string
  }

  export type IngredientUserCreateManyUserInput = {
    ingredientId: string
    permission: string
  }

  export type StorageUserCreateManyUserInput = {
    storageId: string
    permission: string
  }

  export type StorageCreateManyCreatedByInput = {
    id?: string
    name: string
    description?: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedById: string
  }

  export type StorageCreateManyEditedByInput = {
    id?: string
    name: string
    description?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
  }

  export type InventoryCreateManyCreatedByInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    editedById: string
  }

  export type InventoryCreateManyEditedByInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById: string
  }

  export type InventoryUserCreateManyUserInput = {
    inventoryId: string
    permission: string
  }

  export type FollowCreateManyFollowedByInput = {
    followingId: string
    relationship: string
  }

  export type FollowCreateManyFollowingInput = {
    followedById: string
    relationship: string
  }

  export type RecipeBookUserUpdateWithoutUserInput = {
    permission?: StringFieldUpdateOperationsInput | string
    recipeBook?: RecipeBookUpdateOneRequiredWithoutRecipeBookUserNestedInput
  }

  export type RecipeBookUserUncheckedUpdateWithoutUserInput = {
    recipeBookId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookUserUncheckedUpdateManyWithoutUserInput = {
    recipeBookId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedBy?: UserUpdateOneWithoutRecipeBookEditedByNestedInput
    recipeBookBuild?: RecipeBookBuildUpdateManyWithoutRecipeBookNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutRecipeBookNestedInput
    crewRecipeBook?: CrewRecipeBookUpdateManyWithoutRecipeBookNestedInput
  }

  export type RecipeBookUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutRecipeBookNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutRecipeBookNestedInput
    crewRecipeBook?: CrewRecipeBookUncheckedUpdateManyWithoutRecipeBookNestedInput
  }

  export type RecipeBookUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeBookUpdateWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutRecipeBookNestedInput
    recipeBookBuild?: RecipeBookBuildUpdateManyWithoutRecipeBookNestedInput
    recipeBookUser?: RecipeBookUserUpdateManyWithoutRecipeBookNestedInput
    crewRecipeBook?: CrewRecipeBookUpdateManyWithoutRecipeBookNestedInput
  }

  export type RecipeBookUncheckedUpdateWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutRecipeBookNestedInput
    recipeBookUser?: RecipeBookUserUncheckedUpdateManyWithoutRecipeBookNestedInput
    crewRecipeBook?: CrewRecipeBookUncheckedUpdateManyWithoutRecipeBookNestedInput
  }

  export type RecipeBookUncheckedUpdateManyWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    editedBy?: UserUpdateOneWithoutRecipeEditedByNestedInput
    build?: BuildUpdateManyWithoutRecipeNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    build?: BuildUncheckedUpdateManyWithoutRecipeNestedInput
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeUpdateWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutRecipeNestedInput
    build?: BuildUpdateManyWithoutRecipeNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    build?: BuildUncheckedUpdateManyWithoutRecipeNestedInput
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateManyWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BuildUserUpdateWithoutUserInput = {
    permission?: StringFieldUpdateOperationsInput | string
    build?: BuildUpdateOneWithoutBuildUserNestedInput
  }

  export type BuildUserUncheckedUpdateWithoutUserInput = {
    buildId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type BuildUserUncheckedUpdateManyWithoutUserInput = {
    buildId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type BuildUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    editedBy?: UserUpdateOneWithoutBuildEditedByNestedInput
    recipe?: RecipeUpdateOneWithoutBuildNestedInput
    touch?: TouchUpdateManyWithoutBuildNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUpdateManyWithoutBuildNestedInput
    crewBuild?: CrewBuildUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeId?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    touch?: TouchUncheckedUpdateManyWithoutBuildNestedInput
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutBuildNestedInput
    crewBuild?: CrewBuildUncheckedUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeId?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
  }

  export type BuildUpdateWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdBy?: UserUpdateOneWithoutBuildNestedInput
    recipe?: RecipeUpdateOneWithoutBuildNestedInput
    touch?: TouchUpdateManyWithoutBuildNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUpdateManyWithoutBuildNestedInput
    crewBuild?: CrewBuildUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeId?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    touch?: TouchUncheckedUpdateManyWithoutBuildNestedInput
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutBuildNestedInput
    crewBuild?: CrewBuildUncheckedUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateManyWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeId?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
  }

  export type ArchivedBuildUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    build?: BuildUpdateOneRequiredWithoutArchivedBuildNestedInput
    recipe?: RecipeUpdateOneWithoutArchivedBuildNestedInput
    archivedTouch?: ArchivedTouchUpdateManyWithoutArchivedBuildNestedInput
  }

  export type ArchivedBuildUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buildId?: StringFieldUpdateOperationsInput | string
    recipeId?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    archivedTouch?: ArchivedTouchUncheckedUpdateManyWithoutArchivedBuildNestedInput
  }

  export type ArchivedBuildUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buildId?: StringFieldUpdateOperationsInput | string
    recipeId?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
  }

  export type CrewUserUpdateWithoutUserInput = {
    permission?: StringFieldUpdateOperationsInput | string
    crew?: CrewUpdateOneRequiredWithoutCrewUserNestedInput
  }

  export type CrewUserUncheckedUpdateWithoutUserInput = {
    crewId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type CrewUserUncheckedUpdateManyWithoutUserInput = {
    crewId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type CrewUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedBy?: UserUpdateOneWithoutCrewEditedByNestedInput
    crewUser?: CrewUserUpdateManyWithoutCrewNestedInput
    crewInventory?: CrewInventoryUpdateManyWithoutCrewNestedInput
    crewStorage?: CrewStorageUpdateManyWithoutCrewNestedInput
    crewIngredient?: CrewIngredientUpdateManyWithoutCrewNestedInput
    crewRecipeBook?: CrewRecipeBookUpdateManyWithoutCrewNestedInput
    crewBuild?: CrewBuildUpdateManyWithoutCrewNestedInput
  }

  export type CrewUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: StringFieldUpdateOperationsInput | string
    crewUser?: CrewUserUncheckedUpdateManyWithoutCrewNestedInput
    crewInventory?: CrewInventoryUncheckedUpdateManyWithoutCrewNestedInput
    crewStorage?: CrewStorageUncheckedUpdateManyWithoutCrewNestedInput
    crewIngredient?: CrewIngredientUncheckedUpdateManyWithoutCrewNestedInput
    crewRecipeBook?: CrewRecipeBookUncheckedUpdateManyWithoutCrewNestedInput
    crewBuild?: CrewBuildUncheckedUpdateManyWithoutCrewNestedInput
  }

  export type CrewUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: StringFieldUpdateOperationsInput | string
  }

  export type CrewUpdateWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCrewNestedInput
    crewUser?: CrewUserUpdateManyWithoutCrewNestedInput
    crewInventory?: CrewInventoryUpdateManyWithoutCrewNestedInput
    crewStorage?: CrewStorageUpdateManyWithoutCrewNestedInput
    crewIngredient?: CrewIngredientUpdateManyWithoutCrewNestedInput
    crewRecipeBook?: CrewRecipeBookUpdateManyWithoutCrewNestedInput
    crewBuild?: CrewBuildUpdateManyWithoutCrewNestedInput
  }

  export type CrewUncheckedUpdateWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    crewUser?: CrewUserUncheckedUpdateManyWithoutCrewNestedInput
    crewInventory?: CrewInventoryUncheckedUpdateManyWithoutCrewNestedInput
    crewStorage?: CrewStorageUncheckedUpdateManyWithoutCrewNestedInput
    crewIngredient?: CrewIngredientUncheckedUpdateManyWithoutCrewNestedInput
    crewRecipeBook?: CrewRecipeBookUncheckedUpdateManyWithoutCrewNestedInput
    crewBuild?: CrewBuildUncheckedUpdateManyWithoutCrewNestedInput
  }

  export type CrewUncheckedUpdateManyWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type IngredientUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientType?: IngredientTypeUpdateOneRequiredWithoutIngredientNestedInput
    touch?: TouchUpdateManyWithoutIngredientNestedInput
    archivedTouch?: ArchivedTouchUpdateManyWithoutIngredientNestedInput
    ingredientStorage?: IngredientStorageUpdateManyWithoutIngredientNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutIngredientNestedInput
    crewIngredient?: CrewIngredientUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    ingredientTypeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutIngredientNestedInput
    archivedTouch?: ArchivedTouchUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutIngredientNestedInput
    crewIngredient?: CrewIngredientUncheckedUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    ingredientTypeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IngredientPreferenceUpdateWithoutUserInput = {
    ingredientType?: IngredientTypeUpdateOneRequiredWithoutIngredientPreferenceNestedInput
    ingredient?: IngredientUpdateOneRequiredWithoutIngredientPreferenceNestedInput
  }

  export type IngredientPreferenceUncheckedUpdateWithoutUserInput = {
    ingredientTypeId?: StringFieldUpdateOperationsInput | string
    ingredientId?: StringFieldUpdateOperationsInput | string
  }

  export type IngredientPreferenceUncheckedUpdateManyWithoutUserInput = {
    ingredientTypeId?: StringFieldUpdateOperationsInput | string
    ingredientId?: StringFieldUpdateOperationsInput | string
  }

  export type IngredientUserUpdateWithoutUserInput = {
    permission?: StringFieldUpdateOperationsInput | string
    ingredient?: IngredientUpdateOneRequiredWithoutIngredientUserNestedInput
  }

  export type IngredientUserUncheckedUpdateWithoutUserInput = {
    ingredientId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type IngredientUserUncheckedUpdateManyWithoutUserInput = {
    ingredientId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type StorageUserUpdateWithoutUserInput = {
    permission?: StringFieldUpdateOperationsInput | string
    Storage?: StorageUpdateOneRequiredWithoutStorageUserNestedInput
  }

  export type StorageUserUncheckedUpdateWithoutUserInput = {
    storageId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type StorageUserUncheckedUpdateManyWithoutUserInput = {
    storageId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type StorageUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedBy?: UserUpdateOneWithoutStorageEditedByNestedInput
    inventoryStorage?: InventoryStorageUpdateManyWithoutStorageNestedInput
    ingredientStorage?: IngredientStorageUpdateManyWithoutStorageNestedInput
    storageUser?: StorageUserUpdateManyWithoutStorageNestedInput
    crewStorage?: CrewStorageUpdateManyWithoutStorageNestedInput
  }

  export type StorageUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: StringFieldUpdateOperationsInput | string
    inventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutStorageNestedInput
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutStorageNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutStorageNestedInput
    crewStorage?: CrewStorageUncheckedUpdateManyWithoutStorageNestedInput
  }

  export type StorageUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: StringFieldUpdateOperationsInput | string
  }

  export type StorageUpdateWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutStorageNestedInput
    inventoryStorage?: InventoryStorageUpdateManyWithoutStorageNestedInput
    ingredientStorage?: IngredientStorageUpdateManyWithoutStorageNestedInput
    storageUser?: StorageUserUpdateManyWithoutStorageNestedInput
    crewStorage?: CrewStorageUpdateManyWithoutStorageNestedInput
  }

  export type StorageUncheckedUpdateWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    inventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutStorageNestedInput
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutStorageNestedInput
    storageUser?: StorageUserUncheckedUpdateManyWithoutStorageNestedInput
    crewStorage?: CrewStorageUncheckedUpdateManyWithoutStorageNestedInput
  }

  export type StorageUncheckedUpdateManyWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedBy?: UserUpdateOneWithoutInventoryEditedByNestedInput
    inventoryStorage?: InventoryStorageUpdateManyWithoutInventoryNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutInventoryNestedInput
    crewInventory?: CrewInventoryUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: StringFieldUpdateOperationsInput | string
    inventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutInventoryNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutInventoryNestedInput
    crewInventory?: CrewInventoryUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedById?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryUpdateWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutInventoryNestedInput
    inventoryStorage?: InventoryStorageUpdateManyWithoutInventoryNestedInput
    inventoryUser?: InventoryUserUpdateManyWithoutInventoryNestedInput
    crewInventory?: CrewInventoryUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    inventoryStorage?: InventoryStorageUncheckedUpdateManyWithoutInventoryNestedInput
    inventoryUser?: InventoryUserUncheckedUpdateManyWithoutInventoryNestedInput
    crewInventory?: CrewInventoryUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateManyWithoutEditedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryUserUpdateWithoutUserInput = {
    permission?: StringFieldUpdateOperationsInput | string
    inventory?: InventoryUpdateOneRequiredWithoutInventoryUserNestedInput
  }

  export type InventoryUserUncheckedUpdateWithoutUserInput = {
    inventoryId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryUserUncheckedUpdateManyWithoutUserInput = {
    inventoryId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type FollowUpdateWithoutFollowedByInput = {
    relationship?: StringFieldUpdateOperationsInput | string
    following?: UserUpdateOneRequiredWithoutFollowingNestedInput
  }

  export type FollowUncheckedUpdateWithoutFollowedByInput = {
    followingId?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
  }

  export type FollowUncheckedUpdateManyWithoutFollowedByInput = {
    followingId?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
  }

  export type FollowUpdateWithoutFollowingInput = {
    relationship?: StringFieldUpdateOperationsInput | string
    followedBy?: UserUpdateOneRequiredWithoutFollowedByNestedInput
  }

  export type FollowUncheckedUpdateWithoutFollowingInput = {
    followedById?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
  }

  export type FollowUncheckedUpdateManyWithoutFollowingInput = {
    followedById?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookBuildCreateManyRecipeBookInput = {
    buildId: string
  }

  export type RecipeBookUserCreateManyRecipeBookInput = {
    userId: string
    permission: string
  }

  export type CrewRecipeBookCreateManyRecipeBookInput = {
    crewId: string
  }

  export type RecipeBookBuildUpdateWithoutRecipeBookInput = {
    build?: BuildUpdateOneRequiredWithoutRecipeBookBuildNestedInput
  }

  export type RecipeBookBuildUncheckedUpdateWithoutRecipeBookInput = {
    buildId?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookBuildUncheckedUpdateManyWithoutRecipeBookInput = {
    buildId?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookUserUpdateWithoutRecipeBookInput = {
    permission?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutRecipeBookUserNestedInput
  }

  export type RecipeBookUserUncheckedUpdateWithoutRecipeBookInput = {
    userId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookUserUncheckedUpdateManyWithoutRecipeBookInput = {
    userId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type CrewRecipeBookUpdateWithoutRecipeBookInput = {
    crew?: CrewUpdateOneRequiredWithoutCrewRecipeBookNestedInput
  }

  export type CrewRecipeBookUncheckedUpdateWithoutRecipeBookInput = {
    crewId?: StringFieldUpdateOperationsInput | string
  }

  export type CrewRecipeBookUncheckedUpdateManyWithoutRecipeBookInput = {
    crewId?: StringFieldUpdateOperationsInput | string
  }

  export type TouchCreateManyBuildInput = {
    id?: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    ingredientTypeId: string
    ingredientId?: string | null
    version?: number | null
  }

  export type ArchivedBuildCreateManyBuildInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    createdById?: string | null
    recipeId?: string | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version: number
  }

  export type RecipeBookBuildCreateManyBuildInput = {
    recipeBookId: string
  }

  export type BuildUserCreateManyBuildInput = {
    userId: string
    permission: string
  }

  export type CrewBuildCreateManyBuildInput = {
    crewId: string
  }

  export type TouchUpdateWithoutBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    ingredientType?: IngredientTypeUpdateOneRequiredWithoutTouchNestedInput
    ingredient?: IngredientUpdateOneWithoutTouchNestedInput
  }

  export type TouchUncheckedUpdateWithoutBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientTypeId?: StringFieldUpdateOperationsInput | string
    ingredientId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TouchUncheckedUpdateManyWithoutBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientTypeId?: StringFieldUpdateOperationsInput | string
    ingredientId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ArchivedBuildUpdateWithoutBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdBy?: UserUpdateOneWithoutArchivedBuildNestedInput
    recipe?: RecipeUpdateOneWithoutArchivedBuildNestedInput
    archivedTouch?: ArchivedTouchUpdateManyWithoutArchivedBuildNestedInput
  }

  export type ArchivedBuildUncheckedUpdateWithoutBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeId?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    archivedTouch?: ArchivedTouchUncheckedUpdateManyWithoutArchivedBuildNestedInput
  }

  export type ArchivedBuildUncheckedUpdateManyWithoutBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    recipeId?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
  }

  export type RecipeBookBuildUpdateWithoutBuildInput = {
    recipeBook?: RecipeBookUpdateOneRequiredWithoutRecipeBookBuildNestedInput
  }

  export type RecipeBookBuildUncheckedUpdateWithoutBuildInput = {
    recipeBookId?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeBookBuildUncheckedUpdateManyWithoutBuildInput = {
    recipeBookId?: StringFieldUpdateOperationsInput | string
  }

  export type BuildUserUpdateWithoutBuildInput = {
    permission?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneWithoutBuildUserNestedInput
  }

  export type BuildUserUncheckedUpdateWithoutBuildInput = {
    userId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type BuildUserUncheckedUpdateManyWithoutBuildInput = {
    userId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type CrewBuildUpdateWithoutBuildInput = {
    crew?: CrewUpdateOneRequiredWithoutCrewBuildNestedInput
  }

  export type CrewBuildUncheckedUpdateWithoutBuildInput = {
    crewId?: StringFieldUpdateOperationsInput | string
  }

  export type CrewBuildUncheckedUpdateManyWithoutBuildInput = {
    crewId?: StringFieldUpdateOperationsInput | string
  }

  export type ArchivedTouchCreateManyArchivedBuildInput = {
    id?: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    ingredientTypeId: string
    ingredientId?: string | null
    version?: number | null
  }

  export type ArchivedTouchUpdateWithoutArchivedBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    ingredientType?: IngredientTypeUpdateOneRequiredWithoutArchivedTouchNestedInput
    ingredient?: IngredientUpdateOneWithoutArchivedTouchNestedInput
  }

  export type ArchivedTouchUncheckedUpdateWithoutArchivedBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientTypeId?: StringFieldUpdateOperationsInput | string
    ingredientId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ArchivedTouchUncheckedUpdateManyWithoutArchivedBuildInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientTypeId?: StringFieldUpdateOperationsInput | string
    ingredientId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BuildCreateManyRecipeInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    editedAt?: Date | string
    createdById?: string | null
    editedById?: string | null
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version?: number
  }

  export type ArchivedBuildCreateManyRecipeInput = {
    id?: string
    buildName?: string
    createdAt?: Date | string
    createdById?: string | null
    buildId: string
    instructions?: string | null
    notes?: string | null
    glassware?: string | null
    ice?: string | null
    version: number
  }

  export type BuildUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdBy?: UserUpdateOneWithoutBuildNestedInput
    editedBy?: UserUpdateOneWithoutBuildEditedByNestedInput
    touch?: TouchUpdateManyWithoutBuildNestedInput
    archivedBuild?: ArchivedBuildUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUpdateManyWithoutBuildNestedInput
    crewBuild?: CrewBuildUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    touch?: TouchUncheckedUpdateManyWithoutBuildNestedInput
    archivedBuild?: ArchivedBuildUncheckedUpdateManyWithoutBuildNestedInput
    RecipeBookBuild?: RecipeBookBuildUncheckedUpdateManyWithoutBuildNestedInput
    buildUser?: BuildUserUncheckedUpdateManyWithoutBuildNestedInput
    crewBuild?: CrewBuildUncheckedUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateManyWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    editedById?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
  }

  export type ArchivedBuildUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdBy?: UserUpdateOneWithoutArchivedBuildNestedInput
    build?: BuildUpdateOneRequiredWithoutArchivedBuildNestedInput
    archivedTouch?: ArchivedTouchUpdateManyWithoutArchivedBuildNestedInput
  }

  export type ArchivedBuildUncheckedUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    buildId?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    archivedTouch?: ArchivedTouchUncheckedUpdateManyWithoutArchivedBuildNestedInput
  }

  export type ArchivedBuildUncheckedUpdateManyWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    buildId?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
  }

  export type TouchCreateManyIngredientTypeInput = {
    id?: string
    buildId: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    ingredientId?: string | null
    version?: number | null
  }

  export type ArchivedTouchCreateManyIngredientTypeInput = {
    id?: string
    archivedBuildId: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    ingredientId?: string | null
    version?: number | null
  }

  export type IngredientCreateManyIngredientTypeInput = {
    id?: string
    dateCreated?: Date | string
    createdById?: string | null
    name?: string
    description: string
    price?: number | null
    amount?: number | null
    unit?: string | null
    source?: string | null
  }

  export type IngredientPreferenceCreateManyIngredientTypeInput = {
    ingredientId: string
    userId: string
  }

  export type TouchUpdateWithoutIngredientTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    build?: BuildUpdateOneRequiredWithoutTouchNestedInput
    ingredient?: IngredientUpdateOneWithoutTouchNestedInput
  }

  export type TouchUncheckedUpdateWithoutIngredientTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TouchUncheckedUpdateManyWithoutIngredientTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ArchivedTouchUpdateWithoutIngredientTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    archivedBuild?: ArchivedBuildUpdateOneRequiredWithoutArchivedTouchNestedInput
    ingredient?: IngredientUpdateOneWithoutArchivedTouchNestedInput
  }

  export type ArchivedTouchUncheckedUpdateWithoutIngredientTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    archivedBuildId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ArchivedTouchUncheckedUpdateManyWithoutIngredientTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    archivedBuildId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type IngredientUpdateWithoutIngredientTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutIngredientNestedInput
    touch?: TouchUpdateManyWithoutIngredientNestedInput
    archivedTouch?: ArchivedTouchUpdateManyWithoutIngredientNestedInput
    ingredientStorage?: IngredientStorageUpdateManyWithoutIngredientNestedInput
    ingredientUser?: IngredientUserUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUpdateManyWithoutIngredientNestedInput
    crewIngredient?: CrewIngredientUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientUncheckedUpdateWithoutIngredientTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: TouchUncheckedUpdateManyWithoutIngredientNestedInput
    archivedTouch?: ArchivedTouchUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientStorage?: IngredientStorageUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientUser?: IngredientUserUncheckedUpdateManyWithoutIngredientNestedInput
    ingredientPreference?: IngredientPreferenceUncheckedUpdateManyWithoutIngredientNestedInput
    crewIngredient?: CrewIngredientUncheckedUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientUncheckedUpdateManyWithoutIngredientTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IngredientPreferenceUpdateWithoutIngredientTypeInput = {
    ingredient?: IngredientUpdateOneRequiredWithoutIngredientPreferenceNestedInput
    user?: UserUpdateOneRequiredWithoutIngredientPreferenceNestedInput
  }

  export type IngredientPreferenceUncheckedUpdateWithoutIngredientTypeInput = {
    ingredientId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type IngredientPreferenceUncheckedUpdateManyWithoutIngredientTypeInput = {
    ingredientId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TouchCreateManyIngredientInput = {
    id?: string
    buildId: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    ingredientTypeId: string
    version?: number | null
  }

  export type ArchivedTouchCreateManyIngredientInput = {
    id?: string
    archivedBuildId: string
    order?: number | null
    amount?: number | null
    unit?: string | null
    ingredientTypeId: string
    version?: number | null
  }

  export type IngredientStorageCreateManyIngredientInput = {
    storageId: string
    quantity?: number | null
  }

  export type IngredientUserCreateManyIngredientInput = {
    userId: string
    permission: string
  }

  export type IngredientPreferenceCreateManyIngredientInput = {
    ingredientTypeId: string
    userId: string
  }

  export type CrewIngredientCreateManyIngredientInput = {
    crewId: string
  }

  export type TouchUpdateWithoutIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    build?: BuildUpdateOneRequiredWithoutTouchNestedInput
    ingredientType?: IngredientTypeUpdateOneRequiredWithoutTouchNestedInput
  }

  export type TouchUncheckedUpdateWithoutIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientTypeId?: StringFieldUpdateOperationsInput | string
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TouchUncheckedUpdateManyWithoutIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientTypeId?: StringFieldUpdateOperationsInput | string
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ArchivedTouchUpdateWithoutIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    archivedBuild?: ArchivedBuildUpdateOneRequiredWithoutArchivedTouchNestedInput
    ingredientType?: IngredientTypeUpdateOneRequiredWithoutArchivedTouchNestedInput
  }

  export type ArchivedTouchUncheckedUpdateWithoutIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    archivedBuildId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientTypeId?: StringFieldUpdateOperationsInput | string
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ArchivedTouchUncheckedUpdateManyWithoutIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    archivedBuildId?: StringFieldUpdateOperationsInput | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientTypeId?: StringFieldUpdateOperationsInput | string
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type IngredientStorageUpdateWithoutIngredientInput = {
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    Storage?: StorageUpdateOneRequiredWithoutIngredientStorageNestedInput
  }

  export type IngredientStorageUncheckedUpdateWithoutIngredientInput = {
    storageId?: StringFieldUpdateOperationsInput | string
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type IngredientStorageUncheckedUpdateManyWithoutIngredientInput = {
    storageId?: StringFieldUpdateOperationsInput | string
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type IngredientUserUpdateWithoutIngredientInput = {
    permission?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutIngredientUserNestedInput
  }

  export type IngredientUserUncheckedUpdateWithoutIngredientInput = {
    userId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type IngredientUserUncheckedUpdateManyWithoutIngredientInput = {
    userId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type IngredientPreferenceUpdateWithoutIngredientInput = {
    ingredientType?: IngredientTypeUpdateOneRequiredWithoutIngredientPreferenceNestedInput
    user?: UserUpdateOneRequiredWithoutIngredientPreferenceNestedInput
  }

  export type IngredientPreferenceUncheckedUpdateWithoutIngredientInput = {
    ingredientTypeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type IngredientPreferenceUncheckedUpdateManyWithoutIngredientInput = {
    ingredientTypeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CrewIngredientUpdateWithoutIngredientInput = {
    crew?: CrewUpdateOneRequiredWithoutCrewIngredientNestedInput
  }

  export type CrewIngredientUncheckedUpdateWithoutIngredientInput = {
    crewId?: StringFieldUpdateOperationsInput | string
  }

  export type CrewIngredientUncheckedUpdateManyWithoutIngredientInput = {
    crewId?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryStorageCreateManyInventoryInput = {
    storageId: string
  }

  export type InventoryUserCreateManyInventoryInput = {
    userId: string
    permission: string
  }

  export type CrewInventoryCreateManyInventoryInput = {
    crewId: string
  }

  export type InventoryStorageUpdateWithoutInventoryInput = {
    storage?: StorageUpdateOneRequiredWithoutInventoryStorageNestedInput
  }

  export type InventoryStorageUncheckedUpdateWithoutInventoryInput = {
    storageId?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryStorageUncheckedUpdateManyWithoutInventoryInput = {
    storageId?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryUserUpdateWithoutInventoryInput = {
    permission?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutInventoryUserNestedInput
  }

  export type InventoryUserUncheckedUpdateWithoutInventoryInput = {
    userId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryUserUncheckedUpdateManyWithoutInventoryInput = {
    userId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type CrewInventoryUpdateWithoutInventoryInput = {
    crew?: CrewUpdateOneRequiredWithoutCrewInventoryNestedInput
  }

  export type CrewInventoryUncheckedUpdateWithoutInventoryInput = {
    crewId?: StringFieldUpdateOperationsInput | string
  }

  export type CrewInventoryUncheckedUpdateManyWithoutInventoryInput = {
    crewId?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryStorageCreateManyStorageInput = {
    inventoryId: string
  }

  export type IngredientStorageCreateManyStorageInput = {
    ingredientId: string
    quantity?: number | null
  }

  export type StorageUserCreateManyStorageInput = {
    userId: string
    permission: string
  }

  export type CrewStorageCreateManyStorageInput = {
    crewId: string
  }

  export type InventoryStorageUpdateWithoutStorageInput = {
    inventory?: InventoryUpdateOneRequiredWithoutInventoryStorageNestedInput
  }

  export type InventoryStorageUncheckedUpdateWithoutStorageInput = {
    inventoryId?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryStorageUncheckedUpdateManyWithoutStorageInput = {
    inventoryId?: StringFieldUpdateOperationsInput | string
  }

  export type IngredientStorageUpdateWithoutStorageInput = {
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    ingredient?: IngredientUpdateOneRequiredWithoutIngredientStorageNestedInput
  }

  export type IngredientStorageUncheckedUpdateWithoutStorageInput = {
    ingredientId?: StringFieldUpdateOperationsInput | string
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type IngredientStorageUncheckedUpdateManyWithoutStorageInput = {
    ingredientId?: StringFieldUpdateOperationsInput | string
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type StorageUserUpdateWithoutStorageInput = {
    permission?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutStorageUserNestedInput
  }

  export type StorageUserUncheckedUpdateWithoutStorageInput = {
    userId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type StorageUserUncheckedUpdateManyWithoutStorageInput = {
    userId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type CrewStorageUpdateWithoutStorageInput = {
    crew?: CrewUpdateOneRequiredWithoutCrewStorageNestedInput
  }

  export type CrewStorageUncheckedUpdateWithoutStorageInput = {
    crewId?: StringFieldUpdateOperationsInput | string
  }

  export type CrewStorageUncheckedUpdateManyWithoutStorageInput = {
    crewId?: StringFieldUpdateOperationsInput | string
  }

  export type CrewUserCreateManyCrewInput = {
    userId: string
    permission: string
  }

  export type CrewInventoryCreateManyCrewInput = {
    inventoryId: string
  }

  export type CrewStorageCreateManyCrewInput = {
    storageId: string
  }

  export type CrewIngredientCreateManyCrewInput = {
    ingredientId: string
  }

  export type CrewRecipeBookCreateManyCrewInput = {
    recipeBookId: string
  }

  export type CrewBuildCreateManyCrewInput = {
    buildId: string
  }

  export type CrewUserUpdateWithoutCrewInput = {
    permission?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutCrewUserNestedInput
  }

  export type CrewUserUncheckedUpdateWithoutCrewInput = {
    userId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type CrewUserUncheckedUpdateManyWithoutCrewInput = {
    userId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type CrewInventoryUpdateWithoutCrewInput = {
    inventory?: InventoryUpdateOneRequiredWithoutCrewInventoryNestedInput
  }

  export type CrewInventoryUncheckedUpdateWithoutCrewInput = {
    inventoryId?: StringFieldUpdateOperationsInput | string
  }

  export type CrewInventoryUncheckedUpdateManyWithoutCrewInput = {
    inventoryId?: StringFieldUpdateOperationsInput | string
  }

  export type CrewStorageUpdateWithoutCrewInput = {
    storage?: StorageUpdateOneRequiredWithoutCrewStorageNestedInput
  }

  export type CrewStorageUncheckedUpdateWithoutCrewInput = {
    storageId?: StringFieldUpdateOperationsInput | string
  }

  export type CrewStorageUncheckedUpdateManyWithoutCrewInput = {
    storageId?: StringFieldUpdateOperationsInput | string
  }

  export type CrewIngredientUpdateWithoutCrewInput = {
    ingredient?: IngredientUpdateOneRequiredWithoutCrewIngredientNestedInput
  }

  export type CrewIngredientUncheckedUpdateWithoutCrewInput = {
    ingredientId?: StringFieldUpdateOperationsInput | string
  }

  export type CrewIngredientUncheckedUpdateManyWithoutCrewInput = {
    ingredientId?: StringFieldUpdateOperationsInput | string
  }

  export type CrewRecipeBookUpdateWithoutCrewInput = {
    recipeBook?: RecipeBookUpdateOneRequiredWithoutCrewRecipeBookNestedInput
  }

  export type CrewRecipeBookUncheckedUpdateWithoutCrewInput = {
    recipeBookId?: StringFieldUpdateOperationsInput | string
  }

  export type CrewRecipeBookUncheckedUpdateManyWithoutCrewInput = {
    recipeBookId?: StringFieldUpdateOperationsInput | string
  }

  export type CrewBuildUpdateWithoutCrewInput = {
    build?: BuildUpdateOneRequiredWithoutCrewBuildNestedInput
  }

  export type CrewBuildUncheckedUpdateWithoutCrewInput = {
    buildId?: StringFieldUpdateOperationsInput | string
  }

  export type CrewBuildUncheckedUpdateManyWithoutCrewInput = {
    buildId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecipeBookCountOutputTypeDefaultArgs instead
     */
    export type RecipeBookCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecipeBookCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BuildCountOutputTypeDefaultArgs instead
     */
    export type BuildCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BuildCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ArchivedBuildCountOutputTypeDefaultArgs instead
     */
    export type ArchivedBuildCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ArchivedBuildCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecipeCountOutputTypeDefaultArgs instead
     */
    export type RecipeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecipeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IngredientTypeCountOutputTypeDefaultArgs instead
     */
    export type IngredientTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IngredientTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IngredientCountOutputTypeDefaultArgs instead
     */
    export type IngredientCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IngredientCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventoryCountOutputTypeDefaultArgs instead
     */
    export type InventoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StorageCountOutputTypeDefaultArgs instead
     */
    export type StorageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StorageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CrewCountOutputTypeDefaultArgs instead
     */
    export type CrewCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CrewCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FollowDefaultArgs instead
     */
    export type FollowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FollowDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileDefaultArgs instead
     */
    export type ProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecipeBookDefaultArgs instead
     */
    export type RecipeBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecipeBookDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecipeBookUserDefaultArgs instead
     */
    export type RecipeBookUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecipeBookUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BuildDefaultArgs instead
     */
    export type BuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BuildDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ArchivedBuildDefaultArgs instead
     */
    export type ArchivedBuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ArchivedBuildDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BuildUserDefaultArgs instead
     */
    export type BuildUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BuildUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecipeDefaultArgs instead
     */
    export type RecipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecipeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecipeBookBuildDefaultArgs instead
     */
    export type RecipeBookBuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecipeBookBuildDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TouchDefaultArgs instead
     */
    export type TouchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TouchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ArchivedTouchDefaultArgs instead
     */
    export type ArchivedTouchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ArchivedTouchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IngredientTypeDefaultArgs instead
     */
    export type IngredientTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IngredientTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IngredientDefaultArgs instead
     */
    export type IngredientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IngredientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IngredientUserDefaultArgs instead
     */
    export type IngredientUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IngredientUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IngredientPreferenceDefaultArgs instead
     */
    export type IngredientPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IngredientPreferenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventoryDefaultArgs instead
     */
    export type InventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventoryUserDefaultArgs instead
     */
    export type InventoryUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventoryUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StorageDefaultArgs instead
     */
    export type StorageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StorageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventoryStorageDefaultArgs instead
     */
    export type InventoryStorageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventoryStorageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IngredientStorageDefaultArgs instead
     */
    export type IngredientStorageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IngredientStorageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StorageUserDefaultArgs instead
     */
    export type StorageUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StorageUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CrewDefaultArgs instead
     */
    export type CrewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CrewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CrewUserDefaultArgs instead
     */
    export type CrewUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CrewUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CrewInventoryDefaultArgs instead
     */
    export type CrewInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CrewInventoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CrewStorageDefaultArgs instead
     */
    export type CrewStorageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CrewStorageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CrewIngredientDefaultArgs instead
     */
    export type CrewIngredientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CrewIngredientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CrewRecipeBookDefaultArgs instead
     */
    export type CrewRecipeBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CrewRecipeBookDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CrewBuildDefaultArgs instead
     */
    export type CrewBuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CrewBuildDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}