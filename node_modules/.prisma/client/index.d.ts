
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Groups
 * 
 */
export type Groups = {
  id: number
  groupName: string
  dateCreated: Date
}

/**
 * Model GroupIngredient
 * 
 */
export type GroupIngredient = {
  groupId: number
  ingredientId: number
}

/**
 * Model GroupMod
 * 
 */
export type GroupMod = {
  userId: string
  groupId: number
}

/**
 * Model GroupSpec
 * 
 */
export type GroupSpec = {
  groupId: number
  specId: number
}

/**
 * Model GroupUser
 * 
 */
export type GroupUser = {
  userId: string
  groupId: number
}

/**
 * Model Ingredient
 * 
 */
export type Ingredient = {
  id: number
  dateCreated: Date
  name: string
  amount: number | null
  unit: string | null
  price: Prisma.Decimal | null
  source: string | null
  postedById: string
}

/**
 * Model Touch
 * 
 */
export type Touch = {
  id: number
  ingredientId: number | null
  order: number | null
  amount: number | null
  unit: string | null
  specId: number | null
  postedById: string
}

/**
 * Model Recipe
 * 
 */
export type Recipe = {
  id: number
  createdAt: Date
  name: string
  origin: string
  history: string | null
  postedById: string
}

/**
 * Model Spec
 * 
 */
export type Spec = {
  id: number
  specName: string
  postedById: string
  instructions: string | null
  glassware: string | null
  ice: string | null
  recipeId: number | null
}

/**
 * Model UserData
 * 
 */
export type UserData = {
  id: number
  userId: string | null
  userBio: string | null
  workPlace: string | null
  profilePicture: string | null
}

/**
 * Model User
 * 
 */
export type User = {
  id: string
  userName: string
  firstName: string | null
  lastName: string | null
  dateJoined: Date
  email: string
  password: string
}

/**
 * Model SharedIngredient
 * 
 */
export type SharedIngredient = {
  userId: string
  ingredientId: number
  sharedById: string
  sharedAt: Date
}

/**
 * Model SharedSpec
 * 
 */
export type SharedSpec = {
  userId: string
  specId: number
  sharedById: string
  sharedAt: Date
}

/**
 * Model AdminOnSpec
 * 
 */
export type AdminOnSpec = {
  userId: string
  specId: number
  assignedById: string
  assignedAt: Date
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Groups
 * const groups = await prisma.groups.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Groups
   * const groups = await prisma.groups.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.groups`: Exposes CRUD operations for the **Groups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups
    * const groups = await prisma.groups.findMany()
    * ```
    */
  get groups(): Prisma.GroupsDelegate<GlobalReject>;

  /**
   * `prisma.groupIngredient`: Exposes CRUD operations for the **GroupIngredient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupIngredients
    * const groupIngredients = await prisma.groupIngredient.findMany()
    * ```
    */
  get groupIngredient(): Prisma.GroupIngredientDelegate<GlobalReject>;

  /**
   * `prisma.groupMod`: Exposes CRUD operations for the **GroupMod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupMods
    * const groupMods = await prisma.groupMod.findMany()
    * ```
    */
  get groupMod(): Prisma.GroupModDelegate<GlobalReject>;

  /**
   * `prisma.groupSpec`: Exposes CRUD operations for the **GroupSpec** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupSpecs
    * const groupSpecs = await prisma.groupSpec.findMany()
    * ```
    */
  get groupSpec(): Prisma.GroupSpecDelegate<GlobalReject>;

  /**
   * `prisma.groupUser`: Exposes CRUD operations for the **GroupUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupUsers
    * const groupUsers = await prisma.groupUser.findMany()
    * ```
    */
  get groupUser(): Prisma.GroupUserDelegate<GlobalReject>;

  /**
   * `prisma.ingredient`: Exposes CRUD operations for the **Ingredient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ingredients
    * const ingredients = await prisma.ingredient.findMany()
    * ```
    */
  get ingredient(): Prisma.IngredientDelegate<GlobalReject>;

  /**
   * `prisma.touch`: Exposes CRUD operations for the **Touch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Touches
    * const touches = await prisma.touch.findMany()
    * ```
    */
  get touch(): Prisma.TouchDelegate<GlobalReject>;

  /**
   * `prisma.recipe`: Exposes CRUD operations for the **Recipe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recipes
    * const recipes = await prisma.recipe.findMany()
    * ```
    */
  get recipe(): Prisma.RecipeDelegate<GlobalReject>;

  /**
   * `prisma.spec`: Exposes CRUD operations for the **Spec** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Specs
    * const specs = await prisma.spec.findMany()
    * ```
    */
  get spec(): Prisma.SpecDelegate<GlobalReject>;

  /**
   * `prisma.userData`: Exposes CRUD operations for the **UserData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserData
    * const userData = await prisma.userData.findMany()
    * ```
    */
  get userData(): Prisma.UserDataDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.sharedIngredient`: Exposes CRUD operations for the **SharedIngredient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SharedIngredients
    * const sharedIngredients = await prisma.sharedIngredient.findMany()
    * ```
    */
  get sharedIngredient(): Prisma.SharedIngredientDelegate<GlobalReject>;

  /**
   * `prisma.sharedSpec`: Exposes CRUD operations for the **SharedSpec** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SharedSpecs
    * const sharedSpecs = await prisma.sharedSpec.findMany()
    * ```
    */
  get sharedSpec(): Prisma.SharedSpecDelegate<GlobalReject>;

  /**
   * `prisma.adminOnSpec`: Exposes CRUD operations for the **AdminOnSpec** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminOnSpecs
    * const adminOnSpecs = await prisma.adminOnSpec.findMany()
    * ```
    */
  get adminOnSpec(): Prisma.AdminOnSpecDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export import Metrics = runtime.Metrics
  export import Metric = runtime.Metric
  export import MetricHistogram = runtime.MetricHistogram
  export import MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
   * Prisma Client JS version: 4.3.1
   * Query Engine version: c875e43600dfe042452e0b868f7a48b817b9640b
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export import FieldRef = runtime.FieldRef

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Groups: 'Groups',
    GroupIngredient: 'GroupIngredient',
    GroupMod: 'GroupMod',
    GroupSpec: 'GroupSpec',
    GroupUser: 'GroupUser',
    Ingredient: 'Ingredient',
    Touch: 'Touch',
    Recipe: 'Recipe',
    Spec: 'Spec',
    UserData: 'UserData',
    User: 'User',
    SharedIngredient: 'SharedIngredient',
    SharedSpec: 'SharedSpec',
    AdminOnSpec: 'AdminOnSpec'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type GroupsCountOutputType
   */


  export type GroupsCountOutputType = {
    groupIngredient: number
    GroupMod: number
    GroupSpec: number
    GroupUser: number
  }

  export type GroupsCountOutputTypeSelect = {
    groupIngredient?: boolean
    GroupMod?: boolean
    GroupSpec?: boolean
    GroupUser?: boolean
  }

  export type GroupsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | GroupsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? GroupsCountOutputType
    : S extends undefined
    ? never
    : S extends GroupsCountOutputTypeArgs
    ?'include' extends U
    ? GroupsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof GroupsCountOutputType ? GroupsCountOutputType[P] : never
  } 
    : GroupsCountOutputType
  : GroupsCountOutputType




  // Custom InputTypes

  /**
   * GroupsCountOutputType without action
   */
  export type GroupsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the GroupsCountOutputType
     * 
    **/
    select?: GroupsCountOutputTypeSelect | null
  }



  /**
   * Count Type IngredientCountOutputType
   */


  export type IngredientCountOutputType = {
    groupIngredient: number
    touch: number
    sharedIngredient: number
  }

  export type IngredientCountOutputTypeSelect = {
    groupIngredient?: boolean
    touch?: boolean
    sharedIngredient?: boolean
  }

  export type IngredientCountOutputTypeGetPayload<
    S extends boolean | null | undefined | IngredientCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? IngredientCountOutputType
    : S extends undefined
    ? never
    : S extends IngredientCountOutputTypeArgs
    ?'include' extends U
    ? IngredientCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof IngredientCountOutputType ? IngredientCountOutputType[P] : never
  } 
    : IngredientCountOutputType
  : IngredientCountOutputType




  // Custom InputTypes

  /**
   * IngredientCountOutputType without action
   */
  export type IngredientCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the IngredientCountOutputType
     * 
    **/
    select?: IngredientCountOutputTypeSelect | null
  }



  /**
   * Count Type RecipeCountOutputType
   */


  export type RecipeCountOutputType = {
    spec: number
  }

  export type RecipeCountOutputTypeSelect = {
    spec?: boolean
  }

  export type RecipeCountOutputTypeGetPayload<
    S extends boolean | null | undefined | RecipeCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? RecipeCountOutputType
    : S extends undefined
    ? never
    : S extends RecipeCountOutputTypeArgs
    ?'include' extends U
    ? RecipeCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof RecipeCountOutputType ? RecipeCountOutputType[P] : never
  } 
    : RecipeCountOutputType
  : RecipeCountOutputType




  // Custom InputTypes

  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RecipeCountOutputType
     * 
    **/
    select?: RecipeCountOutputTypeSelect | null
  }



  /**
   * Count Type SpecCountOutputType
   */


  export type SpecCountOutputType = {
    groupSpec: number
    sharedSpec: number
    touch: number
    adminOnSpec: number
  }

  export type SpecCountOutputTypeSelect = {
    groupSpec?: boolean
    sharedSpec?: boolean
    touch?: boolean
    adminOnSpec?: boolean
  }

  export type SpecCountOutputTypeGetPayload<
    S extends boolean | null | undefined | SpecCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? SpecCountOutputType
    : S extends undefined
    ? never
    : S extends SpecCountOutputTypeArgs
    ?'include' extends U
    ? SpecCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof SpecCountOutputType ? SpecCountOutputType[P] : never
  } 
    : SpecCountOutputType
  : SpecCountOutputType




  // Custom InputTypes

  /**
   * SpecCountOutputType without action
   */
  export type SpecCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SpecCountOutputType
     * 
    **/
    select?: SpecCountOutputTypeSelect | null
  }



  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    groupMod: number
    groupUser: number
    userData: number
    sharedIngredient: number
    ingredientSharedBy: number
    sharedSpec: number
    specSharedBy: number
    recipes: number
    spec: number
    ingredient: number
    touch: number
    adminOnSpec: number
    adminAssignedBy: number
  }

  export type UserCountOutputTypeSelect = {
    groupMod?: boolean
    groupUser?: boolean
    userData?: boolean
    sharedIngredient?: boolean
    ingredientSharedBy?: boolean
    sharedSpec?: boolean
    specSharedBy?: boolean
    recipes?: boolean
    spec?: boolean
    ingredient?: boolean
    touch?: boolean
    adminOnSpec?: boolean
    adminAssignedBy?: boolean
  }

  export type UserCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UserCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UserCountOutputType
    : S extends undefined
    ? never
    : S extends UserCountOutputTypeArgs
    ?'include' extends U
    ? UserCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
    : UserCountOutputType
  : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Groups
   */


  export type AggregateGroups = {
    _count: GroupsCountAggregateOutputType | null
    _avg: GroupsAvgAggregateOutputType | null
    _sum: GroupsSumAggregateOutputType | null
    _min: GroupsMinAggregateOutputType | null
    _max: GroupsMaxAggregateOutputType | null
  }

  export type GroupsAvgAggregateOutputType = {
    id: number | null
  }

  export type GroupsSumAggregateOutputType = {
    id: number | null
  }

  export type GroupsMinAggregateOutputType = {
    id: number | null
    groupName: string | null
    dateCreated: Date | null
  }

  export type GroupsMaxAggregateOutputType = {
    id: number | null
    groupName: string | null
    dateCreated: Date | null
  }

  export type GroupsCountAggregateOutputType = {
    id: number
    groupName: number
    dateCreated: number
    _all: number
  }


  export type GroupsAvgAggregateInputType = {
    id?: true
  }

  export type GroupsSumAggregateInputType = {
    id?: true
  }

  export type GroupsMinAggregateInputType = {
    id?: true
    groupName?: true
    dateCreated?: true
  }

  export type GroupsMaxAggregateInputType = {
    id?: true
    groupName?: true
    dateCreated?: true
  }

  export type GroupsCountAggregateInputType = {
    id?: true
    groupName?: true
    dateCreated?: true
    _all?: true
  }

  export type GroupsAggregateArgs = {
    /**
     * Filter which Groups to aggregate.
     * 
    **/
    where?: GroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     * 
    **/
    orderBy?: Enumerable<GroupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: GroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Groups
    **/
    _count?: true | GroupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupsMaxAggregateInputType
  }

  export type GetGroupsAggregateType<T extends GroupsAggregateArgs> = {
        [P in keyof T & keyof AggregateGroups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroups[P]>
      : GetScalarType<T[P], AggregateGroups[P]>
  }




  export type GroupsGroupByArgs = {
    where?: GroupsWhereInput
    orderBy?: Enumerable<GroupsOrderByWithAggregationInput>
    by: Array<GroupsScalarFieldEnum>
    having?: GroupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupsCountAggregateInputType | true
    _avg?: GroupsAvgAggregateInputType
    _sum?: GroupsSumAggregateInputType
    _min?: GroupsMinAggregateInputType
    _max?: GroupsMaxAggregateInputType
  }


  export type GroupsGroupByOutputType = {
    id: number
    groupName: string
    dateCreated: Date
    _count: GroupsCountAggregateOutputType | null
    _avg: GroupsAvgAggregateOutputType | null
    _sum: GroupsSumAggregateOutputType | null
    _min: GroupsMinAggregateOutputType | null
    _max: GroupsMaxAggregateOutputType | null
  }

  type GetGroupsGroupByPayload<T extends GroupsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<GroupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupsGroupByOutputType[P]>
            : GetScalarType<T[P], GroupsGroupByOutputType[P]>
        }
      >
    >


  export type GroupsSelect = {
    id?: boolean
    groupName?: boolean
    dateCreated?: boolean
    groupIngredient?: boolean | GroupIngredientFindManyArgs
    GroupMod?: boolean | GroupModFindManyArgs
    GroupSpec?: boolean | GroupSpecFindManyArgs
    GroupUser?: boolean | GroupUserFindManyArgs
    _count?: boolean | GroupsCountOutputTypeArgs
  }

  export type GroupsInclude = {
    groupIngredient?: boolean | GroupIngredientFindManyArgs
    GroupMod?: boolean | GroupModFindManyArgs
    GroupSpec?: boolean | GroupSpecFindManyArgs
    GroupUser?: boolean | GroupUserFindManyArgs
    _count?: boolean | GroupsCountOutputTypeArgs
  }

  export type GroupsGetPayload<
    S extends boolean | null | undefined | GroupsArgs,
    U = keyof S
      > = S extends true
        ? Groups
    : S extends undefined
    ? never
    : S extends GroupsArgs | GroupsFindManyArgs
    ?'include' extends U
    ? Groups  & {
    [P in TrueKeys<S['include']>]:
        P extends 'groupIngredient' ? Array < GroupIngredientGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'GroupMod' ? Array < GroupModGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'GroupSpec' ? Array < GroupSpecGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'GroupUser' ? Array < GroupUserGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? GroupsCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'groupIngredient' ? Array < GroupIngredientGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'GroupMod' ? Array < GroupModGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'GroupSpec' ? Array < GroupSpecGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'GroupUser' ? Array < GroupUserGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? GroupsCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Groups ? Groups[P] : never
  } 
    : Groups
  : Groups


  type GroupsCountArgs = Merge<
    Omit<GroupsFindManyArgs, 'select' | 'include'> & {
      select?: GroupsCountAggregateInputType | true
    }
  >

  export interface GroupsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Groups that matches the filter.
     * @param {GroupsFindUniqueArgs} args - Arguments to find a Groups
     * @example
     * // Get one Groups
     * const groups = await prisma.groups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GroupsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GroupsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Groups'> extends True ? CheckSelect<T, Prisma__GroupsClient<Groups>, Prisma__GroupsClient<GroupsGetPayload<T>>> : CheckSelect<T, Prisma__GroupsClient<Groups | null >, Prisma__GroupsClient<GroupsGetPayload<T> | null >>

    /**
     * Find the first Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsFindFirstArgs} args - Arguments to find a Groups
     * @example
     * // Get one Groups
     * const groups = await prisma.groups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GroupsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GroupsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Groups'> extends True ? CheckSelect<T, Prisma__GroupsClient<Groups>, Prisma__GroupsClient<GroupsGetPayload<T>>> : CheckSelect<T, Prisma__GroupsClient<Groups | null >, Prisma__GroupsClient<GroupsGetPayload<T> | null >>

    /**
     * Find zero or more Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups
     * const groups = await prisma.groups.findMany()
     * 
     * // Get first 10 Groups
     * const groups = await prisma.groups.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupsWithIdOnly = await prisma.groups.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GroupsFindManyArgs>(
      args?: SelectSubset<T, GroupsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Groups>>, PrismaPromise<Array<GroupsGetPayload<T>>>>

    /**
     * Create a Groups.
     * @param {GroupsCreateArgs} args - Arguments to create a Groups.
     * @example
     * // Create one Groups
     * const Groups = await prisma.groups.create({
     *   data: {
     *     // ... data to create a Groups
     *   }
     * })
     * 
    **/
    create<T extends GroupsCreateArgs>(
      args: SelectSubset<T, GroupsCreateArgs>
    ): CheckSelect<T, Prisma__GroupsClient<Groups>, Prisma__GroupsClient<GroupsGetPayload<T>>>

    /**
     * Create many Groups.
     *     @param {GroupsCreateManyArgs} args - Arguments to create many Groups.
     *     @example
     *     // Create many Groups
     *     const groups = await prisma.groups.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GroupsCreateManyArgs>(
      args?: SelectSubset<T, GroupsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Groups.
     * @param {GroupsDeleteArgs} args - Arguments to delete one Groups.
     * @example
     * // Delete one Groups
     * const Groups = await prisma.groups.delete({
     *   where: {
     *     // ... filter to delete one Groups
     *   }
     * })
     * 
    **/
    delete<T extends GroupsDeleteArgs>(
      args: SelectSubset<T, GroupsDeleteArgs>
    ): CheckSelect<T, Prisma__GroupsClient<Groups>, Prisma__GroupsClient<GroupsGetPayload<T>>>

    /**
     * Update one Groups.
     * @param {GroupsUpdateArgs} args - Arguments to update one Groups.
     * @example
     * // Update one Groups
     * const groups = await prisma.groups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GroupsUpdateArgs>(
      args: SelectSubset<T, GroupsUpdateArgs>
    ): CheckSelect<T, Prisma__GroupsClient<Groups>, Prisma__GroupsClient<GroupsGetPayload<T>>>

    /**
     * Delete zero or more Groups.
     * @param {GroupsDeleteManyArgs} args - Arguments to filter Groups to delete.
     * @example
     * // Delete a few Groups
     * const { count } = await prisma.groups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GroupsDeleteManyArgs>(
      args?: SelectSubset<T, GroupsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups
     * const groups = await prisma.groups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GroupsUpdateManyArgs>(
      args: SelectSubset<T, GroupsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Groups.
     * @param {GroupsUpsertArgs} args - Arguments to update or create a Groups.
     * @example
     * // Update or create a Groups
     * const groups = await prisma.groups.upsert({
     *   create: {
     *     // ... data to create a Groups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Groups we want to update
     *   }
     * })
    **/
    upsert<T extends GroupsUpsertArgs>(
      args: SelectSubset<T, GroupsUpsertArgs>
    ): CheckSelect<T, Prisma__GroupsClient<Groups>, Prisma__GroupsClient<GroupsGetPayload<T>>>

    /**
     * Find one Groups that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {GroupsFindUniqueOrThrowArgs} args - Arguments to find a Groups
     * @example
     * // Get one Groups
     * const groups = await prisma.groups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GroupsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, GroupsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__GroupsClient<Groups>, Prisma__GroupsClient<GroupsGetPayload<T>>>

    /**
     * Find the first Groups that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsFindFirstOrThrowArgs} args - Arguments to find a Groups
     * @example
     * // Get one Groups
     * const groups = await prisma.groups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GroupsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, GroupsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__GroupsClient<Groups>, Prisma__GroupsClient<GroupsGetPayload<T>>>

    /**
     * Count the number of Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsCountArgs} args - Arguments to filter Groups to count.
     * @example
     * // Count the number of Groups
     * const count = await prisma.groups.count({
     *   where: {
     *     // ... the filter for the Groups we want to count
     *   }
     * })
    **/
    count<T extends GroupsCountArgs>(
      args?: Subset<T, GroupsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupsAggregateArgs>(args: Subset<T, GroupsAggregateArgs>): PrismaPromise<GetGroupsAggregateType<T>>

    /**
     * Group by Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupsGroupByArgs['orderBy'] }
        : { orderBy?: GroupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Groups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GroupsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    groupIngredient<T extends GroupIngredientFindManyArgs = {}>(args?: Subset<T, GroupIngredientFindManyArgs>): CheckSelect<T, PrismaPromise<Array<GroupIngredient>>, PrismaPromise<Array<GroupIngredientGetPayload<T>>>>;

    GroupMod<T extends GroupModFindManyArgs = {}>(args?: Subset<T, GroupModFindManyArgs>): CheckSelect<T, PrismaPromise<Array<GroupMod>>, PrismaPromise<Array<GroupModGetPayload<T>>>>;

    GroupSpec<T extends GroupSpecFindManyArgs = {}>(args?: Subset<T, GroupSpecFindManyArgs>): CheckSelect<T, PrismaPromise<Array<GroupSpec>>, PrismaPromise<Array<GroupSpecGetPayload<T>>>>;

    GroupUser<T extends GroupUserFindManyArgs = {}>(args?: Subset<T, GroupUserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<GroupUser>>, PrismaPromise<Array<GroupUserGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Groups base type for findUnique actions
   */
  export type GroupsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Groups
     * 
    **/
    select?: GroupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupsInclude | null
    /**
     * Filter, which Groups to fetch.
     * 
    **/
    where: GroupsWhereUniqueInput
  }

  /**
   * Groups: findUnique
   */
  export interface GroupsFindUniqueArgs extends GroupsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Groups base type for findFirst actions
   */
  export type GroupsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Groups
     * 
    **/
    select?: GroupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupsInclude | null
    /**
     * Filter, which Groups to fetch.
     * 
    **/
    where?: GroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     * 
    **/
    orderBy?: Enumerable<GroupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     * 
    **/
    cursor?: GroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     * 
    **/
    distinct?: Enumerable<GroupsScalarFieldEnum>
  }

  /**
   * Groups: findFirst
   */
  export interface GroupsFindFirstArgs extends GroupsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Groups findMany
   */
  export type GroupsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Groups
     * 
    **/
    select?: GroupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupsInclude | null
    /**
     * Filter, which Groups to fetch.
     * 
    **/
    where?: GroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     * 
    **/
    orderBy?: Enumerable<GroupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Groups.
     * 
    **/
    cursor?: GroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     * 
    **/
    skip?: number
    distinct?: Enumerable<GroupsScalarFieldEnum>
  }


  /**
   * Groups create
   */
  export type GroupsCreateArgs = {
    /**
     * Select specific fields to fetch from the Groups
     * 
    **/
    select?: GroupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupsInclude | null
    /**
     * The data needed to create a Groups.
     * 
    **/
    data: XOR<GroupsCreateInput, GroupsUncheckedCreateInput>
  }


  /**
   * Groups createMany
   */
  export type GroupsCreateManyArgs = {
    /**
     * The data used to create many Groups.
     * 
    **/
    data: Enumerable<GroupsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Groups update
   */
  export type GroupsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Groups
     * 
    **/
    select?: GroupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupsInclude | null
    /**
     * The data needed to update a Groups.
     * 
    **/
    data: XOR<GroupsUpdateInput, GroupsUncheckedUpdateInput>
    /**
     * Choose, which Groups to update.
     * 
    **/
    where: GroupsWhereUniqueInput
  }


  /**
   * Groups updateMany
   */
  export type GroupsUpdateManyArgs = {
    /**
     * The data used to update Groups.
     * 
    **/
    data: XOR<GroupsUpdateManyMutationInput, GroupsUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     * 
    **/
    where?: GroupsWhereInput
  }


  /**
   * Groups upsert
   */
  export type GroupsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Groups
     * 
    **/
    select?: GroupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupsInclude | null
    /**
     * The filter to search for the Groups to update in case it exists.
     * 
    **/
    where: GroupsWhereUniqueInput
    /**
     * In case the Groups found by the `where` argument doesn't exist, create a new Groups with this data.
     * 
    **/
    create: XOR<GroupsCreateInput, GroupsUncheckedCreateInput>
    /**
     * In case the Groups was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<GroupsUpdateInput, GroupsUncheckedUpdateInput>
  }


  /**
   * Groups delete
   */
  export type GroupsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Groups
     * 
    **/
    select?: GroupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupsInclude | null
    /**
     * Filter which Groups to delete.
     * 
    **/
    where: GroupsWhereUniqueInput
  }


  /**
   * Groups deleteMany
   */
  export type GroupsDeleteManyArgs = {
    /**
     * Filter which Groups to delete
     * 
    **/
    where?: GroupsWhereInput
  }


  /**
   * Groups: findUniqueOrThrow
   */
  export type GroupsFindUniqueOrThrowArgs = GroupsFindUniqueArgsBase
      

  /**
   * Groups: findFirstOrThrow
   */
  export type GroupsFindFirstOrThrowArgs = GroupsFindFirstArgsBase
      

  /**
   * Groups without action
   */
  export type GroupsArgs = {
    /**
     * Select specific fields to fetch from the Groups
     * 
    **/
    select?: GroupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupsInclude | null
  }



  /**
   * Model GroupIngredient
   */


  export type AggregateGroupIngredient = {
    _count: GroupIngredientCountAggregateOutputType | null
    _avg: GroupIngredientAvgAggregateOutputType | null
    _sum: GroupIngredientSumAggregateOutputType | null
    _min: GroupIngredientMinAggregateOutputType | null
    _max: GroupIngredientMaxAggregateOutputType | null
  }

  export type GroupIngredientAvgAggregateOutputType = {
    groupId: number | null
    ingredientId: number | null
  }

  export type GroupIngredientSumAggregateOutputType = {
    groupId: number | null
    ingredientId: number | null
  }

  export type GroupIngredientMinAggregateOutputType = {
    groupId: number | null
    ingredientId: number | null
  }

  export type GroupIngredientMaxAggregateOutputType = {
    groupId: number | null
    ingredientId: number | null
  }

  export type GroupIngredientCountAggregateOutputType = {
    groupId: number
    ingredientId: number
    _all: number
  }


  export type GroupIngredientAvgAggregateInputType = {
    groupId?: true
    ingredientId?: true
  }

  export type GroupIngredientSumAggregateInputType = {
    groupId?: true
    ingredientId?: true
  }

  export type GroupIngredientMinAggregateInputType = {
    groupId?: true
    ingredientId?: true
  }

  export type GroupIngredientMaxAggregateInputType = {
    groupId?: true
    ingredientId?: true
  }

  export type GroupIngredientCountAggregateInputType = {
    groupId?: true
    ingredientId?: true
    _all?: true
  }

  export type GroupIngredientAggregateArgs = {
    /**
     * Filter which GroupIngredient to aggregate.
     * 
    **/
    where?: GroupIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupIngredients to fetch.
     * 
    **/
    orderBy?: Enumerable<GroupIngredientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: GroupIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupIngredients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupIngredients.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupIngredients
    **/
    _count?: true | GroupIngredientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupIngredientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupIngredientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupIngredientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupIngredientMaxAggregateInputType
  }

  export type GetGroupIngredientAggregateType<T extends GroupIngredientAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupIngredient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupIngredient[P]>
      : GetScalarType<T[P], AggregateGroupIngredient[P]>
  }




  export type GroupIngredientGroupByArgs = {
    where?: GroupIngredientWhereInput
    orderBy?: Enumerable<GroupIngredientOrderByWithAggregationInput>
    by: Array<GroupIngredientScalarFieldEnum>
    having?: GroupIngredientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupIngredientCountAggregateInputType | true
    _avg?: GroupIngredientAvgAggregateInputType
    _sum?: GroupIngredientSumAggregateInputType
    _min?: GroupIngredientMinAggregateInputType
    _max?: GroupIngredientMaxAggregateInputType
  }


  export type GroupIngredientGroupByOutputType = {
    groupId: number
    ingredientId: number
    _count: GroupIngredientCountAggregateOutputType | null
    _avg: GroupIngredientAvgAggregateOutputType | null
    _sum: GroupIngredientSumAggregateOutputType | null
    _min: GroupIngredientMinAggregateOutputType | null
    _max: GroupIngredientMaxAggregateOutputType | null
  }

  type GetGroupIngredientGroupByPayload<T extends GroupIngredientGroupByArgs> = PrismaPromise<
    Array<
      PickArray<GroupIngredientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupIngredientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupIngredientGroupByOutputType[P]>
            : GetScalarType<T[P], GroupIngredientGroupByOutputType[P]>
        }
      >
    >


  export type GroupIngredientSelect = {
    groupId?: boolean
    ingredientId?: boolean
    groups?: boolean | GroupsArgs
    ingredient?: boolean | IngredientArgs
  }

  export type GroupIngredientInclude = {
    groups?: boolean | GroupsArgs
    ingredient?: boolean | IngredientArgs
  }

  export type GroupIngredientGetPayload<
    S extends boolean | null | undefined | GroupIngredientArgs,
    U = keyof S
      > = S extends true
        ? GroupIngredient
    : S extends undefined
    ? never
    : S extends GroupIngredientArgs | GroupIngredientFindManyArgs
    ?'include' extends U
    ? GroupIngredient  & {
    [P in TrueKeys<S['include']>]:
        P extends 'groups' ? GroupsGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'ingredient' ? IngredientGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'groups' ? GroupsGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'ingredient' ? IngredientGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof GroupIngredient ? GroupIngredient[P] : never
  } 
    : GroupIngredient
  : GroupIngredient


  type GroupIngredientCountArgs = Merge<
    Omit<GroupIngredientFindManyArgs, 'select' | 'include'> & {
      select?: GroupIngredientCountAggregateInputType | true
    }
  >

  export interface GroupIngredientDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one GroupIngredient that matches the filter.
     * @param {GroupIngredientFindUniqueArgs} args - Arguments to find a GroupIngredient
     * @example
     * // Get one GroupIngredient
     * const groupIngredient = await prisma.groupIngredient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GroupIngredientFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GroupIngredientFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'GroupIngredient'> extends True ? CheckSelect<T, Prisma__GroupIngredientClient<GroupIngredient>, Prisma__GroupIngredientClient<GroupIngredientGetPayload<T>>> : CheckSelect<T, Prisma__GroupIngredientClient<GroupIngredient | null >, Prisma__GroupIngredientClient<GroupIngredientGetPayload<T> | null >>

    /**
     * Find the first GroupIngredient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupIngredientFindFirstArgs} args - Arguments to find a GroupIngredient
     * @example
     * // Get one GroupIngredient
     * const groupIngredient = await prisma.groupIngredient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GroupIngredientFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GroupIngredientFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'GroupIngredient'> extends True ? CheckSelect<T, Prisma__GroupIngredientClient<GroupIngredient>, Prisma__GroupIngredientClient<GroupIngredientGetPayload<T>>> : CheckSelect<T, Prisma__GroupIngredientClient<GroupIngredient | null >, Prisma__GroupIngredientClient<GroupIngredientGetPayload<T> | null >>

    /**
     * Find zero or more GroupIngredients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupIngredientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupIngredients
     * const groupIngredients = await prisma.groupIngredient.findMany()
     * 
     * // Get first 10 GroupIngredients
     * const groupIngredients = await prisma.groupIngredient.findMany({ take: 10 })
     * 
     * // Only select the `groupId`
     * const groupIngredientWithGroupIdOnly = await prisma.groupIngredient.findMany({ select: { groupId: true } })
     * 
    **/
    findMany<T extends GroupIngredientFindManyArgs>(
      args?: SelectSubset<T, GroupIngredientFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<GroupIngredient>>, PrismaPromise<Array<GroupIngredientGetPayload<T>>>>

    /**
     * Create a GroupIngredient.
     * @param {GroupIngredientCreateArgs} args - Arguments to create a GroupIngredient.
     * @example
     * // Create one GroupIngredient
     * const GroupIngredient = await prisma.groupIngredient.create({
     *   data: {
     *     // ... data to create a GroupIngredient
     *   }
     * })
     * 
    **/
    create<T extends GroupIngredientCreateArgs>(
      args: SelectSubset<T, GroupIngredientCreateArgs>
    ): CheckSelect<T, Prisma__GroupIngredientClient<GroupIngredient>, Prisma__GroupIngredientClient<GroupIngredientGetPayload<T>>>

    /**
     * Create many GroupIngredients.
     *     @param {GroupIngredientCreateManyArgs} args - Arguments to create many GroupIngredients.
     *     @example
     *     // Create many GroupIngredients
     *     const groupIngredient = await prisma.groupIngredient.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GroupIngredientCreateManyArgs>(
      args?: SelectSubset<T, GroupIngredientCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a GroupIngredient.
     * @param {GroupIngredientDeleteArgs} args - Arguments to delete one GroupIngredient.
     * @example
     * // Delete one GroupIngredient
     * const GroupIngredient = await prisma.groupIngredient.delete({
     *   where: {
     *     // ... filter to delete one GroupIngredient
     *   }
     * })
     * 
    **/
    delete<T extends GroupIngredientDeleteArgs>(
      args: SelectSubset<T, GroupIngredientDeleteArgs>
    ): CheckSelect<T, Prisma__GroupIngredientClient<GroupIngredient>, Prisma__GroupIngredientClient<GroupIngredientGetPayload<T>>>

    /**
     * Update one GroupIngredient.
     * @param {GroupIngredientUpdateArgs} args - Arguments to update one GroupIngredient.
     * @example
     * // Update one GroupIngredient
     * const groupIngredient = await prisma.groupIngredient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GroupIngredientUpdateArgs>(
      args: SelectSubset<T, GroupIngredientUpdateArgs>
    ): CheckSelect<T, Prisma__GroupIngredientClient<GroupIngredient>, Prisma__GroupIngredientClient<GroupIngredientGetPayload<T>>>

    /**
     * Delete zero or more GroupIngredients.
     * @param {GroupIngredientDeleteManyArgs} args - Arguments to filter GroupIngredients to delete.
     * @example
     * // Delete a few GroupIngredients
     * const { count } = await prisma.groupIngredient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GroupIngredientDeleteManyArgs>(
      args?: SelectSubset<T, GroupIngredientDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupIngredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupIngredientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupIngredients
     * const groupIngredient = await prisma.groupIngredient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GroupIngredientUpdateManyArgs>(
      args: SelectSubset<T, GroupIngredientUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one GroupIngredient.
     * @param {GroupIngredientUpsertArgs} args - Arguments to update or create a GroupIngredient.
     * @example
     * // Update or create a GroupIngredient
     * const groupIngredient = await prisma.groupIngredient.upsert({
     *   create: {
     *     // ... data to create a GroupIngredient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupIngredient we want to update
     *   }
     * })
    **/
    upsert<T extends GroupIngredientUpsertArgs>(
      args: SelectSubset<T, GroupIngredientUpsertArgs>
    ): CheckSelect<T, Prisma__GroupIngredientClient<GroupIngredient>, Prisma__GroupIngredientClient<GroupIngredientGetPayload<T>>>

    /**
     * Find one GroupIngredient that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {GroupIngredientFindUniqueOrThrowArgs} args - Arguments to find a GroupIngredient
     * @example
     * // Get one GroupIngredient
     * const groupIngredient = await prisma.groupIngredient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GroupIngredientFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, GroupIngredientFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__GroupIngredientClient<GroupIngredient>, Prisma__GroupIngredientClient<GroupIngredientGetPayload<T>>>

    /**
     * Find the first GroupIngredient that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupIngredientFindFirstOrThrowArgs} args - Arguments to find a GroupIngredient
     * @example
     * // Get one GroupIngredient
     * const groupIngredient = await prisma.groupIngredient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GroupIngredientFindFirstOrThrowArgs>(
      args?: SelectSubset<T, GroupIngredientFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__GroupIngredientClient<GroupIngredient>, Prisma__GroupIngredientClient<GroupIngredientGetPayload<T>>>

    /**
     * Count the number of GroupIngredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupIngredientCountArgs} args - Arguments to filter GroupIngredients to count.
     * @example
     * // Count the number of GroupIngredients
     * const count = await prisma.groupIngredient.count({
     *   where: {
     *     // ... the filter for the GroupIngredients we want to count
     *   }
     * })
    **/
    count<T extends GroupIngredientCountArgs>(
      args?: Subset<T, GroupIngredientCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupIngredientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupIngredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupIngredientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupIngredientAggregateArgs>(args: Subset<T, GroupIngredientAggregateArgs>): PrismaPromise<GetGroupIngredientAggregateType<T>>

    /**
     * Group by GroupIngredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupIngredientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupIngredientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupIngredientGroupByArgs['orderBy'] }
        : { orderBy?: GroupIngredientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupIngredientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupIngredientGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupIngredient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GroupIngredientClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    groups<T extends GroupsArgs = {}>(args?: Subset<T, GroupsArgs>): CheckSelect<T, Prisma__GroupsClient<Groups | null >, Prisma__GroupsClient<GroupsGetPayload<T> | null >>;

    ingredient<T extends IngredientArgs = {}>(args?: Subset<T, IngredientArgs>): CheckSelect<T, Prisma__IngredientClient<Ingredient | null >, Prisma__IngredientClient<IngredientGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * GroupIngredient base type for findUnique actions
   */
  export type GroupIngredientFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the GroupIngredient
     * 
    **/
    select?: GroupIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupIngredientInclude | null
    /**
     * Filter, which GroupIngredient to fetch.
     * 
    **/
    where: GroupIngredientWhereUniqueInput
  }

  /**
   * GroupIngredient: findUnique
   */
  export interface GroupIngredientFindUniqueArgs extends GroupIngredientFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * GroupIngredient base type for findFirst actions
   */
  export type GroupIngredientFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the GroupIngredient
     * 
    **/
    select?: GroupIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupIngredientInclude | null
    /**
     * Filter, which GroupIngredient to fetch.
     * 
    **/
    where?: GroupIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupIngredients to fetch.
     * 
    **/
    orderBy?: Enumerable<GroupIngredientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupIngredients.
     * 
    **/
    cursor?: GroupIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupIngredients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupIngredients.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupIngredients.
     * 
    **/
    distinct?: Enumerable<GroupIngredientScalarFieldEnum>
  }

  /**
   * GroupIngredient: findFirst
   */
  export interface GroupIngredientFindFirstArgs extends GroupIngredientFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * GroupIngredient findMany
   */
  export type GroupIngredientFindManyArgs = {
    /**
     * Select specific fields to fetch from the GroupIngredient
     * 
    **/
    select?: GroupIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupIngredientInclude | null
    /**
     * Filter, which GroupIngredients to fetch.
     * 
    **/
    where?: GroupIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupIngredients to fetch.
     * 
    **/
    orderBy?: Enumerable<GroupIngredientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupIngredients.
     * 
    **/
    cursor?: GroupIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupIngredients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupIngredients.
     * 
    **/
    skip?: number
    distinct?: Enumerable<GroupIngredientScalarFieldEnum>
  }


  /**
   * GroupIngredient create
   */
  export type GroupIngredientCreateArgs = {
    /**
     * Select specific fields to fetch from the GroupIngredient
     * 
    **/
    select?: GroupIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupIngredientInclude | null
    /**
     * The data needed to create a GroupIngredient.
     * 
    **/
    data: XOR<GroupIngredientCreateInput, GroupIngredientUncheckedCreateInput>
  }


  /**
   * GroupIngredient createMany
   */
  export type GroupIngredientCreateManyArgs = {
    /**
     * The data used to create many GroupIngredients.
     * 
    **/
    data: Enumerable<GroupIngredientCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * GroupIngredient update
   */
  export type GroupIngredientUpdateArgs = {
    /**
     * Select specific fields to fetch from the GroupIngredient
     * 
    **/
    select?: GroupIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupIngredientInclude | null
    /**
     * The data needed to update a GroupIngredient.
     * 
    **/
    data: XOR<GroupIngredientUpdateInput, GroupIngredientUncheckedUpdateInput>
    /**
     * Choose, which GroupIngredient to update.
     * 
    **/
    where: GroupIngredientWhereUniqueInput
  }


  /**
   * GroupIngredient updateMany
   */
  export type GroupIngredientUpdateManyArgs = {
    /**
     * The data used to update GroupIngredients.
     * 
    **/
    data: XOR<GroupIngredientUpdateManyMutationInput, GroupIngredientUncheckedUpdateManyInput>
    /**
     * Filter which GroupIngredients to update
     * 
    **/
    where?: GroupIngredientWhereInput
  }


  /**
   * GroupIngredient upsert
   */
  export type GroupIngredientUpsertArgs = {
    /**
     * Select specific fields to fetch from the GroupIngredient
     * 
    **/
    select?: GroupIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupIngredientInclude | null
    /**
     * The filter to search for the GroupIngredient to update in case it exists.
     * 
    **/
    where: GroupIngredientWhereUniqueInput
    /**
     * In case the GroupIngredient found by the `where` argument doesn't exist, create a new GroupIngredient with this data.
     * 
    **/
    create: XOR<GroupIngredientCreateInput, GroupIngredientUncheckedCreateInput>
    /**
     * In case the GroupIngredient was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<GroupIngredientUpdateInput, GroupIngredientUncheckedUpdateInput>
  }


  /**
   * GroupIngredient delete
   */
  export type GroupIngredientDeleteArgs = {
    /**
     * Select specific fields to fetch from the GroupIngredient
     * 
    **/
    select?: GroupIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupIngredientInclude | null
    /**
     * Filter which GroupIngredient to delete.
     * 
    **/
    where: GroupIngredientWhereUniqueInput
  }


  /**
   * GroupIngredient deleteMany
   */
  export type GroupIngredientDeleteManyArgs = {
    /**
     * Filter which GroupIngredients to delete
     * 
    **/
    where?: GroupIngredientWhereInput
  }


  /**
   * GroupIngredient: findUniqueOrThrow
   */
  export type GroupIngredientFindUniqueOrThrowArgs = GroupIngredientFindUniqueArgsBase
      

  /**
   * GroupIngredient: findFirstOrThrow
   */
  export type GroupIngredientFindFirstOrThrowArgs = GroupIngredientFindFirstArgsBase
      

  /**
   * GroupIngredient without action
   */
  export type GroupIngredientArgs = {
    /**
     * Select specific fields to fetch from the GroupIngredient
     * 
    **/
    select?: GroupIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupIngredientInclude | null
  }



  /**
   * Model GroupMod
   */


  export type AggregateGroupMod = {
    _count: GroupModCountAggregateOutputType | null
    _avg: GroupModAvgAggregateOutputType | null
    _sum: GroupModSumAggregateOutputType | null
    _min: GroupModMinAggregateOutputType | null
    _max: GroupModMaxAggregateOutputType | null
  }

  export type GroupModAvgAggregateOutputType = {
    groupId: number | null
  }

  export type GroupModSumAggregateOutputType = {
    groupId: number | null
  }

  export type GroupModMinAggregateOutputType = {
    userId: string | null
    groupId: number | null
  }

  export type GroupModMaxAggregateOutputType = {
    userId: string | null
    groupId: number | null
  }

  export type GroupModCountAggregateOutputType = {
    userId: number
    groupId: number
    _all: number
  }


  export type GroupModAvgAggregateInputType = {
    groupId?: true
  }

  export type GroupModSumAggregateInputType = {
    groupId?: true
  }

  export type GroupModMinAggregateInputType = {
    userId?: true
    groupId?: true
  }

  export type GroupModMaxAggregateInputType = {
    userId?: true
    groupId?: true
  }

  export type GroupModCountAggregateInputType = {
    userId?: true
    groupId?: true
    _all?: true
  }

  export type GroupModAggregateArgs = {
    /**
     * Filter which GroupMod to aggregate.
     * 
    **/
    where?: GroupModWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMods to fetch.
     * 
    **/
    orderBy?: Enumerable<GroupModOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: GroupModWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMods from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMods.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupMods
    **/
    _count?: true | GroupModCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupModAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupModSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupModMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupModMaxAggregateInputType
  }

  export type GetGroupModAggregateType<T extends GroupModAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupMod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupMod[P]>
      : GetScalarType<T[P], AggregateGroupMod[P]>
  }




  export type GroupModGroupByArgs = {
    where?: GroupModWhereInput
    orderBy?: Enumerable<GroupModOrderByWithAggregationInput>
    by: Array<GroupModScalarFieldEnum>
    having?: GroupModScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupModCountAggregateInputType | true
    _avg?: GroupModAvgAggregateInputType
    _sum?: GroupModSumAggregateInputType
    _min?: GroupModMinAggregateInputType
    _max?: GroupModMaxAggregateInputType
  }


  export type GroupModGroupByOutputType = {
    userId: string
    groupId: number
    _count: GroupModCountAggregateOutputType | null
    _avg: GroupModAvgAggregateOutputType | null
    _sum: GroupModSumAggregateOutputType | null
    _min: GroupModMinAggregateOutputType | null
    _max: GroupModMaxAggregateOutputType | null
  }

  type GetGroupModGroupByPayload<T extends GroupModGroupByArgs> = PrismaPromise<
    Array<
      PickArray<GroupModGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupModGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupModGroupByOutputType[P]>
            : GetScalarType<T[P], GroupModGroupByOutputType[P]>
        }
      >
    >


  export type GroupModSelect = {
    userId?: boolean
    groupId?: boolean
    groups?: boolean | GroupsArgs
    users?: boolean | UserArgs
  }

  export type GroupModInclude = {
    groups?: boolean | GroupsArgs
    users?: boolean | UserArgs
  }

  export type GroupModGetPayload<
    S extends boolean | null | undefined | GroupModArgs,
    U = keyof S
      > = S extends true
        ? GroupMod
    : S extends undefined
    ? never
    : S extends GroupModArgs | GroupModFindManyArgs
    ?'include' extends U
    ? GroupMod  & {
    [P in TrueKeys<S['include']>]:
        P extends 'groups' ? GroupsGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'users' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'groups' ? GroupsGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'users' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof GroupMod ? GroupMod[P] : never
  } 
    : GroupMod
  : GroupMod


  type GroupModCountArgs = Merge<
    Omit<GroupModFindManyArgs, 'select' | 'include'> & {
      select?: GroupModCountAggregateInputType | true
    }
  >

  export interface GroupModDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one GroupMod that matches the filter.
     * @param {GroupModFindUniqueArgs} args - Arguments to find a GroupMod
     * @example
     * // Get one GroupMod
     * const groupMod = await prisma.groupMod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GroupModFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GroupModFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'GroupMod'> extends True ? CheckSelect<T, Prisma__GroupModClient<GroupMod>, Prisma__GroupModClient<GroupModGetPayload<T>>> : CheckSelect<T, Prisma__GroupModClient<GroupMod | null >, Prisma__GroupModClient<GroupModGetPayload<T> | null >>

    /**
     * Find the first GroupMod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupModFindFirstArgs} args - Arguments to find a GroupMod
     * @example
     * // Get one GroupMod
     * const groupMod = await prisma.groupMod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GroupModFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GroupModFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'GroupMod'> extends True ? CheckSelect<T, Prisma__GroupModClient<GroupMod>, Prisma__GroupModClient<GroupModGetPayload<T>>> : CheckSelect<T, Prisma__GroupModClient<GroupMod | null >, Prisma__GroupModClient<GroupModGetPayload<T> | null >>

    /**
     * Find zero or more GroupMods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupModFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupMods
     * const groupMods = await prisma.groupMod.findMany()
     * 
     * // Get first 10 GroupMods
     * const groupMods = await prisma.groupMod.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const groupModWithUserIdOnly = await prisma.groupMod.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends GroupModFindManyArgs>(
      args?: SelectSubset<T, GroupModFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<GroupMod>>, PrismaPromise<Array<GroupModGetPayload<T>>>>

    /**
     * Create a GroupMod.
     * @param {GroupModCreateArgs} args - Arguments to create a GroupMod.
     * @example
     * // Create one GroupMod
     * const GroupMod = await prisma.groupMod.create({
     *   data: {
     *     // ... data to create a GroupMod
     *   }
     * })
     * 
    **/
    create<T extends GroupModCreateArgs>(
      args: SelectSubset<T, GroupModCreateArgs>
    ): CheckSelect<T, Prisma__GroupModClient<GroupMod>, Prisma__GroupModClient<GroupModGetPayload<T>>>

    /**
     * Create many GroupMods.
     *     @param {GroupModCreateManyArgs} args - Arguments to create many GroupMods.
     *     @example
     *     // Create many GroupMods
     *     const groupMod = await prisma.groupMod.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GroupModCreateManyArgs>(
      args?: SelectSubset<T, GroupModCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a GroupMod.
     * @param {GroupModDeleteArgs} args - Arguments to delete one GroupMod.
     * @example
     * // Delete one GroupMod
     * const GroupMod = await prisma.groupMod.delete({
     *   where: {
     *     // ... filter to delete one GroupMod
     *   }
     * })
     * 
    **/
    delete<T extends GroupModDeleteArgs>(
      args: SelectSubset<T, GroupModDeleteArgs>
    ): CheckSelect<T, Prisma__GroupModClient<GroupMod>, Prisma__GroupModClient<GroupModGetPayload<T>>>

    /**
     * Update one GroupMod.
     * @param {GroupModUpdateArgs} args - Arguments to update one GroupMod.
     * @example
     * // Update one GroupMod
     * const groupMod = await prisma.groupMod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GroupModUpdateArgs>(
      args: SelectSubset<T, GroupModUpdateArgs>
    ): CheckSelect<T, Prisma__GroupModClient<GroupMod>, Prisma__GroupModClient<GroupModGetPayload<T>>>

    /**
     * Delete zero or more GroupMods.
     * @param {GroupModDeleteManyArgs} args - Arguments to filter GroupMods to delete.
     * @example
     * // Delete a few GroupMods
     * const { count } = await prisma.groupMod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GroupModDeleteManyArgs>(
      args?: SelectSubset<T, GroupModDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupMods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupModUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupMods
     * const groupMod = await prisma.groupMod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GroupModUpdateManyArgs>(
      args: SelectSubset<T, GroupModUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one GroupMod.
     * @param {GroupModUpsertArgs} args - Arguments to update or create a GroupMod.
     * @example
     * // Update or create a GroupMod
     * const groupMod = await prisma.groupMod.upsert({
     *   create: {
     *     // ... data to create a GroupMod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupMod we want to update
     *   }
     * })
    **/
    upsert<T extends GroupModUpsertArgs>(
      args: SelectSubset<T, GroupModUpsertArgs>
    ): CheckSelect<T, Prisma__GroupModClient<GroupMod>, Prisma__GroupModClient<GroupModGetPayload<T>>>

    /**
     * Find one GroupMod that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {GroupModFindUniqueOrThrowArgs} args - Arguments to find a GroupMod
     * @example
     * // Get one GroupMod
     * const groupMod = await prisma.groupMod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GroupModFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, GroupModFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__GroupModClient<GroupMod>, Prisma__GroupModClient<GroupModGetPayload<T>>>

    /**
     * Find the first GroupMod that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupModFindFirstOrThrowArgs} args - Arguments to find a GroupMod
     * @example
     * // Get one GroupMod
     * const groupMod = await prisma.groupMod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GroupModFindFirstOrThrowArgs>(
      args?: SelectSubset<T, GroupModFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__GroupModClient<GroupMod>, Prisma__GroupModClient<GroupModGetPayload<T>>>

    /**
     * Count the number of GroupMods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupModCountArgs} args - Arguments to filter GroupMods to count.
     * @example
     * // Count the number of GroupMods
     * const count = await prisma.groupMod.count({
     *   where: {
     *     // ... the filter for the GroupMods we want to count
     *   }
     * })
    **/
    count<T extends GroupModCountArgs>(
      args?: Subset<T, GroupModCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupModCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupMod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupModAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupModAggregateArgs>(args: Subset<T, GroupModAggregateArgs>): PrismaPromise<GetGroupModAggregateType<T>>

    /**
     * Group by GroupMod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupModGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupModGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupModGroupByArgs['orderBy'] }
        : { orderBy?: GroupModGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupModGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupModGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupMod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GroupModClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    groups<T extends GroupsArgs = {}>(args?: Subset<T, GroupsArgs>): CheckSelect<T, Prisma__GroupsClient<Groups | null >, Prisma__GroupsClient<GroupsGetPayload<T> | null >>;

    users<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * GroupMod base type for findUnique actions
   */
  export type GroupModFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the GroupMod
     * 
    **/
    select?: GroupModSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupModInclude | null
    /**
     * Filter, which GroupMod to fetch.
     * 
    **/
    where: GroupModWhereUniqueInput
  }

  /**
   * GroupMod: findUnique
   */
  export interface GroupModFindUniqueArgs extends GroupModFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * GroupMod base type for findFirst actions
   */
  export type GroupModFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the GroupMod
     * 
    **/
    select?: GroupModSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupModInclude | null
    /**
     * Filter, which GroupMod to fetch.
     * 
    **/
    where?: GroupModWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMods to fetch.
     * 
    **/
    orderBy?: Enumerable<GroupModOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupMods.
     * 
    **/
    cursor?: GroupModWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMods from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMods.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupMods.
     * 
    **/
    distinct?: Enumerable<GroupModScalarFieldEnum>
  }

  /**
   * GroupMod: findFirst
   */
  export interface GroupModFindFirstArgs extends GroupModFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * GroupMod findMany
   */
  export type GroupModFindManyArgs = {
    /**
     * Select specific fields to fetch from the GroupMod
     * 
    **/
    select?: GroupModSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupModInclude | null
    /**
     * Filter, which GroupMods to fetch.
     * 
    **/
    where?: GroupModWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMods to fetch.
     * 
    **/
    orderBy?: Enumerable<GroupModOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupMods.
     * 
    **/
    cursor?: GroupModWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMods from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMods.
     * 
    **/
    skip?: number
    distinct?: Enumerable<GroupModScalarFieldEnum>
  }


  /**
   * GroupMod create
   */
  export type GroupModCreateArgs = {
    /**
     * Select specific fields to fetch from the GroupMod
     * 
    **/
    select?: GroupModSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupModInclude | null
    /**
     * The data needed to create a GroupMod.
     * 
    **/
    data: XOR<GroupModCreateInput, GroupModUncheckedCreateInput>
  }


  /**
   * GroupMod createMany
   */
  export type GroupModCreateManyArgs = {
    /**
     * The data used to create many GroupMods.
     * 
    **/
    data: Enumerable<GroupModCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * GroupMod update
   */
  export type GroupModUpdateArgs = {
    /**
     * Select specific fields to fetch from the GroupMod
     * 
    **/
    select?: GroupModSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupModInclude | null
    /**
     * The data needed to update a GroupMod.
     * 
    **/
    data: XOR<GroupModUpdateInput, GroupModUncheckedUpdateInput>
    /**
     * Choose, which GroupMod to update.
     * 
    **/
    where: GroupModWhereUniqueInput
  }


  /**
   * GroupMod updateMany
   */
  export type GroupModUpdateManyArgs = {
    /**
     * The data used to update GroupMods.
     * 
    **/
    data: XOR<GroupModUpdateManyMutationInput, GroupModUncheckedUpdateManyInput>
    /**
     * Filter which GroupMods to update
     * 
    **/
    where?: GroupModWhereInput
  }


  /**
   * GroupMod upsert
   */
  export type GroupModUpsertArgs = {
    /**
     * Select specific fields to fetch from the GroupMod
     * 
    **/
    select?: GroupModSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupModInclude | null
    /**
     * The filter to search for the GroupMod to update in case it exists.
     * 
    **/
    where: GroupModWhereUniqueInput
    /**
     * In case the GroupMod found by the `where` argument doesn't exist, create a new GroupMod with this data.
     * 
    **/
    create: XOR<GroupModCreateInput, GroupModUncheckedCreateInput>
    /**
     * In case the GroupMod was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<GroupModUpdateInput, GroupModUncheckedUpdateInput>
  }


  /**
   * GroupMod delete
   */
  export type GroupModDeleteArgs = {
    /**
     * Select specific fields to fetch from the GroupMod
     * 
    **/
    select?: GroupModSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupModInclude | null
    /**
     * Filter which GroupMod to delete.
     * 
    **/
    where: GroupModWhereUniqueInput
  }


  /**
   * GroupMod deleteMany
   */
  export type GroupModDeleteManyArgs = {
    /**
     * Filter which GroupMods to delete
     * 
    **/
    where?: GroupModWhereInput
  }


  /**
   * GroupMod: findUniqueOrThrow
   */
  export type GroupModFindUniqueOrThrowArgs = GroupModFindUniqueArgsBase
      

  /**
   * GroupMod: findFirstOrThrow
   */
  export type GroupModFindFirstOrThrowArgs = GroupModFindFirstArgsBase
      

  /**
   * GroupMod without action
   */
  export type GroupModArgs = {
    /**
     * Select specific fields to fetch from the GroupMod
     * 
    **/
    select?: GroupModSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupModInclude | null
  }



  /**
   * Model GroupSpec
   */


  export type AggregateGroupSpec = {
    _count: GroupSpecCountAggregateOutputType | null
    _avg: GroupSpecAvgAggregateOutputType | null
    _sum: GroupSpecSumAggregateOutputType | null
    _min: GroupSpecMinAggregateOutputType | null
    _max: GroupSpecMaxAggregateOutputType | null
  }

  export type GroupSpecAvgAggregateOutputType = {
    groupId: number | null
    specId: number | null
  }

  export type GroupSpecSumAggregateOutputType = {
    groupId: number | null
    specId: number | null
  }

  export type GroupSpecMinAggregateOutputType = {
    groupId: number | null
    specId: number | null
  }

  export type GroupSpecMaxAggregateOutputType = {
    groupId: number | null
    specId: number | null
  }

  export type GroupSpecCountAggregateOutputType = {
    groupId: number
    specId: number
    _all: number
  }


  export type GroupSpecAvgAggregateInputType = {
    groupId?: true
    specId?: true
  }

  export type GroupSpecSumAggregateInputType = {
    groupId?: true
    specId?: true
  }

  export type GroupSpecMinAggregateInputType = {
    groupId?: true
    specId?: true
  }

  export type GroupSpecMaxAggregateInputType = {
    groupId?: true
    specId?: true
  }

  export type GroupSpecCountAggregateInputType = {
    groupId?: true
    specId?: true
    _all?: true
  }

  export type GroupSpecAggregateArgs = {
    /**
     * Filter which GroupSpec to aggregate.
     * 
    **/
    where?: GroupSpecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupSpecs to fetch.
     * 
    **/
    orderBy?: Enumerable<GroupSpecOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: GroupSpecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupSpecs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupSpecs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupSpecs
    **/
    _count?: true | GroupSpecCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupSpecAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupSpecSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupSpecMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupSpecMaxAggregateInputType
  }

  export type GetGroupSpecAggregateType<T extends GroupSpecAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupSpec]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupSpec[P]>
      : GetScalarType<T[P], AggregateGroupSpec[P]>
  }




  export type GroupSpecGroupByArgs = {
    where?: GroupSpecWhereInput
    orderBy?: Enumerable<GroupSpecOrderByWithAggregationInput>
    by: Array<GroupSpecScalarFieldEnum>
    having?: GroupSpecScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupSpecCountAggregateInputType | true
    _avg?: GroupSpecAvgAggregateInputType
    _sum?: GroupSpecSumAggregateInputType
    _min?: GroupSpecMinAggregateInputType
    _max?: GroupSpecMaxAggregateInputType
  }


  export type GroupSpecGroupByOutputType = {
    groupId: number
    specId: number
    _count: GroupSpecCountAggregateOutputType | null
    _avg: GroupSpecAvgAggregateOutputType | null
    _sum: GroupSpecSumAggregateOutputType | null
    _min: GroupSpecMinAggregateOutputType | null
    _max: GroupSpecMaxAggregateOutputType | null
  }

  type GetGroupSpecGroupByPayload<T extends GroupSpecGroupByArgs> = PrismaPromise<
    Array<
      PickArray<GroupSpecGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupSpecGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupSpecGroupByOutputType[P]>
            : GetScalarType<T[P], GroupSpecGroupByOutputType[P]>
        }
      >
    >


  export type GroupSpecSelect = {
    groupId?: boolean
    specId?: boolean
    groups?: boolean | GroupsArgs
    spec?: boolean | SpecArgs
  }

  export type GroupSpecInclude = {
    groups?: boolean | GroupsArgs
    spec?: boolean | SpecArgs
  }

  export type GroupSpecGetPayload<
    S extends boolean | null | undefined | GroupSpecArgs,
    U = keyof S
      > = S extends true
        ? GroupSpec
    : S extends undefined
    ? never
    : S extends GroupSpecArgs | GroupSpecFindManyArgs
    ?'include' extends U
    ? GroupSpec  & {
    [P in TrueKeys<S['include']>]:
        P extends 'groups' ? GroupsGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'spec' ? SpecGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'groups' ? GroupsGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'spec' ? SpecGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof GroupSpec ? GroupSpec[P] : never
  } 
    : GroupSpec
  : GroupSpec


  type GroupSpecCountArgs = Merge<
    Omit<GroupSpecFindManyArgs, 'select' | 'include'> & {
      select?: GroupSpecCountAggregateInputType | true
    }
  >

  export interface GroupSpecDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one GroupSpec that matches the filter.
     * @param {GroupSpecFindUniqueArgs} args - Arguments to find a GroupSpec
     * @example
     * // Get one GroupSpec
     * const groupSpec = await prisma.groupSpec.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GroupSpecFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GroupSpecFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'GroupSpec'> extends True ? CheckSelect<T, Prisma__GroupSpecClient<GroupSpec>, Prisma__GroupSpecClient<GroupSpecGetPayload<T>>> : CheckSelect<T, Prisma__GroupSpecClient<GroupSpec | null >, Prisma__GroupSpecClient<GroupSpecGetPayload<T> | null >>

    /**
     * Find the first GroupSpec that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupSpecFindFirstArgs} args - Arguments to find a GroupSpec
     * @example
     * // Get one GroupSpec
     * const groupSpec = await prisma.groupSpec.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GroupSpecFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GroupSpecFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'GroupSpec'> extends True ? CheckSelect<T, Prisma__GroupSpecClient<GroupSpec>, Prisma__GroupSpecClient<GroupSpecGetPayload<T>>> : CheckSelect<T, Prisma__GroupSpecClient<GroupSpec | null >, Prisma__GroupSpecClient<GroupSpecGetPayload<T> | null >>

    /**
     * Find zero or more GroupSpecs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupSpecFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupSpecs
     * const groupSpecs = await prisma.groupSpec.findMany()
     * 
     * // Get first 10 GroupSpecs
     * const groupSpecs = await prisma.groupSpec.findMany({ take: 10 })
     * 
     * // Only select the `groupId`
     * const groupSpecWithGroupIdOnly = await prisma.groupSpec.findMany({ select: { groupId: true } })
     * 
    **/
    findMany<T extends GroupSpecFindManyArgs>(
      args?: SelectSubset<T, GroupSpecFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<GroupSpec>>, PrismaPromise<Array<GroupSpecGetPayload<T>>>>

    /**
     * Create a GroupSpec.
     * @param {GroupSpecCreateArgs} args - Arguments to create a GroupSpec.
     * @example
     * // Create one GroupSpec
     * const GroupSpec = await prisma.groupSpec.create({
     *   data: {
     *     // ... data to create a GroupSpec
     *   }
     * })
     * 
    **/
    create<T extends GroupSpecCreateArgs>(
      args: SelectSubset<T, GroupSpecCreateArgs>
    ): CheckSelect<T, Prisma__GroupSpecClient<GroupSpec>, Prisma__GroupSpecClient<GroupSpecGetPayload<T>>>

    /**
     * Create many GroupSpecs.
     *     @param {GroupSpecCreateManyArgs} args - Arguments to create many GroupSpecs.
     *     @example
     *     // Create many GroupSpecs
     *     const groupSpec = await prisma.groupSpec.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GroupSpecCreateManyArgs>(
      args?: SelectSubset<T, GroupSpecCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a GroupSpec.
     * @param {GroupSpecDeleteArgs} args - Arguments to delete one GroupSpec.
     * @example
     * // Delete one GroupSpec
     * const GroupSpec = await prisma.groupSpec.delete({
     *   where: {
     *     // ... filter to delete one GroupSpec
     *   }
     * })
     * 
    **/
    delete<T extends GroupSpecDeleteArgs>(
      args: SelectSubset<T, GroupSpecDeleteArgs>
    ): CheckSelect<T, Prisma__GroupSpecClient<GroupSpec>, Prisma__GroupSpecClient<GroupSpecGetPayload<T>>>

    /**
     * Update one GroupSpec.
     * @param {GroupSpecUpdateArgs} args - Arguments to update one GroupSpec.
     * @example
     * // Update one GroupSpec
     * const groupSpec = await prisma.groupSpec.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GroupSpecUpdateArgs>(
      args: SelectSubset<T, GroupSpecUpdateArgs>
    ): CheckSelect<T, Prisma__GroupSpecClient<GroupSpec>, Prisma__GroupSpecClient<GroupSpecGetPayload<T>>>

    /**
     * Delete zero or more GroupSpecs.
     * @param {GroupSpecDeleteManyArgs} args - Arguments to filter GroupSpecs to delete.
     * @example
     * // Delete a few GroupSpecs
     * const { count } = await prisma.groupSpec.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GroupSpecDeleteManyArgs>(
      args?: SelectSubset<T, GroupSpecDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupSpecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupSpecUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupSpecs
     * const groupSpec = await prisma.groupSpec.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GroupSpecUpdateManyArgs>(
      args: SelectSubset<T, GroupSpecUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one GroupSpec.
     * @param {GroupSpecUpsertArgs} args - Arguments to update or create a GroupSpec.
     * @example
     * // Update or create a GroupSpec
     * const groupSpec = await prisma.groupSpec.upsert({
     *   create: {
     *     // ... data to create a GroupSpec
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupSpec we want to update
     *   }
     * })
    **/
    upsert<T extends GroupSpecUpsertArgs>(
      args: SelectSubset<T, GroupSpecUpsertArgs>
    ): CheckSelect<T, Prisma__GroupSpecClient<GroupSpec>, Prisma__GroupSpecClient<GroupSpecGetPayload<T>>>

    /**
     * Find one GroupSpec that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {GroupSpecFindUniqueOrThrowArgs} args - Arguments to find a GroupSpec
     * @example
     * // Get one GroupSpec
     * const groupSpec = await prisma.groupSpec.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GroupSpecFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, GroupSpecFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__GroupSpecClient<GroupSpec>, Prisma__GroupSpecClient<GroupSpecGetPayload<T>>>

    /**
     * Find the first GroupSpec that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupSpecFindFirstOrThrowArgs} args - Arguments to find a GroupSpec
     * @example
     * // Get one GroupSpec
     * const groupSpec = await prisma.groupSpec.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GroupSpecFindFirstOrThrowArgs>(
      args?: SelectSubset<T, GroupSpecFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__GroupSpecClient<GroupSpec>, Prisma__GroupSpecClient<GroupSpecGetPayload<T>>>

    /**
     * Count the number of GroupSpecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupSpecCountArgs} args - Arguments to filter GroupSpecs to count.
     * @example
     * // Count the number of GroupSpecs
     * const count = await prisma.groupSpec.count({
     *   where: {
     *     // ... the filter for the GroupSpecs we want to count
     *   }
     * })
    **/
    count<T extends GroupSpecCountArgs>(
      args?: Subset<T, GroupSpecCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupSpecCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupSpec.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupSpecAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupSpecAggregateArgs>(args: Subset<T, GroupSpecAggregateArgs>): PrismaPromise<GetGroupSpecAggregateType<T>>

    /**
     * Group by GroupSpec.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupSpecGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupSpecGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupSpecGroupByArgs['orderBy'] }
        : { orderBy?: GroupSpecGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupSpecGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupSpecGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupSpec.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GroupSpecClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    groups<T extends GroupsArgs = {}>(args?: Subset<T, GroupsArgs>): CheckSelect<T, Prisma__GroupsClient<Groups | null >, Prisma__GroupsClient<GroupsGetPayload<T> | null >>;

    spec<T extends SpecArgs = {}>(args?: Subset<T, SpecArgs>): CheckSelect<T, Prisma__SpecClient<Spec | null >, Prisma__SpecClient<SpecGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * GroupSpec base type for findUnique actions
   */
  export type GroupSpecFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the GroupSpec
     * 
    **/
    select?: GroupSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupSpecInclude | null
    /**
     * Filter, which GroupSpec to fetch.
     * 
    **/
    where: GroupSpecWhereUniqueInput
  }

  /**
   * GroupSpec: findUnique
   */
  export interface GroupSpecFindUniqueArgs extends GroupSpecFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * GroupSpec base type for findFirst actions
   */
  export type GroupSpecFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the GroupSpec
     * 
    **/
    select?: GroupSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupSpecInclude | null
    /**
     * Filter, which GroupSpec to fetch.
     * 
    **/
    where?: GroupSpecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupSpecs to fetch.
     * 
    **/
    orderBy?: Enumerable<GroupSpecOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupSpecs.
     * 
    **/
    cursor?: GroupSpecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupSpecs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupSpecs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupSpecs.
     * 
    **/
    distinct?: Enumerable<GroupSpecScalarFieldEnum>
  }

  /**
   * GroupSpec: findFirst
   */
  export interface GroupSpecFindFirstArgs extends GroupSpecFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * GroupSpec findMany
   */
  export type GroupSpecFindManyArgs = {
    /**
     * Select specific fields to fetch from the GroupSpec
     * 
    **/
    select?: GroupSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupSpecInclude | null
    /**
     * Filter, which GroupSpecs to fetch.
     * 
    **/
    where?: GroupSpecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupSpecs to fetch.
     * 
    **/
    orderBy?: Enumerable<GroupSpecOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupSpecs.
     * 
    **/
    cursor?: GroupSpecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupSpecs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupSpecs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<GroupSpecScalarFieldEnum>
  }


  /**
   * GroupSpec create
   */
  export type GroupSpecCreateArgs = {
    /**
     * Select specific fields to fetch from the GroupSpec
     * 
    **/
    select?: GroupSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupSpecInclude | null
    /**
     * The data needed to create a GroupSpec.
     * 
    **/
    data: XOR<GroupSpecCreateInput, GroupSpecUncheckedCreateInput>
  }


  /**
   * GroupSpec createMany
   */
  export type GroupSpecCreateManyArgs = {
    /**
     * The data used to create many GroupSpecs.
     * 
    **/
    data: Enumerable<GroupSpecCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * GroupSpec update
   */
  export type GroupSpecUpdateArgs = {
    /**
     * Select specific fields to fetch from the GroupSpec
     * 
    **/
    select?: GroupSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupSpecInclude | null
    /**
     * The data needed to update a GroupSpec.
     * 
    **/
    data: XOR<GroupSpecUpdateInput, GroupSpecUncheckedUpdateInput>
    /**
     * Choose, which GroupSpec to update.
     * 
    **/
    where: GroupSpecWhereUniqueInput
  }


  /**
   * GroupSpec updateMany
   */
  export type GroupSpecUpdateManyArgs = {
    /**
     * The data used to update GroupSpecs.
     * 
    **/
    data: XOR<GroupSpecUpdateManyMutationInput, GroupSpecUncheckedUpdateManyInput>
    /**
     * Filter which GroupSpecs to update
     * 
    **/
    where?: GroupSpecWhereInput
  }


  /**
   * GroupSpec upsert
   */
  export type GroupSpecUpsertArgs = {
    /**
     * Select specific fields to fetch from the GroupSpec
     * 
    **/
    select?: GroupSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupSpecInclude | null
    /**
     * The filter to search for the GroupSpec to update in case it exists.
     * 
    **/
    where: GroupSpecWhereUniqueInput
    /**
     * In case the GroupSpec found by the `where` argument doesn't exist, create a new GroupSpec with this data.
     * 
    **/
    create: XOR<GroupSpecCreateInput, GroupSpecUncheckedCreateInput>
    /**
     * In case the GroupSpec was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<GroupSpecUpdateInput, GroupSpecUncheckedUpdateInput>
  }


  /**
   * GroupSpec delete
   */
  export type GroupSpecDeleteArgs = {
    /**
     * Select specific fields to fetch from the GroupSpec
     * 
    **/
    select?: GroupSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupSpecInclude | null
    /**
     * Filter which GroupSpec to delete.
     * 
    **/
    where: GroupSpecWhereUniqueInput
  }


  /**
   * GroupSpec deleteMany
   */
  export type GroupSpecDeleteManyArgs = {
    /**
     * Filter which GroupSpecs to delete
     * 
    **/
    where?: GroupSpecWhereInput
  }


  /**
   * GroupSpec: findUniqueOrThrow
   */
  export type GroupSpecFindUniqueOrThrowArgs = GroupSpecFindUniqueArgsBase
      

  /**
   * GroupSpec: findFirstOrThrow
   */
  export type GroupSpecFindFirstOrThrowArgs = GroupSpecFindFirstArgsBase
      

  /**
   * GroupSpec without action
   */
  export type GroupSpecArgs = {
    /**
     * Select specific fields to fetch from the GroupSpec
     * 
    **/
    select?: GroupSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupSpecInclude | null
  }



  /**
   * Model GroupUser
   */


  export type AggregateGroupUser = {
    _count: GroupUserCountAggregateOutputType | null
    _avg: GroupUserAvgAggregateOutputType | null
    _sum: GroupUserSumAggregateOutputType | null
    _min: GroupUserMinAggregateOutputType | null
    _max: GroupUserMaxAggregateOutputType | null
  }

  export type GroupUserAvgAggregateOutputType = {
    groupId: number | null
  }

  export type GroupUserSumAggregateOutputType = {
    groupId: number | null
  }

  export type GroupUserMinAggregateOutputType = {
    userId: string | null
    groupId: number | null
  }

  export type GroupUserMaxAggregateOutputType = {
    userId: string | null
    groupId: number | null
  }

  export type GroupUserCountAggregateOutputType = {
    userId: number
    groupId: number
    _all: number
  }


  export type GroupUserAvgAggregateInputType = {
    groupId?: true
  }

  export type GroupUserSumAggregateInputType = {
    groupId?: true
  }

  export type GroupUserMinAggregateInputType = {
    userId?: true
    groupId?: true
  }

  export type GroupUserMaxAggregateInputType = {
    userId?: true
    groupId?: true
  }

  export type GroupUserCountAggregateInputType = {
    userId?: true
    groupId?: true
    _all?: true
  }

  export type GroupUserAggregateArgs = {
    /**
     * Filter which GroupUser to aggregate.
     * 
    **/
    where?: GroupUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<GroupUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: GroupUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupUsers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupUsers
    **/
    _count?: true | GroupUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupUserMaxAggregateInputType
  }

  export type GetGroupUserAggregateType<T extends GroupUserAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupUser[P]>
      : GetScalarType<T[P], AggregateGroupUser[P]>
  }




  export type GroupUserGroupByArgs = {
    where?: GroupUserWhereInput
    orderBy?: Enumerable<GroupUserOrderByWithAggregationInput>
    by: Array<GroupUserScalarFieldEnum>
    having?: GroupUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupUserCountAggregateInputType | true
    _avg?: GroupUserAvgAggregateInputType
    _sum?: GroupUserSumAggregateInputType
    _min?: GroupUserMinAggregateInputType
    _max?: GroupUserMaxAggregateInputType
  }


  export type GroupUserGroupByOutputType = {
    userId: string
    groupId: number
    _count: GroupUserCountAggregateOutputType | null
    _avg: GroupUserAvgAggregateOutputType | null
    _sum: GroupUserSumAggregateOutputType | null
    _min: GroupUserMinAggregateOutputType | null
    _max: GroupUserMaxAggregateOutputType | null
  }

  type GetGroupUserGroupByPayload<T extends GroupUserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<GroupUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupUserGroupByOutputType[P]>
            : GetScalarType<T[P], GroupUserGroupByOutputType[P]>
        }
      >
    >


  export type GroupUserSelect = {
    userId?: boolean
    groupId?: boolean
    groups?: boolean | GroupsArgs
    users?: boolean | UserArgs
  }

  export type GroupUserInclude = {
    groups?: boolean | GroupsArgs
    users?: boolean | UserArgs
  }

  export type GroupUserGetPayload<
    S extends boolean | null | undefined | GroupUserArgs,
    U = keyof S
      > = S extends true
        ? GroupUser
    : S extends undefined
    ? never
    : S extends GroupUserArgs | GroupUserFindManyArgs
    ?'include' extends U
    ? GroupUser  & {
    [P in TrueKeys<S['include']>]:
        P extends 'groups' ? GroupsGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'users' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'groups' ? GroupsGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'users' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof GroupUser ? GroupUser[P] : never
  } 
    : GroupUser
  : GroupUser


  type GroupUserCountArgs = Merge<
    Omit<GroupUserFindManyArgs, 'select' | 'include'> & {
      select?: GroupUserCountAggregateInputType | true
    }
  >

  export interface GroupUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one GroupUser that matches the filter.
     * @param {GroupUserFindUniqueArgs} args - Arguments to find a GroupUser
     * @example
     * // Get one GroupUser
     * const groupUser = await prisma.groupUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GroupUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GroupUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'GroupUser'> extends True ? CheckSelect<T, Prisma__GroupUserClient<GroupUser>, Prisma__GroupUserClient<GroupUserGetPayload<T>>> : CheckSelect<T, Prisma__GroupUserClient<GroupUser | null >, Prisma__GroupUserClient<GroupUserGetPayload<T> | null >>

    /**
     * Find the first GroupUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupUserFindFirstArgs} args - Arguments to find a GroupUser
     * @example
     * // Get one GroupUser
     * const groupUser = await prisma.groupUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GroupUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GroupUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'GroupUser'> extends True ? CheckSelect<T, Prisma__GroupUserClient<GroupUser>, Prisma__GroupUserClient<GroupUserGetPayload<T>>> : CheckSelect<T, Prisma__GroupUserClient<GroupUser | null >, Prisma__GroupUserClient<GroupUserGetPayload<T> | null >>

    /**
     * Find zero or more GroupUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupUsers
     * const groupUsers = await prisma.groupUser.findMany()
     * 
     * // Get first 10 GroupUsers
     * const groupUsers = await prisma.groupUser.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const groupUserWithUserIdOnly = await prisma.groupUser.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends GroupUserFindManyArgs>(
      args?: SelectSubset<T, GroupUserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<GroupUser>>, PrismaPromise<Array<GroupUserGetPayload<T>>>>

    /**
     * Create a GroupUser.
     * @param {GroupUserCreateArgs} args - Arguments to create a GroupUser.
     * @example
     * // Create one GroupUser
     * const GroupUser = await prisma.groupUser.create({
     *   data: {
     *     // ... data to create a GroupUser
     *   }
     * })
     * 
    **/
    create<T extends GroupUserCreateArgs>(
      args: SelectSubset<T, GroupUserCreateArgs>
    ): CheckSelect<T, Prisma__GroupUserClient<GroupUser>, Prisma__GroupUserClient<GroupUserGetPayload<T>>>

    /**
     * Create many GroupUsers.
     *     @param {GroupUserCreateManyArgs} args - Arguments to create many GroupUsers.
     *     @example
     *     // Create many GroupUsers
     *     const groupUser = await prisma.groupUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GroupUserCreateManyArgs>(
      args?: SelectSubset<T, GroupUserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a GroupUser.
     * @param {GroupUserDeleteArgs} args - Arguments to delete one GroupUser.
     * @example
     * // Delete one GroupUser
     * const GroupUser = await prisma.groupUser.delete({
     *   where: {
     *     // ... filter to delete one GroupUser
     *   }
     * })
     * 
    **/
    delete<T extends GroupUserDeleteArgs>(
      args: SelectSubset<T, GroupUserDeleteArgs>
    ): CheckSelect<T, Prisma__GroupUserClient<GroupUser>, Prisma__GroupUserClient<GroupUserGetPayload<T>>>

    /**
     * Update one GroupUser.
     * @param {GroupUserUpdateArgs} args - Arguments to update one GroupUser.
     * @example
     * // Update one GroupUser
     * const groupUser = await prisma.groupUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GroupUserUpdateArgs>(
      args: SelectSubset<T, GroupUserUpdateArgs>
    ): CheckSelect<T, Prisma__GroupUserClient<GroupUser>, Prisma__GroupUserClient<GroupUserGetPayload<T>>>

    /**
     * Delete zero or more GroupUsers.
     * @param {GroupUserDeleteManyArgs} args - Arguments to filter GroupUsers to delete.
     * @example
     * // Delete a few GroupUsers
     * const { count } = await prisma.groupUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GroupUserDeleteManyArgs>(
      args?: SelectSubset<T, GroupUserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupUsers
     * const groupUser = await prisma.groupUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GroupUserUpdateManyArgs>(
      args: SelectSubset<T, GroupUserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one GroupUser.
     * @param {GroupUserUpsertArgs} args - Arguments to update or create a GroupUser.
     * @example
     * // Update or create a GroupUser
     * const groupUser = await prisma.groupUser.upsert({
     *   create: {
     *     // ... data to create a GroupUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupUser we want to update
     *   }
     * })
    **/
    upsert<T extends GroupUserUpsertArgs>(
      args: SelectSubset<T, GroupUserUpsertArgs>
    ): CheckSelect<T, Prisma__GroupUserClient<GroupUser>, Prisma__GroupUserClient<GroupUserGetPayload<T>>>

    /**
     * Find one GroupUser that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {GroupUserFindUniqueOrThrowArgs} args - Arguments to find a GroupUser
     * @example
     * // Get one GroupUser
     * const groupUser = await prisma.groupUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GroupUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, GroupUserFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__GroupUserClient<GroupUser>, Prisma__GroupUserClient<GroupUserGetPayload<T>>>

    /**
     * Find the first GroupUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupUserFindFirstOrThrowArgs} args - Arguments to find a GroupUser
     * @example
     * // Get one GroupUser
     * const groupUser = await prisma.groupUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GroupUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, GroupUserFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__GroupUserClient<GroupUser>, Prisma__GroupUserClient<GroupUserGetPayload<T>>>

    /**
     * Count the number of GroupUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupUserCountArgs} args - Arguments to filter GroupUsers to count.
     * @example
     * // Count the number of GroupUsers
     * const count = await prisma.groupUser.count({
     *   where: {
     *     // ... the filter for the GroupUsers we want to count
     *   }
     * })
    **/
    count<T extends GroupUserCountArgs>(
      args?: Subset<T, GroupUserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupUserAggregateArgs>(args: Subset<T, GroupUserAggregateArgs>): PrismaPromise<GetGroupUserAggregateType<T>>

    /**
     * Group by GroupUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupUserGroupByArgs['orderBy'] }
        : { orderBy?: GroupUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupUserGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GroupUserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    groups<T extends GroupsArgs = {}>(args?: Subset<T, GroupsArgs>): CheckSelect<T, Prisma__GroupsClient<Groups | null >, Prisma__GroupsClient<GroupsGetPayload<T> | null >>;

    users<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * GroupUser base type for findUnique actions
   */
  export type GroupUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the GroupUser
     * 
    **/
    select?: GroupUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupUserInclude | null
    /**
     * Filter, which GroupUser to fetch.
     * 
    **/
    where: GroupUserWhereUniqueInput
  }

  /**
   * GroupUser: findUnique
   */
  export interface GroupUserFindUniqueArgs extends GroupUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * GroupUser base type for findFirst actions
   */
  export type GroupUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the GroupUser
     * 
    **/
    select?: GroupUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupUserInclude | null
    /**
     * Filter, which GroupUser to fetch.
     * 
    **/
    where?: GroupUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<GroupUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupUsers.
     * 
    **/
    cursor?: GroupUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupUsers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupUsers.
     * 
    **/
    distinct?: Enumerable<GroupUserScalarFieldEnum>
  }

  /**
   * GroupUser: findFirst
   */
  export interface GroupUserFindFirstArgs extends GroupUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * GroupUser findMany
   */
  export type GroupUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the GroupUser
     * 
    **/
    select?: GroupUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupUserInclude | null
    /**
     * Filter, which GroupUsers to fetch.
     * 
    **/
    where?: GroupUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<GroupUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupUsers.
     * 
    **/
    cursor?: GroupUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupUsers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<GroupUserScalarFieldEnum>
  }


  /**
   * GroupUser create
   */
  export type GroupUserCreateArgs = {
    /**
     * Select specific fields to fetch from the GroupUser
     * 
    **/
    select?: GroupUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupUserInclude | null
    /**
     * The data needed to create a GroupUser.
     * 
    **/
    data: XOR<GroupUserCreateInput, GroupUserUncheckedCreateInput>
  }


  /**
   * GroupUser createMany
   */
  export type GroupUserCreateManyArgs = {
    /**
     * The data used to create many GroupUsers.
     * 
    **/
    data: Enumerable<GroupUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * GroupUser update
   */
  export type GroupUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the GroupUser
     * 
    **/
    select?: GroupUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupUserInclude | null
    /**
     * The data needed to update a GroupUser.
     * 
    **/
    data: XOR<GroupUserUpdateInput, GroupUserUncheckedUpdateInput>
    /**
     * Choose, which GroupUser to update.
     * 
    **/
    where: GroupUserWhereUniqueInput
  }


  /**
   * GroupUser updateMany
   */
  export type GroupUserUpdateManyArgs = {
    /**
     * The data used to update GroupUsers.
     * 
    **/
    data: XOR<GroupUserUpdateManyMutationInput, GroupUserUncheckedUpdateManyInput>
    /**
     * Filter which GroupUsers to update
     * 
    **/
    where?: GroupUserWhereInput
  }


  /**
   * GroupUser upsert
   */
  export type GroupUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the GroupUser
     * 
    **/
    select?: GroupUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupUserInclude | null
    /**
     * The filter to search for the GroupUser to update in case it exists.
     * 
    **/
    where: GroupUserWhereUniqueInput
    /**
     * In case the GroupUser found by the `where` argument doesn't exist, create a new GroupUser with this data.
     * 
    **/
    create: XOR<GroupUserCreateInput, GroupUserUncheckedCreateInput>
    /**
     * In case the GroupUser was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<GroupUserUpdateInput, GroupUserUncheckedUpdateInput>
  }


  /**
   * GroupUser delete
   */
  export type GroupUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the GroupUser
     * 
    **/
    select?: GroupUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupUserInclude | null
    /**
     * Filter which GroupUser to delete.
     * 
    **/
    where: GroupUserWhereUniqueInput
  }


  /**
   * GroupUser deleteMany
   */
  export type GroupUserDeleteManyArgs = {
    /**
     * Filter which GroupUsers to delete
     * 
    **/
    where?: GroupUserWhereInput
  }


  /**
   * GroupUser: findUniqueOrThrow
   */
  export type GroupUserFindUniqueOrThrowArgs = GroupUserFindUniqueArgsBase
      

  /**
   * GroupUser: findFirstOrThrow
   */
  export type GroupUserFindFirstOrThrowArgs = GroupUserFindFirstArgsBase
      

  /**
   * GroupUser without action
   */
  export type GroupUserArgs = {
    /**
     * Select specific fields to fetch from the GroupUser
     * 
    **/
    select?: GroupUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupUserInclude | null
  }



  /**
   * Model Ingredient
   */


  export type AggregateIngredient = {
    _count: IngredientCountAggregateOutputType | null
    _avg: IngredientAvgAggregateOutputType | null
    _sum: IngredientSumAggregateOutputType | null
    _min: IngredientMinAggregateOutputType | null
    _max: IngredientMaxAggregateOutputType | null
  }

  export type IngredientAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    price: Decimal | null
  }

  export type IngredientSumAggregateOutputType = {
    id: number | null
    amount: number | null
    price: Decimal | null
  }

  export type IngredientMinAggregateOutputType = {
    id: number | null
    dateCreated: Date | null
    name: string | null
    amount: number | null
    unit: string | null
    price: Decimal | null
    source: string | null
    postedById: string | null
  }

  export type IngredientMaxAggregateOutputType = {
    id: number | null
    dateCreated: Date | null
    name: string | null
    amount: number | null
    unit: string | null
    price: Decimal | null
    source: string | null
    postedById: string | null
  }

  export type IngredientCountAggregateOutputType = {
    id: number
    dateCreated: number
    name: number
    amount: number
    unit: number
    price: number
    source: number
    postedById: number
    _all: number
  }


  export type IngredientAvgAggregateInputType = {
    id?: true
    amount?: true
    price?: true
  }

  export type IngredientSumAggregateInputType = {
    id?: true
    amount?: true
    price?: true
  }

  export type IngredientMinAggregateInputType = {
    id?: true
    dateCreated?: true
    name?: true
    amount?: true
    unit?: true
    price?: true
    source?: true
    postedById?: true
  }

  export type IngredientMaxAggregateInputType = {
    id?: true
    dateCreated?: true
    name?: true
    amount?: true
    unit?: true
    price?: true
    source?: true
    postedById?: true
  }

  export type IngredientCountAggregateInputType = {
    id?: true
    dateCreated?: true
    name?: true
    amount?: true
    unit?: true
    price?: true
    source?: true
    postedById?: true
    _all?: true
  }

  export type IngredientAggregateArgs = {
    /**
     * Filter which Ingredient to aggregate.
     * 
    **/
    where?: IngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ingredients to fetch.
     * 
    **/
    orderBy?: Enumerable<IngredientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: IngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ingredients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ingredients.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ingredients
    **/
    _count?: true | IngredientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IngredientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IngredientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IngredientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IngredientMaxAggregateInputType
  }

  export type GetIngredientAggregateType<T extends IngredientAggregateArgs> = {
        [P in keyof T & keyof AggregateIngredient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIngredient[P]>
      : GetScalarType<T[P], AggregateIngredient[P]>
  }




  export type IngredientGroupByArgs = {
    where?: IngredientWhereInput
    orderBy?: Enumerable<IngredientOrderByWithAggregationInput>
    by: Array<IngredientScalarFieldEnum>
    having?: IngredientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IngredientCountAggregateInputType | true
    _avg?: IngredientAvgAggregateInputType
    _sum?: IngredientSumAggregateInputType
    _min?: IngredientMinAggregateInputType
    _max?: IngredientMaxAggregateInputType
  }


  export type IngredientGroupByOutputType = {
    id: number
    dateCreated: Date
    name: string
    amount: number | null
    unit: string | null
    price: Decimal | null
    source: string | null
    postedById: string
    _count: IngredientCountAggregateOutputType | null
    _avg: IngredientAvgAggregateOutputType | null
    _sum: IngredientSumAggregateOutputType | null
    _min: IngredientMinAggregateOutputType | null
    _max: IngredientMaxAggregateOutputType | null
  }

  type GetIngredientGroupByPayload<T extends IngredientGroupByArgs> = PrismaPromise<
    Array<
      PickArray<IngredientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IngredientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IngredientGroupByOutputType[P]>
            : GetScalarType<T[P], IngredientGroupByOutputType[P]>
        }
      >
    >


  export type IngredientSelect = {
    id?: boolean
    dateCreated?: boolean
    name?: boolean
    amount?: boolean
    unit?: boolean
    price?: boolean
    source?: boolean
    postedBy?: boolean | UserArgs
    postedById?: boolean
    groupIngredient?: boolean | GroupIngredientFindManyArgs
    touch?: boolean | TouchFindManyArgs
    sharedIngredient?: boolean | SharedIngredientFindManyArgs
    _count?: boolean | IngredientCountOutputTypeArgs
  }

  export type IngredientInclude = {
    postedBy?: boolean | UserArgs
    groupIngredient?: boolean | GroupIngredientFindManyArgs
    touch?: boolean | TouchFindManyArgs
    sharedIngredient?: boolean | SharedIngredientFindManyArgs
    _count?: boolean | IngredientCountOutputTypeArgs
  }

  export type IngredientGetPayload<
    S extends boolean | null | undefined | IngredientArgs,
    U = keyof S
      > = S extends true
        ? Ingredient
    : S extends undefined
    ? never
    : S extends IngredientArgs | IngredientFindManyArgs
    ?'include' extends U
    ? Ingredient  & {
    [P in TrueKeys<S['include']>]:
        P extends 'postedBy' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'groupIngredient' ? Array < GroupIngredientGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'touch' ? Array < TouchGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'sharedIngredient' ? Array < SharedIngredientGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? IngredientCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'postedBy' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'groupIngredient' ? Array < GroupIngredientGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'touch' ? Array < TouchGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'sharedIngredient' ? Array < SharedIngredientGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? IngredientCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Ingredient ? Ingredient[P] : never
  } 
    : Ingredient
  : Ingredient


  type IngredientCountArgs = Merge<
    Omit<IngredientFindManyArgs, 'select' | 'include'> & {
      select?: IngredientCountAggregateInputType | true
    }
  >

  export interface IngredientDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Ingredient that matches the filter.
     * @param {IngredientFindUniqueArgs} args - Arguments to find a Ingredient
     * @example
     * // Get one Ingredient
     * const ingredient = await prisma.ingredient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IngredientFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, IngredientFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Ingredient'> extends True ? CheckSelect<T, Prisma__IngredientClient<Ingredient>, Prisma__IngredientClient<IngredientGetPayload<T>>> : CheckSelect<T, Prisma__IngredientClient<Ingredient | null >, Prisma__IngredientClient<IngredientGetPayload<T> | null >>

    /**
     * Find the first Ingredient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientFindFirstArgs} args - Arguments to find a Ingredient
     * @example
     * // Get one Ingredient
     * const ingredient = await prisma.ingredient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IngredientFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, IngredientFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Ingredient'> extends True ? CheckSelect<T, Prisma__IngredientClient<Ingredient>, Prisma__IngredientClient<IngredientGetPayload<T>>> : CheckSelect<T, Prisma__IngredientClient<Ingredient | null >, Prisma__IngredientClient<IngredientGetPayload<T> | null >>

    /**
     * Find zero or more Ingredients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ingredients
     * const ingredients = await prisma.ingredient.findMany()
     * 
     * // Get first 10 Ingredients
     * const ingredients = await prisma.ingredient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ingredientWithIdOnly = await prisma.ingredient.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends IngredientFindManyArgs>(
      args?: SelectSubset<T, IngredientFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Ingredient>>, PrismaPromise<Array<IngredientGetPayload<T>>>>

    /**
     * Create a Ingredient.
     * @param {IngredientCreateArgs} args - Arguments to create a Ingredient.
     * @example
     * // Create one Ingredient
     * const Ingredient = await prisma.ingredient.create({
     *   data: {
     *     // ... data to create a Ingredient
     *   }
     * })
     * 
    **/
    create<T extends IngredientCreateArgs>(
      args: SelectSubset<T, IngredientCreateArgs>
    ): CheckSelect<T, Prisma__IngredientClient<Ingredient>, Prisma__IngredientClient<IngredientGetPayload<T>>>

    /**
     * Create many Ingredients.
     *     @param {IngredientCreateManyArgs} args - Arguments to create many Ingredients.
     *     @example
     *     // Create many Ingredients
     *     const ingredient = await prisma.ingredient.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IngredientCreateManyArgs>(
      args?: SelectSubset<T, IngredientCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Ingredient.
     * @param {IngredientDeleteArgs} args - Arguments to delete one Ingredient.
     * @example
     * // Delete one Ingredient
     * const Ingredient = await prisma.ingredient.delete({
     *   where: {
     *     // ... filter to delete one Ingredient
     *   }
     * })
     * 
    **/
    delete<T extends IngredientDeleteArgs>(
      args: SelectSubset<T, IngredientDeleteArgs>
    ): CheckSelect<T, Prisma__IngredientClient<Ingredient>, Prisma__IngredientClient<IngredientGetPayload<T>>>

    /**
     * Update one Ingredient.
     * @param {IngredientUpdateArgs} args - Arguments to update one Ingredient.
     * @example
     * // Update one Ingredient
     * const ingredient = await prisma.ingredient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IngredientUpdateArgs>(
      args: SelectSubset<T, IngredientUpdateArgs>
    ): CheckSelect<T, Prisma__IngredientClient<Ingredient>, Prisma__IngredientClient<IngredientGetPayload<T>>>

    /**
     * Delete zero or more Ingredients.
     * @param {IngredientDeleteManyArgs} args - Arguments to filter Ingredients to delete.
     * @example
     * // Delete a few Ingredients
     * const { count } = await prisma.ingredient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IngredientDeleteManyArgs>(
      args?: SelectSubset<T, IngredientDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ingredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ingredients
     * const ingredient = await prisma.ingredient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IngredientUpdateManyArgs>(
      args: SelectSubset<T, IngredientUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Ingredient.
     * @param {IngredientUpsertArgs} args - Arguments to update or create a Ingredient.
     * @example
     * // Update or create a Ingredient
     * const ingredient = await prisma.ingredient.upsert({
     *   create: {
     *     // ... data to create a Ingredient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ingredient we want to update
     *   }
     * })
    **/
    upsert<T extends IngredientUpsertArgs>(
      args: SelectSubset<T, IngredientUpsertArgs>
    ): CheckSelect<T, Prisma__IngredientClient<Ingredient>, Prisma__IngredientClient<IngredientGetPayload<T>>>

    /**
     * Find one Ingredient that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {IngredientFindUniqueOrThrowArgs} args - Arguments to find a Ingredient
     * @example
     * // Get one Ingredient
     * const ingredient = await prisma.ingredient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends IngredientFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, IngredientFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__IngredientClient<Ingredient>, Prisma__IngredientClient<IngredientGetPayload<T>>>

    /**
     * Find the first Ingredient that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientFindFirstOrThrowArgs} args - Arguments to find a Ingredient
     * @example
     * // Get one Ingredient
     * const ingredient = await prisma.ingredient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends IngredientFindFirstOrThrowArgs>(
      args?: SelectSubset<T, IngredientFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__IngredientClient<Ingredient>, Prisma__IngredientClient<IngredientGetPayload<T>>>

    /**
     * Count the number of Ingredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientCountArgs} args - Arguments to filter Ingredients to count.
     * @example
     * // Count the number of Ingredients
     * const count = await prisma.ingredient.count({
     *   where: {
     *     // ... the filter for the Ingredients we want to count
     *   }
     * })
    **/
    count<T extends IngredientCountArgs>(
      args?: Subset<T, IngredientCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IngredientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ingredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IngredientAggregateArgs>(args: Subset<T, IngredientAggregateArgs>): PrismaPromise<GetIngredientAggregateType<T>>

    /**
     * Group by Ingredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IngredientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IngredientGroupByArgs['orderBy'] }
        : { orderBy?: IngredientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IngredientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIngredientGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Ingredient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__IngredientClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    postedBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    groupIngredient<T extends GroupIngredientFindManyArgs = {}>(args?: Subset<T, GroupIngredientFindManyArgs>): CheckSelect<T, PrismaPromise<Array<GroupIngredient>>, PrismaPromise<Array<GroupIngredientGetPayload<T>>>>;

    touch<T extends TouchFindManyArgs = {}>(args?: Subset<T, TouchFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Touch>>, PrismaPromise<Array<TouchGetPayload<T>>>>;

    sharedIngredient<T extends SharedIngredientFindManyArgs = {}>(args?: Subset<T, SharedIngredientFindManyArgs>): CheckSelect<T, PrismaPromise<Array<SharedIngredient>>, PrismaPromise<Array<SharedIngredientGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Ingredient base type for findUnique actions
   */
  export type IngredientFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Ingredient
     * 
    **/
    select?: IngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IngredientInclude | null
    /**
     * Filter, which Ingredient to fetch.
     * 
    **/
    where: IngredientWhereUniqueInput
  }

  /**
   * Ingredient: findUnique
   */
  export interface IngredientFindUniqueArgs extends IngredientFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Ingredient base type for findFirst actions
   */
  export type IngredientFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Ingredient
     * 
    **/
    select?: IngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IngredientInclude | null
    /**
     * Filter, which Ingredient to fetch.
     * 
    **/
    where?: IngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ingredients to fetch.
     * 
    **/
    orderBy?: Enumerable<IngredientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ingredients.
     * 
    **/
    cursor?: IngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ingredients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ingredients.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ingredients.
     * 
    **/
    distinct?: Enumerable<IngredientScalarFieldEnum>
  }

  /**
   * Ingredient: findFirst
   */
  export interface IngredientFindFirstArgs extends IngredientFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Ingredient findMany
   */
  export type IngredientFindManyArgs = {
    /**
     * Select specific fields to fetch from the Ingredient
     * 
    **/
    select?: IngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IngredientInclude | null
    /**
     * Filter, which Ingredients to fetch.
     * 
    **/
    where?: IngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ingredients to fetch.
     * 
    **/
    orderBy?: Enumerable<IngredientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ingredients.
     * 
    **/
    cursor?: IngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ingredients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ingredients.
     * 
    **/
    skip?: number
    distinct?: Enumerable<IngredientScalarFieldEnum>
  }


  /**
   * Ingredient create
   */
  export type IngredientCreateArgs = {
    /**
     * Select specific fields to fetch from the Ingredient
     * 
    **/
    select?: IngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IngredientInclude | null
    /**
     * The data needed to create a Ingredient.
     * 
    **/
    data: XOR<IngredientCreateInput, IngredientUncheckedCreateInput>
  }


  /**
   * Ingredient createMany
   */
  export type IngredientCreateManyArgs = {
    /**
     * The data used to create many Ingredients.
     * 
    **/
    data: Enumerable<IngredientCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Ingredient update
   */
  export type IngredientUpdateArgs = {
    /**
     * Select specific fields to fetch from the Ingredient
     * 
    **/
    select?: IngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IngredientInclude | null
    /**
     * The data needed to update a Ingredient.
     * 
    **/
    data: XOR<IngredientUpdateInput, IngredientUncheckedUpdateInput>
    /**
     * Choose, which Ingredient to update.
     * 
    **/
    where: IngredientWhereUniqueInput
  }


  /**
   * Ingredient updateMany
   */
  export type IngredientUpdateManyArgs = {
    /**
     * The data used to update Ingredients.
     * 
    **/
    data: XOR<IngredientUpdateManyMutationInput, IngredientUncheckedUpdateManyInput>
    /**
     * Filter which Ingredients to update
     * 
    **/
    where?: IngredientWhereInput
  }


  /**
   * Ingredient upsert
   */
  export type IngredientUpsertArgs = {
    /**
     * Select specific fields to fetch from the Ingredient
     * 
    **/
    select?: IngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IngredientInclude | null
    /**
     * The filter to search for the Ingredient to update in case it exists.
     * 
    **/
    where: IngredientWhereUniqueInput
    /**
     * In case the Ingredient found by the `where` argument doesn't exist, create a new Ingredient with this data.
     * 
    **/
    create: XOR<IngredientCreateInput, IngredientUncheckedCreateInput>
    /**
     * In case the Ingredient was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<IngredientUpdateInput, IngredientUncheckedUpdateInput>
  }


  /**
   * Ingredient delete
   */
  export type IngredientDeleteArgs = {
    /**
     * Select specific fields to fetch from the Ingredient
     * 
    **/
    select?: IngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IngredientInclude | null
    /**
     * Filter which Ingredient to delete.
     * 
    **/
    where: IngredientWhereUniqueInput
  }


  /**
   * Ingredient deleteMany
   */
  export type IngredientDeleteManyArgs = {
    /**
     * Filter which Ingredients to delete
     * 
    **/
    where?: IngredientWhereInput
  }


  /**
   * Ingredient: findUniqueOrThrow
   */
  export type IngredientFindUniqueOrThrowArgs = IngredientFindUniqueArgsBase
      

  /**
   * Ingredient: findFirstOrThrow
   */
  export type IngredientFindFirstOrThrowArgs = IngredientFindFirstArgsBase
      

  /**
   * Ingredient without action
   */
  export type IngredientArgs = {
    /**
     * Select specific fields to fetch from the Ingredient
     * 
    **/
    select?: IngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IngredientInclude | null
  }



  /**
   * Model Touch
   */


  export type AggregateTouch = {
    _count: TouchCountAggregateOutputType | null
    _avg: TouchAvgAggregateOutputType | null
    _sum: TouchSumAggregateOutputType | null
    _min: TouchMinAggregateOutputType | null
    _max: TouchMaxAggregateOutputType | null
  }

  export type TouchAvgAggregateOutputType = {
    id: number | null
    ingredientId: number | null
    order: number | null
    amount: number | null
    specId: number | null
  }

  export type TouchSumAggregateOutputType = {
    id: number | null
    ingredientId: number | null
    order: number | null
    amount: number | null
    specId: number | null
  }

  export type TouchMinAggregateOutputType = {
    id: number | null
    ingredientId: number | null
    order: number | null
    amount: number | null
    unit: string | null
    specId: number | null
    postedById: string | null
  }

  export type TouchMaxAggregateOutputType = {
    id: number | null
    ingredientId: number | null
    order: number | null
    amount: number | null
    unit: string | null
    specId: number | null
    postedById: string | null
  }

  export type TouchCountAggregateOutputType = {
    id: number
    ingredientId: number
    order: number
    amount: number
    unit: number
    specId: number
    postedById: number
    _all: number
  }


  export type TouchAvgAggregateInputType = {
    id?: true
    ingredientId?: true
    order?: true
    amount?: true
    specId?: true
  }

  export type TouchSumAggregateInputType = {
    id?: true
    ingredientId?: true
    order?: true
    amount?: true
    specId?: true
  }

  export type TouchMinAggregateInputType = {
    id?: true
    ingredientId?: true
    order?: true
    amount?: true
    unit?: true
    specId?: true
    postedById?: true
  }

  export type TouchMaxAggregateInputType = {
    id?: true
    ingredientId?: true
    order?: true
    amount?: true
    unit?: true
    specId?: true
    postedById?: true
  }

  export type TouchCountAggregateInputType = {
    id?: true
    ingredientId?: true
    order?: true
    amount?: true
    unit?: true
    specId?: true
    postedById?: true
    _all?: true
  }

  export type TouchAggregateArgs = {
    /**
     * Filter which Touch to aggregate.
     * 
    **/
    where?: TouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Touches to fetch.
     * 
    **/
    orderBy?: Enumerable<TouchOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Touches from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Touches.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Touches
    **/
    _count?: true | TouchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TouchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TouchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TouchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TouchMaxAggregateInputType
  }

  export type GetTouchAggregateType<T extends TouchAggregateArgs> = {
        [P in keyof T & keyof AggregateTouch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTouch[P]>
      : GetScalarType<T[P], AggregateTouch[P]>
  }




  export type TouchGroupByArgs = {
    where?: TouchWhereInput
    orderBy?: Enumerable<TouchOrderByWithAggregationInput>
    by: Array<TouchScalarFieldEnum>
    having?: TouchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TouchCountAggregateInputType | true
    _avg?: TouchAvgAggregateInputType
    _sum?: TouchSumAggregateInputType
    _min?: TouchMinAggregateInputType
    _max?: TouchMaxAggregateInputType
  }


  export type TouchGroupByOutputType = {
    id: number
    ingredientId: number | null
    order: number | null
    amount: number | null
    unit: string | null
    specId: number | null
    postedById: string
    _count: TouchCountAggregateOutputType | null
    _avg: TouchAvgAggregateOutputType | null
    _sum: TouchSumAggregateOutputType | null
    _min: TouchMinAggregateOutputType | null
    _max: TouchMaxAggregateOutputType | null
  }

  type GetTouchGroupByPayload<T extends TouchGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TouchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TouchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TouchGroupByOutputType[P]>
            : GetScalarType<T[P], TouchGroupByOutputType[P]>
        }
      >
    >


  export type TouchSelect = {
    id?: boolean
    ingredientId?: boolean
    order?: boolean
    amount?: boolean
    unit?: boolean
    ingredient?: boolean | IngredientArgs
    spec?: boolean | SpecArgs
    specId?: boolean
    postedBy?: boolean | UserArgs
    postedById?: boolean
  }

  export type TouchInclude = {
    ingredient?: boolean | IngredientArgs
    spec?: boolean | SpecArgs
    postedBy?: boolean | UserArgs
  }

  export type TouchGetPayload<
    S extends boolean | null | undefined | TouchArgs,
    U = keyof S
      > = S extends true
        ? Touch
    : S extends undefined
    ? never
    : S extends TouchArgs | TouchFindManyArgs
    ?'include' extends U
    ? Touch  & {
    [P in TrueKeys<S['include']>]:
        P extends 'ingredient' ? IngredientGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'spec' ? SpecGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'postedBy' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'ingredient' ? IngredientGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'spec' ? SpecGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'postedBy' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof Touch ? Touch[P] : never
  } 
    : Touch
  : Touch


  type TouchCountArgs = Merge<
    Omit<TouchFindManyArgs, 'select' | 'include'> & {
      select?: TouchCountAggregateInputType | true
    }
  >

  export interface TouchDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Touch that matches the filter.
     * @param {TouchFindUniqueArgs} args - Arguments to find a Touch
     * @example
     * // Get one Touch
     * const touch = await prisma.touch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TouchFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TouchFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Touch'> extends True ? CheckSelect<T, Prisma__TouchClient<Touch>, Prisma__TouchClient<TouchGetPayload<T>>> : CheckSelect<T, Prisma__TouchClient<Touch | null >, Prisma__TouchClient<TouchGetPayload<T> | null >>

    /**
     * Find the first Touch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchFindFirstArgs} args - Arguments to find a Touch
     * @example
     * // Get one Touch
     * const touch = await prisma.touch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TouchFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TouchFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Touch'> extends True ? CheckSelect<T, Prisma__TouchClient<Touch>, Prisma__TouchClient<TouchGetPayload<T>>> : CheckSelect<T, Prisma__TouchClient<Touch | null >, Prisma__TouchClient<TouchGetPayload<T> | null >>

    /**
     * Find zero or more Touches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Touches
     * const touches = await prisma.touch.findMany()
     * 
     * // Get first 10 Touches
     * const touches = await prisma.touch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const touchWithIdOnly = await prisma.touch.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TouchFindManyArgs>(
      args?: SelectSubset<T, TouchFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Touch>>, PrismaPromise<Array<TouchGetPayload<T>>>>

    /**
     * Create a Touch.
     * @param {TouchCreateArgs} args - Arguments to create a Touch.
     * @example
     * // Create one Touch
     * const Touch = await prisma.touch.create({
     *   data: {
     *     // ... data to create a Touch
     *   }
     * })
     * 
    **/
    create<T extends TouchCreateArgs>(
      args: SelectSubset<T, TouchCreateArgs>
    ): CheckSelect<T, Prisma__TouchClient<Touch>, Prisma__TouchClient<TouchGetPayload<T>>>

    /**
     * Create many Touches.
     *     @param {TouchCreateManyArgs} args - Arguments to create many Touches.
     *     @example
     *     // Create many Touches
     *     const touch = await prisma.touch.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TouchCreateManyArgs>(
      args?: SelectSubset<T, TouchCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Touch.
     * @param {TouchDeleteArgs} args - Arguments to delete one Touch.
     * @example
     * // Delete one Touch
     * const Touch = await prisma.touch.delete({
     *   where: {
     *     // ... filter to delete one Touch
     *   }
     * })
     * 
    **/
    delete<T extends TouchDeleteArgs>(
      args: SelectSubset<T, TouchDeleteArgs>
    ): CheckSelect<T, Prisma__TouchClient<Touch>, Prisma__TouchClient<TouchGetPayload<T>>>

    /**
     * Update one Touch.
     * @param {TouchUpdateArgs} args - Arguments to update one Touch.
     * @example
     * // Update one Touch
     * const touch = await prisma.touch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TouchUpdateArgs>(
      args: SelectSubset<T, TouchUpdateArgs>
    ): CheckSelect<T, Prisma__TouchClient<Touch>, Prisma__TouchClient<TouchGetPayload<T>>>

    /**
     * Delete zero or more Touches.
     * @param {TouchDeleteManyArgs} args - Arguments to filter Touches to delete.
     * @example
     * // Delete a few Touches
     * const { count } = await prisma.touch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TouchDeleteManyArgs>(
      args?: SelectSubset<T, TouchDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Touches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Touches
     * const touch = await prisma.touch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TouchUpdateManyArgs>(
      args: SelectSubset<T, TouchUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Touch.
     * @param {TouchUpsertArgs} args - Arguments to update or create a Touch.
     * @example
     * // Update or create a Touch
     * const touch = await prisma.touch.upsert({
     *   create: {
     *     // ... data to create a Touch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Touch we want to update
     *   }
     * })
    **/
    upsert<T extends TouchUpsertArgs>(
      args: SelectSubset<T, TouchUpsertArgs>
    ): CheckSelect<T, Prisma__TouchClient<Touch>, Prisma__TouchClient<TouchGetPayload<T>>>

    /**
     * Find one Touch that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {TouchFindUniqueOrThrowArgs} args - Arguments to find a Touch
     * @example
     * // Get one Touch
     * const touch = await prisma.touch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TouchFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TouchFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__TouchClient<Touch>, Prisma__TouchClient<TouchGetPayload<T>>>

    /**
     * Find the first Touch that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchFindFirstOrThrowArgs} args - Arguments to find a Touch
     * @example
     * // Get one Touch
     * const touch = await prisma.touch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TouchFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TouchFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__TouchClient<Touch>, Prisma__TouchClient<TouchGetPayload<T>>>

    /**
     * Count the number of Touches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchCountArgs} args - Arguments to filter Touches to count.
     * @example
     * // Count the number of Touches
     * const count = await prisma.touch.count({
     *   where: {
     *     // ... the filter for the Touches we want to count
     *   }
     * })
    **/
    count<T extends TouchCountArgs>(
      args?: Subset<T, TouchCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TouchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Touch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TouchAggregateArgs>(args: Subset<T, TouchAggregateArgs>): PrismaPromise<GetTouchAggregateType<T>>

    /**
     * Group by Touch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TouchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TouchGroupByArgs['orderBy'] }
        : { orderBy?: TouchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TouchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTouchGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Touch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TouchClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    ingredient<T extends IngredientArgs = {}>(args?: Subset<T, IngredientArgs>): CheckSelect<T, Prisma__IngredientClient<Ingredient | null >, Prisma__IngredientClient<IngredientGetPayload<T> | null >>;

    spec<T extends SpecArgs = {}>(args?: Subset<T, SpecArgs>): CheckSelect<T, Prisma__SpecClient<Spec | null >, Prisma__SpecClient<SpecGetPayload<T> | null >>;

    postedBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Touch base type for findUnique actions
   */
  export type TouchFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Touch
     * 
    **/
    select?: TouchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TouchInclude | null
    /**
     * Filter, which Touch to fetch.
     * 
    **/
    where: TouchWhereUniqueInput
  }

  /**
   * Touch: findUnique
   */
  export interface TouchFindUniqueArgs extends TouchFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Touch base type for findFirst actions
   */
  export type TouchFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Touch
     * 
    **/
    select?: TouchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TouchInclude | null
    /**
     * Filter, which Touch to fetch.
     * 
    **/
    where?: TouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Touches to fetch.
     * 
    **/
    orderBy?: Enumerable<TouchOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Touches.
     * 
    **/
    cursor?: TouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Touches from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Touches.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Touches.
     * 
    **/
    distinct?: Enumerable<TouchScalarFieldEnum>
  }

  /**
   * Touch: findFirst
   */
  export interface TouchFindFirstArgs extends TouchFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Touch findMany
   */
  export type TouchFindManyArgs = {
    /**
     * Select specific fields to fetch from the Touch
     * 
    **/
    select?: TouchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TouchInclude | null
    /**
     * Filter, which Touches to fetch.
     * 
    **/
    where?: TouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Touches to fetch.
     * 
    **/
    orderBy?: Enumerable<TouchOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Touches.
     * 
    **/
    cursor?: TouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Touches from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Touches.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TouchScalarFieldEnum>
  }


  /**
   * Touch create
   */
  export type TouchCreateArgs = {
    /**
     * Select specific fields to fetch from the Touch
     * 
    **/
    select?: TouchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TouchInclude | null
    /**
     * The data needed to create a Touch.
     * 
    **/
    data: XOR<TouchCreateInput, TouchUncheckedCreateInput>
  }


  /**
   * Touch createMany
   */
  export type TouchCreateManyArgs = {
    /**
     * The data used to create many Touches.
     * 
    **/
    data: Enumerable<TouchCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Touch update
   */
  export type TouchUpdateArgs = {
    /**
     * Select specific fields to fetch from the Touch
     * 
    **/
    select?: TouchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TouchInclude | null
    /**
     * The data needed to update a Touch.
     * 
    **/
    data: XOR<TouchUpdateInput, TouchUncheckedUpdateInput>
    /**
     * Choose, which Touch to update.
     * 
    **/
    where: TouchWhereUniqueInput
  }


  /**
   * Touch updateMany
   */
  export type TouchUpdateManyArgs = {
    /**
     * The data used to update Touches.
     * 
    **/
    data: XOR<TouchUpdateManyMutationInput, TouchUncheckedUpdateManyInput>
    /**
     * Filter which Touches to update
     * 
    **/
    where?: TouchWhereInput
  }


  /**
   * Touch upsert
   */
  export type TouchUpsertArgs = {
    /**
     * Select specific fields to fetch from the Touch
     * 
    **/
    select?: TouchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TouchInclude | null
    /**
     * The filter to search for the Touch to update in case it exists.
     * 
    **/
    where: TouchWhereUniqueInput
    /**
     * In case the Touch found by the `where` argument doesn't exist, create a new Touch with this data.
     * 
    **/
    create: XOR<TouchCreateInput, TouchUncheckedCreateInput>
    /**
     * In case the Touch was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TouchUpdateInput, TouchUncheckedUpdateInput>
  }


  /**
   * Touch delete
   */
  export type TouchDeleteArgs = {
    /**
     * Select specific fields to fetch from the Touch
     * 
    **/
    select?: TouchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TouchInclude | null
    /**
     * Filter which Touch to delete.
     * 
    **/
    where: TouchWhereUniqueInput
  }


  /**
   * Touch deleteMany
   */
  export type TouchDeleteManyArgs = {
    /**
     * Filter which Touches to delete
     * 
    **/
    where?: TouchWhereInput
  }


  /**
   * Touch: findUniqueOrThrow
   */
  export type TouchFindUniqueOrThrowArgs = TouchFindUniqueArgsBase
      

  /**
   * Touch: findFirstOrThrow
   */
  export type TouchFindFirstOrThrowArgs = TouchFindFirstArgsBase
      

  /**
   * Touch without action
   */
  export type TouchArgs = {
    /**
     * Select specific fields to fetch from the Touch
     * 
    **/
    select?: TouchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TouchInclude | null
  }



  /**
   * Model Recipe
   */


  export type AggregateRecipe = {
    _count: RecipeCountAggregateOutputType | null
    _avg: RecipeAvgAggregateOutputType | null
    _sum: RecipeSumAggregateOutputType | null
    _min: RecipeMinAggregateOutputType | null
    _max: RecipeMaxAggregateOutputType | null
  }

  export type RecipeAvgAggregateOutputType = {
    id: number | null
  }

  export type RecipeSumAggregateOutputType = {
    id: number | null
  }

  export type RecipeMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    origin: string | null
    history: string | null
    postedById: string | null
  }

  export type RecipeMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    origin: string | null
    history: string | null
    postedById: string | null
  }

  export type RecipeCountAggregateOutputType = {
    id: number
    createdAt: number
    name: number
    origin: number
    history: number
    postedById: number
    _all: number
  }


  export type RecipeAvgAggregateInputType = {
    id?: true
  }

  export type RecipeSumAggregateInputType = {
    id?: true
  }

  export type RecipeMinAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    origin?: true
    history?: true
    postedById?: true
  }

  export type RecipeMaxAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    origin?: true
    history?: true
    postedById?: true
  }

  export type RecipeCountAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    origin?: true
    history?: true
    postedById?: true
    _all?: true
  }

  export type RecipeAggregateArgs = {
    /**
     * Filter which Recipe to aggregate.
     * 
    **/
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     * 
    **/
    orderBy?: Enumerable<RecipeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Recipes
    **/
    _count?: true | RecipeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecipeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecipeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeMaxAggregateInputType
  }

  export type GetRecipeAggregateType<T extends RecipeAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipe[P]>
      : GetScalarType<T[P], AggregateRecipe[P]>
  }




  export type RecipeGroupByArgs = {
    where?: RecipeWhereInput
    orderBy?: Enumerable<RecipeOrderByWithAggregationInput>
    by: Array<RecipeScalarFieldEnum>
    having?: RecipeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeCountAggregateInputType | true
    _avg?: RecipeAvgAggregateInputType
    _sum?: RecipeSumAggregateInputType
    _min?: RecipeMinAggregateInputType
    _max?: RecipeMaxAggregateInputType
  }


  export type RecipeGroupByOutputType = {
    id: number
    createdAt: Date
    name: string
    origin: string
    history: string | null
    postedById: string
    _count: RecipeCountAggregateOutputType | null
    _avg: RecipeAvgAggregateOutputType | null
    _sum: RecipeSumAggregateOutputType | null
    _min: RecipeMinAggregateOutputType | null
    _max: RecipeMaxAggregateOutputType | null
  }

  type GetRecipeGroupByPayload<T extends RecipeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RecipeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeGroupByOutputType[P]>
        }
      >
    >


  export type RecipeSelect = {
    id?: boolean
    createdAt?: boolean
    name?: boolean
    origin?: boolean
    history?: boolean
    postedBy?: boolean | UserArgs
    postedById?: boolean
    spec?: boolean | SpecFindManyArgs
    _count?: boolean | RecipeCountOutputTypeArgs
  }

  export type RecipeInclude = {
    postedBy?: boolean | UserArgs
    spec?: boolean | SpecFindManyArgs
    _count?: boolean | RecipeCountOutputTypeArgs
  }

  export type RecipeGetPayload<
    S extends boolean | null | undefined | RecipeArgs,
    U = keyof S
      > = S extends true
        ? Recipe
    : S extends undefined
    ? never
    : S extends RecipeArgs | RecipeFindManyArgs
    ?'include' extends U
    ? Recipe  & {
    [P in TrueKeys<S['include']>]:
        P extends 'postedBy' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'spec' ? Array < SpecGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? RecipeCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'postedBy' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'spec' ? Array < SpecGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? RecipeCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Recipe ? Recipe[P] : never
  } 
    : Recipe
  : Recipe


  type RecipeCountArgs = Merge<
    Omit<RecipeFindManyArgs, 'select' | 'include'> & {
      select?: RecipeCountAggregateInputType | true
    }
  >

  export interface RecipeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Recipe that matches the filter.
     * @param {RecipeFindUniqueArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RecipeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RecipeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Recipe'> extends True ? CheckSelect<T, Prisma__RecipeClient<Recipe>, Prisma__RecipeClient<RecipeGetPayload<T>>> : CheckSelect<T, Prisma__RecipeClient<Recipe | null >, Prisma__RecipeClient<RecipeGetPayload<T> | null >>

    /**
     * Find the first Recipe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindFirstArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RecipeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RecipeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Recipe'> extends True ? CheckSelect<T, Prisma__RecipeClient<Recipe>, Prisma__RecipeClient<RecipeGetPayload<T>>> : CheckSelect<T, Prisma__RecipeClient<Recipe | null >, Prisma__RecipeClient<RecipeGetPayload<T> | null >>

    /**
     * Find zero or more Recipes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recipes
     * const recipes = await prisma.recipe.findMany()
     * 
     * // Get first 10 Recipes
     * const recipes = await prisma.recipe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeWithIdOnly = await prisma.recipe.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RecipeFindManyArgs>(
      args?: SelectSubset<T, RecipeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Recipe>>, PrismaPromise<Array<RecipeGetPayload<T>>>>

    /**
     * Create a Recipe.
     * @param {RecipeCreateArgs} args - Arguments to create a Recipe.
     * @example
     * // Create one Recipe
     * const Recipe = await prisma.recipe.create({
     *   data: {
     *     // ... data to create a Recipe
     *   }
     * })
     * 
    **/
    create<T extends RecipeCreateArgs>(
      args: SelectSubset<T, RecipeCreateArgs>
    ): CheckSelect<T, Prisma__RecipeClient<Recipe>, Prisma__RecipeClient<RecipeGetPayload<T>>>

    /**
     * Create many Recipes.
     *     @param {RecipeCreateManyArgs} args - Arguments to create many Recipes.
     *     @example
     *     // Create many Recipes
     *     const recipe = await prisma.recipe.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RecipeCreateManyArgs>(
      args?: SelectSubset<T, RecipeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Recipe.
     * @param {RecipeDeleteArgs} args - Arguments to delete one Recipe.
     * @example
     * // Delete one Recipe
     * const Recipe = await prisma.recipe.delete({
     *   where: {
     *     // ... filter to delete one Recipe
     *   }
     * })
     * 
    **/
    delete<T extends RecipeDeleteArgs>(
      args: SelectSubset<T, RecipeDeleteArgs>
    ): CheckSelect<T, Prisma__RecipeClient<Recipe>, Prisma__RecipeClient<RecipeGetPayload<T>>>

    /**
     * Update one Recipe.
     * @param {RecipeUpdateArgs} args - Arguments to update one Recipe.
     * @example
     * // Update one Recipe
     * const recipe = await prisma.recipe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RecipeUpdateArgs>(
      args: SelectSubset<T, RecipeUpdateArgs>
    ): CheckSelect<T, Prisma__RecipeClient<Recipe>, Prisma__RecipeClient<RecipeGetPayload<T>>>

    /**
     * Delete zero or more Recipes.
     * @param {RecipeDeleteManyArgs} args - Arguments to filter Recipes to delete.
     * @example
     * // Delete a few Recipes
     * const { count } = await prisma.recipe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RecipeDeleteManyArgs>(
      args?: SelectSubset<T, RecipeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recipes
     * const recipe = await prisma.recipe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RecipeUpdateManyArgs>(
      args: SelectSubset<T, RecipeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Recipe.
     * @param {RecipeUpsertArgs} args - Arguments to update or create a Recipe.
     * @example
     * // Update or create a Recipe
     * const recipe = await prisma.recipe.upsert({
     *   create: {
     *     // ... data to create a Recipe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recipe we want to update
     *   }
     * })
    **/
    upsert<T extends RecipeUpsertArgs>(
      args: SelectSubset<T, RecipeUpsertArgs>
    ): CheckSelect<T, Prisma__RecipeClient<Recipe>, Prisma__RecipeClient<RecipeGetPayload<T>>>

    /**
     * Find one Recipe that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {RecipeFindUniqueOrThrowArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RecipeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RecipeFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__RecipeClient<Recipe>, Prisma__RecipeClient<RecipeGetPayload<T>>>

    /**
     * Find the first Recipe that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindFirstOrThrowArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RecipeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RecipeFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__RecipeClient<Recipe>, Prisma__RecipeClient<RecipeGetPayload<T>>>

    /**
     * Count the number of Recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeCountArgs} args - Arguments to filter Recipes to count.
     * @example
     * // Count the number of Recipes
     * const count = await prisma.recipe.count({
     *   where: {
     *     // ... the filter for the Recipes we want to count
     *   }
     * })
    **/
    count<T extends RecipeCountArgs>(
      args?: Subset<T, RecipeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeAggregateArgs>(args: Subset<T, RecipeAggregateArgs>): PrismaPromise<GetRecipeAggregateType<T>>

    /**
     * Group by Recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeGroupByArgs['orderBy'] }
        : { orderBy?: RecipeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Recipe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RecipeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    postedBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    spec<T extends SpecFindManyArgs = {}>(args?: Subset<T, SpecFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Spec>>, PrismaPromise<Array<SpecGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Recipe base type for findUnique actions
   */
  export type RecipeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Recipe
     * 
    **/
    select?: RecipeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeInclude | null
    /**
     * Filter, which Recipe to fetch.
     * 
    **/
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe: findUnique
   */
  export interface RecipeFindUniqueArgs extends RecipeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Recipe base type for findFirst actions
   */
  export type RecipeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Recipe
     * 
    **/
    select?: RecipeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeInclude | null
    /**
     * Filter, which Recipe to fetch.
     * 
    **/
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     * 
    **/
    orderBy?: Enumerable<RecipeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recipes.
     * 
    **/
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recipes.
     * 
    **/
    distinct?: Enumerable<RecipeScalarFieldEnum>
  }

  /**
   * Recipe: findFirst
   */
  export interface RecipeFindFirstArgs extends RecipeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Recipe findMany
   */
  export type RecipeFindManyArgs = {
    /**
     * Select specific fields to fetch from the Recipe
     * 
    **/
    select?: RecipeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeInclude | null
    /**
     * Filter, which Recipes to fetch.
     * 
    **/
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     * 
    **/
    orderBy?: Enumerable<RecipeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Recipes.
     * 
    **/
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RecipeScalarFieldEnum>
  }


  /**
   * Recipe create
   */
  export type RecipeCreateArgs = {
    /**
     * Select specific fields to fetch from the Recipe
     * 
    **/
    select?: RecipeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeInclude | null
    /**
     * The data needed to create a Recipe.
     * 
    **/
    data: XOR<RecipeCreateInput, RecipeUncheckedCreateInput>
  }


  /**
   * Recipe createMany
   */
  export type RecipeCreateManyArgs = {
    /**
     * The data used to create many Recipes.
     * 
    **/
    data: Enumerable<RecipeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Recipe update
   */
  export type RecipeUpdateArgs = {
    /**
     * Select specific fields to fetch from the Recipe
     * 
    **/
    select?: RecipeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeInclude | null
    /**
     * The data needed to update a Recipe.
     * 
    **/
    data: XOR<RecipeUpdateInput, RecipeUncheckedUpdateInput>
    /**
     * Choose, which Recipe to update.
     * 
    **/
    where: RecipeWhereUniqueInput
  }


  /**
   * Recipe updateMany
   */
  export type RecipeUpdateManyArgs = {
    /**
     * The data used to update Recipes.
     * 
    **/
    data: XOR<RecipeUpdateManyMutationInput, RecipeUncheckedUpdateManyInput>
    /**
     * Filter which Recipes to update
     * 
    **/
    where?: RecipeWhereInput
  }


  /**
   * Recipe upsert
   */
  export type RecipeUpsertArgs = {
    /**
     * Select specific fields to fetch from the Recipe
     * 
    **/
    select?: RecipeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeInclude | null
    /**
     * The filter to search for the Recipe to update in case it exists.
     * 
    **/
    where: RecipeWhereUniqueInput
    /**
     * In case the Recipe found by the `where` argument doesn't exist, create a new Recipe with this data.
     * 
    **/
    create: XOR<RecipeCreateInput, RecipeUncheckedCreateInput>
    /**
     * In case the Recipe was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RecipeUpdateInput, RecipeUncheckedUpdateInput>
  }


  /**
   * Recipe delete
   */
  export type RecipeDeleteArgs = {
    /**
     * Select specific fields to fetch from the Recipe
     * 
    **/
    select?: RecipeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeInclude | null
    /**
     * Filter which Recipe to delete.
     * 
    **/
    where: RecipeWhereUniqueInput
  }


  /**
   * Recipe deleteMany
   */
  export type RecipeDeleteManyArgs = {
    /**
     * Filter which Recipes to delete
     * 
    **/
    where?: RecipeWhereInput
  }


  /**
   * Recipe: findUniqueOrThrow
   */
  export type RecipeFindUniqueOrThrowArgs = RecipeFindUniqueArgsBase
      

  /**
   * Recipe: findFirstOrThrow
   */
  export type RecipeFindFirstOrThrowArgs = RecipeFindFirstArgsBase
      

  /**
   * Recipe without action
   */
  export type RecipeArgs = {
    /**
     * Select specific fields to fetch from the Recipe
     * 
    **/
    select?: RecipeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RecipeInclude | null
  }



  /**
   * Model Spec
   */


  export type AggregateSpec = {
    _count: SpecCountAggregateOutputType | null
    _avg: SpecAvgAggregateOutputType | null
    _sum: SpecSumAggregateOutputType | null
    _min: SpecMinAggregateOutputType | null
    _max: SpecMaxAggregateOutputType | null
  }

  export type SpecAvgAggregateOutputType = {
    id: number | null
    recipeId: number | null
  }

  export type SpecSumAggregateOutputType = {
    id: number | null
    recipeId: number | null
  }

  export type SpecMinAggregateOutputType = {
    id: number | null
    specName: string | null
    postedById: string | null
    instructions: string | null
    glassware: string | null
    ice: string | null
    recipeId: number | null
  }

  export type SpecMaxAggregateOutputType = {
    id: number | null
    specName: string | null
    postedById: string | null
    instructions: string | null
    glassware: string | null
    ice: string | null
    recipeId: number | null
  }

  export type SpecCountAggregateOutputType = {
    id: number
    specName: number
    postedById: number
    instructions: number
    glassware: number
    ice: number
    recipeId: number
    _all: number
  }


  export type SpecAvgAggregateInputType = {
    id?: true
    recipeId?: true
  }

  export type SpecSumAggregateInputType = {
    id?: true
    recipeId?: true
  }

  export type SpecMinAggregateInputType = {
    id?: true
    specName?: true
    postedById?: true
    instructions?: true
    glassware?: true
    ice?: true
    recipeId?: true
  }

  export type SpecMaxAggregateInputType = {
    id?: true
    specName?: true
    postedById?: true
    instructions?: true
    glassware?: true
    ice?: true
    recipeId?: true
  }

  export type SpecCountAggregateInputType = {
    id?: true
    specName?: true
    postedById?: true
    instructions?: true
    glassware?: true
    ice?: true
    recipeId?: true
    _all?: true
  }

  export type SpecAggregateArgs = {
    /**
     * Filter which Spec to aggregate.
     * 
    **/
    where?: SpecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specs to fetch.
     * 
    **/
    orderBy?: Enumerable<SpecOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SpecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Specs
    **/
    _count?: true | SpecCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpecAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpecSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpecMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpecMaxAggregateInputType
  }

  export type GetSpecAggregateType<T extends SpecAggregateArgs> = {
        [P in keyof T & keyof AggregateSpec]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpec[P]>
      : GetScalarType<T[P], AggregateSpec[P]>
  }




  export type SpecGroupByArgs = {
    where?: SpecWhereInput
    orderBy?: Enumerable<SpecOrderByWithAggregationInput>
    by: Array<SpecScalarFieldEnum>
    having?: SpecScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpecCountAggregateInputType | true
    _avg?: SpecAvgAggregateInputType
    _sum?: SpecSumAggregateInputType
    _min?: SpecMinAggregateInputType
    _max?: SpecMaxAggregateInputType
  }


  export type SpecGroupByOutputType = {
    id: number
    specName: string
    postedById: string
    instructions: string | null
    glassware: string | null
    ice: string | null
    recipeId: number | null
    _count: SpecCountAggregateOutputType | null
    _avg: SpecAvgAggregateOutputType | null
    _sum: SpecSumAggregateOutputType | null
    _min: SpecMinAggregateOutputType | null
    _max: SpecMaxAggregateOutputType | null
  }

  type GetSpecGroupByPayload<T extends SpecGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SpecGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpecGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpecGroupByOutputType[P]>
            : GetScalarType<T[P], SpecGroupByOutputType[P]>
        }
      >
    >


  export type SpecSelect = {
    id?: boolean
    specName?: boolean
    postedBy?: boolean | UserArgs
    postedById?: boolean
    instructions?: boolean
    glassware?: boolean
    ice?: boolean
    groupSpec?: boolean | GroupSpecFindManyArgs
    sharedSpec?: boolean | SharedSpecFindManyArgs
    recipe?: boolean | RecipeArgs
    recipeId?: boolean
    touch?: boolean | TouchFindManyArgs
    adminOnSpec?: boolean | AdminOnSpecFindManyArgs
    _count?: boolean | SpecCountOutputTypeArgs
  }

  export type SpecInclude = {
    postedBy?: boolean | UserArgs
    groupSpec?: boolean | GroupSpecFindManyArgs
    sharedSpec?: boolean | SharedSpecFindManyArgs
    recipe?: boolean | RecipeArgs
    touch?: boolean | TouchFindManyArgs
    adminOnSpec?: boolean | AdminOnSpecFindManyArgs
    _count?: boolean | SpecCountOutputTypeArgs
  }

  export type SpecGetPayload<
    S extends boolean | null | undefined | SpecArgs,
    U = keyof S
      > = S extends true
        ? Spec
    : S extends undefined
    ? never
    : S extends SpecArgs | SpecFindManyArgs
    ?'include' extends U
    ? Spec  & {
    [P in TrueKeys<S['include']>]:
        P extends 'postedBy' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'groupSpec' ? Array < GroupSpecGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'sharedSpec' ? Array < SharedSpecGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'recipe' ? RecipeGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'touch' ? Array < TouchGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'adminOnSpec' ? Array < AdminOnSpecGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? SpecCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'postedBy' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'groupSpec' ? Array < GroupSpecGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'sharedSpec' ? Array < SharedSpecGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'recipe' ? RecipeGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'touch' ? Array < TouchGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'adminOnSpec' ? Array < AdminOnSpecGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? SpecCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Spec ? Spec[P] : never
  } 
    : Spec
  : Spec


  type SpecCountArgs = Merge<
    Omit<SpecFindManyArgs, 'select' | 'include'> & {
      select?: SpecCountAggregateInputType | true
    }
  >

  export interface SpecDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Spec that matches the filter.
     * @param {SpecFindUniqueArgs} args - Arguments to find a Spec
     * @example
     * // Get one Spec
     * const spec = await prisma.spec.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SpecFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SpecFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Spec'> extends True ? CheckSelect<T, Prisma__SpecClient<Spec>, Prisma__SpecClient<SpecGetPayload<T>>> : CheckSelect<T, Prisma__SpecClient<Spec | null >, Prisma__SpecClient<SpecGetPayload<T> | null >>

    /**
     * Find the first Spec that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecFindFirstArgs} args - Arguments to find a Spec
     * @example
     * // Get one Spec
     * const spec = await prisma.spec.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SpecFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SpecFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Spec'> extends True ? CheckSelect<T, Prisma__SpecClient<Spec>, Prisma__SpecClient<SpecGetPayload<T>>> : CheckSelect<T, Prisma__SpecClient<Spec | null >, Prisma__SpecClient<SpecGetPayload<T> | null >>

    /**
     * Find zero or more Specs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Specs
     * const specs = await prisma.spec.findMany()
     * 
     * // Get first 10 Specs
     * const specs = await prisma.spec.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const specWithIdOnly = await prisma.spec.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SpecFindManyArgs>(
      args?: SelectSubset<T, SpecFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Spec>>, PrismaPromise<Array<SpecGetPayload<T>>>>

    /**
     * Create a Spec.
     * @param {SpecCreateArgs} args - Arguments to create a Spec.
     * @example
     * // Create one Spec
     * const Spec = await prisma.spec.create({
     *   data: {
     *     // ... data to create a Spec
     *   }
     * })
     * 
    **/
    create<T extends SpecCreateArgs>(
      args: SelectSubset<T, SpecCreateArgs>
    ): CheckSelect<T, Prisma__SpecClient<Spec>, Prisma__SpecClient<SpecGetPayload<T>>>

    /**
     * Create many Specs.
     *     @param {SpecCreateManyArgs} args - Arguments to create many Specs.
     *     @example
     *     // Create many Specs
     *     const spec = await prisma.spec.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SpecCreateManyArgs>(
      args?: SelectSubset<T, SpecCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Spec.
     * @param {SpecDeleteArgs} args - Arguments to delete one Spec.
     * @example
     * // Delete one Spec
     * const Spec = await prisma.spec.delete({
     *   where: {
     *     // ... filter to delete one Spec
     *   }
     * })
     * 
    **/
    delete<T extends SpecDeleteArgs>(
      args: SelectSubset<T, SpecDeleteArgs>
    ): CheckSelect<T, Prisma__SpecClient<Spec>, Prisma__SpecClient<SpecGetPayload<T>>>

    /**
     * Update one Spec.
     * @param {SpecUpdateArgs} args - Arguments to update one Spec.
     * @example
     * // Update one Spec
     * const spec = await prisma.spec.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SpecUpdateArgs>(
      args: SelectSubset<T, SpecUpdateArgs>
    ): CheckSelect<T, Prisma__SpecClient<Spec>, Prisma__SpecClient<SpecGetPayload<T>>>

    /**
     * Delete zero or more Specs.
     * @param {SpecDeleteManyArgs} args - Arguments to filter Specs to delete.
     * @example
     * // Delete a few Specs
     * const { count } = await prisma.spec.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SpecDeleteManyArgs>(
      args?: SelectSubset<T, SpecDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Specs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Specs
     * const spec = await prisma.spec.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SpecUpdateManyArgs>(
      args: SelectSubset<T, SpecUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Spec.
     * @param {SpecUpsertArgs} args - Arguments to update or create a Spec.
     * @example
     * // Update or create a Spec
     * const spec = await prisma.spec.upsert({
     *   create: {
     *     // ... data to create a Spec
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Spec we want to update
     *   }
     * })
    **/
    upsert<T extends SpecUpsertArgs>(
      args: SelectSubset<T, SpecUpsertArgs>
    ): CheckSelect<T, Prisma__SpecClient<Spec>, Prisma__SpecClient<SpecGetPayload<T>>>

    /**
     * Find one Spec that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {SpecFindUniqueOrThrowArgs} args - Arguments to find a Spec
     * @example
     * // Get one Spec
     * const spec = await prisma.spec.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SpecFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SpecFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__SpecClient<Spec>, Prisma__SpecClient<SpecGetPayload<T>>>

    /**
     * Find the first Spec that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecFindFirstOrThrowArgs} args - Arguments to find a Spec
     * @example
     * // Get one Spec
     * const spec = await prisma.spec.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SpecFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SpecFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__SpecClient<Spec>, Prisma__SpecClient<SpecGetPayload<T>>>

    /**
     * Count the number of Specs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecCountArgs} args - Arguments to filter Specs to count.
     * @example
     * // Count the number of Specs
     * const count = await prisma.spec.count({
     *   where: {
     *     // ... the filter for the Specs we want to count
     *   }
     * })
    **/
    count<T extends SpecCountArgs>(
      args?: Subset<T, SpecCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpecCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Spec.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpecAggregateArgs>(args: Subset<T, SpecAggregateArgs>): PrismaPromise<GetSpecAggregateType<T>>

    /**
     * Group by Spec.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpecGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpecGroupByArgs['orderBy'] }
        : { orderBy?: SpecGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpecGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpecGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Spec.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SpecClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    postedBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    groupSpec<T extends GroupSpecFindManyArgs = {}>(args?: Subset<T, GroupSpecFindManyArgs>): CheckSelect<T, PrismaPromise<Array<GroupSpec>>, PrismaPromise<Array<GroupSpecGetPayload<T>>>>;

    sharedSpec<T extends SharedSpecFindManyArgs = {}>(args?: Subset<T, SharedSpecFindManyArgs>): CheckSelect<T, PrismaPromise<Array<SharedSpec>>, PrismaPromise<Array<SharedSpecGetPayload<T>>>>;

    recipe<T extends RecipeArgs = {}>(args?: Subset<T, RecipeArgs>): CheckSelect<T, Prisma__RecipeClient<Recipe | null >, Prisma__RecipeClient<RecipeGetPayload<T> | null >>;

    touch<T extends TouchFindManyArgs = {}>(args?: Subset<T, TouchFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Touch>>, PrismaPromise<Array<TouchGetPayload<T>>>>;

    adminOnSpec<T extends AdminOnSpecFindManyArgs = {}>(args?: Subset<T, AdminOnSpecFindManyArgs>): CheckSelect<T, PrismaPromise<Array<AdminOnSpec>>, PrismaPromise<Array<AdminOnSpecGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Spec base type for findUnique actions
   */
  export type SpecFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Spec
     * 
    **/
    select?: SpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SpecInclude | null
    /**
     * Filter, which Spec to fetch.
     * 
    **/
    where: SpecWhereUniqueInput
  }

  /**
   * Spec: findUnique
   */
  export interface SpecFindUniqueArgs extends SpecFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Spec base type for findFirst actions
   */
  export type SpecFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Spec
     * 
    **/
    select?: SpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SpecInclude | null
    /**
     * Filter, which Spec to fetch.
     * 
    **/
    where?: SpecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specs to fetch.
     * 
    **/
    orderBy?: Enumerable<SpecOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Specs.
     * 
    **/
    cursor?: SpecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Specs.
     * 
    **/
    distinct?: Enumerable<SpecScalarFieldEnum>
  }

  /**
   * Spec: findFirst
   */
  export interface SpecFindFirstArgs extends SpecFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Spec findMany
   */
  export type SpecFindManyArgs = {
    /**
     * Select specific fields to fetch from the Spec
     * 
    **/
    select?: SpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SpecInclude | null
    /**
     * Filter, which Specs to fetch.
     * 
    **/
    where?: SpecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specs to fetch.
     * 
    **/
    orderBy?: Enumerable<SpecOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Specs.
     * 
    **/
    cursor?: SpecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SpecScalarFieldEnum>
  }


  /**
   * Spec create
   */
  export type SpecCreateArgs = {
    /**
     * Select specific fields to fetch from the Spec
     * 
    **/
    select?: SpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SpecInclude | null
    /**
     * The data needed to create a Spec.
     * 
    **/
    data: XOR<SpecCreateInput, SpecUncheckedCreateInput>
  }


  /**
   * Spec createMany
   */
  export type SpecCreateManyArgs = {
    /**
     * The data used to create many Specs.
     * 
    **/
    data: Enumerable<SpecCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Spec update
   */
  export type SpecUpdateArgs = {
    /**
     * Select specific fields to fetch from the Spec
     * 
    **/
    select?: SpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SpecInclude | null
    /**
     * The data needed to update a Spec.
     * 
    **/
    data: XOR<SpecUpdateInput, SpecUncheckedUpdateInput>
    /**
     * Choose, which Spec to update.
     * 
    **/
    where: SpecWhereUniqueInput
  }


  /**
   * Spec updateMany
   */
  export type SpecUpdateManyArgs = {
    /**
     * The data used to update Specs.
     * 
    **/
    data: XOR<SpecUpdateManyMutationInput, SpecUncheckedUpdateManyInput>
    /**
     * Filter which Specs to update
     * 
    **/
    where?: SpecWhereInput
  }


  /**
   * Spec upsert
   */
  export type SpecUpsertArgs = {
    /**
     * Select specific fields to fetch from the Spec
     * 
    **/
    select?: SpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SpecInclude | null
    /**
     * The filter to search for the Spec to update in case it exists.
     * 
    **/
    where: SpecWhereUniqueInput
    /**
     * In case the Spec found by the `where` argument doesn't exist, create a new Spec with this data.
     * 
    **/
    create: XOR<SpecCreateInput, SpecUncheckedCreateInput>
    /**
     * In case the Spec was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SpecUpdateInput, SpecUncheckedUpdateInput>
  }


  /**
   * Spec delete
   */
  export type SpecDeleteArgs = {
    /**
     * Select specific fields to fetch from the Spec
     * 
    **/
    select?: SpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SpecInclude | null
    /**
     * Filter which Spec to delete.
     * 
    **/
    where: SpecWhereUniqueInput
  }


  /**
   * Spec deleteMany
   */
  export type SpecDeleteManyArgs = {
    /**
     * Filter which Specs to delete
     * 
    **/
    where?: SpecWhereInput
  }


  /**
   * Spec: findUniqueOrThrow
   */
  export type SpecFindUniqueOrThrowArgs = SpecFindUniqueArgsBase
      

  /**
   * Spec: findFirstOrThrow
   */
  export type SpecFindFirstOrThrowArgs = SpecFindFirstArgsBase
      

  /**
   * Spec without action
   */
  export type SpecArgs = {
    /**
     * Select specific fields to fetch from the Spec
     * 
    **/
    select?: SpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SpecInclude | null
  }



  /**
   * Model UserData
   */


  export type AggregateUserData = {
    _count: UserDataCountAggregateOutputType | null
    _avg: UserDataAvgAggregateOutputType | null
    _sum: UserDataSumAggregateOutputType | null
    _min: UserDataMinAggregateOutputType | null
    _max: UserDataMaxAggregateOutputType | null
  }

  export type UserDataAvgAggregateOutputType = {
    id: number | null
  }

  export type UserDataSumAggregateOutputType = {
    id: number | null
  }

  export type UserDataMinAggregateOutputType = {
    id: number | null
    userId: string | null
    userBio: string | null
    workPlace: string | null
    profilePicture: string | null
  }

  export type UserDataMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    userBio: string | null
    workPlace: string | null
    profilePicture: string | null
  }

  export type UserDataCountAggregateOutputType = {
    id: number
    userId: number
    userBio: number
    workPlace: number
    profilePicture: number
    _all: number
  }


  export type UserDataAvgAggregateInputType = {
    id?: true
  }

  export type UserDataSumAggregateInputType = {
    id?: true
  }

  export type UserDataMinAggregateInputType = {
    id?: true
    userId?: true
    userBio?: true
    workPlace?: true
    profilePicture?: true
  }

  export type UserDataMaxAggregateInputType = {
    id?: true
    userId?: true
    userBio?: true
    workPlace?: true
    profilePicture?: true
  }

  export type UserDataCountAggregateInputType = {
    id?: true
    userId?: true
    userBio?: true
    workPlace?: true
    profilePicture?: true
    _all?: true
  }

  export type UserDataAggregateArgs = {
    /**
     * Filter which UserData to aggregate.
     * 
    **/
    where?: UserDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserData to fetch.
     * 
    **/
    orderBy?: Enumerable<UserDataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserData from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserData.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserData
    **/
    _count?: true | UserDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserDataMaxAggregateInputType
  }

  export type GetUserDataAggregateType<T extends UserDataAggregateArgs> = {
        [P in keyof T & keyof AggregateUserData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserData[P]>
      : GetScalarType<T[P], AggregateUserData[P]>
  }




  export type UserDataGroupByArgs = {
    where?: UserDataWhereInput
    orderBy?: Enumerable<UserDataOrderByWithAggregationInput>
    by: Array<UserDataScalarFieldEnum>
    having?: UserDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserDataCountAggregateInputType | true
    _avg?: UserDataAvgAggregateInputType
    _sum?: UserDataSumAggregateInputType
    _min?: UserDataMinAggregateInputType
    _max?: UserDataMaxAggregateInputType
  }


  export type UserDataGroupByOutputType = {
    id: number
    userId: string | null
    userBio: string | null
    workPlace: string | null
    profilePicture: string | null
    _count: UserDataCountAggregateOutputType | null
    _avg: UserDataAvgAggregateOutputType | null
    _sum: UserDataSumAggregateOutputType | null
    _min: UserDataMinAggregateOutputType | null
    _max: UserDataMaxAggregateOutputType | null
  }

  type GetUserDataGroupByPayload<T extends UserDataGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserDataGroupByOutputType[P]>
            : GetScalarType<T[P], UserDataGroupByOutputType[P]>
        }
      >
    >


  export type UserDataSelect = {
    id?: boolean
    userId?: boolean
    userBio?: boolean
    workPlace?: boolean
    profilePicture?: boolean
    users?: boolean | UserArgs
  }

  export type UserDataInclude = {
    users?: boolean | UserArgs
  }

  export type UserDataGetPayload<
    S extends boolean | null | undefined | UserDataArgs,
    U = keyof S
      > = S extends true
        ? UserData
    : S extends undefined
    ? never
    : S extends UserDataArgs | UserDataFindManyArgs
    ?'include' extends U
    ? UserData  & {
    [P in TrueKeys<S['include']>]:
        P extends 'users' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'users' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof UserData ? UserData[P] : never
  } 
    : UserData
  : UserData


  type UserDataCountArgs = Merge<
    Omit<UserDataFindManyArgs, 'select' | 'include'> & {
      select?: UserDataCountAggregateInputType | true
    }
  >

  export interface UserDataDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one UserData that matches the filter.
     * @param {UserDataFindUniqueArgs} args - Arguments to find a UserData
     * @example
     * // Get one UserData
     * const userData = await prisma.userData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserDataFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserDataFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserData'> extends True ? CheckSelect<T, Prisma__UserDataClient<UserData>, Prisma__UserDataClient<UserDataGetPayload<T>>> : CheckSelect<T, Prisma__UserDataClient<UserData | null >, Prisma__UserDataClient<UserDataGetPayload<T> | null >>

    /**
     * Find the first UserData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDataFindFirstArgs} args - Arguments to find a UserData
     * @example
     * // Get one UserData
     * const userData = await prisma.userData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserDataFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserDataFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserData'> extends True ? CheckSelect<T, Prisma__UserDataClient<UserData>, Prisma__UserDataClient<UserDataGetPayload<T>>> : CheckSelect<T, Prisma__UserDataClient<UserData | null >, Prisma__UserDataClient<UserDataGetPayload<T> | null >>

    /**
     * Find zero or more UserData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDataFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserData
     * const userData = await prisma.userData.findMany()
     * 
     * // Get first 10 UserData
     * const userData = await prisma.userData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userDataWithIdOnly = await prisma.userData.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserDataFindManyArgs>(
      args?: SelectSubset<T, UserDataFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserData>>, PrismaPromise<Array<UserDataGetPayload<T>>>>

    /**
     * Create a UserData.
     * @param {UserDataCreateArgs} args - Arguments to create a UserData.
     * @example
     * // Create one UserData
     * const UserData = await prisma.userData.create({
     *   data: {
     *     // ... data to create a UserData
     *   }
     * })
     * 
    **/
    create<T extends UserDataCreateArgs>(
      args: SelectSubset<T, UserDataCreateArgs>
    ): CheckSelect<T, Prisma__UserDataClient<UserData>, Prisma__UserDataClient<UserDataGetPayload<T>>>

    /**
     * Create many UserData.
     *     @param {UserDataCreateManyArgs} args - Arguments to create many UserData.
     *     @example
     *     // Create many UserData
     *     const userData = await prisma.userData.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserDataCreateManyArgs>(
      args?: SelectSubset<T, UserDataCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserData.
     * @param {UserDataDeleteArgs} args - Arguments to delete one UserData.
     * @example
     * // Delete one UserData
     * const UserData = await prisma.userData.delete({
     *   where: {
     *     // ... filter to delete one UserData
     *   }
     * })
     * 
    **/
    delete<T extends UserDataDeleteArgs>(
      args: SelectSubset<T, UserDataDeleteArgs>
    ): CheckSelect<T, Prisma__UserDataClient<UserData>, Prisma__UserDataClient<UserDataGetPayload<T>>>

    /**
     * Update one UserData.
     * @param {UserDataUpdateArgs} args - Arguments to update one UserData.
     * @example
     * // Update one UserData
     * const userData = await prisma.userData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserDataUpdateArgs>(
      args: SelectSubset<T, UserDataUpdateArgs>
    ): CheckSelect<T, Prisma__UserDataClient<UserData>, Prisma__UserDataClient<UserDataGetPayload<T>>>

    /**
     * Delete zero or more UserData.
     * @param {UserDataDeleteManyArgs} args - Arguments to filter UserData to delete.
     * @example
     * // Delete a few UserData
     * const { count } = await prisma.userData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDataDeleteManyArgs>(
      args?: SelectSubset<T, UserDataDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserData
     * const userData = await prisma.userData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserDataUpdateManyArgs>(
      args: SelectSubset<T, UserDataUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserData.
     * @param {UserDataUpsertArgs} args - Arguments to update or create a UserData.
     * @example
     * // Update or create a UserData
     * const userData = await prisma.userData.upsert({
     *   create: {
     *     // ... data to create a UserData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserData we want to update
     *   }
     * })
    **/
    upsert<T extends UserDataUpsertArgs>(
      args: SelectSubset<T, UserDataUpsertArgs>
    ): CheckSelect<T, Prisma__UserDataClient<UserData>, Prisma__UserDataClient<UserDataGetPayload<T>>>

    /**
     * Find one UserData that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {UserDataFindUniqueOrThrowArgs} args - Arguments to find a UserData
     * @example
     * // Get one UserData
     * const userData = await prisma.userData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserDataFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserDataFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__UserDataClient<UserData>, Prisma__UserDataClient<UserDataGetPayload<T>>>

    /**
     * Find the first UserData that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDataFindFirstOrThrowArgs} args - Arguments to find a UserData
     * @example
     * // Get one UserData
     * const userData = await prisma.userData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserDataFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserDataFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__UserDataClient<UserData>, Prisma__UserDataClient<UserDataGetPayload<T>>>

    /**
     * Count the number of UserData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDataCountArgs} args - Arguments to filter UserData to count.
     * @example
     * // Count the number of UserData
     * const count = await prisma.userData.count({
     *   where: {
     *     // ... the filter for the UserData we want to count
     *   }
     * })
    **/
    count<T extends UserDataCountArgs>(
      args?: Subset<T, UserDataCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserDataAggregateArgs>(args: Subset<T, UserDataAggregateArgs>): PrismaPromise<GetUserDataAggregateType<T>>

    /**
     * Group by UserData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserDataGroupByArgs['orderBy'] }
        : { orderBy?: UserDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserDataGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserDataClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    users<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserData base type for findUnique actions
   */
  export type UserDataFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserData
     * 
    **/
    select?: UserDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserDataInclude | null
    /**
     * Filter, which UserData to fetch.
     * 
    **/
    where: UserDataWhereUniqueInput
  }

  /**
   * UserData: findUnique
   */
  export interface UserDataFindUniqueArgs extends UserDataFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserData base type for findFirst actions
   */
  export type UserDataFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserData
     * 
    **/
    select?: UserDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserDataInclude | null
    /**
     * Filter, which UserData to fetch.
     * 
    **/
    where?: UserDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserData to fetch.
     * 
    **/
    orderBy?: Enumerable<UserDataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserData.
     * 
    **/
    cursor?: UserDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserData from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserData.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserData.
     * 
    **/
    distinct?: Enumerable<UserDataScalarFieldEnum>
  }

  /**
   * UserData: findFirst
   */
  export interface UserDataFindFirstArgs extends UserDataFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserData findMany
   */
  export type UserDataFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserData
     * 
    **/
    select?: UserDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserDataInclude | null
    /**
     * Filter, which UserData to fetch.
     * 
    **/
    where?: UserDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserData to fetch.
     * 
    **/
    orderBy?: Enumerable<UserDataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserData.
     * 
    **/
    cursor?: UserDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserData from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserData.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserDataScalarFieldEnum>
  }


  /**
   * UserData create
   */
  export type UserDataCreateArgs = {
    /**
     * Select specific fields to fetch from the UserData
     * 
    **/
    select?: UserDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserDataInclude | null
    /**
     * The data needed to create a UserData.
     * 
    **/
    data: XOR<UserDataCreateInput, UserDataUncheckedCreateInput>
  }


  /**
   * UserData createMany
   */
  export type UserDataCreateManyArgs = {
    /**
     * The data used to create many UserData.
     * 
    **/
    data: Enumerable<UserDataCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserData update
   */
  export type UserDataUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserData
     * 
    **/
    select?: UserDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserDataInclude | null
    /**
     * The data needed to update a UserData.
     * 
    **/
    data: XOR<UserDataUpdateInput, UserDataUncheckedUpdateInput>
    /**
     * Choose, which UserData to update.
     * 
    **/
    where: UserDataWhereUniqueInput
  }


  /**
   * UserData updateMany
   */
  export type UserDataUpdateManyArgs = {
    /**
     * The data used to update UserData.
     * 
    **/
    data: XOR<UserDataUpdateManyMutationInput, UserDataUncheckedUpdateManyInput>
    /**
     * Filter which UserData to update
     * 
    **/
    where?: UserDataWhereInput
  }


  /**
   * UserData upsert
   */
  export type UserDataUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserData
     * 
    **/
    select?: UserDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserDataInclude | null
    /**
     * The filter to search for the UserData to update in case it exists.
     * 
    **/
    where: UserDataWhereUniqueInput
    /**
     * In case the UserData found by the `where` argument doesn't exist, create a new UserData with this data.
     * 
    **/
    create: XOR<UserDataCreateInput, UserDataUncheckedCreateInput>
    /**
     * In case the UserData was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserDataUpdateInput, UserDataUncheckedUpdateInput>
  }


  /**
   * UserData delete
   */
  export type UserDataDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserData
     * 
    **/
    select?: UserDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserDataInclude | null
    /**
     * Filter which UserData to delete.
     * 
    **/
    where: UserDataWhereUniqueInput
  }


  /**
   * UserData deleteMany
   */
  export type UserDataDeleteManyArgs = {
    /**
     * Filter which UserData to delete
     * 
    **/
    where?: UserDataWhereInput
  }


  /**
   * UserData: findUniqueOrThrow
   */
  export type UserDataFindUniqueOrThrowArgs = UserDataFindUniqueArgsBase
      

  /**
   * UserData: findFirstOrThrow
   */
  export type UserDataFindFirstOrThrowArgs = UserDataFindFirstArgsBase
      

  /**
   * UserData without action
   */
  export type UserDataArgs = {
    /**
     * Select specific fields to fetch from the UserData
     * 
    **/
    select?: UserDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserDataInclude | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    userName: string | null
    firstName: string | null
    lastName: string | null
    dateJoined: Date | null
    email: string | null
    password: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    userName: string | null
    firstName: string | null
    lastName: string | null
    dateJoined: Date | null
    email: string | null
    password: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    userName: number
    firstName: number
    lastName: number
    dateJoined: number
    email: number
    password: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    userName?: true
    firstName?: true
    lastName?: true
    dateJoined?: true
    email?: true
    password?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    userName?: true
    firstName?: true
    lastName?: true
    dateJoined?: true
    email?: true
    password?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    userName?: true
    firstName?: true
    lastName?: true
    dateJoined?: true
    email?: true
    password?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    userName: string
    firstName: string | null
    lastName: string | null
    dateJoined: Date
    email: string
    password: string
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    userName?: boolean
    firstName?: boolean
    lastName?: boolean
    dateJoined?: boolean
    email?: boolean
    password?: boolean
    groupMod?: boolean | GroupModFindManyArgs
    groupUser?: boolean | GroupUserFindManyArgs
    userData?: boolean | UserDataFindManyArgs
    sharedIngredient?: boolean | SharedIngredientFindManyArgs
    ingredientSharedBy?: boolean | SharedIngredientFindManyArgs
    sharedSpec?: boolean | SharedSpecFindManyArgs
    specSharedBy?: boolean | SharedSpecFindManyArgs
    recipes?: boolean | RecipeFindManyArgs
    spec?: boolean | SpecFindManyArgs
    ingredient?: boolean | IngredientFindManyArgs
    touch?: boolean | TouchFindManyArgs
    adminOnSpec?: boolean | AdminOnSpecFindManyArgs
    adminAssignedBy?: boolean | AdminOnSpecFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserInclude = {
    groupMod?: boolean | GroupModFindManyArgs
    groupUser?: boolean | GroupUserFindManyArgs
    userData?: boolean | UserDataFindManyArgs
    sharedIngredient?: boolean | SharedIngredientFindManyArgs
    ingredientSharedBy?: boolean | SharedIngredientFindManyArgs
    sharedSpec?: boolean | SharedSpecFindManyArgs
    specSharedBy?: boolean | SharedSpecFindManyArgs
    recipes?: boolean | RecipeFindManyArgs
    spec?: boolean | SpecFindManyArgs
    ingredient?: boolean | IngredientFindManyArgs
    touch?: boolean | TouchFindManyArgs
    adminOnSpec?: boolean | AdminOnSpecFindManyArgs
    adminAssignedBy?: boolean | AdminOnSpecFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]:
        P extends 'groupMod' ? Array < GroupModGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'groupUser' ? Array < GroupUserGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'userData' ? Array < UserDataGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'sharedIngredient' ? Array < SharedIngredientGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'ingredientSharedBy' ? Array < SharedIngredientGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'sharedSpec' ? Array < SharedSpecGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'specSharedBy' ? Array < SharedSpecGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'recipes' ? Array < RecipeGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'spec' ? Array < SpecGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'ingredient' ? Array < IngredientGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'touch' ? Array < TouchGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'adminOnSpec' ? Array < AdminOnSpecGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'adminAssignedBy' ? Array < AdminOnSpecGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'groupMod' ? Array < GroupModGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'groupUser' ? Array < GroupUserGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'userData' ? Array < UserDataGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'sharedIngredient' ? Array < SharedIngredientGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'ingredientSharedBy' ? Array < SharedIngredientGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'sharedSpec' ? Array < SharedSpecGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'specSharedBy' ? Array < SharedSpecGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'recipes' ? Array < RecipeGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'spec' ? Array < SpecGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'ingredient' ? Array < IngredientGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'touch' ? Array < TouchGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'adminOnSpec' ? Array < AdminOnSpecGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'adminAssignedBy' ? Array < AdminOnSpecGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof User ? User[P] : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Find one User that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    groupMod<T extends GroupModFindManyArgs = {}>(args?: Subset<T, GroupModFindManyArgs>): CheckSelect<T, PrismaPromise<Array<GroupMod>>, PrismaPromise<Array<GroupModGetPayload<T>>>>;

    groupUser<T extends GroupUserFindManyArgs = {}>(args?: Subset<T, GroupUserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<GroupUser>>, PrismaPromise<Array<GroupUserGetPayload<T>>>>;

    userData<T extends UserDataFindManyArgs = {}>(args?: Subset<T, UserDataFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserData>>, PrismaPromise<Array<UserDataGetPayload<T>>>>;

    sharedIngredient<T extends SharedIngredientFindManyArgs = {}>(args?: Subset<T, SharedIngredientFindManyArgs>): CheckSelect<T, PrismaPromise<Array<SharedIngredient>>, PrismaPromise<Array<SharedIngredientGetPayload<T>>>>;

    ingredientSharedBy<T extends SharedIngredientFindManyArgs = {}>(args?: Subset<T, SharedIngredientFindManyArgs>): CheckSelect<T, PrismaPromise<Array<SharedIngredient>>, PrismaPromise<Array<SharedIngredientGetPayload<T>>>>;

    sharedSpec<T extends SharedSpecFindManyArgs = {}>(args?: Subset<T, SharedSpecFindManyArgs>): CheckSelect<T, PrismaPromise<Array<SharedSpec>>, PrismaPromise<Array<SharedSpecGetPayload<T>>>>;

    specSharedBy<T extends SharedSpecFindManyArgs = {}>(args?: Subset<T, SharedSpecFindManyArgs>): CheckSelect<T, PrismaPromise<Array<SharedSpec>>, PrismaPromise<Array<SharedSpecGetPayload<T>>>>;

    recipes<T extends RecipeFindManyArgs = {}>(args?: Subset<T, RecipeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Recipe>>, PrismaPromise<Array<RecipeGetPayload<T>>>>;

    spec<T extends SpecFindManyArgs = {}>(args?: Subset<T, SpecFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Spec>>, PrismaPromise<Array<SpecGetPayload<T>>>>;

    ingredient<T extends IngredientFindManyArgs = {}>(args?: Subset<T, IngredientFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Ingredient>>, PrismaPromise<Array<IngredientGetPayload<T>>>>;

    touch<T extends TouchFindManyArgs = {}>(args?: Subset<T, TouchFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Touch>>, PrismaPromise<Array<TouchGetPayload<T>>>>;

    adminOnSpec<T extends AdminOnSpecFindManyArgs = {}>(args?: Subset<T, AdminOnSpecFindManyArgs>): CheckSelect<T, PrismaPromise<Array<AdminOnSpec>>, PrismaPromise<Array<AdminOnSpecGetPayload<T>>>>;

    adminAssignedBy<T extends AdminOnSpecFindManyArgs = {}>(args?: Subset<T, AdminOnSpecFindManyArgs>): CheckSelect<T, PrismaPromise<Array<AdminOnSpec>>, PrismaPromise<Array<AdminOnSpecGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }

  /**
   * User: findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User: findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     * 
    **/
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     * 
    **/
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User: findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = UserFindUniqueArgsBase
      

  /**
   * User: findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = UserFindFirstArgsBase
      

  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model SharedIngredient
   */


  export type AggregateSharedIngredient = {
    _count: SharedIngredientCountAggregateOutputType | null
    _avg: SharedIngredientAvgAggregateOutputType | null
    _sum: SharedIngredientSumAggregateOutputType | null
    _min: SharedIngredientMinAggregateOutputType | null
    _max: SharedIngredientMaxAggregateOutputType | null
  }

  export type SharedIngredientAvgAggregateOutputType = {
    ingredientId: number | null
  }

  export type SharedIngredientSumAggregateOutputType = {
    ingredientId: number | null
  }

  export type SharedIngredientMinAggregateOutputType = {
    userId: string | null
    ingredientId: number | null
    sharedById: string | null
    sharedAt: Date | null
  }

  export type SharedIngredientMaxAggregateOutputType = {
    userId: string | null
    ingredientId: number | null
    sharedById: string | null
    sharedAt: Date | null
  }

  export type SharedIngredientCountAggregateOutputType = {
    userId: number
    ingredientId: number
    sharedById: number
    sharedAt: number
    _all: number
  }


  export type SharedIngredientAvgAggregateInputType = {
    ingredientId?: true
  }

  export type SharedIngredientSumAggregateInputType = {
    ingredientId?: true
  }

  export type SharedIngredientMinAggregateInputType = {
    userId?: true
    ingredientId?: true
    sharedById?: true
    sharedAt?: true
  }

  export type SharedIngredientMaxAggregateInputType = {
    userId?: true
    ingredientId?: true
    sharedById?: true
    sharedAt?: true
  }

  export type SharedIngredientCountAggregateInputType = {
    userId?: true
    ingredientId?: true
    sharedById?: true
    sharedAt?: true
    _all?: true
  }

  export type SharedIngredientAggregateArgs = {
    /**
     * Filter which SharedIngredient to aggregate.
     * 
    **/
    where?: SharedIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedIngredients to fetch.
     * 
    **/
    orderBy?: Enumerable<SharedIngredientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SharedIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedIngredients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedIngredients.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SharedIngredients
    **/
    _count?: true | SharedIngredientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SharedIngredientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SharedIngredientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SharedIngredientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SharedIngredientMaxAggregateInputType
  }

  export type GetSharedIngredientAggregateType<T extends SharedIngredientAggregateArgs> = {
        [P in keyof T & keyof AggregateSharedIngredient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSharedIngredient[P]>
      : GetScalarType<T[P], AggregateSharedIngredient[P]>
  }




  export type SharedIngredientGroupByArgs = {
    where?: SharedIngredientWhereInput
    orderBy?: Enumerable<SharedIngredientOrderByWithAggregationInput>
    by: Array<SharedIngredientScalarFieldEnum>
    having?: SharedIngredientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SharedIngredientCountAggregateInputType | true
    _avg?: SharedIngredientAvgAggregateInputType
    _sum?: SharedIngredientSumAggregateInputType
    _min?: SharedIngredientMinAggregateInputType
    _max?: SharedIngredientMaxAggregateInputType
  }


  export type SharedIngredientGroupByOutputType = {
    userId: string
    ingredientId: number
    sharedById: string
    sharedAt: Date
    _count: SharedIngredientCountAggregateOutputType | null
    _avg: SharedIngredientAvgAggregateOutputType | null
    _sum: SharedIngredientSumAggregateOutputType | null
    _min: SharedIngredientMinAggregateOutputType | null
    _max: SharedIngredientMaxAggregateOutputType | null
  }

  type GetSharedIngredientGroupByPayload<T extends SharedIngredientGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SharedIngredientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SharedIngredientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SharedIngredientGroupByOutputType[P]>
            : GetScalarType<T[P], SharedIngredientGroupByOutputType[P]>
        }
      >
    >


  export type SharedIngredientSelect = {
    userId?: boolean
    ingredientId?: boolean
    sharedById?: boolean
    sharedAt?: boolean
    ingredient?: boolean | IngredientArgs
    user?: boolean | UserArgs
    sharedBy?: boolean | UserArgs
  }

  export type SharedIngredientInclude = {
    ingredient?: boolean | IngredientArgs
    user?: boolean | UserArgs
    sharedBy?: boolean | UserArgs
  }

  export type SharedIngredientGetPayload<
    S extends boolean | null | undefined | SharedIngredientArgs,
    U = keyof S
      > = S extends true
        ? SharedIngredient
    : S extends undefined
    ? never
    : S extends SharedIngredientArgs | SharedIngredientFindManyArgs
    ?'include' extends U
    ? SharedIngredient  & {
    [P in TrueKeys<S['include']>]:
        P extends 'ingredient' ? IngredientGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'sharedBy' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'ingredient' ? IngredientGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'sharedBy' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof SharedIngredient ? SharedIngredient[P] : never
  } 
    : SharedIngredient
  : SharedIngredient


  type SharedIngredientCountArgs = Merge<
    Omit<SharedIngredientFindManyArgs, 'select' | 'include'> & {
      select?: SharedIngredientCountAggregateInputType | true
    }
  >

  export interface SharedIngredientDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one SharedIngredient that matches the filter.
     * @param {SharedIngredientFindUniqueArgs} args - Arguments to find a SharedIngredient
     * @example
     * // Get one SharedIngredient
     * const sharedIngredient = await prisma.sharedIngredient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SharedIngredientFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SharedIngredientFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SharedIngredient'> extends True ? CheckSelect<T, Prisma__SharedIngredientClient<SharedIngredient>, Prisma__SharedIngredientClient<SharedIngredientGetPayload<T>>> : CheckSelect<T, Prisma__SharedIngredientClient<SharedIngredient | null >, Prisma__SharedIngredientClient<SharedIngredientGetPayload<T> | null >>

    /**
     * Find the first SharedIngredient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedIngredientFindFirstArgs} args - Arguments to find a SharedIngredient
     * @example
     * // Get one SharedIngredient
     * const sharedIngredient = await prisma.sharedIngredient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SharedIngredientFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SharedIngredientFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SharedIngredient'> extends True ? CheckSelect<T, Prisma__SharedIngredientClient<SharedIngredient>, Prisma__SharedIngredientClient<SharedIngredientGetPayload<T>>> : CheckSelect<T, Prisma__SharedIngredientClient<SharedIngredient | null >, Prisma__SharedIngredientClient<SharedIngredientGetPayload<T> | null >>

    /**
     * Find zero or more SharedIngredients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedIngredientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SharedIngredients
     * const sharedIngredients = await prisma.sharedIngredient.findMany()
     * 
     * // Get first 10 SharedIngredients
     * const sharedIngredients = await prisma.sharedIngredient.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const sharedIngredientWithUserIdOnly = await prisma.sharedIngredient.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends SharedIngredientFindManyArgs>(
      args?: SelectSubset<T, SharedIngredientFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SharedIngredient>>, PrismaPromise<Array<SharedIngredientGetPayload<T>>>>

    /**
     * Create a SharedIngredient.
     * @param {SharedIngredientCreateArgs} args - Arguments to create a SharedIngredient.
     * @example
     * // Create one SharedIngredient
     * const SharedIngredient = await prisma.sharedIngredient.create({
     *   data: {
     *     // ... data to create a SharedIngredient
     *   }
     * })
     * 
    **/
    create<T extends SharedIngredientCreateArgs>(
      args: SelectSubset<T, SharedIngredientCreateArgs>
    ): CheckSelect<T, Prisma__SharedIngredientClient<SharedIngredient>, Prisma__SharedIngredientClient<SharedIngredientGetPayload<T>>>

    /**
     * Create many SharedIngredients.
     *     @param {SharedIngredientCreateManyArgs} args - Arguments to create many SharedIngredients.
     *     @example
     *     // Create many SharedIngredients
     *     const sharedIngredient = await prisma.sharedIngredient.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SharedIngredientCreateManyArgs>(
      args?: SelectSubset<T, SharedIngredientCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SharedIngredient.
     * @param {SharedIngredientDeleteArgs} args - Arguments to delete one SharedIngredient.
     * @example
     * // Delete one SharedIngredient
     * const SharedIngredient = await prisma.sharedIngredient.delete({
     *   where: {
     *     // ... filter to delete one SharedIngredient
     *   }
     * })
     * 
    **/
    delete<T extends SharedIngredientDeleteArgs>(
      args: SelectSubset<T, SharedIngredientDeleteArgs>
    ): CheckSelect<T, Prisma__SharedIngredientClient<SharedIngredient>, Prisma__SharedIngredientClient<SharedIngredientGetPayload<T>>>

    /**
     * Update one SharedIngredient.
     * @param {SharedIngredientUpdateArgs} args - Arguments to update one SharedIngredient.
     * @example
     * // Update one SharedIngredient
     * const sharedIngredient = await prisma.sharedIngredient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SharedIngredientUpdateArgs>(
      args: SelectSubset<T, SharedIngredientUpdateArgs>
    ): CheckSelect<T, Prisma__SharedIngredientClient<SharedIngredient>, Prisma__SharedIngredientClient<SharedIngredientGetPayload<T>>>

    /**
     * Delete zero or more SharedIngredients.
     * @param {SharedIngredientDeleteManyArgs} args - Arguments to filter SharedIngredients to delete.
     * @example
     * // Delete a few SharedIngredients
     * const { count } = await prisma.sharedIngredient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SharedIngredientDeleteManyArgs>(
      args?: SelectSubset<T, SharedIngredientDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SharedIngredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedIngredientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SharedIngredients
     * const sharedIngredient = await prisma.sharedIngredient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SharedIngredientUpdateManyArgs>(
      args: SelectSubset<T, SharedIngredientUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SharedIngredient.
     * @param {SharedIngredientUpsertArgs} args - Arguments to update or create a SharedIngredient.
     * @example
     * // Update or create a SharedIngredient
     * const sharedIngredient = await prisma.sharedIngredient.upsert({
     *   create: {
     *     // ... data to create a SharedIngredient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SharedIngredient we want to update
     *   }
     * })
    **/
    upsert<T extends SharedIngredientUpsertArgs>(
      args: SelectSubset<T, SharedIngredientUpsertArgs>
    ): CheckSelect<T, Prisma__SharedIngredientClient<SharedIngredient>, Prisma__SharedIngredientClient<SharedIngredientGetPayload<T>>>

    /**
     * Find one SharedIngredient that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {SharedIngredientFindUniqueOrThrowArgs} args - Arguments to find a SharedIngredient
     * @example
     * // Get one SharedIngredient
     * const sharedIngredient = await prisma.sharedIngredient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SharedIngredientFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SharedIngredientFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__SharedIngredientClient<SharedIngredient>, Prisma__SharedIngredientClient<SharedIngredientGetPayload<T>>>

    /**
     * Find the first SharedIngredient that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedIngredientFindFirstOrThrowArgs} args - Arguments to find a SharedIngredient
     * @example
     * // Get one SharedIngredient
     * const sharedIngredient = await prisma.sharedIngredient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SharedIngredientFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SharedIngredientFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__SharedIngredientClient<SharedIngredient>, Prisma__SharedIngredientClient<SharedIngredientGetPayload<T>>>

    /**
     * Count the number of SharedIngredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedIngredientCountArgs} args - Arguments to filter SharedIngredients to count.
     * @example
     * // Count the number of SharedIngredients
     * const count = await prisma.sharedIngredient.count({
     *   where: {
     *     // ... the filter for the SharedIngredients we want to count
     *   }
     * })
    **/
    count<T extends SharedIngredientCountArgs>(
      args?: Subset<T, SharedIngredientCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SharedIngredientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SharedIngredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedIngredientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SharedIngredientAggregateArgs>(args: Subset<T, SharedIngredientAggregateArgs>): PrismaPromise<GetSharedIngredientAggregateType<T>>

    /**
     * Group by SharedIngredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedIngredientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SharedIngredientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SharedIngredientGroupByArgs['orderBy'] }
        : { orderBy?: SharedIngredientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SharedIngredientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSharedIngredientGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SharedIngredient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SharedIngredientClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    ingredient<T extends IngredientArgs = {}>(args?: Subset<T, IngredientArgs>): CheckSelect<T, Prisma__IngredientClient<Ingredient | null >, Prisma__IngredientClient<IngredientGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    sharedBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SharedIngredient base type for findUnique actions
   */
  export type SharedIngredientFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SharedIngredient
     * 
    **/
    select?: SharedIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SharedIngredientInclude | null
    /**
     * Filter, which SharedIngredient to fetch.
     * 
    **/
    where: SharedIngredientWhereUniqueInput
  }

  /**
   * SharedIngredient: findUnique
   */
  export interface SharedIngredientFindUniqueArgs extends SharedIngredientFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SharedIngredient base type for findFirst actions
   */
  export type SharedIngredientFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SharedIngredient
     * 
    **/
    select?: SharedIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SharedIngredientInclude | null
    /**
     * Filter, which SharedIngredient to fetch.
     * 
    **/
    where?: SharedIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedIngredients to fetch.
     * 
    **/
    orderBy?: Enumerable<SharedIngredientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SharedIngredients.
     * 
    **/
    cursor?: SharedIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedIngredients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedIngredients.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SharedIngredients.
     * 
    **/
    distinct?: Enumerable<SharedIngredientScalarFieldEnum>
  }

  /**
   * SharedIngredient: findFirst
   */
  export interface SharedIngredientFindFirstArgs extends SharedIngredientFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SharedIngredient findMany
   */
  export type SharedIngredientFindManyArgs = {
    /**
     * Select specific fields to fetch from the SharedIngredient
     * 
    **/
    select?: SharedIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SharedIngredientInclude | null
    /**
     * Filter, which SharedIngredients to fetch.
     * 
    **/
    where?: SharedIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedIngredients to fetch.
     * 
    **/
    orderBy?: Enumerable<SharedIngredientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SharedIngredients.
     * 
    **/
    cursor?: SharedIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedIngredients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedIngredients.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SharedIngredientScalarFieldEnum>
  }


  /**
   * SharedIngredient create
   */
  export type SharedIngredientCreateArgs = {
    /**
     * Select specific fields to fetch from the SharedIngredient
     * 
    **/
    select?: SharedIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SharedIngredientInclude | null
    /**
     * The data needed to create a SharedIngredient.
     * 
    **/
    data: XOR<SharedIngredientCreateInput, SharedIngredientUncheckedCreateInput>
  }


  /**
   * SharedIngredient createMany
   */
  export type SharedIngredientCreateManyArgs = {
    /**
     * The data used to create many SharedIngredients.
     * 
    **/
    data: Enumerable<SharedIngredientCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SharedIngredient update
   */
  export type SharedIngredientUpdateArgs = {
    /**
     * Select specific fields to fetch from the SharedIngredient
     * 
    **/
    select?: SharedIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SharedIngredientInclude | null
    /**
     * The data needed to update a SharedIngredient.
     * 
    **/
    data: XOR<SharedIngredientUpdateInput, SharedIngredientUncheckedUpdateInput>
    /**
     * Choose, which SharedIngredient to update.
     * 
    **/
    where: SharedIngredientWhereUniqueInput
  }


  /**
   * SharedIngredient updateMany
   */
  export type SharedIngredientUpdateManyArgs = {
    /**
     * The data used to update SharedIngredients.
     * 
    **/
    data: XOR<SharedIngredientUpdateManyMutationInput, SharedIngredientUncheckedUpdateManyInput>
    /**
     * Filter which SharedIngredients to update
     * 
    **/
    where?: SharedIngredientWhereInput
  }


  /**
   * SharedIngredient upsert
   */
  export type SharedIngredientUpsertArgs = {
    /**
     * Select specific fields to fetch from the SharedIngredient
     * 
    **/
    select?: SharedIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SharedIngredientInclude | null
    /**
     * The filter to search for the SharedIngredient to update in case it exists.
     * 
    **/
    where: SharedIngredientWhereUniqueInput
    /**
     * In case the SharedIngredient found by the `where` argument doesn't exist, create a new SharedIngredient with this data.
     * 
    **/
    create: XOR<SharedIngredientCreateInput, SharedIngredientUncheckedCreateInput>
    /**
     * In case the SharedIngredient was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SharedIngredientUpdateInput, SharedIngredientUncheckedUpdateInput>
  }


  /**
   * SharedIngredient delete
   */
  export type SharedIngredientDeleteArgs = {
    /**
     * Select specific fields to fetch from the SharedIngredient
     * 
    **/
    select?: SharedIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SharedIngredientInclude | null
    /**
     * Filter which SharedIngredient to delete.
     * 
    **/
    where: SharedIngredientWhereUniqueInput
  }


  /**
   * SharedIngredient deleteMany
   */
  export type SharedIngredientDeleteManyArgs = {
    /**
     * Filter which SharedIngredients to delete
     * 
    **/
    where?: SharedIngredientWhereInput
  }


  /**
   * SharedIngredient: findUniqueOrThrow
   */
  export type SharedIngredientFindUniqueOrThrowArgs = SharedIngredientFindUniqueArgsBase
      

  /**
   * SharedIngredient: findFirstOrThrow
   */
  export type SharedIngredientFindFirstOrThrowArgs = SharedIngredientFindFirstArgsBase
      

  /**
   * SharedIngredient without action
   */
  export type SharedIngredientArgs = {
    /**
     * Select specific fields to fetch from the SharedIngredient
     * 
    **/
    select?: SharedIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SharedIngredientInclude | null
  }



  /**
   * Model SharedSpec
   */


  export type AggregateSharedSpec = {
    _count: SharedSpecCountAggregateOutputType | null
    _avg: SharedSpecAvgAggregateOutputType | null
    _sum: SharedSpecSumAggregateOutputType | null
    _min: SharedSpecMinAggregateOutputType | null
    _max: SharedSpecMaxAggregateOutputType | null
  }

  export type SharedSpecAvgAggregateOutputType = {
    specId: number | null
  }

  export type SharedSpecSumAggregateOutputType = {
    specId: number | null
  }

  export type SharedSpecMinAggregateOutputType = {
    userId: string | null
    specId: number | null
    sharedById: string | null
    sharedAt: Date | null
  }

  export type SharedSpecMaxAggregateOutputType = {
    userId: string | null
    specId: number | null
    sharedById: string | null
    sharedAt: Date | null
  }

  export type SharedSpecCountAggregateOutputType = {
    userId: number
    specId: number
    sharedById: number
    sharedAt: number
    _all: number
  }


  export type SharedSpecAvgAggregateInputType = {
    specId?: true
  }

  export type SharedSpecSumAggregateInputType = {
    specId?: true
  }

  export type SharedSpecMinAggregateInputType = {
    userId?: true
    specId?: true
    sharedById?: true
    sharedAt?: true
  }

  export type SharedSpecMaxAggregateInputType = {
    userId?: true
    specId?: true
    sharedById?: true
    sharedAt?: true
  }

  export type SharedSpecCountAggregateInputType = {
    userId?: true
    specId?: true
    sharedById?: true
    sharedAt?: true
    _all?: true
  }

  export type SharedSpecAggregateArgs = {
    /**
     * Filter which SharedSpec to aggregate.
     * 
    **/
    where?: SharedSpecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedSpecs to fetch.
     * 
    **/
    orderBy?: Enumerable<SharedSpecOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SharedSpecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedSpecs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedSpecs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SharedSpecs
    **/
    _count?: true | SharedSpecCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SharedSpecAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SharedSpecSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SharedSpecMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SharedSpecMaxAggregateInputType
  }

  export type GetSharedSpecAggregateType<T extends SharedSpecAggregateArgs> = {
        [P in keyof T & keyof AggregateSharedSpec]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSharedSpec[P]>
      : GetScalarType<T[P], AggregateSharedSpec[P]>
  }




  export type SharedSpecGroupByArgs = {
    where?: SharedSpecWhereInput
    orderBy?: Enumerable<SharedSpecOrderByWithAggregationInput>
    by: Array<SharedSpecScalarFieldEnum>
    having?: SharedSpecScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SharedSpecCountAggregateInputType | true
    _avg?: SharedSpecAvgAggregateInputType
    _sum?: SharedSpecSumAggregateInputType
    _min?: SharedSpecMinAggregateInputType
    _max?: SharedSpecMaxAggregateInputType
  }


  export type SharedSpecGroupByOutputType = {
    userId: string
    specId: number
    sharedById: string
    sharedAt: Date
    _count: SharedSpecCountAggregateOutputType | null
    _avg: SharedSpecAvgAggregateOutputType | null
    _sum: SharedSpecSumAggregateOutputType | null
    _min: SharedSpecMinAggregateOutputType | null
    _max: SharedSpecMaxAggregateOutputType | null
  }

  type GetSharedSpecGroupByPayload<T extends SharedSpecGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SharedSpecGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SharedSpecGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SharedSpecGroupByOutputType[P]>
            : GetScalarType<T[P], SharedSpecGroupByOutputType[P]>
        }
      >
    >


  export type SharedSpecSelect = {
    userId?: boolean
    specId?: boolean
    sharedById?: boolean
    sharedAt?: boolean
    spec?: boolean | SpecArgs
    user?: boolean | UserArgs
    sharedBy?: boolean | UserArgs
  }

  export type SharedSpecInclude = {
    spec?: boolean | SpecArgs
    user?: boolean | UserArgs
    sharedBy?: boolean | UserArgs
  }

  export type SharedSpecGetPayload<
    S extends boolean | null | undefined | SharedSpecArgs,
    U = keyof S
      > = S extends true
        ? SharedSpec
    : S extends undefined
    ? never
    : S extends SharedSpecArgs | SharedSpecFindManyArgs
    ?'include' extends U
    ? SharedSpec  & {
    [P in TrueKeys<S['include']>]:
        P extends 'spec' ? SpecGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'sharedBy' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'spec' ? SpecGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'sharedBy' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof SharedSpec ? SharedSpec[P] : never
  } 
    : SharedSpec
  : SharedSpec


  type SharedSpecCountArgs = Merge<
    Omit<SharedSpecFindManyArgs, 'select' | 'include'> & {
      select?: SharedSpecCountAggregateInputType | true
    }
  >

  export interface SharedSpecDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one SharedSpec that matches the filter.
     * @param {SharedSpecFindUniqueArgs} args - Arguments to find a SharedSpec
     * @example
     * // Get one SharedSpec
     * const sharedSpec = await prisma.sharedSpec.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SharedSpecFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SharedSpecFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SharedSpec'> extends True ? CheckSelect<T, Prisma__SharedSpecClient<SharedSpec>, Prisma__SharedSpecClient<SharedSpecGetPayload<T>>> : CheckSelect<T, Prisma__SharedSpecClient<SharedSpec | null >, Prisma__SharedSpecClient<SharedSpecGetPayload<T> | null >>

    /**
     * Find the first SharedSpec that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedSpecFindFirstArgs} args - Arguments to find a SharedSpec
     * @example
     * // Get one SharedSpec
     * const sharedSpec = await prisma.sharedSpec.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SharedSpecFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SharedSpecFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SharedSpec'> extends True ? CheckSelect<T, Prisma__SharedSpecClient<SharedSpec>, Prisma__SharedSpecClient<SharedSpecGetPayload<T>>> : CheckSelect<T, Prisma__SharedSpecClient<SharedSpec | null >, Prisma__SharedSpecClient<SharedSpecGetPayload<T> | null >>

    /**
     * Find zero or more SharedSpecs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedSpecFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SharedSpecs
     * const sharedSpecs = await prisma.sharedSpec.findMany()
     * 
     * // Get first 10 SharedSpecs
     * const sharedSpecs = await prisma.sharedSpec.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const sharedSpecWithUserIdOnly = await prisma.sharedSpec.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends SharedSpecFindManyArgs>(
      args?: SelectSubset<T, SharedSpecFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SharedSpec>>, PrismaPromise<Array<SharedSpecGetPayload<T>>>>

    /**
     * Create a SharedSpec.
     * @param {SharedSpecCreateArgs} args - Arguments to create a SharedSpec.
     * @example
     * // Create one SharedSpec
     * const SharedSpec = await prisma.sharedSpec.create({
     *   data: {
     *     // ... data to create a SharedSpec
     *   }
     * })
     * 
    **/
    create<T extends SharedSpecCreateArgs>(
      args: SelectSubset<T, SharedSpecCreateArgs>
    ): CheckSelect<T, Prisma__SharedSpecClient<SharedSpec>, Prisma__SharedSpecClient<SharedSpecGetPayload<T>>>

    /**
     * Create many SharedSpecs.
     *     @param {SharedSpecCreateManyArgs} args - Arguments to create many SharedSpecs.
     *     @example
     *     // Create many SharedSpecs
     *     const sharedSpec = await prisma.sharedSpec.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SharedSpecCreateManyArgs>(
      args?: SelectSubset<T, SharedSpecCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SharedSpec.
     * @param {SharedSpecDeleteArgs} args - Arguments to delete one SharedSpec.
     * @example
     * // Delete one SharedSpec
     * const SharedSpec = await prisma.sharedSpec.delete({
     *   where: {
     *     // ... filter to delete one SharedSpec
     *   }
     * })
     * 
    **/
    delete<T extends SharedSpecDeleteArgs>(
      args: SelectSubset<T, SharedSpecDeleteArgs>
    ): CheckSelect<T, Prisma__SharedSpecClient<SharedSpec>, Prisma__SharedSpecClient<SharedSpecGetPayload<T>>>

    /**
     * Update one SharedSpec.
     * @param {SharedSpecUpdateArgs} args - Arguments to update one SharedSpec.
     * @example
     * // Update one SharedSpec
     * const sharedSpec = await prisma.sharedSpec.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SharedSpecUpdateArgs>(
      args: SelectSubset<T, SharedSpecUpdateArgs>
    ): CheckSelect<T, Prisma__SharedSpecClient<SharedSpec>, Prisma__SharedSpecClient<SharedSpecGetPayload<T>>>

    /**
     * Delete zero or more SharedSpecs.
     * @param {SharedSpecDeleteManyArgs} args - Arguments to filter SharedSpecs to delete.
     * @example
     * // Delete a few SharedSpecs
     * const { count } = await prisma.sharedSpec.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SharedSpecDeleteManyArgs>(
      args?: SelectSubset<T, SharedSpecDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SharedSpecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedSpecUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SharedSpecs
     * const sharedSpec = await prisma.sharedSpec.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SharedSpecUpdateManyArgs>(
      args: SelectSubset<T, SharedSpecUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SharedSpec.
     * @param {SharedSpecUpsertArgs} args - Arguments to update or create a SharedSpec.
     * @example
     * // Update or create a SharedSpec
     * const sharedSpec = await prisma.sharedSpec.upsert({
     *   create: {
     *     // ... data to create a SharedSpec
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SharedSpec we want to update
     *   }
     * })
    **/
    upsert<T extends SharedSpecUpsertArgs>(
      args: SelectSubset<T, SharedSpecUpsertArgs>
    ): CheckSelect<T, Prisma__SharedSpecClient<SharedSpec>, Prisma__SharedSpecClient<SharedSpecGetPayload<T>>>

    /**
     * Find one SharedSpec that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {SharedSpecFindUniqueOrThrowArgs} args - Arguments to find a SharedSpec
     * @example
     * // Get one SharedSpec
     * const sharedSpec = await prisma.sharedSpec.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SharedSpecFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SharedSpecFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__SharedSpecClient<SharedSpec>, Prisma__SharedSpecClient<SharedSpecGetPayload<T>>>

    /**
     * Find the first SharedSpec that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedSpecFindFirstOrThrowArgs} args - Arguments to find a SharedSpec
     * @example
     * // Get one SharedSpec
     * const sharedSpec = await prisma.sharedSpec.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SharedSpecFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SharedSpecFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__SharedSpecClient<SharedSpec>, Prisma__SharedSpecClient<SharedSpecGetPayload<T>>>

    /**
     * Count the number of SharedSpecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedSpecCountArgs} args - Arguments to filter SharedSpecs to count.
     * @example
     * // Count the number of SharedSpecs
     * const count = await prisma.sharedSpec.count({
     *   where: {
     *     // ... the filter for the SharedSpecs we want to count
     *   }
     * })
    **/
    count<T extends SharedSpecCountArgs>(
      args?: Subset<T, SharedSpecCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SharedSpecCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SharedSpec.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedSpecAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SharedSpecAggregateArgs>(args: Subset<T, SharedSpecAggregateArgs>): PrismaPromise<GetSharedSpecAggregateType<T>>

    /**
     * Group by SharedSpec.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedSpecGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SharedSpecGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SharedSpecGroupByArgs['orderBy'] }
        : { orderBy?: SharedSpecGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SharedSpecGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSharedSpecGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SharedSpec.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SharedSpecClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    spec<T extends SpecArgs = {}>(args?: Subset<T, SpecArgs>): CheckSelect<T, Prisma__SpecClient<Spec | null >, Prisma__SpecClient<SpecGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    sharedBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SharedSpec base type for findUnique actions
   */
  export type SharedSpecFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SharedSpec
     * 
    **/
    select?: SharedSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SharedSpecInclude | null
    /**
     * Filter, which SharedSpec to fetch.
     * 
    **/
    where: SharedSpecWhereUniqueInput
  }

  /**
   * SharedSpec: findUnique
   */
  export interface SharedSpecFindUniqueArgs extends SharedSpecFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SharedSpec base type for findFirst actions
   */
  export type SharedSpecFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SharedSpec
     * 
    **/
    select?: SharedSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SharedSpecInclude | null
    /**
     * Filter, which SharedSpec to fetch.
     * 
    **/
    where?: SharedSpecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedSpecs to fetch.
     * 
    **/
    orderBy?: Enumerable<SharedSpecOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SharedSpecs.
     * 
    **/
    cursor?: SharedSpecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedSpecs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedSpecs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SharedSpecs.
     * 
    **/
    distinct?: Enumerable<SharedSpecScalarFieldEnum>
  }

  /**
   * SharedSpec: findFirst
   */
  export interface SharedSpecFindFirstArgs extends SharedSpecFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SharedSpec findMany
   */
  export type SharedSpecFindManyArgs = {
    /**
     * Select specific fields to fetch from the SharedSpec
     * 
    **/
    select?: SharedSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SharedSpecInclude | null
    /**
     * Filter, which SharedSpecs to fetch.
     * 
    **/
    where?: SharedSpecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedSpecs to fetch.
     * 
    **/
    orderBy?: Enumerable<SharedSpecOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SharedSpecs.
     * 
    **/
    cursor?: SharedSpecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedSpecs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedSpecs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SharedSpecScalarFieldEnum>
  }


  /**
   * SharedSpec create
   */
  export type SharedSpecCreateArgs = {
    /**
     * Select specific fields to fetch from the SharedSpec
     * 
    **/
    select?: SharedSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SharedSpecInclude | null
    /**
     * The data needed to create a SharedSpec.
     * 
    **/
    data: XOR<SharedSpecCreateInput, SharedSpecUncheckedCreateInput>
  }


  /**
   * SharedSpec createMany
   */
  export type SharedSpecCreateManyArgs = {
    /**
     * The data used to create many SharedSpecs.
     * 
    **/
    data: Enumerable<SharedSpecCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SharedSpec update
   */
  export type SharedSpecUpdateArgs = {
    /**
     * Select specific fields to fetch from the SharedSpec
     * 
    **/
    select?: SharedSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SharedSpecInclude | null
    /**
     * The data needed to update a SharedSpec.
     * 
    **/
    data: XOR<SharedSpecUpdateInput, SharedSpecUncheckedUpdateInput>
    /**
     * Choose, which SharedSpec to update.
     * 
    **/
    where: SharedSpecWhereUniqueInput
  }


  /**
   * SharedSpec updateMany
   */
  export type SharedSpecUpdateManyArgs = {
    /**
     * The data used to update SharedSpecs.
     * 
    **/
    data: XOR<SharedSpecUpdateManyMutationInput, SharedSpecUncheckedUpdateManyInput>
    /**
     * Filter which SharedSpecs to update
     * 
    **/
    where?: SharedSpecWhereInput
  }


  /**
   * SharedSpec upsert
   */
  export type SharedSpecUpsertArgs = {
    /**
     * Select specific fields to fetch from the SharedSpec
     * 
    **/
    select?: SharedSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SharedSpecInclude | null
    /**
     * The filter to search for the SharedSpec to update in case it exists.
     * 
    **/
    where: SharedSpecWhereUniqueInput
    /**
     * In case the SharedSpec found by the `where` argument doesn't exist, create a new SharedSpec with this data.
     * 
    **/
    create: XOR<SharedSpecCreateInput, SharedSpecUncheckedCreateInput>
    /**
     * In case the SharedSpec was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SharedSpecUpdateInput, SharedSpecUncheckedUpdateInput>
  }


  /**
   * SharedSpec delete
   */
  export type SharedSpecDeleteArgs = {
    /**
     * Select specific fields to fetch from the SharedSpec
     * 
    **/
    select?: SharedSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SharedSpecInclude | null
    /**
     * Filter which SharedSpec to delete.
     * 
    **/
    where: SharedSpecWhereUniqueInput
  }


  /**
   * SharedSpec deleteMany
   */
  export type SharedSpecDeleteManyArgs = {
    /**
     * Filter which SharedSpecs to delete
     * 
    **/
    where?: SharedSpecWhereInput
  }


  /**
   * SharedSpec: findUniqueOrThrow
   */
  export type SharedSpecFindUniqueOrThrowArgs = SharedSpecFindUniqueArgsBase
      

  /**
   * SharedSpec: findFirstOrThrow
   */
  export type SharedSpecFindFirstOrThrowArgs = SharedSpecFindFirstArgsBase
      

  /**
   * SharedSpec without action
   */
  export type SharedSpecArgs = {
    /**
     * Select specific fields to fetch from the SharedSpec
     * 
    **/
    select?: SharedSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SharedSpecInclude | null
  }



  /**
   * Model AdminOnSpec
   */


  export type AggregateAdminOnSpec = {
    _count: AdminOnSpecCountAggregateOutputType | null
    _avg: AdminOnSpecAvgAggregateOutputType | null
    _sum: AdminOnSpecSumAggregateOutputType | null
    _min: AdminOnSpecMinAggregateOutputType | null
    _max: AdminOnSpecMaxAggregateOutputType | null
  }

  export type AdminOnSpecAvgAggregateOutputType = {
    specId: number | null
  }

  export type AdminOnSpecSumAggregateOutputType = {
    specId: number | null
  }

  export type AdminOnSpecMinAggregateOutputType = {
    userId: string | null
    specId: number | null
    assignedById: string | null
    assignedAt: Date | null
  }

  export type AdminOnSpecMaxAggregateOutputType = {
    userId: string | null
    specId: number | null
    assignedById: string | null
    assignedAt: Date | null
  }

  export type AdminOnSpecCountAggregateOutputType = {
    userId: number
    specId: number
    assignedById: number
    assignedAt: number
    _all: number
  }


  export type AdminOnSpecAvgAggregateInputType = {
    specId?: true
  }

  export type AdminOnSpecSumAggregateInputType = {
    specId?: true
  }

  export type AdminOnSpecMinAggregateInputType = {
    userId?: true
    specId?: true
    assignedById?: true
    assignedAt?: true
  }

  export type AdminOnSpecMaxAggregateInputType = {
    userId?: true
    specId?: true
    assignedById?: true
    assignedAt?: true
  }

  export type AdminOnSpecCountAggregateInputType = {
    userId?: true
    specId?: true
    assignedById?: true
    assignedAt?: true
    _all?: true
  }

  export type AdminOnSpecAggregateArgs = {
    /**
     * Filter which AdminOnSpec to aggregate.
     * 
    **/
    where?: AdminOnSpecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminOnSpecs to fetch.
     * 
    **/
    orderBy?: Enumerable<AdminOnSpecOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AdminOnSpecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminOnSpecs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminOnSpecs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminOnSpecs
    **/
    _count?: true | AdminOnSpecCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminOnSpecAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminOnSpecSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminOnSpecMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminOnSpecMaxAggregateInputType
  }

  export type GetAdminOnSpecAggregateType<T extends AdminOnSpecAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminOnSpec]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminOnSpec[P]>
      : GetScalarType<T[P], AggregateAdminOnSpec[P]>
  }




  export type AdminOnSpecGroupByArgs = {
    where?: AdminOnSpecWhereInput
    orderBy?: Enumerable<AdminOnSpecOrderByWithAggregationInput>
    by: Array<AdminOnSpecScalarFieldEnum>
    having?: AdminOnSpecScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminOnSpecCountAggregateInputType | true
    _avg?: AdminOnSpecAvgAggregateInputType
    _sum?: AdminOnSpecSumAggregateInputType
    _min?: AdminOnSpecMinAggregateInputType
    _max?: AdminOnSpecMaxAggregateInputType
  }


  export type AdminOnSpecGroupByOutputType = {
    userId: string
    specId: number
    assignedById: string
    assignedAt: Date
    _count: AdminOnSpecCountAggregateOutputType | null
    _avg: AdminOnSpecAvgAggregateOutputType | null
    _sum: AdminOnSpecSumAggregateOutputType | null
    _min: AdminOnSpecMinAggregateOutputType | null
    _max: AdminOnSpecMaxAggregateOutputType | null
  }

  type GetAdminOnSpecGroupByPayload<T extends AdminOnSpecGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AdminOnSpecGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminOnSpecGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminOnSpecGroupByOutputType[P]>
            : GetScalarType<T[P], AdminOnSpecGroupByOutputType[P]>
        }
      >
    >


  export type AdminOnSpecSelect = {
    userId?: boolean
    specId?: boolean
    assignedById?: boolean
    assignedAt?: boolean
    spec?: boolean | SpecArgs
    user?: boolean | UserArgs
    assignedBy?: boolean | UserArgs
  }

  export type AdminOnSpecInclude = {
    spec?: boolean | SpecArgs
    user?: boolean | UserArgs
    assignedBy?: boolean | UserArgs
  }

  export type AdminOnSpecGetPayload<
    S extends boolean | null | undefined | AdminOnSpecArgs,
    U = keyof S
      > = S extends true
        ? AdminOnSpec
    : S extends undefined
    ? never
    : S extends AdminOnSpecArgs | AdminOnSpecFindManyArgs
    ?'include' extends U
    ? AdminOnSpec  & {
    [P in TrueKeys<S['include']>]:
        P extends 'spec' ? SpecGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'assignedBy' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'spec' ? SpecGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'assignedBy' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof AdminOnSpec ? AdminOnSpec[P] : never
  } 
    : AdminOnSpec
  : AdminOnSpec


  type AdminOnSpecCountArgs = Merge<
    Omit<AdminOnSpecFindManyArgs, 'select' | 'include'> & {
      select?: AdminOnSpecCountAggregateInputType | true
    }
  >

  export interface AdminOnSpecDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one AdminOnSpec that matches the filter.
     * @param {AdminOnSpecFindUniqueArgs} args - Arguments to find a AdminOnSpec
     * @example
     * // Get one AdminOnSpec
     * const adminOnSpec = await prisma.adminOnSpec.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdminOnSpecFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AdminOnSpecFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AdminOnSpec'> extends True ? CheckSelect<T, Prisma__AdminOnSpecClient<AdminOnSpec>, Prisma__AdminOnSpecClient<AdminOnSpecGetPayload<T>>> : CheckSelect<T, Prisma__AdminOnSpecClient<AdminOnSpec | null >, Prisma__AdminOnSpecClient<AdminOnSpecGetPayload<T> | null >>

    /**
     * Find the first AdminOnSpec that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminOnSpecFindFirstArgs} args - Arguments to find a AdminOnSpec
     * @example
     * // Get one AdminOnSpec
     * const adminOnSpec = await prisma.adminOnSpec.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdminOnSpecFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AdminOnSpecFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AdminOnSpec'> extends True ? CheckSelect<T, Prisma__AdminOnSpecClient<AdminOnSpec>, Prisma__AdminOnSpecClient<AdminOnSpecGetPayload<T>>> : CheckSelect<T, Prisma__AdminOnSpecClient<AdminOnSpec | null >, Prisma__AdminOnSpecClient<AdminOnSpecGetPayload<T> | null >>

    /**
     * Find zero or more AdminOnSpecs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminOnSpecFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminOnSpecs
     * const adminOnSpecs = await prisma.adminOnSpec.findMany()
     * 
     * // Get first 10 AdminOnSpecs
     * const adminOnSpecs = await prisma.adminOnSpec.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const adminOnSpecWithUserIdOnly = await prisma.adminOnSpec.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends AdminOnSpecFindManyArgs>(
      args?: SelectSubset<T, AdminOnSpecFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<AdminOnSpec>>, PrismaPromise<Array<AdminOnSpecGetPayload<T>>>>

    /**
     * Create a AdminOnSpec.
     * @param {AdminOnSpecCreateArgs} args - Arguments to create a AdminOnSpec.
     * @example
     * // Create one AdminOnSpec
     * const AdminOnSpec = await prisma.adminOnSpec.create({
     *   data: {
     *     // ... data to create a AdminOnSpec
     *   }
     * })
     * 
    **/
    create<T extends AdminOnSpecCreateArgs>(
      args: SelectSubset<T, AdminOnSpecCreateArgs>
    ): CheckSelect<T, Prisma__AdminOnSpecClient<AdminOnSpec>, Prisma__AdminOnSpecClient<AdminOnSpecGetPayload<T>>>

    /**
     * Create many AdminOnSpecs.
     *     @param {AdminOnSpecCreateManyArgs} args - Arguments to create many AdminOnSpecs.
     *     @example
     *     // Create many AdminOnSpecs
     *     const adminOnSpec = await prisma.adminOnSpec.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdminOnSpecCreateManyArgs>(
      args?: SelectSubset<T, AdminOnSpecCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a AdminOnSpec.
     * @param {AdminOnSpecDeleteArgs} args - Arguments to delete one AdminOnSpec.
     * @example
     * // Delete one AdminOnSpec
     * const AdminOnSpec = await prisma.adminOnSpec.delete({
     *   where: {
     *     // ... filter to delete one AdminOnSpec
     *   }
     * })
     * 
    **/
    delete<T extends AdminOnSpecDeleteArgs>(
      args: SelectSubset<T, AdminOnSpecDeleteArgs>
    ): CheckSelect<T, Prisma__AdminOnSpecClient<AdminOnSpec>, Prisma__AdminOnSpecClient<AdminOnSpecGetPayload<T>>>

    /**
     * Update one AdminOnSpec.
     * @param {AdminOnSpecUpdateArgs} args - Arguments to update one AdminOnSpec.
     * @example
     * // Update one AdminOnSpec
     * const adminOnSpec = await prisma.adminOnSpec.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdminOnSpecUpdateArgs>(
      args: SelectSubset<T, AdminOnSpecUpdateArgs>
    ): CheckSelect<T, Prisma__AdminOnSpecClient<AdminOnSpec>, Prisma__AdminOnSpecClient<AdminOnSpecGetPayload<T>>>

    /**
     * Delete zero or more AdminOnSpecs.
     * @param {AdminOnSpecDeleteManyArgs} args - Arguments to filter AdminOnSpecs to delete.
     * @example
     * // Delete a few AdminOnSpecs
     * const { count } = await prisma.adminOnSpec.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdminOnSpecDeleteManyArgs>(
      args?: SelectSubset<T, AdminOnSpecDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminOnSpecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminOnSpecUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminOnSpecs
     * const adminOnSpec = await prisma.adminOnSpec.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdminOnSpecUpdateManyArgs>(
      args: SelectSubset<T, AdminOnSpecUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminOnSpec.
     * @param {AdminOnSpecUpsertArgs} args - Arguments to update or create a AdminOnSpec.
     * @example
     * // Update or create a AdminOnSpec
     * const adminOnSpec = await prisma.adminOnSpec.upsert({
     *   create: {
     *     // ... data to create a AdminOnSpec
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminOnSpec we want to update
     *   }
     * })
    **/
    upsert<T extends AdminOnSpecUpsertArgs>(
      args: SelectSubset<T, AdminOnSpecUpsertArgs>
    ): CheckSelect<T, Prisma__AdminOnSpecClient<AdminOnSpec>, Prisma__AdminOnSpecClient<AdminOnSpecGetPayload<T>>>

    /**
     * Find one AdminOnSpec that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {AdminOnSpecFindUniqueOrThrowArgs} args - Arguments to find a AdminOnSpec
     * @example
     * // Get one AdminOnSpec
     * const adminOnSpec = await prisma.adminOnSpec.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AdminOnSpecFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AdminOnSpecFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__AdminOnSpecClient<AdminOnSpec>, Prisma__AdminOnSpecClient<AdminOnSpecGetPayload<T>>>

    /**
     * Find the first AdminOnSpec that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminOnSpecFindFirstOrThrowArgs} args - Arguments to find a AdminOnSpec
     * @example
     * // Get one AdminOnSpec
     * const adminOnSpec = await prisma.adminOnSpec.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AdminOnSpecFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AdminOnSpecFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__AdminOnSpecClient<AdminOnSpec>, Prisma__AdminOnSpecClient<AdminOnSpecGetPayload<T>>>

    /**
     * Count the number of AdminOnSpecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminOnSpecCountArgs} args - Arguments to filter AdminOnSpecs to count.
     * @example
     * // Count the number of AdminOnSpecs
     * const count = await prisma.adminOnSpec.count({
     *   where: {
     *     // ... the filter for the AdminOnSpecs we want to count
     *   }
     * })
    **/
    count<T extends AdminOnSpecCountArgs>(
      args?: Subset<T, AdminOnSpecCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminOnSpecCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminOnSpec.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminOnSpecAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminOnSpecAggregateArgs>(args: Subset<T, AdminOnSpecAggregateArgs>): PrismaPromise<GetAdminOnSpecAggregateType<T>>

    /**
     * Group by AdminOnSpec.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminOnSpecGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminOnSpecGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminOnSpecGroupByArgs['orderBy'] }
        : { orderBy?: AdminOnSpecGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminOnSpecGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminOnSpecGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminOnSpec.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AdminOnSpecClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    spec<T extends SpecArgs = {}>(args?: Subset<T, SpecArgs>): CheckSelect<T, Prisma__SpecClient<Spec | null >, Prisma__SpecClient<SpecGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    assignedBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AdminOnSpec base type for findUnique actions
   */
  export type AdminOnSpecFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the AdminOnSpec
     * 
    **/
    select?: AdminOnSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdminOnSpecInclude | null
    /**
     * Filter, which AdminOnSpec to fetch.
     * 
    **/
    where: AdminOnSpecWhereUniqueInput
  }

  /**
   * AdminOnSpec: findUnique
   */
  export interface AdminOnSpecFindUniqueArgs extends AdminOnSpecFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AdminOnSpec base type for findFirst actions
   */
  export type AdminOnSpecFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the AdminOnSpec
     * 
    **/
    select?: AdminOnSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdminOnSpecInclude | null
    /**
     * Filter, which AdminOnSpec to fetch.
     * 
    **/
    where?: AdminOnSpecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminOnSpecs to fetch.
     * 
    **/
    orderBy?: Enumerable<AdminOnSpecOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminOnSpecs.
     * 
    **/
    cursor?: AdminOnSpecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminOnSpecs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminOnSpecs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminOnSpecs.
     * 
    **/
    distinct?: Enumerable<AdminOnSpecScalarFieldEnum>
  }

  /**
   * AdminOnSpec: findFirst
   */
  export interface AdminOnSpecFindFirstArgs extends AdminOnSpecFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AdminOnSpec findMany
   */
  export type AdminOnSpecFindManyArgs = {
    /**
     * Select specific fields to fetch from the AdminOnSpec
     * 
    **/
    select?: AdminOnSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdminOnSpecInclude | null
    /**
     * Filter, which AdminOnSpecs to fetch.
     * 
    **/
    where?: AdminOnSpecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminOnSpecs to fetch.
     * 
    **/
    orderBy?: Enumerable<AdminOnSpecOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminOnSpecs.
     * 
    **/
    cursor?: AdminOnSpecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminOnSpecs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminOnSpecs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AdminOnSpecScalarFieldEnum>
  }


  /**
   * AdminOnSpec create
   */
  export type AdminOnSpecCreateArgs = {
    /**
     * Select specific fields to fetch from the AdminOnSpec
     * 
    **/
    select?: AdminOnSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdminOnSpecInclude | null
    /**
     * The data needed to create a AdminOnSpec.
     * 
    **/
    data: XOR<AdminOnSpecCreateInput, AdminOnSpecUncheckedCreateInput>
  }


  /**
   * AdminOnSpec createMany
   */
  export type AdminOnSpecCreateManyArgs = {
    /**
     * The data used to create many AdminOnSpecs.
     * 
    **/
    data: Enumerable<AdminOnSpecCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AdminOnSpec update
   */
  export type AdminOnSpecUpdateArgs = {
    /**
     * Select specific fields to fetch from the AdminOnSpec
     * 
    **/
    select?: AdminOnSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdminOnSpecInclude | null
    /**
     * The data needed to update a AdminOnSpec.
     * 
    **/
    data: XOR<AdminOnSpecUpdateInput, AdminOnSpecUncheckedUpdateInput>
    /**
     * Choose, which AdminOnSpec to update.
     * 
    **/
    where: AdminOnSpecWhereUniqueInput
  }


  /**
   * AdminOnSpec updateMany
   */
  export type AdminOnSpecUpdateManyArgs = {
    /**
     * The data used to update AdminOnSpecs.
     * 
    **/
    data: XOR<AdminOnSpecUpdateManyMutationInput, AdminOnSpecUncheckedUpdateManyInput>
    /**
     * Filter which AdminOnSpecs to update
     * 
    **/
    where?: AdminOnSpecWhereInput
  }


  /**
   * AdminOnSpec upsert
   */
  export type AdminOnSpecUpsertArgs = {
    /**
     * Select specific fields to fetch from the AdminOnSpec
     * 
    **/
    select?: AdminOnSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdminOnSpecInclude | null
    /**
     * The filter to search for the AdminOnSpec to update in case it exists.
     * 
    **/
    where: AdminOnSpecWhereUniqueInput
    /**
     * In case the AdminOnSpec found by the `where` argument doesn't exist, create a new AdminOnSpec with this data.
     * 
    **/
    create: XOR<AdminOnSpecCreateInput, AdminOnSpecUncheckedCreateInput>
    /**
     * In case the AdminOnSpec was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AdminOnSpecUpdateInput, AdminOnSpecUncheckedUpdateInput>
  }


  /**
   * AdminOnSpec delete
   */
  export type AdminOnSpecDeleteArgs = {
    /**
     * Select specific fields to fetch from the AdminOnSpec
     * 
    **/
    select?: AdminOnSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdminOnSpecInclude | null
    /**
     * Filter which AdminOnSpec to delete.
     * 
    **/
    where: AdminOnSpecWhereUniqueInput
  }


  /**
   * AdminOnSpec deleteMany
   */
  export type AdminOnSpecDeleteManyArgs = {
    /**
     * Filter which AdminOnSpecs to delete
     * 
    **/
    where?: AdminOnSpecWhereInput
  }


  /**
   * AdminOnSpec: findUniqueOrThrow
   */
  export type AdminOnSpecFindUniqueOrThrowArgs = AdminOnSpecFindUniqueArgsBase
      

  /**
   * AdminOnSpec: findFirstOrThrow
   */
  export type AdminOnSpecFindFirstOrThrowArgs = AdminOnSpecFindFirstArgsBase
      

  /**
   * AdminOnSpec without action
   */
  export type AdminOnSpecArgs = {
    /**
     * Select specific fields to fetch from the AdminOnSpec
     * 
    **/
    select?: AdminOnSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdminOnSpecInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AdminOnSpecScalarFieldEnum: {
    userId: 'userId',
    specId: 'specId',
    assignedById: 'assignedById',
    assignedAt: 'assignedAt'
  };

  export type AdminOnSpecScalarFieldEnum = (typeof AdminOnSpecScalarFieldEnum)[keyof typeof AdminOnSpecScalarFieldEnum]


  export const GroupIngredientScalarFieldEnum: {
    groupId: 'groupId',
    ingredientId: 'ingredientId'
  };

  export type GroupIngredientScalarFieldEnum = (typeof GroupIngredientScalarFieldEnum)[keyof typeof GroupIngredientScalarFieldEnum]


  export const GroupModScalarFieldEnum: {
    userId: 'userId',
    groupId: 'groupId'
  };

  export type GroupModScalarFieldEnum = (typeof GroupModScalarFieldEnum)[keyof typeof GroupModScalarFieldEnum]


  export const GroupSpecScalarFieldEnum: {
    groupId: 'groupId',
    specId: 'specId'
  };

  export type GroupSpecScalarFieldEnum = (typeof GroupSpecScalarFieldEnum)[keyof typeof GroupSpecScalarFieldEnum]


  export const GroupUserScalarFieldEnum: {
    userId: 'userId',
    groupId: 'groupId'
  };

  export type GroupUserScalarFieldEnum = (typeof GroupUserScalarFieldEnum)[keyof typeof GroupUserScalarFieldEnum]


  export const GroupsScalarFieldEnum: {
    id: 'id',
    groupName: 'groupName',
    dateCreated: 'dateCreated'
  };

  export type GroupsScalarFieldEnum = (typeof GroupsScalarFieldEnum)[keyof typeof GroupsScalarFieldEnum]


  export const IngredientScalarFieldEnum: {
    id: 'id',
    dateCreated: 'dateCreated',
    name: 'name',
    amount: 'amount',
    unit: 'unit',
    price: 'price',
    source: 'source',
    postedById: 'postedById'
  };

  export type IngredientScalarFieldEnum = (typeof IngredientScalarFieldEnum)[keyof typeof IngredientScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const RecipeScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    name: 'name',
    origin: 'origin',
    history: 'history',
    postedById: 'postedById'
  };

  export type RecipeScalarFieldEnum = (typeof RecipeScalarFieldEnum)[keyof typeof RecipeScalarFieldEnum]


  export const SharedIngredientScalarFieldEnum: {
    userId: 'userId',
    ingredientId: 'ingredientId',
    sharedById: 'sharedById',
    sharedAt: 'sharedAt'
  };

  export type SharedIngredientScalarFieldEnum = (typeof SharedIngredientScalarFieldEnum)[keyof typeof SharedIngredientScalarFieldEnum]


  export const SharedSpecScalarFieldEnum: {
    userId: 'userId',
    specId: 'specId',
    sharedById: 'sharedById',
    sharedAt: 'sharedAt'
  };

  export type SharedSpecScalarFieldEnum = (typeof SharedSpecScalarFieldEnum)[keyof typeof SharedSpecScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const SpecScalarFieldEnum: {
    id: 'id',
    specName: 'specName',
    postedById: 'postedById',
    instructions: 'instructions',
    glassware: 'glassware',
    ice: 'ice',
    recipeId: 'recipeId'
  };

  export type SpecScalarFieldEnum = (typeof SpecScalarFieldEnum)[keyof typeof SpecScalarFieldEnum]


  export const TouchScalarFieldEnum: {
    id: 'id',
    ingredientId: 'ingredientId',
    order: 'order',
    amount: 'amount',
    unit: 'unit',
    specId: 'specId',
    postedById: 'postedById'
  };

  export type TouchScalarFieldEnum = (typeof TouchScalarFieldEnum)[keyof typeof TouchScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserDataScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    userBio: 'userBio',
    workPlace: 'workPlace',
    profilePicture: 'profilePicture'
  };

  export type UserDataScalarFieldEnum = (typeof UserDataScalarFieldEnum)[keyof typeof UserDataScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    userName: 'userName',
    firstName: 'firstName',
    lastName: 'lastName',
    dateJoined: 'dateJoined',
    email: 'email',
    password: 'password'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type GroupsWhereInput = {
    AND?: Enumerable<GroupsWhereInput>
    OR?: Enumerable<GroupsWhereInput>
    NOT?: Enumerable<GroupsWhereInput>
    id?: IntFilter | number
    groupName?: StringFilter | string
    dateCreated?: DateTimeFilter | Date | string
    groupIngredient?: GroupIngredientListRelationFilter
    GroupMod?: GroupModListRelationFilter
    GroupSpec?: GroupSpecListRelationFilter
    GroupUser?: GroupUserListRelationFilter
  }

  export type GroupsOrderByWithRelationInput = {
    id?: SortOrder
    groupName?: SortOrder
    dateCreated?: SortOrder
    groupIngredient?: GroupIngredientOrderByRelationAggregateInput
    GroupMod?: GroupModOrderByRelationAggregateInput
    GroupSpec?: GroupSpecOrderByRelationAggregateInput
    GroupUser?: GroupUserOrderByRelationAggregateInput
  }

  export type GroupsWhereUniqueInput = {
    id?: number
  }

  export type GroupsOrderByWithAggregationInput = {
    id?: SortOrder
    groupName?: SortOrder
    dateCreated?: SortOrder
    _count?: GroupsCountOrderByAggregateInput
    _avg?: GroupsAvgOrderByAggregateInput
    _max?: GroupsMaxOrderByAggregateInput
    _min?: GroupsMinOrderByAggregateInput
    _sum?: GroupsSumOrderByAggregateInput
  }

  export type GroupsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GroupsScalarWhereWithAggregatesInput>
    OR?: Enumerable<GroupsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GroupsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    groupName?: StringWithAggregatesFilter | string
    dateCreated?: DateTimeWithAggregatesFilter | Date | string
  }

  export type GroupIngredientWhereInput = {
    AND?: Enumerable<GroupIngredientWhereInput>
    OR?: Enumerable<GroupIngredientWhereInput>
    NOT?: Enumerable<GroupIngredientWhereInput>
    groupId?: IntFilter | number
    ingredientId?: IntFilter | number
    groups?: XOR<GroupsRelationFilter, GroupsWhereInput>
    ingredient?: XOR<IngredientRelationFilter, IngredientWhereInput>
  }

  export type GroupIngredientOrderByWithRelationInput = {
    groupId?: SortOrder
    ingredientId?: SortOrder
    groups?: GroupsOrderByWithRelationInput
    ingredient?: IngredientOrderByWithRelationInput
  }

  export type GroupIngredientWhereUniqueInput = {
    groupId_ingredientId?: GroupIngredientGroupIdIngredientIdCompoundUniqueInput
  }

  export type GroupIngredientOrderByWithAggregationInput = {
    groupId?: SortOrder
    ingredientId?: SortOrder
    _count?: GroupIngredientCountOrderByAggregateInput
    _avg?: GroupIngredientAvgOrderByAggregateInput
    _max?: GroupIngredientMaxOrderByAggregateInput
    _min?: GroupIngredientMinOrderByAggregateInput
    _sum?: GroupIngredientSumOrderByAggregateInput
  }

  export type GroupIngredientScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GroupIngredientScalarWhereWithAggregatesInput>
    OR?: Enumerable<GroupIngredientScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GroupIngredientScalarWhereWithAggregatesInput>
    groupId?: IntWithAggregatesFilter | number
    ingredientId?: IntWithAggregatesFilter | number
  }

  export type GroupModWhereInput = {
    AND?: Enumerable<GroupModWhereInput>
    OR?: Enumerable<GroupModWhereInput>
    NOT?: Enumerable<GroupModWhereInput>
    userId?: StringFilter | string
    groupId?: IntFilter | number
    groups?: XOR<GroupsRelationFilter, GroupsWhereInput>
    users?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type GroupModOrderByWithRelationInput = {
    userId?: SortOrder
    groupId?: SortOrder
    groups?: GroupsOrderByWithRelationInput
    users?: UserOrderByWithRelationInput
  }

  export type GroupModWhereUniqueInput = {
    userId_groupId?: GroupModUserIdGroupIdCompoundUniqueInput
  }

  export type GroupModOrderByWithAggregationInput = {
    userId?: SortOrder
    groupId?: SortOrder
    _count?: GroupModCountOrderByAggregateInput
    _avg?: GroupModAvgOrderByAggregateInput
    _max?: GroupModMaxOrderByAggregateInput
    _min?: GroupModMinOrderByAggregateInput
    _sum?: GroupModSumOrderByAggregateInput
  }

  export type GroupModScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GroupModScalarWhereWithAggregatesInput>
    OR?: Enumerable<GroupModScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GroupModScalarWhereWithAggregatesInput>
    userId?: StringWithAggregatesFilter | string
    groupId?: IntWithAggregatesFilter | number
  }

  export type GroupSpecWhereInput = {
    AND?: Enumerable<GroupSpecWhereInput>
    OR?: Enumerable<GroupSpecWhereInput>
    NOT?: Enumerable<GroupSpecWhereInput>
    groupId?: IntFilter | number
    specId?: IntFilter | number
    groups?: XOR<GroupsRelationFilter, GroupsWhereInput>
    spec?: XOR<SpecRelationFilter, SpecWhereInput>
  }

  export type GroupSpecOrderByWithRelationInput = {
    groupId?: SortOrder
    specId?: SortOrder
    groups?: GroupsOrderByWithRelationInput
    spec?: SpecOrderByWithRelationInput
  }

  export type GroupSpecWhereUniqueInput = {
    groupId_specId?: GroupSpecGroupIdSpecIdCompoundUniqueInput
  }

  export type GroupSpecOrderByWithAggregationInput = {
    groupId?: SortOrder
    specId?: SortOrder
    _count?: GroupSpecCountOrderByAggregateInput
    _avg?: GroupSpecAvgOrderByAggregateInput
    _max?: GroupSpecMaxOrderByAggregateInput
    _min?: GroupSpecMinOrderByAggregateInput
    _sum?: GroupSpecSumOrderByAggregateInput
  }

  export type GroupSpecScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GroupSpecScalarWhereWithAggregatesInput>
    OR?: Enumerable<GroupSpecScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GroupSpecScalarWhereWithAggregatesInput>
    groupId?: IntWithAggregatesFilter | number
    specId?: IntWithAggregatesFilter | number
  }

  export type GroupUserWhereInput = {
    AND?: Enumerable<GroupUserWhereInput>
    OR?: Enumerable<GroupUserWhereInput>
    NOT?: Enumerable<GroupUserWhereInput>
    userId?: StringFilter | string
    groupId?: IntFilter | number
    groups?: XOR<GroupsRelationFilter, GroupsWhereInput>
    users?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type GroupUserOrderByWithRelationInput = {
    userId?: SortOrder
    groupId?: SortOrder
    groups?: GroupsOrderByWithRelationInput
    users?: UserOrderByWithRelationInput
  }

  export type GroupUserWhereUniqueInput = {
    userId_groupId?: GroupUserUserIdGroupIdCompoundUniqueInput
  }

  export type GroupUserOrderByWithAggregationInput = {
    userId?: SortOrder
    groupId?: SortOrder
    _count?: GroupUserCountOrderByAggregateInput
    _avg?: GroupUserAvgOrderByAggregateInput
    _max?: GroupUserMaxOrderByAggregateInput
    _min?: GroupUserMinOrderByAggregateInput
    _sum?: GroupUserSumOrderByAggregateInput
  }

  export type GroupUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GroupUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<GroupUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GroupUserScalarWhereWithAggregatesInput>
    userId?: StringWithAggregatesFilter | string
    groupId?: IntWithAggregatesFilter | number
  }

  export type IngredientWhereInput = {
    AND?: Enumerable<IngredientWhereInput>
    OR?: Enumerable<IngredientWhereInput>
    NOT?: Enumerable<IngredientWhereInput>
    id?: IntFilter | number
    dateCreated?: DateTimeFilter | Date | string
    name?: StringFilter | string
    amount?: IntNullableFilter | number | null
    unit?: StringNullableFilter | string | null
    price?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    source?: StringNullableFilter | string | null
    postedBy?: XOR<UserRelationFilter, UserWhereInput> | null
    postedById?: StringFilter | string
    groupIngredient?: GroupIngredientListRelationFilter
    touch?: TouchListRelationFilter
    sharedIngredient?: SharedIngredientListRelationFilter
  }

  export type IngredientOrderByWithRelationInput = {
    id?: SortOrder
    dateCreated?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    price?: SortOrder
    source?: SortOrder
    postedBy?: UserOrderByWithRelationInput
    postedById?: SortOrder
    groupIngredient?: GroupIngredientOrderByRelationAggregateInput
    touch?: TouchOrderByRelationAggregateInput
    sharedIngredient?: SharedIngredientOrderByRelationAggregateInput
  }

  export type IngredientWhereUniqueInput = {
    id?: number
  }

  export type IngredientOrderByWithAggregationInput = {
    id?: SortOrder
    dateCreated?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    price?: SortOrder
    source?: SortOrder
    postedById?: SortOrder
    _count?: IngredientCountOrderByAggregateInput
    _avg?: IngredientAvgOrderByAggregateInput
    _max?: IngredientMaxOrderByAggregateInput
    _min?: IngredientMinOrderByAggregateInput
    _sum?: IngredientSumOrderByAggregateInput
  }

  export type IngredientScalarWhereWithAggregatesInput = {
    AND?: Enumerable<IngredientScalarWhereWithAggregatesInput>
    OR?: Enumerable<IngredientScalarWhereWithAggregatesInput>
    NOT?: Enumerable<IngredientScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    dateCreated?: DateTimeWithAggregatesFilter | Date | string
    name?: StringWithAggregatesFilter | string
    amount?: IntNullableWithAggregatesFilter | number | null
    unit?: StringNullableWithAggregatesFilter | string | null
    price?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    source?: StringNullableWithAggregatesFilter | string | null
    postedById?: StringWithAggregatesFilter | string
  }

  export type TouchWhereInput = {
    AND?: Enumerable<TouchWhereInput>
    OR?: Enumerable<TouchWhereInput>
    NOT?: Enumerable<TouchWhereInput>
    id?: IntFilter | number
    ingredientId?: IntNullableFilter | number | null
    order?: IntNullableFilter | number | null
    amount?: FloatNullableFilter | number | null
    unit?: StringNullableFilter | string | null
    ingredient?: XOR<IngredientRelationFilter, IngredientWhereInput> | null
    spec?: XOR<SpecRelationFilter, SpecWhereInput> | null
    specId?: IntNullableFilter | number | null
    postedBy?: XOR<UserRelationFilter, UserWhereInput> | null
    postedById?: StringFilter | string
  }

  export type TouchOrderByWithRelationInput = {
    id?: SortOrder
    ingredientId?: SortOrder
    order?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    ingredient?: IngredientOrderByWithRelationInput
    spec?: SpecOrderByWithRelationInput
    specId?: SortOrder
    postedBy?: UserOrderByWithRelationInput
    postedById?: SortOrder
  }

  export type TouchWhereUniqueInput = {
    id?: number
  }

  export type TouchOrderByWithAggregationInput = {
    id?: SortOrder
    ingredientId?: SortOrder
    order?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    specId?: SortOrder
    postedById?: SortOrder
    _count?: TouchCountOrderByAggregateInput
    _avg?: TouchAvgOrderByAggregateInput
    _max?: TouchMaxOrderByAggregateInput
    _min?: TouchMinOrderByAggregateInput
    _sum?: TouchSumOrderByAggregateInput
  }

  export type TouchScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TouchScalarWhereWithAggregatesInput>
    OR?: Enumerable<TouchScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TouchScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    ingredientId?: IntNullableWithAggregatesFilter | number | null
    order?: IntNullableWithAggregatesFilter | number | null
    amount?: FloatNullableWithAggregatesFilter | number | null
    unit?: StringNullableWithAggregatesFilter | string | null
    specId?: IntNullableWithAggregatesFilter | number | null
    postedById?: StringWithAggregatesFilter | string
  }

  export type RecipeWhereInput = {
    AND?: Enumerable<RecipeWhereInput>
    OR?: Enumerable<RecipeWhereInput>
    NOT?: Enumerable<RecipeWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    name?: StringFilter | string
    origin?: StringFilter | string
    history?: StringNullableFilter | string | null
    postedBy?: XOR<UserRelationFilter, UserWhereInput> | null
    postedById?: StringFilter | string
    spec?: SpecListRelationFilter
  }

  export type RecipeOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    origin?: SortOrder
    history?: SortOrder
    postedBy?: UserOrderByWithRelationInput
    postedById?: SortOrder
    spec?: SpecOrderByRelationAggregateInput
  }

  export type RecipeWhereUniqueInput = {
    id?: number
  }

  export type RecipeOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    origin?: SortOrder
    history?: SortOrder
    postedById?: SortOrder
    _count?: RecipeCountOrderByAggregateInput
    _avg?: RecipeAvgOrderByAggregateInput
    _max?: RecipeMaxOrderByAggregateInput
    _min?: RecipeMinOrderByAggregateInput
    _sum?: RecipeSumOrderByAggregateInput
  }

  export type RecipeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RecipeScalarWhereWithAggregatesInput>
    OR?: Enumerable<RecipeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RecipeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    name?: StringWithAggregatesFilter | string
    origin?: StringWithAggregatesFilter | string
    history?: StringNullableWithAggregatesFilter | string | null
    postedById?: StringWithAggregatesFilter | string
  }

  export type SpecWhereInput = {
    AND?: Enumerable<SpecWhereInput>
    OR?: Enumerable<SpecWhereInput>
    NOT?: Enumerable<SpecWhereInput>
    id?: IntFilter | number
    specName?: StringFilter | string
    postedBy?: XOR<UserRelationFilter, UserWhereInput> | null
    postedById?: StringFilter | string
    instructions?: StringNullableFilter | string | null
    glassware?: StringNullableFilter | string | null
    ice?: StringNullableFilter | string | null
    groupSpec?: GroupSpecListRelationFilter
    sharedSpec?: SharedSpecListRelationFilter
    recipe?: XOR<RecipeRelationFilter, RecipeWhereInput> | null
    recipeId?: IntNullableFilter | number | null
    touch?: TouchListRelationFilter
    adminOnSpec?: AdminOnSpecListRelationFilter
  }

  export type SpecOrderByWithRelationInput = {
    id?: SortOrder
    specName?: SortOrder
    postedBy?: UserOrderByWithRelationInput
    postedById?: SortOrder
    instructions?: SortOrder
    glassware?: SortOrder
    ice?: SortOrder
    groupSpec?: GroupSpecOrderByRelationAggregateInput
    sharedSpec?: SharedSpecOrderByRelationAggregateInput
    recipe?: RecipeOrderByWithRelationInput
    recipeId?: SortOrder
    touch?: TouchOrderByRelationAggregateInput
    adminOnSpec?: AdminOnSpecOrderByRelationAggregateInput
  }

  export type SpecWhereUniqueInput = {
    id?: number
  }

  export type SpecOrderByWithAggregationInput = {
    id?: SortOrder
    specName?: SortOrder
    postedById?: SortOrder
    instructions?: SortOrder
    glassware?: SortOrder
    ice?: SortOrder
    recipeId?: SortOrder
    _count?: SpecCountOrderByAggregateInput
    _avg?: SpecAvgOrderByAggregateInput
    _max?: SpecMaxOrderByAggregateInput
    _min?: SpecMinOrderByAggregateInput
    _sum?: SpecSumOrderByAggregateInput
  }

  export type SpecScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SpecScalarWhereWithAggregatesInput>
    OR?: Enumerable<SpecScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SpecScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    specName?: StringWithAggregatesFilter | string
    postedById?: StringWithAggregatesFilter | string
    instructions?: StringNullableWithAggregatesFilter | string | null
    glassware?: StringNullableWithAggregatesFilter | string | null
    ice?: StringNullableWithAggregatesFilter | string | null
    recipeId?: IntNullableWithAggregatesFilter | number | null
  }

  export type UserDataWhereInput = {
    AND?: Enumerable<UserDataWhereInput>
    OR?: Enumerable<UserDataWhereInput>
    NOT?: Enumerable<UserDataWhereInput>
    id?: IntFilter | number
    userId?: StringNullableFilter | string | null
    userBio?: StringNullableFilter | string | null
    workPlace?: StringNullableFilter | string | null
    profilePicture?: StringNullableFilter | string | null
    users?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type UserDataOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    userBio?: SortOrder
    workPlace?: SortOrder
    profilePicture?: SortOrder
    users?: UserOrderByWithRelationInput
  }

  export type UserDataWhereUniqueInput = {
    id?: number
  }

  export type UserDataOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    userBio?: SortOrder
    workPlace?: SortOrder
    profilePicture?: SortOrder
    _count?: UserDataCountOrderByAggregateInput
    _avg?: UserDataAvgOrderByAggregateInput
    _max?: UserDataMaxOrderByAggregateInput
    _min?: UserDataMinOrderByAggregateInput
    _sum?: UserDataSumOrderByAggregateInput
  }

  export type UserDataScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserDataScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserDataScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserDataScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: StringNullableWithAggregatesFilter | string | null
    userBio?: StringNullableWithAggregatesFilter | string | null
    workPlace?: StringNullableWithAggregatesFilter | string | null
    profilePicture?: StringNullableWithAggregatesFilter | string | null
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    userName?: StringFilter | string
    firstName?: StringNullableFilter | string | null
    lastName?: StringNullableFilter | string | null
    dateJoined?: DateTimeFilter | Date | string
    email?: StringFilter | string
    password?: StringFilter | string
    groupMod?: GroupModListRelationFilter
    groupUser?: GroupUserListRelationFilter
    userData?: UserDataListRelationFilter
    sharedIngredient?: SharedIngredientListRelationFilter
    ingredientSharedBy?: SharedIngredientListRelationFilter
    sharedSpec?: SharedSpecListRelationFilter
    specSharedBy?: SharedSpecListRelationFilter
    recipes?: RecipeListRelationFilter
    spec?: SpecListRelationFilter
    ingredient?: IngredientListRelationFilter
    touch?: TouchListRelationFilter
    adminOnSpec?: AdminOnSpecListRelationFilter
    adminAssignedBy?: AdminOnSpecListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    userName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateJoined?: SortOrder
    email?: SortOrder
    password?: SortOrder
    groupMod?: GroupModOrderByRelationAggregateInput
    groupUser?: GroupUserOrderByRelationAggregateInput
    userData?: UserDataOrderByRelationAggregateInput
    sharedIngredient?: SharedIngredientOrderByRelationAggregateInput
    ingredientSharedBy?: SharedIngredientOrderByRelationAggregateInput
    sharedSpec?: SharedSpecOrderByRelationAggregateInput
    specSharedBy?: SharedSpecOrderByRelationAggregateInput
    recipes?: RecipeOrderByRelationAggregateInput
    spec?: SpecOrderByRelationAggregateInput
    ingredient?: IngredientOrderByRelationAggregateInput
    touch?: TouchOrderByRelationAggregateInput
    adminOnSpec?: AdminOnSpecOrderByRelationAggregateInput
    adminAssignedBy?: AdminOnSpecOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    userName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateJoined?: SortOrder
    email?: SortOrder
    password?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userName?: StringWithAggregatesFilter | string
    firstName?: StringNullableWithAggregatesFilter | string | null
    lastName?: StringNullableWithAggregatesFilter | string | null
    dateJoined?: DateTimeWithAggregatesFilter | Date | string
    email?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
  }

  export type SharedIngredientWhereInput = {
    AND?: Enumerable<SharedIngredientWhereInput>
    OR?: Enumerable<SharedIngredientWhereInput>
    NOT?: Enumerable<SharedIngredientWhereInput>
    userId?: StringFilter | string
    ingredientId?: IntFilter | number
    sharedById?: StringFilter | string
    sharedAt?: DateTimeFilter | Date | string
    ingredient?: XOR<IngredientRelationFilter, IngredientWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    sharedBy?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SharedIngredientOrderByWithRelationInput = {
    userId?: SortOrder
    ingredientId?: SortOrder
    sharedById?: SortOrder
    sharedAt?: SortOrder
    ingredient?: IngredientOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    sharedBy?: UserOrderByWithRelationInput
  }

  export type SharedIngredientWhereUniqueInput = {
    userId_ingredientId?: SharedIngredientUserIdIngredientIdCompoundUniqueInput
  }

  export type SharedIngredientOrderByWithAggregationInput = {
    userId?: SortOrder
    ingredientId?: SortOrder
    sharedById?: SortOrder
    sharedAt?: SortOrder
    _count?: SharedIngredientCountOrderByAggregateInput
    _avg?: SharedIngredientAvgOrderByAggregateInput
    _max?: SharedIngredientMaxOrderByAggregateInput
    _min?: SharedIngredientMinOrderByAggregateInput
    _sum?: SharedIngredientSumOrderByAggregateInput
  }

  export type SharedIngredientScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SharedIngredientScalarWhereWithAggregatesInput>
    OR?: Enumerable<SharedIngredientScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SharedIngredientScalarWhereWithAggregatesInput>
    userId?: StringWithAggregatesFilter | string
    ingredientId?: IntWithAggregatesFilter | number
    sharedById?: StringWithAggregatesFilter | string
    sharedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SharedSpecWhereInput = {
    AND?: Enumerable<SharedSpecWhereInput>
    OR?: Enumerable<SharedSpecWhereInput>
    NOT?: Enumerable<SharedSpecWhereInput>
    userId?: StringFilter | string
    specId?: IntFilter | number
    sharedById?: StringFilter | string
    sharedAt?: DateTimeFilter | Date | string
    spec?: XOR<SpecRelationFilter, SpecWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    sharedBy?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SharedSpecOrderByWithRelationInput = {
    userId?: SortOrder
    specId?: SortOrder
    sharedById?: SortOrder
    sharedAt?: SortOrder
    spec?: SpecOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    sharedBy?: UserOrderByWithRelationInput
  }

  export type SharedSpecWhereUniqueInput = {
    userId_specId?: SharedSpecUserIdSpecIdCompoundUniqueInput
  }

  export type SharedSpecOrderByWithAggregationInput = {
    userId?: SortOrder
    specId?: SortOrder
    sharedById?: SortOrder
    sharedAt?: SortOrder
    _count?: SharedSpecCountOrderByAggregateInput
    _avg?: SharedSpecAvgOrderByAggregateInput
    _max?: SharedSpecMaxOrderByAggregateInput
    _min?: SharedSpecMinOrderByAggregateInput
    _sum?: SharedSpecSumOrderByAggregateInput
  }

  export type SharedSpecScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SharedSpecScalarWhereWithAggregatesInput>
    OR?: Enumerable<SharedSpecScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SharedSpecScalarWhereWithAggregatesInput>
    userId?: StringWithAggregatesFilter | string
    specId?: IntWithAggregatesFilter | number
    sharedById?: StringWithAggregatesFilter | string
    sharedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AdminOnSpecWhereInput = {
    AND?: Enumerable<AdminOnSpecWhereInput>
    OR?: Enumerable<AdminOnSpecWhereInput>
    NOT?: Enumerable<AdminOnSpecWhereInput>
    userId?: StringFilter | string
    specId?: IntFilter | number
    assignedById?: StringFilter | string
    assignedAt?: DateTimeFilter | Date | string
    spec?: XOR<SpecRelationFilter, SpecWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    assignedBy?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AdminOnSpecOrderByWithRelationInput = {
    userId?: SortOrder
    specId?: SortOrder
    assignedById?: SortOrder
    assignedAt?: SortOrder
    spec?: SpecOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    assignedBy?: UserOrderByWithRelationInput
  }

  export type AdminOnSpecWhereUniqueInput = {
    userId_specId?: AdminOnSpecUserIdSpecIdCompoundUniqueInput
  }

  export type AdminOnSpecOrderByWithAggregationInput = {
    userId?: SortOrder
    specId?: SortOrder
    assignedById?: SortOrder
    assignedAt?: SortOrder
    _count?: AdminOnSpecCountOrderByAggregateInput
    _avg?: AdminOnSpecAvgOrderByAggregateInput
    _max?: AdminOnSpecMaxOrderByAggregateInput
    _min?: AdminOnSpecMinOrderByAggregateInput
    _sum?: AdminOnSpecSumOrderByAggregateInput
  }

  export type AdminOnSpecScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AdminOnSpecScalarWhereWithAggregatesInput>
    OR?: Enumerable<AdminOnSpecScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AdminOnSpecScalarWhereWithAggregatesInput>
    userId?: StringWithAggregatesFilter | string
    specId?: IntWithAggregatesFilter | number
    assignedById?: StringWithAggregatesFilter | string
    assignedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type GroupsCreateInput = {
    groupName: string
    dateCreated: Date | string
    groupIngredient?: GroupIngredientCreateNestedManyWithoutGroupsInput
    GroupMod?: GroupModCreateNestedManyWithoutGroupsInput
    GroupSpec?: GroupSpecCreateNestedManyWithoutGroupsInput
    GroupUser?: GroupUserCreateNestedManyWithoutGroupsInput
  }

  export type GroupsUncheckedCreateInput = {
    id?: number
    groupName: string
    dateCreated: Date | string
    groupIngredient?: GroupIngredientUncheckedCreateNestedManyWithoutGroupsInput
    GroupMod?: GroupModUncheckedCreateNestedManyWithoutGroupsInput
    GroupSpec?: GroupSpecUncheckedCreateNestedManyWithoutGroupsInput
    GroupUser?: GroupUserUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type GroupsUpdateInput = {
    groupName?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    groupIngredient?: GroupIngredientUpdateManyWithoutGroupsNestedInput
    GroupMod?: GroupModUpdateManyWithoutGroupsNestedInput
    GroupSpec?: GroupSpecUpdateManyWithoutGroupsNestedInput
    GroupUser?: GroupUserUpdateManyWithoutGroupsNestedInput
  }

  export type GroupsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupName?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    groupIngredient?: GroupIngredientUncheckedUpdateManyWithoutGroupsNestedInput
    GroupMod?: GroupModUncheckedUpdateManyWithoutGroupsNestedInput
    GroupSpec?: GroupSpecUncheckedUpdateManyWithoutGroupsNestedInput
    GroupUser?: GroupUserUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type GroupsCreateManyInput = {
    id?: number
    groupName: string
    dateCreated: Date | string
  }

  export type GroupsUpdateManyMutationInput = {
    groupName?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupName?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupIngredientCreateInput = {
    groups: GroupsCreateNestedOneWithoutGroupIngredientInput
    ingredient: IngredientCreateNestedOneWithoutGroupIngredientInput
  }

  export type GroupIngredientUncheckedCreateInput = {
    groupId: number
    ingredientId: number
  }

  export type GroupIngredientUpdateInput = {
    groups?: GroupsUpdateOneRequiredWithoutGroupIngredientNestedInput
    ingredient?: IngredientUpdateOneRequiredWithoutGroupIngredientNestedInput
  }

  export type GroupIngredientUncheckedUpdateInput = {
    groupId?: IntFieldUpdateOperationsInput | number
    ingredientId?: IntFieldUpdateOperationsInput | number
  }

  export type GroupIngredientCreateManyInput = {
    groupId: number
    ingredientId: number
  }

  export type GroupIngredientUpdateManyMutationInput = {

  }

  export type GroupIngredientUncheckedUpdateManyInput = {
    groupId?: IntFieldUpdateOperationsInput | number
    ingredientId?: IntFieldUpdateOperationsInput | number
  }

  export type GroupModCreateInput = {
    groups: GroupsCreateNestedOneWithoutGroupModInput
    users: UserCreateNestedOneWithoutGroupModInput
  }

  export type GroupModUncheckedCreateInput = {
    userId: string
    groupId: number
  }

  export type GroupModUpdateInput = {
    groups?: GroupsUpdateOneRequiredWithoutGroupModNestedInput
    users?: UserUpdateOneRequiredWithoutGroupModNestedInput
  }

  export type GroupModUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    groupId?: IntFieldUpdateOperationsInput | number
  }

  export type GroupModCreateManyInput = {
    userId: string
    groupId: number
  }

  export type GroupModUpdateManyMutationInput = {

  }

  export type GroupModUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    groupId?: IntFieldUpdateOperationsInput | number
  }

  export type GroupSpecCreateInput = {
    groups: GroupsCreateNestedOneWithoutGroupSpecInput
    spec: SpecCreateNestedOneWithoutGroupSpecInput
  }

  export type GroupSpecUncheckedCreateInput = {
    groupId: number
    specId: number
  }

  export type GroupSpecUpdateInput = {
    groups?: GroupsUpdateOneRequiredWithoutGroupSpecNestedInput
    spec?: SpecUpdateOneRequiredWithoutGroupSpecNestedInput
  }

  export type GroupSpecUncheckedUpdateInput = {
    groupId?: IntFieldUpdateOperationsInput | number
    specId?: IntFieldUpdateOperationsInput | number
  }

  export type GroupSpecCreateManyInput = {
    groupId: number
    specId: number
  }

  export type GroupSpecUpdateManyMutationInput = {

  }

  export type GroupSpecUncheckedUpdateManyInput = {
    groupId?: IntFieldUpdateOperationsInput | number
    specId?: IntFieldUpdateOperationsInput | number
  }

  export type GroupUserCreateInput = {
    groups: GroupsCreateNestedOneWithoutGroupUserInput
    users: UserCreateNestedOneWithoutGroupUserInput
  }

  export type GroupUserUncheckedCreateInput = {
    userId: string
    groupId: number
  }

  export type GroupUserUpdateInput = {
    groups?: GroupsUpdateOneRequiredWithoutGroupUserNestedInput
    users?: UserUpdateOneRequiredWithoutGroupUserNestedInput
  }

  export type GroupUserUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    groupId?: IntFieldUpdateOperationsInput | number
  }

  export type GroupUserCreateManyInput = {
    userId: string
    groupId: number
  }

  export type GroupUserUpdateManyMutationInput = {

  }

  export type GroupUserUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    groupId?: IntFieldUpdateOperationsInput | number
  }

  export type IngredientCreateInput = {
    dateCreated?: Date | string
    name: string
    amount?: number | null
    unit?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    source?: string | null
    postedBy?: UserCreateNestedOneWithoutIngredientInput
    groupIngredient?: GroupIngredientCreateNestedManyWithoutIngredientInput
    touch?: TouchCreateNestedManyWithoutIngredientInput
    sharedIngredient?: SharedIngredientCreateNestedManyWithoutIngredientInput
  }

  export type IngredientUncheckedCreateInput = {
    id?: number
    dateCreated?: Date | string
    name: string
    amount?: number | null
    unit?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    source?: string | null
    postedById: string
    groupIngredient?: GroupIngredientUncheckedCreateNestedManyWithoutIngredientInput
    touch?: TouchUncheckedCreateNestedManyWithoutIngredientInput
    sharedIngredient?: SharedIngredientUncheckedCreateNestedManyWithoutIngredientInput
  }

  export type IngredientUpdateInput = {
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    postedBy?: UserUpdateOneWithoutIngredientNestedInput
    groupIngredient?: GroupIngredientUpdateManyWithoutIngredientNestedInput
    touch?: TouchUpdateManyWithoutIngredientNestedInput
    sharedIngredient?: SharedIngredientUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    postedById?: StringFieldUpdateOperationsInput | string
    groupIngredient?: GroupIngredientUncheckedUpdateManyWithoutIngredientNestedInput
    touch?: TouchUncheckedUpdateManyWithoutIngredientNestedInput
    sharedIngredient?: SharedIngredientUncheckedUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientCreateManyInput = {
    id?: number
    dateCreated?: Date | string
    name: string
    amount?: number | null
    unit?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    source?: string | null
    postedById: string
  }

  export type IngredientUpdateManyMutationInput = {
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IngredientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    postedById?: StringFieldUpdateOperationsInput | string
  }

  export type TouchCreateInput = {
    order?: number | null
    amount?: number | null
    unit?: string | null
    ingredient?: IngredientCreateNestedOneWithoutTouchInput
    spec?: SpecCreateNestedOneWithoutTouchInput
    postedBy?: UserCreateNestedOneWithoutTouchInput
  }

  export type TouchUncheckedCreateInput = {
    id?: number
    ingredientId?: number | null
    order?: number | null
    amount?: number | null
    unit?: string | null
    specId?: number | null
    postedById: string
  }

  export type TouchUpdateInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    ingredient?: IngredientUpdateOneWithoutTouchNestedInput
    spec?: SpecUpdateOneWithoutTouchNestedInput
    postedBy?: UserUpdateOneWithoutTouchNestedInput
  }

  export type TouchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ingredientId?: NullableIntFieldUpdateOperationsInput | number | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    specId?: NullableIntFieldUpdateOperationsInput | number | null
    postedById?: StringFieldUpdateOperationsInput | string
  }

  export type TouchCreateManyInput = {
    id?: number
    ingredientId?: number | null
    order?: number | null
    amount?: number | null
    unit?: string | null
    specId?: number | null
    postedById: string
  }

  export type TouchUpdateManyMutationInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TouchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ingredientId?: NullableIntFieldUpdateOperationsInput | number | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    specId?: NullableIntFieldUpdateOperationsInput | number | null
    postedById?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeCreateInput = {
    createdAt?: Date | string
    name: string
    origin: string
    history?: string | null
    postedBy?: UserCreateNestedOneWithoutRecipesInput
    spec?: SpecCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    name: string
    origin: string
    history?: string | null
    postedById: string
    spec?: SpecUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    history?: NullableStringFieldUpdateOperationsInput | string | null
    postedBy?: UserUpdateOneWithoutRecipesNestedInput
    spec?: SpecUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    history?: NullableStringFieldUpdateOperationsInput | string | null
    postedById?: StringFieldUpdateOperationsInput | string
    spec?: SpecUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeCreateManyInput = {
    id?: number
    createdAt?: Date | string
    name: string
    origin: string
    history?: string | null
    postedById: string
  }

  export type RecipeUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    history?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    history?: NullableStringFieldUpdateOperationsInput | string | null
    postedById?: StringFieldUpdateOperationsInput | string
  }

  export type SpecCreateInput = {
    specName?: string
    postedBy?: UserCreateNestedOneWithoutSpecInput
    instructions?: string | null
    glassware?: string | null
    ice?: string | null
    groupSpec?: GroupSpecCreateNestedManyWithoutSpecInput
    sharedSpec?: SharedSpecCreateNestedManyWithoutSpecInput
    recipe?: RecipeCreateNestedOneWithoutSpecInput
    touch?: TouchCreateNestedManyWithoutSpecInput
    adminOnSpec?: AdminOnSpecCreateNestedManyWithoutSpecInput
  }

  export type SpecUncheckedCreateInput = {
    id?: number
    specName?: string
    postedById: string
    instructions?: string | null
    glassware?: string | null
    ice?: string | null
    groupSpec?: GroupSpecUncheckedCreateNestedManyWithoutSpecInput
    sharedSpec?: SharedSpecUncheckedCreateNestedManyWithoutSpecInput
    recipeId?: number | null
    touch?: TouchUncheckedCreateNestedManyWithoutSpecInput
    adminOnSpec?: AdminOnSpecUncheckedCreateNestedManyWithoutSpecInput
  }

  export type SpecUpdateInput = {
    specName?: StringFieldUpdateOperationsInput | string
    postedBy?: UserUpdateOneWithoutSpecNestedInput
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    groupSpec?: GroupSpecUpdateManyWithoutSpecNestedInput
    sharedSpec?: SharedSpecUpdateManyWithoutSpecNestedInput
    recipe?: RecipeUpdateOneWithoutSpecNestedInput
    touch?: TouchUpdateManyWithoutSpecNestedInput
    adminOnSpec?: AdminOnSpecUpdateManyWithoutSpecNestedInput
  }

  export type SpecUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    specName?: StringFieldUpdateOperationsInput | string
    postedById?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    groupSpec?: GroupSpecUncheckedUpdateManyWithoutSpecNestedInput
    sharedSpec?: SharedSpecUncheckedUpdateManyWithoutSpecNestedInput
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
    touch?: TouchUncheckedUpdateManyWithoutSpecNestedInput
    adminOnSpec?: AdminOnSpecUncheckedUpdateManyWithoutSpecNestedInput
  }

  export type SpecCreateManyInput = {
    id?: number
    specName?: string
    postedById: string
    instructions?: string | null
    glassware?: string | null
    ice?: string | null
    recipeId?: number | null
  }

  export type SpecUpdateManyMutationInput = {
    specName?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpecUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    specName?: StringFieldUpdateOperationsInput | string
    postedById?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserDataCreateInput = {
    userBio?: string | null
    workPlace?: string | null
    profilePicture?: string | null
    users?: UserCreateNestedOneWithoutUserDataInput
  }

  export type UserDataUncheckedCreateInput = {
    id?: number
    userId?: string | null
    userBio?: string | null
    workPlace?: string | null
    profilePicture?: string | null
  }

  export type UserDataUpdateInput = {
    userBio?: NullableStringFieldUpdateOperationsInput | string | null
    workPlace?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUpdateOneWithoutUserDataNestedInput
  }

  export type UserDataUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userBio?: NullableStringFieldUpdateOperationsInput | string | null
    workPlace?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserDataCreateManyInput = {
    id?: number
    userId?: string | null
    userBio?: string | null
    workPlace?: string | null
    profilePicture?: string | null
  }

  export type UserDataUpdateManyMutationInput = {
    userBio?: NullableStringFieldUpdateOperationsInput | string | null
    workPlace?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserDataUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userBio?: NullableStringFieldUpdateOperationsInput | string | null
    workPlace?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    email: string
    password: string
    groupMod?: GroupModCreateNestedManyWithoutUsersInput
    groupUser?: GroupUserCreateNestedManyWithoutUsersInput
    userData?: UserDataCreateNestedManyWithoutUsersInput
    sharedIngredient?: SharedIngredientCreateNestedManyWithoutUserInput
    ingredientSharedBy?: SharedIngredientCreateNestedManyWithoutSharedByInput
    sharedSpec?: SharedSpecCreateNestedManyWithoutUserInput
    specSharedBy?: SharedSpecCreateNestedManyWithoutSharedByInput
    recipes?: RecipeCreateNestedManyWithoutPostedByInput
    spec?: SpecCreateNestedManyWithoutPostedByInput
    ingredient?: IngredientCreateNestedManyWithoutPostedByInput
    touch?: TouchCreateNestedManyWithoutPostedByInput
    adminOnSpec?: AdminOnSpecCreateNestedManyWithoutUserInput
    adminAssignedBy?: AdminOnSpecCreateNestedManyWithoutAssignedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    email: string
    password: string
    groupMod?: GroupModUncheckedCreateNestedManyWithoutUsersInput
    groupUser?: GroupUserUncheckedCreateNestedManyWithoutUsersInput
    userData?: UserDataUncheckedCreateNestedManyWithoutUsersInput
    sharedIngredient?: SharedIngredientUncheckedCreateNestedManyWithoutUserInput
    ingredientSharedBy?: SharedIngredientUncheckedCreateNestedManyWithoutSharedByInput
    sharedSpec?: SharedSpecUncheckedCreateNestedManyWithoutUserInput
    specSharedBy?: SharedSpecUncheckedCreateNestedManyWithoutSharedByInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutPostedByInput
    spec?: SpecUncheckedCreateNestedManyWithoutPostedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutPostedByInput
    touch?: TouchUncheckedCreateNestedManyWithoutPostedByInput
    adminOnSpec?: AdminOnSpecUncheckedCreateNestedManyWithoutUserInput
    adminAssignedBy?: AdminOnSpecUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    groupMod?: GroupModUpdateManyWithoutUsersNestedInput
    groupUser?: GroupUserUpdateManyWithoutUsersNestedInput
    userData?: UserDataUpdateManyWithoutUsersNestedInput
    sharedIngredient?: SharedIngredientUpdateManyWithoutUserNestedInput
    ingredientSharedBy?: SharedIngredientUpdateManyWithoutSharedByNestedInput
    sharedSpec?: SharedSpecUpdateManyWithoutUserNestedInput
    specSharedBy?: SharedSpecUpdateManyWithoutSharedByNestedInput
    recipes?: RecipeUpdateManyWithoutPostedByNestedInput
    spec?: SpecUpdateManyWithoutPostedByNestedInput
    ingredient?: IngredientUpdateManyWithoutPostedByNestedInput
    touch?: TouchUpdateManyWithoutPostedByNestedInput
    adminOnSpec?: AdminOnSpecUpdateManyWithoutUserNestedInput
    adminAssignedBy?: AdminOnSpecUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    groupMod?: GroupModUncheckedUpdateManyWithoutUsersNestedInput
    groupUser?: GroupUserUncheckedUpdateManyWithoutUsersNestedInput
    userData?: UserDataUncheckedUpdateManyWithoutUsersNestedInput
    sharedIngredient?: SharedIngredientUncheckedUpdateManyWithoutUserNestedInput
    ingredientSharedBy?: SharedIngredientUncheckedUpdateManyWithoutSharedByNestedInput
    sharedSpec?: SharedSpecUncheckedUpdateManyWithoutUserNestedInput
    specSharedBy?: SharedSpecUncheckedUpdateManyWithoutSharedByNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutPostedByNestedInput
    spec?: SpecUncheckedUpdateManyWithoutPostedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutPostedByNestedInput
    touch?: TouchUncheckedUpdateManyWithoutPostedByNestedInput
    adminOnSpec?: AdminOnSpecUncheckedUpdateManyWithoutUserNestedInput
    adminAssignedBy?: AdminOnSpecUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    email: string
    password: string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type SharedIngredientCreateInput = {
    sharedAt?: Date | string
    ingredient: IngredientCreateNestedOneWithoutSharedIngredientInput
    user: UserCreateNestedOneWithoutSharedIngredientInput
    sharedBy: UserCreateNestedOneWithoutIngredientSharedByInput
  }

  export type SharedIngredientUncheckedCreateInput = {
    userId: string
    ingredientId: number
    sharedById: string
    sharedAt?: Date | string
  }

  export type SharedIngredientUpdateInput = {
    sharedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ingredient?: IngredientUpdateOneRequiredWithoutSharedIngredientNestedInput
    user?: UserUpdateOneRequiredWithoutSharedIngredientNestedInput
    sharedBy?: UserUpdateOneRequiredWithoutIngredientSharedByNestedInput
  }

  export type SharedIngredientUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    ingredientId?: IntFieldUpdateOperationsInput | number
    sharedById?: StringFieldUpdateOperationsInput | string
    sharedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedIngredientCreateManyInput = {
    userId: string
    ingredientId: number
    sharedById: string
    sharedAt?: Date | string
  }

  export type SharedIngredientUpdateManyMutationInput = {
    sharedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedIngredientUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    ingredientId?: IntFieldUpdateOperationsInput | number
    sharedById?: StringFieldUpdateOperationsInput | string
    sharedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedSpecCreateInput = {
    sharedAt?: Date | string
    spec: SpecCreateNestedOneWithoutSharedSpecInput
    user: UserCreateNestedOneWithoutSharedSpecInput
    sharedBy: UserCreateNestedOneWithoutSpecSharedByInput
  }

  export type SharedSpecUncheckedCreateInput = {
    userId: string
    specId: number
    sharedById: string
    sharedAt?: Date | string
  }

  export type SharedSpecUpdateInput = {
    sharedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spec?: SpecUpdateOneRequiredWithoutSharedSpecNestedInput
    user?: UserUpdateOneRequiredWithoutSharedSpecNestedInput
    sharedBy?: UserUpdateOneRequiredWithoutSpecSharedByNestedInput
  }

  export type SharedSpecUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    specId?: IntFieldUpdateOperationsInput | number
    sharedById?: StringFieldUpdateOperationsInput | string
    sharedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedSpecCreateManyInput = {
    userId: string
    specId: number
    sharedById: string
    sharedAt?: Date | string
  }

  export type SharedSpecUpdateManyMutationInput = {
    sharedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedSpecUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    specId?: IntFieldUpdateOperationsInput | number
    sharedById?: StringFieldUpdateOperationsInput | string
    sharedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminOnSpecCreateInput = {
    assignedAt?: Date | string
    spec: SpecCreateNestedOneWithoutAdminOnSpecInput
    user: UserCreateNestedOneWithoutAdminOnSpecInput
    assignedBy: UserCreateNestedOneWithoutAdminAssignedByInput
  }

  export type AdminOnSpecUncheckedCreateInput = {
    userId: string
    specId: number
    assignedById: string
    assignedAt?: Date | string
  }

  export type AdminOnSpecUpdateInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spec?: SpecUpdateOneRequiredWithoutAdminOnSpecNestedInput
    user?: UserUpdateOneRequiredWithoutAdminOnSpecNestedInput
    assignedBy?: UserUpdateOneRequiredWithoutAdminAssignedByNestedInput
  }

  export type AdminOnSpecUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    specId?: IntFieldUpdateOperationsInput | number
    assignedById?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminOnSpecCreateManyInput = {
    userId: string
    specId: number
    assignedById: string
    assignedAt?: Date | string
  }

  export type AdminOnSpecUpdateManyMutationInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminOnSpecUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    specId?: IntFieldUpdateOperationsInput | number
    assignedById?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type GroupIngredientListRelationFilter = {
    every?: GroupIngredientWhereInput
    some?: GroupIngredientWhereInput
    none?: GroupIngredientWhereInput
  }

  export type GroupModListRelationFilter = {
    every?: GroupModWhereInput
    some?: GroupModWhereInput
    none?: GroupModWhereInput
  }

  export type GroupSpecListRelationFilter = {
    every?: GroupSpecWhereInput
    some?: GroupSpecWhereInput
    none?: GroupSpecWhereInput
  }

  export type GroupUserListRelationFilter = {
    every?: GroupUserWhereInput
    some?: GroupUserWhereInput
    none?: GroupUserWhereInput
  }

  export type GroupIngredientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupModOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupSpecOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupsCountOrderByAggregateInput = {
    id?: SortOrder
    groupName?: SortOrder
    dateCreated?: SortOrder
  }

  export type GroupsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GroupsMaxOrderByAggregateInput = {
    id?: SortOrder
    groupName?: SortOrder
    dateCreated?: SortOrder
  }

  export type GroupsMinOrderByAggregateInput = {
    id?: SortOrder
    groupName?: SortOrder
    dateCreated?: SortOrder
  }

  export type GroupsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type GroupsRelationFilter = {
    is?: GroupsWhereInput
    isNot?: GroupsWhereInput
  }

  export type IngredientRelationFilter = {
    is?: IngredientWhereInput | null
    isNot?: IngredientWhereInput | null
  }

  export type GroupIngredientGroupIdIngredientIdCompoundUniqueInput = {
    groupId: number
    ingredientId: number
  }

  export type GroupIngredientCountOrderByAggregateInput = {
    groupId?: SortOrder
    ingredientId?: SortOrder
  }

  export type GroupIngredientAvgOrderByAggregateInput = {
    groupId?: SortOrder
    ingredientId?: SortOrder
  }

  export type GroupIngredientMaxOrderByAggregateInput = {
    groupId?: SortOrder
    ingredientId?: SortOrder
  }

  export type GroupIngredientMinOrderByAggregateInput = {
    groupId?: SortOrder
    ingredientId?: SortOrder
  }

  export type GroupIngredientSumOrderByAggregateInput = {
    groupId?: SortOrder
    ingredientId?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type GroupModUserIdGroupIdCompoundUniqueInput = {
    userId: string
    groupId: number
  }

  export type GroupModCountOrderByAggregateInput = {
    userId?: SortOrder
    groupId?: SortOrder
  }

  export type GroupModAvgOrderByAggregateInput = {
    groupId?: SortOrder
  }

  export type GroupModMaxOrderByAggregateInput = {
    userId?: SortOrder
    groupId?: SortOrder
  }

  export type GroupModMinOrderByAggregateInput = {
    userId?: SortOrder
    groupId?: SortOrder
  }

  export type GroupModSumOrderByAggregateInput = {
    groupId?: SortOrder
  }

  export type SpecRelationFilter = {
    is?: SpecWhereInput
    isNot?: SpecWhereInput
  }

  export type GroupSpecGroupIdSpecIdCompoundUniqueInput = {
    groupId: number
    specId: number
  }

  export type GroupSpecCountOrderByAggregateInput = {
    groupId?: SortOrder
    specId?: SortOrder
  }

  export type GroupSpecAvgOrderByAggregateInput = {
    groupId?: SortOrder
    specId?: SortOrder
  }

  export type GroupSpecMaxOrderByAggregateInput = {
    groupId?: SortOrder
    specId?: SortOrder
  }

  export type GroupSpecMinOrderByAggregateInput = {
    groupId?: SortOrder
    specId?: SortOrder
  }

  export type GroupSpecSumOrderByAggregateInput = {
    groupId?: SortOrder
    specId?: SortOrder
  }

  export type GroupUserUserIdGroupIdCompoundUniqueInput = {
    userId: string
    groupId: number
  }

  export type GroupUserCountOrderByAggregateInput = {
    userId?: SortOrder
    groupId?: SortOrder
  }

  export type GroupUserAvgOrderByAggregateInput = {
    groupId?: SortOrder
  }

  export type GroupUserMaxOrderByAggregateInput = {
    userId?: SortOrder
    groupId?: SortOrder
  }

  export type GroupUserMinOrderByAggregateInput = {
    userId?: SortOrder
    groupId?: SortOrder
  }

  export type GroupUserSumOrderByAggregateInput = {
    groupId?: SortOrder
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type DecimalNullableFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type TouchListRelationFilter = {
    every?: TouchWhereInput
    some?: TouchWhereInput
    none?: TouchWhereInput
  }

  export type SharedIngredientListRelationFilter = {
    every?: SharedIngredientWhereInput
    some?: SharedIngredientWhereInput
    none?: SharedIngredientWhereInput
  }

  export type TouchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SharedIngredientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IngredientCountOrderByAggregateInput = {
    id?: SortOrder
    dateCreated?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    price?: SortOrder
    source?: SortOrder
    postedById?: SortOrder
  }

  export type IngredientAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    price?: SortOrder
  }

  export type IngredientMaxOrderByAggregateInput = {
    id?: SortOrder
    dateCreated?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    price?: SortOrder
    source?: SortOrder
    postedById?: SortOrder
  }

  export type IngredientMinOrderByAggregateInput = {
    id?: SortOrder
    dateCreated?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    price?: SortOrder
    source?: SortOrder
    postedById?: SortOrder
  }

  export type IngredientSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    price?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type DecimalNullableWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type TouchCountOrderByAggregateInput = {
    id?: SortOrder
    ingredientId?: SortOrder
    order?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    specId?: SortOrder
    postedById?: SortOrder
  }

  export type TouchAvgOrderByAggregateInput = {
    id?: SortOrder
    ingredientId?: SortOrder
    order?: SortOrder
    amount?: SortOrder
    specId?: SortOrder
  }

  export type TouchMaxOrderByAggregateInput = {
    id?: SortOrder
    ingredientId?: SortOrder
    order?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    specId?: SortOrder
    postedById?: SortOrder
  }

  export type TouchMinOrderByAggregateInput = {
    id?: SortOrder
    ingredientId?: SortOrder
    order?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    specId?: SortOrder
    postedById?: SortOrder
  }

  export type TouchSumOrderByAggregateInput = {
    id?: SortOrder
    ingredientId?: SortOrder
    order?: SortOrder
    amount?: SortOrder
    specId?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type SpecListRelationFilter = {
    every?: SpecWhereInput
    some?: SpecWhereInput
    none?: SpecWhereInput
  }

  export type SpecOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipeCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    origin?: SortOrder
    history?: SortOrder
    postedById?: SortOrder
  }

  export type RecipeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RecipeMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    origin?: SortOrder
    history?: SortOrder
    postedById?: SortOrder
  }

  export type RecipeMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    origin?: SortOrder
    history?: SortOrder
    postedById?: SortOrder
  }

  export type RecipeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SharedSpecListRelationFilter = {
    every?: SharedSpecWhereInput
    some?: SharedSpecWhereInput
    none?: SharedSpecWhereInput
  }

  export type RecipeRelationFilter = {
    is?: RecipeWhereInput | null
    isNot?: RecipeWhereInput | null
  }

  export type AdminOnSpecListRelationFilter = {
    every?: AdminOnSpecWhereInput
    some?: AdminOnSpecWhereInput
    none?: AdminOnSpecWhereInput
  }

  export type SharedSpecOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminOnSpecOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpecCountOrderByAggregateInput = {
    id?: SortOrder
    specName?: SortOrder
    postedById?: SortOrder
    instructions?: SortOrder
    glassware?: SortOrder
    ice?: SortOrder
    recipeId?: SortOrder
  }

  export type SpecAvgOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
  }

  export type SpecMaxOrderByAggregateInput = {
    id?: SortOrder
    specName?: SortOrder
    postedById?: SortOrder
    instructions?: SortOrder
    glassware?: SortOrder
    ice?: SortOrder
    recipeId?: SortOrder
  }

  export type SpecMinOrderByAggregateInput = {
    id?: SortOrder
    specName?: SortOrder
    postedById?: SortOrder
    instructions?: SortOrder
    glassware?: SortOrder
    ice?: SortOrder
    recipeId?: SortOrder
  }

  export type SpecSumOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
  }

  export type UserDataCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userBio?: SortOrder
    workPlace?: SortOrder
    profilePicture?: SortOrder
  }

  export type UserDataAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserDataMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userBio?: SortOrder
    workPlace?: SortOrder
    profilePicture?: SortOrder
  }

  export type UserDataMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userBio?: SortOrder
    workPlace?: SortOrder
    profilePicture?: SortOrder
  }

  export type UserDataSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserDataListRelationFilter = {
    every?: UserDataWhereInput
    some?: UserDataWhereInput
    none?: UserDataWhereInput
  }

  export type RecipeListRelationFilter = {
    every?: RecipeWhereInput
    some?: RecipeWhereInput
    none?: RecipeWhereInput
  }

  export type IngredientListRelationFilter = {
    every?: IngredientWhereInput
    some?: IngredientWhereInput
    none?: IngredientWhereInput
  }

  export type UserDataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IngredientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    userName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateJoined?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    userName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateJoined?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    userName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateJoined?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type SharedIngredientUserIdIngredientIdCompoundUniqueInput = {
    userId: string
    ingredientId: number
  }

  export type SharedIngredientCountOrderByAggregateInput = {
    userId?: SortOrder
    ingredientId?: SortOrder
    sharedById?: SortOrder
    sharedAt?: SortOrder
  }

  export type SharedIngredientAvgOrderByAggregateInput = {
    ingredientId?: SortOrder
  }

  export type SharedIngredientMaxOrderByAggregateInput = {
    userId?: SortOrder
    ingredientId?: SortOrder
    sharedById?: SortOrder
    sharedAt?: SortOrder
  }

  export type SharedIngredientMinOrderByAggregateInput = {
    userId?: SortOrder
    ingredientId?: SortOrder
    sharedById?: SortOrder
    sharedAt?: SortOrder
  }

  export type SharedIngredientSumOrderByAggregateInput = {
    ingredientId?: SortOrder
  }

  export type SharedSpecUserIdSpecIdCompoundUniqueInput = {
    userId: string
    specId: number
  }

  export type SharedSpecCountOrderByAggregateInput = {
    userId?: SortOrder
    specId?: SortOrder
    sharedById?: SortOrder
    sharedAt?: SortOrder
  }

  export type SharedSpecAvgOrderByAggregateInput = {
    specId?: SortOrder
  }

  export type SharedSpecMaxOrderByAggregateInput = {
    userId?: SortOrder
    specId?: SortOrder
    sharedById?: SortOrder
    sharedAt?: SortOrder
  }

  export type SharedSpecMinOrderByAggregateInput = {
    userId?: SortOrder
    specId?: SortOrder
    sharedById?: SortOrder
    sharedAt?: SortOrder
  }

  export type SharedSpecSumOrderByAggregateInput = {
    specId?: SortOrder
  }

  export type AdminOnSpecUserIdSpecIdCompoundUniqueInput = {
    userId: string
    specId: number
  }

  export type AdminOnSpecCountOrderByAggregateInput = {
    userId?: SortOrder
    specId?: SortOrder
    assignedById?: SortOrder
    assignedAt?: SortOrder
  }

  export type AdminOnSpecAvgOrderByAggregateInput = {
    specId?: SortOrder
  }

  export type AdminOnSpecMaxOrderByAggregateInput = {
    userId?: SortOrder
    specId?: SortOrder
    assignedById?: SortOrder
    assignedAt?: SortOrder
  }

  export type AdminOnSpecMinOrderByAggregateInput = {
    userId?: SortOrder
    specId?: SortOrder
    assignedById?: SortOrder
    assignedAt?: SortOrder
  }

  export type AdminOnSpecSumOrderByAggregateInput = {
    specId?: SortOrder
  }

  export type GroupIngredientCreateNestedManyWithoutGroupsInput = {
    create?: XOR<Enumerable<GroupIngredientCreateWithoutGroupsInput>, Enumerable<GroupIngredientUncheckedCreateWithoutGroupsInput>>
    connectOrCreate?: Enumerable<GroupIngredientCreateOrConnectWithoutGroupsInput>
    createMany?: GroupIngredientCreateManyGroupsInputEnvelope
    connect?: Enumerable<GroupIngredientWhereUniqueInput>
  }

  export type GroupModCreateNestedManyWithoutGroupsInput = {
    create?: XOR<Enumerable<GroupModCreateWithoutGroupsInput>, Enumerable<GroupModUncheckedCreateWithoutGroupsInput>>
    connectOrCreate?: Enumerable<GroupModCreateOrConnectWithoutGroupsInput>
    createMany?: GroupModCreateManyGroupsInputEnvelope
    connect?: Enumerable<GroupModWhereUniqueInput>
  }

  export type GroupSpecCreateNestedManyWithoutGroupsInput = {
    create?: XOR<Enumerable<GroupSpecCreateWithoutGroupsInput>, Enumerable<GroupSpecUncheckedCreateWithoutGroupsInput>>
    connectOrCreate?: Enumerable<GroupSpecCreateOrConnectWithoutGroupsInput>
    createMany?: GroupSpecCreateManyGroupsInputEnvelope
    connect?: Enumerable<GroupSpecWhereUniqueInput>
  }

  export type GroupUserCreateNestedManyWithoutGroupsInput = {
    create?: XOR<Enumerable<GroupUserCreateWithoutGroupsInput>, Enumerable<GroupUserUncheckedCreateWithoutGroupsInput>>
    connectOrCreate?: Enumerable<GroupUserCreateOrConnectWithoutGroupsInput>
    createMany?: GroupUserCreateManyGroupsInputEnvelope
    connect?: Enumerable<GroupUserWhereUniqueInput>
  }

  export type GroupIngredientUncheckedCreateNestedManyWithoutGroupsInput = {
    create?: XOR<Enumerable<GroupIngredientCreateWithoutGroupsInput>, Enumerable<GroupIngredientUncheckedCreateWithoutGroupsInput>>
    connectOrCreate?: Enumerable<GroupIngredientCreateOrConnectWithoutGroupsInput>
    createMany?: GroupIngredientCreateManyGroupsInputEnvelope
    connect?: Enumerable<GroupIngredientWhereUniqueInput>
  }

  export type GroupModUncheckedCreateNestedManyWithoutGroupsInput = {
    create?: XOR<Enumerable<GroupModCreateWithoutGroupsInput>, Enumerable<GroupModUncheckedCreateWithoutGroupsInput>>
    connectOrCreate?: Enumerable<GroupModCreateOrConnectWithoutGroupsInput>
    createMany?: GroupModCreateManyGroupsInputEnvelope
    connect?: Enumerable<GroupModWhereUniqueInput>
  }

  export type GroupSpecUncheckedCreateNestedManyWithoutGroupsInput = {
    create?: XOR<Enumerable<GroupSpecCreateWithoutGroupsInput>, Enumerable<GroupSpecUncheckedCreateWithoutGroupsInput>>
    connectOrCreate?: Enumerable<GroupSpecCreateOrConnectWithoutGroupsInput>
    createMany?: GroupSpecCreateManyGroupsInputEnvelope
    connect?: Enumerable<GroupSpecWhereUniqueInput>
  }

  export type GroupUserUncheckedCreateNestedManyWithoutGroupsInput = {
    create?: XOR<Enumerable<GroupUserCreateWithoutGroupsInput>, Enumerable<GroupUserUncheckedCreateWithoutGroupsInput>>
    connectOrCreate?: Enumerable<GroupUserCreateOrConnectWithoutGroupsInput>
    createMany?: GroupUserCreateManyGroupsInputEnvelope
    connect?: Enumerable<GroupUserWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type GroupIngredientUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<Enumerable<GroupIngredientCreateWithoutGroupsInput>, Enumerable<GroupIngredientUncheckedCreateWithoutGroupsInput>>
    connectOrCreate?: Enumerable<GroupIngredientCreateOrConnectWithoutGroupsInput>
    upsert?: Enumerable<GroupIngredientUpsertWithWhereUniqueWithoutGroupsInput>
    createMany?: GroupIngredientCreateManyGroupsInputEnvelope
    set?: Enumerable<GroupIngredientWhereUniqueInput>
    disconnect?: Enumerable<GroupIngredientWhereUniqueInput>
    delete?: Enumerable<GroupIngredientWhereUniqueInput>
    connect?: Enumerable<GroupIngredientWhereUniqueInput>
    update?: Enumerable<GroupIngredientUpdateWithWhereUniqueWithoutGroupsInput>
    updateMany?: Enumerable<GroupIngredientUpdateManyWithWhereWithoutGroupsInput>
    deleteMany?: Enumerable<GroupIngredientScalarWhereInput>
  }

  export type GroupModUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<Enumerable<GroupModCreateWithoutGroupsInput>, Enumerable<GroupModUncheckedCreateWithoutGroupsInput>>
    connectOrCreate?: Enumerable<GroupModCreateOrConnectWithoutGroupsInput>
    upsert?: Enumerable<GroupModUpsertWithWhereUniqueWithoutGroupsInput>
    createMany?: GroupModCreateManyGroupsInputEnvelope
    set?: Enumerable<GroupModWhereUniqueInput>
    disconnect?: Enumerable<GroupModWhereUniqueInput>
    delete?: Enumerable<GroupModWhereUniqueInput>
    connect?: Enumerable<GroupModWhereUniqueInput>
    update?: Enumerable<GroupModUpdateWithWhereUniqueWithoutGroupsInput>
    updateMany?: Enumerable<GroupModUpdateManyWithWhereWithoutGroupsInput>
    deleteMany?: Enumerable<GroupModScalarWhereInput>
  }

  export type GroupSpecUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<Enumerable<GroupSpecCreateWithoutGroupsInput>, Enumerable<GroupSpecUncheckedCreateWithoutGroupsInput>>
    connectOrCreate?: Enumerable<GroupSpecCreateOrConnectWithoutGroupsInput>
    upsert?: Enumerable<GroupSpecUpsertWithWhereUniqueWithoutGroupsInput>
    createMany?: GroupSpecCreateManyGroupsInputEnvelope
    set?: Enumerable<GroupSpecWhereUniqueInput>
    disconnect?: Enumerable<GroupSpecWhereUniqueInput>
    delete?: Enumerable<GroupSpecWhereUniqueInput>
    connect?: Enumerable<GroupSpecWhereUniqueInput>
    update?: Enumerable<GroupSpecUpdateWithWhereUniqueWithoutGroupsInput>
    updateMany?: Enumerable<GroupSpecUpdateManyWithWhereWithoutGroupsInput>
    deleteMany?: Enumerable<GroupSpecScalarWhereInput>
  }

  export type GroupUserUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<Enumerable<GroupUserCreateWithoutGroupsInput>, Enumerable<GroupUserUncheckedCreateWithoutGroupsInput>>
    connectOrCreate?: Enumerable<GroupUserCreateOrConnectWithoutGroupsInput>
    upsert?: Enumerable<GroupUserUpsertWithWhereUniqueWithoutGroupsInput>
    createMany?: GroupUserCreateManyGroupsInputEnvelope
    set?: Enumerable<GroupUserWhereUniqueInput>
    disconnect?: Enumerable<GroupUserWhereUniqueInput>
    delete?: Enumerable<GroupUserWhereUniqueInput>
    connect?: Enumerable<GroupUserWhereUniqueInput>
    update?: Enumerable<GroupUserUpdateWithWhereUniqueWithoutGroupsInput>
    updateMany?: Enumerable<GroupUserUpdateManyWithWhereWithoutGroupsInput>
    deleteMany?: Enumerable<GroupUserScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type GroupIngredientUncheckedUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<Enumerable<GroupIngredientCreateWithoutGroupsInput>, Enumerable<GroupIngredientUncheckedCreateWithoutGroupsInput>>
    connectOrCreate?: Enumerable<GroupIngredientCreateOrConnectWithoutGroupsInput>
    upsert?: Enumerable<GroupIngredientUpsertWithWhereUniqueWithoutGroupsInput>
    createMany?: GroupIngredientCreateManyGroupsInputEnvelope
    set?: Enumerable<GroupIngredientWhereUniqueInput>
    disconnect?: Enumerable<GroupIngredientWhereUniqueInput>
    delete?: Enumerable<GroupIngredientWhereUniqueInput>
    connect?: Enumerable<GroupIngredientWhereUniqueInput>
    update?: Enumerable<GroupIngredientUpdateWithWhereUniqueWithoutGroupsInput>
    updateMany?: Enumerable<GroupIngredientUpdateManyWithWhereWithoutGroupsInput>
    deleteMany?: Enumerable<GroupIngredientScalarWhereInput>
  }

  export type GroupModUncheckedUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<Enumerable<GroupModCreateWithoutGroupsInput>, Enumerable<GroupModUncheckedCreateWithoutGroupsInput>>
    connectOrCreate?: Enumerable<GroupModCreateOrConnectWithoutGroupsInput>
    upsert?: Enumerable<GroupModUpsertWithWhereUniqueWithoutGroupsInput>
    createMany?: GroupModCreateManyGroupsInputEnvelope
    set?: Enumerable<GroupModWhereUniqueInput>
    disconnect?: Enumerable<GroupModWhereUniqueInput>
    delete?: Enumerable<GroupModWhereUniqueInput>
    connect?: Enumerable<GroupModWhereUniqueInput>
    update?: Enumerable<GroupModUpdateWithWhereUniqueWithoutGroupsInput>
    updateMany?: Enumerable<GroupModUpdateManyWithWhereWithoutGroupsInput>
    deleteMany?: Enumerable<GroupModScalarWhereInput>
  }

  export type GroupSpecUncheckedUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<Enumerable<GroupSpecCreateWithoutGroupsInput>, Enumerable<GroupSpecUncheckedCreateWithoutGroupsInput>>
    connectOrCreate?: Enumerable<GroupSpecCreateOrConnectWithoutGroupsInput>
    upsert?: Enumerable<GroupSpecUpsertWithWhereUniqueWithoutGroupsInput>
    createMany?: GroupSpecCreateManyGroupsInputEnvelope
    set?: Enumerable<GroupSpecWhereUniqueInput>
    disconnect?: Enumerable<GroupSpecWhereUniqueInput>
    delete?: Enumerable<GroupSpecWhereUniqueInput>
    connect?: Enumerable<GroupSpecWhereUniqueInput>
    update?: Enumerable<GroupSpecUpdateWithWhereUniqueWithoutGroupsInput>
    updateMany?: Enumerable<GroupSpecUpdateManyWithWhereWithoutGroupsInput>
    deleteMany?: Enumerable<GroupSpecScalarWhereInput>
  }

  export type GroupUserUncheckedUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<Enumerable<GroupUserCreateWithoutGroupsInput>, Enumerable<GroupUserUncheckedCreateWithoutGroupsInput>>
    connectOrCreate?: Enumerable<GroupUserCreateOrConnectWithoutGroupsInput>
    upsert?: Enumerable<GroupUserUpsertWithWhereUniqueWithoutGroupsInput>
    createMany?: GroupUserCreateManyGroupsInputEnvelope
    set?: Enumerable<GroupUserWhereUniqueInput>
    disconnect?: Enumerable<GroupUserWhereUniqueInput>
    delete?: Enumerable<GroupUserWhereUniqueInput>
    connect?: Enumerable<GroupUserWhereUniqueInput>
    update?: Enumerable<GroupUserUpdateWithWhereUniqueWithoutGroupsInput>
    updateMany?: Enumerable<GroupUserUpdateManyWithWhereWithoutGroupsInput>
    deleteMany?: Enumerable<GroupUserScalarWhereInput>
  }

  export type GroupsCreateNestedOneWithoutGroupIngredientInput = {
    create?: XOR<GroupsCreateWithoutGroupIngredientInput, GroupsUncheckedCreateWithoutGroupIngredientInput>
    connectOrCreate?: GroupsCreateOrConnectWithoutGroupIngredientInput
    connect?: GroupsWhereUniqueInput
  }

  export type IngredientCreateNestedOneWithoutGroupIngredientInput = {
    create?: XOR<IngredientCreateWithoutGroupIngredientInput, IngredientUncheckedCreateWithoutGroupIngredientInput>
    connectOrCreate?: IngredientCreateOrConnectWithoutGroupIngredientInput
    connect?: IngredientWhereUniqueInput
  }

  export type GroupsUpdateOneRequiredWithoutGroupIngredientNestedInput = {
    create?: XOR<GroupsCreateWithoutGroupIngredientInput, GroupsUncheckedCreateWithoutGroupIngredientInput>
    connectOrCreate?: GroupsCreateOrConnectWithoutGroupIngredientInput
    upsert?: GroupsUpsertWithoutGroupIngredientInput
    connect?: GroupsWhereUniqueInput
    update?: XOR<GroupsUpdateWithoutGroupIngredientInput, GroupsUncheckedUpdateWithoutGroupIngredientInput>
  }

  export type IngredientUpdateOneRequiredWithoutGroupIngredientNestedInput = {
    create?: XOR<IngredientCreateWithoutGroupIngredientInput, IngredientUncheckedCreateWithoutGroupIngredientInput>
    connectOrCreate?: IngredientCreateOrConnectWithoutGroupIngredientInput
    upsert?: IngredientUpsertWithoutGroupIngredientInput
    connect?: IngredientWhereUniqueInput
    update?: XOR<IngredientUpdateWithoutGroupIngredientInput, IngredientUncheckedUpdateWithoutGroupIngredientInput>
  }

  export type GroupsCreateNestedOneWithoutGroupModInput = {
    create?: XOR<GroupsCreateWithoutGroupModInput, GroupsUncheckedCreateWithoutGroupModInput>
    connectOrCreate?: GroupsCreateOrConnectWithoutGroupModInput
    connect?: GroupsWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGroupModInput = {
    create?: XOR<UserCreateWithoutGroupModInput, UserUncheckedCreateWithoutGroupModInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupModInput
    connect?: UserWhereUniqueInput
  }

  export type GroupsUpdateOneRequiredWithoutGroupModNestedInput = {
    create?: XOR<GroupsCreateWithoutGroupModInput, GroupsUncheckedCreateWithoutGroupModInput>
    connectOrCreate?: GroupsCreateOrConnectWithoutGroupModInput
    upsert?: GroupsUpsertWithoutGroupModInput
    connect?: GroupsWhereUniqueInput
    update?: XOR<GroupsUpdateWithoutGroupModInput, GroupsUncheckedUpdateWithoutGroupModInput>
  }

  export type UserUpdateOneRequiredWithoutGroupModNestedInput = {
    create?: XOR<UserCreateWithoutGroupModInput, UserUncheckedCreateWithoutGroupModInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupModInput
    upsert?: UserUpsertWithoutGroupModInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutGroupModInput, UserUncheckedUpdateWithoutGroupModInput>
  }

  export type GroupsCreateNestedOneWithoutGroupSpecInput = {
    create?: XOR<GroupsCreateWithoutGroupSpecInput, GroupsUncheckedCreateWithoutGroupSpecInput>
    connectOrCreate?: GroupsCreateOrConnectWithoutGroupSpecInput
    connect?: GroupsWhereUniqueInput
  }

  export type SpecCreateNestedOneWithoutGroupSpecInput = {
    create?: XOR<SpecCreateWithoutGroupSpecInput, SpecUncheckedCreateWithoutGroupSpecInput>
    connectOrCreate?: SpecCreateOrConnectWithoutGroupSpecInput
    connect?: SpecWhereUniqueInput
  }

  export type GroupsUpdateOneRequiredWithoutGroupSpecNestedInput = {
    create?: XOR<GroupsCreateWithoutGroupSpecInput, GroupsUncheckedCreateWithoutGroupSpecInput>
    connectOrCreate?: GroupsCreateOrConnectWithoutGroupSpecInput
    upsert?: GroupsUpsertWithoutGroupSpecInput
    connect?: GroupsWhereUniqueInput
    update?: XOR<GroupsUpdateWithoutGroupSpecInput, GroupsUncheckedUpdateWithoutGroupSpecInput>
  }

  export type SpecUpdateOneRequiredWithoutGroupSpecNestedInput = {
    create?: XOR<SpecCreateWithoutGroupSpecInput, SpecUncheckedCreateWithoutGroupSpecInput>
    connectOrCreate?: SpecCreateOrConnectWithoutGroupSpecInput
    upsert?: SpecUpsertWithoutGroupSpecInput
    connect?: SpecWhereUniqueInput
    update?: XOR<SpecUpdateWithoutGroupSpecInput, SpecUncheckedUpdateWithoutGroupSpecInput>
  }

  export type GroupsCreateNestedOneWithoutGroupUserInput = {
    create?: XOR<GroupsCreateWithoutGroupUserInput, GroupsUncheckedCreateWithoutGroupUserInput>
    connectOrCreate?: GroupsCreateOrConnectWithoutGroupUserInput
    connect?: GroupsWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGroupUserInput = {
    create?: XOR<UserCreateWithoutGroupUserInput, UserUncheckedCreateWithoutGroupUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupUserInput
    connect?: UserWhereUniqueInput
  }

  export type GroupsUpdateOneRequiredWithoutGroupUserNestedInput = {
    create?: XOR<GroupsCreateWithoutGroupUserInput, GroupsUncheckedCreateWithoutGroupUserInput>
    connectOrCreate?: GroupsCreateOrConnectWithoutGroupUserInput
    upsert?: GroupsUpsertWithoutGroupUserInput
    connect?: GroupsWhereUniqueInput
    update?: XOR<GroupsUpdateWithoutGroupUserInput, GroupsUncheckedUpdateWithoutGroupUserInput>
  }

  export type UserUpdateOneRequiredWithoutGroupUserNestedInput = {
    create?: XOR<UserCreateWithoutGroupUserInput, UserUncheckedCreateWithoutGroupUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupUserInput
    upsert?: UserUpsertWithoutGroupUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutGroupUserInput, UserUncheckedUpdateWithoutGroupUserInput>
  }

  export type UserCreateNestedOneWithoutIngredientInput = {
    create?: XOR<UserCreateWithoutIngredientInput, UserUncheckedCreateWithoutIngredientInput>
    connectOrCreate?: UserCreateOrConnectWithoutIngredientInput
    connect?: UserWhereUniqueInput
  }

  export type GroupIngredientCreateNestedManyWithoutIngredientInput = {
    create?: XOR<Enumerable<GroupIngredientCreateWithoutIngredientInput>, Enumerable<GroupIngredientUncheckedCreateWithoutIngredientInput>>
    connectOrCreate?: Enumerable<GroupIngredientCreateOrConnectWithoutIngredientInput>
    createMany?: GroupIngredientCreateManyIngredientInputEnvelope
    connect?: Enumerable<GroupIngredientWhereUniqueInput>
  }

  export type TouchCreateNestedManyWithoutIngredientInput = {
    create?: XOR<Enumerable<TouchCreateWithoutIngredientInput>, Enumerable<TouchUncheckedCreateWithoutIngredientInput>>
    connectOrCreate?: Enumerable<TouchCreateOrConnectWithoutIngredientInput>
    createMany?: TouchCreateManyIngredientInputEnvelope
    connect?: Enumerable<TouchWhereUniqueInput>
  }

  export type SharedIngredientCreateNestedManyWithoutIngredientInput = {
    create?: XOR<Enumerable<SharedIngredientCreateWithoutIngredientInput>, Enumerable<SharedIngredientUncheckedCreateWithoutIngredientInput>>
    connectOrCreate?: Enumerable<SharedIngredientCreateOrConnectWithoutIngredientInput>
    createMany?: SharedIngredientCreateManyIngredientInputEnvelope
    connect?: Enumerable<SharedIngredientWhereUniqueInput>
  }

  export type GroupIngredientUncheckedCreateNestedManyWithoutIngredientInput = {
    create?: XOR<Enumerable<GroupIngredientCreateWithoutIngredientInput>, Enumerable<GroupIngredientUncheckedCreateWithoutIngredientInput>>
    connectOrCreate?: Enumerable<GroupIngredientCreateOrConnectWithoutIngredientInput>
    createMany?: GroupIngredientCreateManyIngredientInputEnvelope
    connect?: Enumerable<GroupIngredientWhereUniqueInput>
  }

  export type TouchUncheckedCreateNestedManyWithoutIngredientInput = {
    create?: XOR<Enumerable<TouchCreateWithoutIngredientInput>, Enumerable<TouchUncheckedCreateWithoutIngredientInput>>
    connectOrCreate?: Enumerable<TouchCreateOrConnectWithoutIngredientInput>
    createMany?: TouchCreateManyIngredientInputEnvelope
    connect?: Enumerable<TouchWhereUniqueInput>
  }

  export type SharedIngredientUncheckedCreateNestedManyWithoutIngredientInput = {
    create?: XOR<Enumerable<SharedIngredientCreateWithoutIngredientInput>, Enumerable<SharedIngredientUncheckedCreateWithoutIngredientInput>>
    connectOrCreate?: Enumerable<SharedIngredientCreateOrConnectWithoutIngredientInput>
    createMany?: SharedIngredientCreateManyIngredientInputEnvelope
    connect?: Enumerable<SharedIngredientWhereUniqueInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneWithoutIngredientNestedInput = {
    create?: XOR<UserCreateWithoutIngredientInput, UserUncheckedCreateWithoutIngredientInput>
    connectOrCreate?: UserCreateOrConnectWithoutIngredientInput
    upsert?: UserUpsertWithoutIngredientInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutIngredientInput, UserUncheckedUpdateWithoutIngredientInput>
  }

  export type GroupIngredientUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<Enumerable<GroupIngredientCreateWithoutIngredientInput>, Enumerable<GroupIngredientUncheckedCreateWithoutIngredientInput>>
    connectOrCreate?: Enumerable<GroupIngredientCreateOrConnectWithoutIngredientInput>
    upsert?: Enumerable<GroupIngredientUpsertWithWhereUniqueWithoutIngredientInput>
    createMany?: GroupIngredientCreateManyIngredientInputEnvelope
    set?: Enumerable<GroupIngredientWhereUniqueInput>
    disconnect?: Enumerable<GroupIngredientWhereUniqueInput>
    delete?: Enumerable<GroupIngredientWhereUniqueInput>
    connect?: Enumerable<GroupIngredientWhereUniqueInput>
    update?: Enumerable<GroupIngredientUpdateWithWhereUniqueWithoutIngredientInput>
    updateMany?: Enumerable<GroupIngredientUpdateManyWithWhereWithoutIngredientInput>
    deleteMany?: Enumerable<GroupIngredientScalarWhereInput>
  }

  export type TouchUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<Enumerable<TouchCreateWithoutIngredientInput>, Enumerable<TouchUncheckedCreateWithoutIngredientInput>>
    connectOrCreate?: Enumerable<TouchCreateOrConnectWithoutIngredientInput>
    upsert?: Enumerable<TouchUpsertWithWhereUniqueWithoutIngredientInput>
    createMany?: TouchCreateManyIngredientInputEnvelope
    set?: Enumerable<TouchWhereUniqueInput>
    disconnect?: Enumerable<TouchWhereUniqueInput>
    delete?: Enumerable<TouchWhereUniqueInput>
    connect?: Enumerable<TouchWhereUniqueInput>
    update?: Enumerable<TouchUpdateWithWhereUniqueWithoutIngredientInput>
    updateMany?: Enumerable<TouchUpdateManyWithWhereWithoutIngredientInput>
    deleteMany?: Enumerable<TouchScalarWhereInput>
  }

  export type SharedIngredientUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<Enumerable<SharedIngredientCreateWithoutIngredientInput>, Enumerable<SharedIngredientUncheckedCreateWithoutIngredientInput>>
    connectOrCreate?: Enumerable<SharedIngredientCreateOrConnectWithoutIngredientInput>
    upsert?: Enumerable<SharedIngredientUpsertWithWhereUniqueWithoutIngredientInput>
    createMany?: SharedIngredientCreateManyIngredientInputEnvelope
    set?: Enumerable<SharedIngredientWhereUniqueInput>
    disconnect?: Enumerable<SharedIngredientWhereUniqueInput>
    delete?: Enumerable<SharedIngredientWhereUniqueInput>
    connect?: Enumerable<SharedIngredientWhereUniqueInput>
    update?: Enumerable<SharedIngredientUpdateWithWhereUniqueWithoutIngredientInput>
    updateMany?: Enumerable<SharedIngredientUpdateManyWithWhereWithoutIngredientInput>
    deleteMany?: Enumerable<SharedIngredientScalarWhereInput>
  }

  export type GroupIngredientUncheckedUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<Enumerable<GroupIngredientCreateWithoutIngredientInput>, Enumerable<GroupIngredientUncheckedCreateWithoutIngredientInput>>
    connectOrCreate?: Enumerable<GroupIngredientCreateOrConnectWithoutIngredientInput>
    upsert?: Enumerable<GroupIngredientUpsertWithWhereUniqueWithoutIngredientInput>
    createMany?: GroupIngredientCreateManyIngredientInputEnvelope
    set?: Enumerable<GroupIngredientWhereUniqueInput>
    disconnect?: Enumerable<GroupIngredientWhereUniqueInput>
    delete?: Enumerable<GroupIngredientWhereUniqueInput>
    connect?: Enumerable<GroupIngredientWhereUniqueInput>
    update?: Enumerable<GroupIngredientUpdateWithWhereUniqueWithoutIngredientInput>
    updateMany?: Enumerable<GroupIngredientUpdateManyWithWhereWithoutIngredientInput>
    deleteMany?: Enumerable<GroupIngredientScalarWhereInput>
  }

  export type TouchUncheckedUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<Enumerable<TouchCreateWithoutIngredientInput>, Enumerable<TouchUncheckedCreateWithoutIngredientInput>>
    connectOrCreate?: Enumerable<TouchCreateOrConnectWithoutIngredientInput>
    upsert?: Enumerable<TouchUpsertWithWhereUniqueWithoutIngredientInput>
    createMany?: TouchCreateManyIngredientInputEnvelope
    set?: Enumerable<TouchWhereUniqueInput>
    disconnect?: Enumerable<TouchWhereUniqueInput>
    delete?: Enumerable<TouchWhereUniqueInput>
    connect?: Enumerable<TouchWhereUniqueInput>
    update?: Enumerable<TouchUpdateWithWhereUniqueWithoutIngredientInput>
    updateMany?: Enumerable<TouchUpdateManyWithWhereWithoutIngredientInput>
    deleteMany?: Enumerable<TouchScalarWhereInput>
  }

  export type SharedIngredientUncheckedUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<Enumerable<SharedIngredientCreateWithoutIngredientInput>, Enumerable<SharedIngredientUncheckedCreateWithoutIngredientInput>>
    connectOrCreate?: Enumerable<SharedIngredientCreateOrConnectWithoutIngredientInput>
    upsert?: Enumerable<SharedIngredientUpsertWithWhereUniqueWithoutIngredientInput>
    createMany?: SharedIngredientCreateManyIngredientInputEnvelope
    set?: Enumerable<SharedIngredientWhereUniqueInput>
    disconnect?: Enumerable<SharedIngredientWhereUniqueInput>
    delete?: Enumerable<SharedIngredientWhereUniqueInput>
    connect?: Enumerable<SharedIngredientWhereUniqueInput>
    update?: Enumerable<SharedIngredientUpdateWithWhereUniqueWithoutIngredientInput>
    updateMany?: Enumerable<SharedIngredientUpdateManyWithWhereWithoutIngredientInput>
    deleteMany?: Enumerable<SharedIngredientScalarWhereInput>
  }

  export type IngredientCreateNestedOneWithoutTouchInput = {
    create?: XOR<IngredientCreateWithoutTouchInput, IngredientUncheckedCreateWithoutTouchInput>
    connectOrCreate?: IngredientCreateOrConnectWithoutTouchInput
    connect?: IngredientWhereUniqueInput
  }

  export type SpecCreateNestedOneWithoutTouchInput = {
    create?: XOR<SpecCreateWithoutTouchInput, SpecUncheckedCreateWithoutTouchInput>
    connectOrCreate?: SpecCreateOrConnectWithoutTouchInput
    connect?: SpecWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTouchInput = {
    create?: XOR<UserCreateWithoutTouchInput, UserUncheckedCreateWithoutTouchInput>
    connectOrCreate?: UserCreateOrConnectWithoutTouchInput
    connect?: UserWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IngredientUpdateOneWithoutTouchNestedInput = {
    create?: XOR<IngredientCreateWithoutTouchInput, IngredientUncheckedCreateWithoutTouchInput>
    connectOrCreate?: IngredientCreateOrConnectWithoutTouchInput
    upsert?: IngredientUpsertWithoutTouchInput
    disconnect?: boolean
    delete?: boolean
    connect?: IngredientWhereUniqueInput
    update?: XOR<IngredientUpdateWithoutTouchInput, IngredientUncheckedUpdateWithoutTouchInput>
  }

  export type SpecUpdateOneWithoutTouchNestedInput = {
    create?: XOR<SpecCreateWithoutTouchInput, SpecUncheckedCreateWithoutTouchInput>
    connectOrCreate?: SpecCreateOrConnectWithoutTouchInput
    upsert?: SpecUpsertWithoutTouchInput
    disconnect?: boolean
    delete?: boolean
    connect?: SpecWhereUniqueInput
    update?: XOR<SpecUpdateWithoutTouchInput, SpecUncheckedUpdateWithoutTouchInput>
  }

  export type UserUpdateOneWithoutTouchNestedInput = {
    create?: XOR<UserCreateWithoutTouchInput, UserUncheckedCreateWithoutTouchInput>
    connectOrCreate?: UserCreateOrConnectWithoutTouchInput
    upsert?: UserUpsertWithoutTouchInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutTouchInput, UserUncheckedUpdateWithoutTouchInput>
  }

  export type UserCreateNestedOneWithoutRecipesInput = {
    create?: XOR<UserCreateWithoutRecipesInput, UserUncheckedCreateWithoutRecipesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipesInput
    connect?: UserWhereUniqueInput
  }

  export type SpecCreateNestedManyWithoutRecipeInput = {
    create?: XOR<Enumerable<SpecCreateWithoutRecipeInput>, Enumerable<SpecUncheckedCreateWithoutRecipeInput>>
    connectOrCreate?: Enumerable<SpecCreateOrConnectWithoutRecipeInput>
    createMany?: SpecCreateManyRecipeInputEnvelope
    connect?: Enumerable<SpecWhereUniqueInput>
  }

  export type SpecUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<Enumerable<SpecCreateWithoutRecipeInput>, Enumerable<SpecUncheckedCreateWithoutRecipeInput>>
    connectOrCreate?: Enumerable<SpecCreateOrConnectWithoutRecipeInput>
    createMany?: SpecCreateManyRecipeInputEnvelope
    connect?: Enumerable<SpecWhereUniqueInput>
  }

  export type UserUpdateOneWithoutRecipesNestedInput = {
    create?: XOR<UserCreateWithoutRecipesInput, UserUncheckedCreateWithoutRecipesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipesInput
    upsert?: UserUpsertWithoutRecipesInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutRecipesInput, UserUncheckedUpdateWithoutRecipesInput>
  }

  export type SpecUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<Enumerable<SpecCreateWithoutRecipeInput>, Enumerable<SpecUncheckedCreateWithoutRecipeInput>>
    connectOrCreate?: Enumerable<SpecCreateOrConnectWithoutRecipeInput>
    upsert?: Enumerable<SpecUpsertWithWhereUniqueWithoutRecipeInput>
    createMany?: SpecCreateManyRecipeInputEnvelope
    set?: Enumerable<SpecWhereUniqueInput>
    disconnect?: Enumerable<SpecWhereUniqueInput>
    delete?: Enumerable<SpecWhereUniqueInput>
    connect?: Enumerable<SpecWhereUniqueInput>
    update?: Enumerable<SpecUpdateWithWhereUniqueWithoutRecipeInput>
    updateMany?: Enumerable<SpecUpdateManyWithWhereWithoutRecipeInput>
    deleteMany?: Enumerable<SpecScalarWhereInput>
  }

  export type SpecUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<Enumerable<SpecCreateWithoutRecipeInput>, Enumerable<SpecUncheckedCreateWithoutRecipeInput>>
    connectOrCreate?: Enumerable<SpecCreateOrConnectWithoutRecipeInput>
    upsert?: Enumerable<SpecUpsertWithWhereUniqueWithoutRecipeInput>
    createMany?: SpecCreateManyRecipeInputEnvelope
    set?: Enumerable<SpecWhereUniqueInput>
    disconnect?: Enumerable<SpecWhereUniqueInput>
    delete?: Enumerable<SpecWhereUniqueInput>
    connect?: Enumerable<SpecWhereUniqueInput>
    update?: Enumerable<SpecUpdateWithWhereUniqueWithoutRecipeInput>
    updateMany?: Enumerable<SpecUpdateManyWithWhereWithoutRecipeInput>
    deleteMany?: Enumerable<SpecScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutSpecInput = {
    create?: XOR<UserCreateWithoutSpecInput, UserUncheckedCreateWithoutSpecInput>
    connectOrCreate?: UserCreateOrConnectWithoutSpecInput
    connect?: UserWhereUniqueInput
  }

  export type GroupSpecCreateNestedManyWithoutSpecInput = {
    create?: XOR<Enumerable<GroupSpecCreateWithoutSpecInput>, Enumerable<GroupSpecUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<GroupSpecCreateOrConnectWithoutSpecInput>
    createMany?: GroupSpecCreateManySpecInputEnvelope
    connect?: Enumerable<GroupSpecWhereUniqueInput>
  }

  export type SharedSpecCreateNestedManyWithoutSpecInput = {
    create?: XOR<Enumerable<SharedSpecCreateWithoutSpecInput>, Enumerable<SharedSpecUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<SharedSpecCreateOrConnectWithoutSpecInput>
    createMany?: SharedSpecCreateManySpecInputEnvelope
    connect?: Enumerable<SharedSpecWhereUniqueInput>
  }

  export type RecipeCreateNestedOneWithoutSpecInput = {
    create?: XOR<RecipeCreateWithoutSpecInput, RecipeUncheckedCreateWithoutSpecInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutSpecInput
    connect?: RecipeWhereUniqueInput
  }

  export type TouchCreateNestedManyWithoutSpecInput = {
    create?: XOR<Enumerable<TouchCreateWithoutSpecInput>, Enumerable<TouchUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<TouchCreateOrConnectWithoutSpecInput>
    createMany?: TouchCreateManySpecInputEnvelope
    connect?: Enumerable<TouchWhereUniqueInput>
  }

  export type AdminOnSpecCreateNestedManyWithoutSpecInput = {
    create?: XOR<Enumerable<AdminOnSpecCreateWithoutSpecInput>, Enumerable<AdminOnSpecUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<AdminOnSpecCreateOrConnectWithoutSpecInput>
    createMany?: AdminOnSpecCreateManySpecInputEnvelope
    connect?: Enumerable<AdminOnSpecWhereUniqueInput>
  }

  export type GroupSpecUncheckedCreateNestedManyWithoutSpecInput = {
    create?: XOR<Enumerable<GroupSpecCreateWithoutSpecInput>, Enumerable<GroupSpecUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<GroupSpecCreateOrConnectWithoutSpecInput>
    createMany?: GroupSpecCreateManySpecInputEnvelope
    connect?: Enumerable<GroupSpecWhereUniqueInput>
  }

  export type SharedSpecUncheckedCreateNestedManyWithoutSpecInput = {
    create?: XOR<Enumerable<SharedSpecCreateWithoutSpecInput>, Enumerable<SharedSpecUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<SharedSpecCreateOrConnectWithoutSpecInput>
    createMany?: SharedSpecCreateManySpecInputEnvelope
    connect?: Enumerable<SharedSpecWhereUniqueInput>
  }

  export type TouchUncheckedCreateNestedManyWithoutSpecInput = {
    create?: XOR<Enumerable<TouchCreateWithoutSpecInput>, Enumerable<TouchUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<TouchCreateOrConnectWithoutSpecInput>
    createMany?: TouchCreateManySpecInputEnvelope
    connect?: Enumerable<TouchWhereUniqueInput>
  }

  export type AdminOnSpecUncheckedCreateNestedManyWithoutSpecInput = {
    create?: XOR<Enumerable<AdminOnSpecCreateWithoutSpecInput>, Enumerable<AdminOnSpecUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<AdminOnSpecCreateOrConnectWithoutSpecInput>
    createMany?: AdminOnSpecCreateManySpecInputEnvelope
    connect?: Enumerable<AdminOnSpecWhereUniqueInput>
  }

  export type UserUpdateOneWithoutSpecNestedInput = {
    create?: XOR<UserCreateWithoutSpecInput, UserUncheckedCreateWithoutSpecInput>
    connectOrCreate?: UserCreateOrConnectWithoutSpecInput
    upsert?: UserUpsertWithoutSpecInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutSpecInput, UserUncheckedUpdateWithoutSpecInput>
  }

  export type GroupSpecUpdateManyWithoutSpecNestedInput = {
    create?: XOR<Enumerable<GroupSpecCreateWithoutSpecInput>, Enumerable<GroupSpecUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<GroupSpecCreateOrConnectWithoutSpecInput>
    upsert?: Enumerable<GroupSpecUpsertWithWhereUniqueWithoutSpecInput>
    createMany?: GroupSpecCreateManySpecInputEnvelope
    set?: Enumerable<GroupSpecWhereUniqueInput>
    disconnect?: Enumerable<GroupSpecWhereUniqueInput>
    delete?: Enumerable<GroupSpecWhereUniqueInput>
    connect?: Enumerable<GroupSpecWhereUniqueInput>
    update?: Enumerable<GroupSpecUpdateWithWhereUniqueWithoutSpecInput>
    updateMany?: Enumerable<GroupSpecUpdateManyWithWhereWithoutSpecInput>
    deleteMany?: Enumerable<GroupSpecScalarWhereInput>
  }

  export type SharedSpecUpdateManyWithoutSpecNestedInput = {
    create?: XOR<Enumerable<SharedSpecCreateWithoutSpecInput>, Enumerable<SharedSpecUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<SharedSpecCreateOrConnectWithoutSpecInput>
    upsert?: Enumerable<SharedSpecUpsertWithWhereUniqueWithoutSpecInput>
    createMany?: SharedSpecCreateManySpecInputEnvelope
    set?: Enumerable<SharedSpecWhereUniqueInput>
    disconnect?: Enumerable<SharedSpecWhereUniqueInput>
    delete?: Enumerable<SharedSpecWhereUniqueInput>
    connect?: Enumerable<SharedSpecWhereUniqueInput>
    update?: Enumerable<SharedSpecUpdateWithWhereUniqueWithoutSpecInput>
    updateMany?: Enumerable<SharedSpecUpdateManyWithWhereWithoutSpecInput>
    deleteMany?: Enumerable<SharedSpecScalarWhereInput>
  }

  export type RecipeUpdateOneWithoutSpecNestedInput = {
    create?: XOR<RecipeCreateWithoutSpecInput, RecipeUncheckedCreateWithoutSpecInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutSpecInput
    upsert?: RecipeUpsertWithoutSpecInput
    disconnect?: boolean
    delete?: boolean
    connect?: RecipeWhereUniqueInput
    update?: XOR<RecipeUpdateWithoutSpecInput, RecipeUncheckedUpdateWithoutSpecInput>
  }

  export type TouchUpdateManyWithoutSpecNestedInput = {
    create?: XOR<Enumerable<TouchCreateWithoutSpecInput>, Enumerable<TouchUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<TouchCreateOrConnectWithoutSpecInput>
    upsert?: Enumerable<TouchUpsertWithWhereUniqueWithoutSpecInput>
    createMany?: TouchCreateManySpecInputEnvelope
    set?: Enumerable<TouchWhereUniqueInput>
    disconnect?: Enumerable<TouchWhereUniqueInput>
    delete?: Enumerable<TouchWhereUniqueInput>
    connect?: Enumerable<TouchWhereUniqueInput>
    update?: Enumerable<TouchUpdateWithWhereUniqueWithoutSpecInput>
    updateMany?: Enumerable<TouchUpdateManyWithWhereWithoutSpecInput>
    deleteMany?: Enumerable<TouchScalarWhereInput>
  }

  export type AdminOnSpecUpdateManyWithoutSpecNestedInput = {
    create?: XOR<Enumerable<AdminOnSpecCreateWithoutSpecInput>, Enumerable<AdminOnSpecUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<AdminOnSpecCreateOrConnectWithoutSpecInput>
    upsert?: Enumerable<AdminOnSpecUpsertWithWhereUniqueWithoutSpecInput>
    createMany?: AdminOnSpecCreateManySpecInputEnvelope
    set?: Enumerable<AdminOnSpecWhereUniqueInput>
    disconnect?: Enumerable<AdminOnSpecWhereUniqueInput>
    delete?: Enumerable<AdminOnSpecWhereUniqueInput>
    connect?: Enumerable<AdminOnSpecWhereUniqueInput>
    update?: Enumerable<AdminOnSpecUpdateWithWhereUniqueWithoutSpecInput>
    updateMany?: Enumerable<AdminOnSpecUpdateManyWithWhereWithoutSpecInput>
    deleteMany?: Enumerable<AdminOnSpecScalarWhereInput>
  }

  export type GroupSpecUncheckedUpdateManyWithoutSpecNestedInput = {
    create?: XOR<Enumerable<GroupSpecCreateWithoutSpecInput>, Enumerable<GroupSpecUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<GroupSpecCreateOrConnectWithoutSpecInput>
    upsert?: Enumerable<GroupSpecUpsertWithWhereUniqueWithoutSpecInput>
    createMany?: GroupSpecCreateManySpecInputEnvelope
    set?: Enumerable<GroupSpecWhereUniqueInput>
    disconnect?: Enumerable<GroupSpecWhereUniqueInput>
    delete?: Enumerable<GroupSpecWhereUniqueInput>
    connect?: Enumerable<GroupSpecWhereUniqueInput>
    update?: Enumerable<GroupSpecUpdateWithWhereUniqueWithoutSpecInput>
    updateMany?: Enumerable<GroupSpecUpdateManyWithWhereWithoutSpecInput>
    deleteMany?: Enumerable<GroupSpecScalarWhereInput>
  }

  export type SharedSpecUncheckedUpdateManyWithoutSpecNestedInput = {
    create?: XOR<Enumerable<SharedSpecCreateWithoutSpecInput>, Enumerable<SharedSpecUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<SharedSpecCreateOrConnectWithoutSpecInput>
    upsert?: Enumerable<SharedSpecUpsertWithWhereUniqueWithoutSpecInput>
    createMany?: SharedSpecCreateManySpecInputEnvelope
    set?: Enumerable<SharedSpecWhereUniqueInput>
    disconnect?: Enumerable<SharedSpecWhereUniqueInput>
    delete?: Enumerable<SharedSpecWhereUniqueInput>
    connect?: Enumerable<SharedSpecWhereUniqueInput>
    update?: Enumerable<SharedSpecUpdateWithWhereUniqueWithoutSpecInput>
    updateMany?: Enumerable<SharedSpecUpdateManyWithWhereWithoutSpecInput>
    deleteMany?: Enumerable<SharedSpecScalarWhereInput>
  }

  export type TouchUncheckedUpdateManyWithoutSpecNestedInput = {
    create?: XOR<Enumerable<TouchCreateWithoutSpecInput>, Enumerable<TouchUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<TouchCreateOrConnectWithoutSpecInput>
    upsert?: Enumerable<TouchUpsertWithWhereUniqueWithoutSpecInput>
    createMany?: TouchCreateManySpecInputEnvelope
    set?: Enumerable<TouchWhereUniqueInput>
    disconnect?: Enumerable<TouchWhereUniqueInput>
    delete?: Enumerable<TouchWhereUniqueInput>
    connect?: Enumerable<TouchWhereUniqueInput>
    update?: Enumerable<TouchUpdateWithWhereUniqueWithoutSpecInput>
    updateMany?: Enumerable<TouchUpdateManyWithWhereWithoutSpecInput>
    deleteMany?: Enumerable<TouchScalarWhereInput>
  }

  export type AdminOnSpecUncheckedUpdateManyWithoutSpecNestedInput = {
    create?: XOR<Enumerable<AdminOnSpecCreateWithoutSpecInput>, Enumerable<AdminOnSpecUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<AdminOnSpecCreateOrConnectWithoutSpecInput>
    upsert?: Enumerable<AdminOnSpecUpsertWithWhereUniqueWithoutSpecInput>
    createMany?: AdminOnSpecCreateManySpecInputEnvelope
    set?: Enumerable<AdminOnSpecWhereUniqueInput>
    disconnect?: Enumerable<AdminOnSpecWhereUniqueInput>
    delete?: Enumerable<AdminOnSpecWhereUniqueInput>
    connect?: Enumerable<AdminOnSpecWhereUniqueInput>
    update?: Enumerable<AdminOnSpecUpdateWithWhereUniqueWithoutSpecInput>
    updateMany?: Enumerable<AdminOnSpecUpdateManyWithWhereWithoutSpecInput>
    deleteMany?: Enumerable<AdminOnSpecScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutUserDataInput = {
    create?: XOR<UserCreateWithoutUserDataInput, UserUncheckedCreateWithoutUserDataInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserDataInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutUserDataNestedInput = {
    create?: XOR<UserCreateWithoutUserDataInput, UserUncheckedCreateWithoutUserDataInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserDataInput
    upsert?: UserUpsertWithoutUserDataInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserDataInput, UserUncheckedUpdateWithoutUserDataInput>
  }

  export type GroupModCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<GroupModCreateWithoutUsersInput>, Enumerable<GroupModUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<GroupModCreateOrConnectWithoutUsersInput>
    createMany?: GroupModCreateManyUsersInputEnvelope
    connect?: Enumerable<GroupModWhereUniqueInput>
  }

  export type GroupUserCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<GroupUserCreateWithoutUsersInput>, Enumerable<GroupUserUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<GroupUserCreateOrConnectWithoutUsersInput>
    createMany?: GroupUserCreateManyUsersInputEnvelope
    connect?: Enumerable<GroupUserWhereUniqueInput>
  }

  export type UserDataCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<UserDataCreateWithoutUsersInput>, Enumerable<UserDataUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<UserDataCreateOrConnectWithoutUsersInput>
    createMany?: UserDataCreateManyUsersInputEnvelope
    connect?: Enumerable<UserDataWhereUniqueInput>
  }

  export type SharedIngredientCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<SharedIngredientCreateWithoutUserInput>, Enumerable<SharedIngredientUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SharedIngredientCreateOrConnectWithoutUserInput>
    createMany?: SharedIngredientCreateManyUserInputEnvelope
    connect?: Enumerable<SharedIngredientWhereUniqueInput>
  }

  export type SharedIngredientCreateNestedManyWithoutSharedByInput = {
    create?: XOR<Enumerable<SharedIngredientCreateWithoutSharedByInput>, Enumerable<SharedIngredientUncheckedCreateWithoutSharedByInput>>
    connectOrCreate?: Enumerable<SharedIngredientCreateOrConnectWithoutSharedByInput>
    createMany?: SharedIngredientCreateManySharedByInputEnvelope
    connect?: Enumerable<SharedIngredientWhereUniqueInput>
  }

  export type SharedSpecCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<SharedSpecCreateWithoutUserInput>, Enumerable<SharedSpecUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SharedSpecCreateOrConnectWithoutUserInput>
    createMany?: SharedSpecCreateManyUserInputEnvelope
    connect?: Enumerable<SharedSpecWhereUniqueInput>
  }

  export type SharedSpecCreateNestedManyWithoutSharedByInput = {
    create?: XOR<Enumerable<SharedSpecCreateWithoutSharedByInput>, Enumerable<SharedSpecUncheckedCreateWithoutSharedByInput>>
    connectOrCreate?: Enumerable<SharedSpecCreateOrConnectWithoutSharedByInput>
    createMany?: SharedSpecCreateManySharedByInputEnvelope
    connect?: Enumerable<SharedSpecWhereUniqueInput>
  }

  export type RecipeCreateNestedManyWithoutPostedByInput = {
    create?: XOR<Enumerable<RecipeCreateWithoutPostedByInput>, Enumerable<RecipeUncheckedCreateWithoutPostedByInput>>
    connectOrCreate?: Enumerable<RecipeCreateOrConnectWithoutPostedByInput>
    createMany?: RecipeCreateManyPostedByInputEnvelope
    connect?: Enumerable<RecipeWhereUniqueInput>
  }

  export type SpecCreateNestedManyWithoutPostedByInput = {
    create?: XOR<Enumerable<SpecCreateWithoutPostedByInput>, Enumerable<SpecUncheckedCreateWithoutPostedByInput>>
    connectOrCreate?: Enumerable<SpecCreateOrConnectWithoutPostedByInput>
    createMany?: SpecCreateManyPostedByInputEnvelope
    connect?: Enumerable<SpecWhereUniqueInput>
  }

  export type IngredientCreateNestedManyWithoutPostedByInput = {
    create?: XOR<Enumerable<IngredientCreateWithoutPostedByInput>, Enumerable<IngredientUncheckedCreateWithoutPostedByInput>>
    connectOrCreate?: Enumerable<IngredientCreateOrConnectWithoutPostedByInput>
    createMany?: IngredientCreateManyPostedByInputEnvelope
    connect?: Enumerable<IngredientWhereUniqueInput>
  }

  export type TouchCreateNestedManyWithoutPostedByInput = {
    create?: XOR<Enumerable<TouchCreateWithoutPostedByInput>, Enumerable<TouchUncheckedCreateWithoutPostedByInput>>
    connectOrCreate?: Enumerable<TouchCreateOrConnectWithoutPostedByInput>
    createMany?: TouchCreateManyPostedByInputEnvelope
    connect?: Enumerable<TouchWhereUniqueInput>
  }

  export type AdminOnSpecCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AdminOnSpecCreateWithoutUserInput>, Enumerable<AdminOnSpecUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AdminOnSpecCreateOrConnectWithoutUserInput>
    createMany?: AdminOnSpecCreateManyUserInputEnvelope
    connect?: Enumerable<AdminOnSpecWhereUniqueInput>
  }

  export type AdminOnSpecCreateNestedManyWithoutAssignedByInput = {
    create?: XOR<Enumerable<AdminOnSpecCreateWithoutAssignedByInput>, Enumerable<AdminOnSpecUncheckedCreateWithoutAssignedByInput>>
    connectOrCreate?: Enumerable<AdminOnSpecCreateOrConnectWithoutAssignedByInput>
    createMany?: AdminOnSpecCreateManyAssignedByInputEnvelope
    connect?: Enumerable<AdminOnSpecWhereUniqueInput>
  }

  export type GroupModUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<GroupModCreateWithoutUsersInput>, Enumerable<GroupModUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<GroupModCreateOrConnectWithoutUsersInput>
    createMany?: GroupModCreateManyUsersInputEnvelope
    connect?: Enumerable<GroupModWhereUniqueInput>
  }

  export type GroupUserUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<GroupUserCreateWithoutUsersInput>, Enumerable<GroupUserUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<GroupUserCreateOrConnectWithoutUsersInput>
    createMany?: GroupUserCreateManyUsersInputEnvelope
    connect?: Enumerable<GroupUserWhereUniqueInput>
  }

  export type UserDataUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<UserDataCreateWithoutUsersInput>, Enumerable<UserDataUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<UserDataCreateOrConnectWithoutUsersInput>
    createMany?: UserDataCreateManyUsersInputEnvelope
    connect?: Enumerable<UserDataWhereUniqueInput>
  }

  export type SharedIngredientUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<SharedIngredientCreateWithoutUserInput>, Enumerable<SharedIngredientUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SharedIngredientCreateOrConnectWithoutUserInput>
    createMany?: SharedIngredientCreateManyUserInputEnvelope
    connect?: Enumerable<SharedIngredientWhereUniqueInput>
  }

  export type SharedIngredientUncheckedCreateNestedManyWithoutSharedByInput = {
    create?: XOR<Enumerable<SharedIngredientCreateWithoutSharedByInput>, Enumerable<SharedIngredientUncheckedCreateWithoutSharedByInput>>
    connectOrCreate?: Enumerable<SharedIngredientCreateOrConnectWithoutSharedByInput>
    createMany?: SharedIngredientCreateManySharedByInputEnvelope
    connect?: Enumerable<SharedIngredientWhereUniqueInput>
  }

  export type SharedSpecUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<SharedSpecCreateWithoutUserInput>, Enumerable<SharedSpecUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SharedSpecCreateOrConnectWithoutUserInput>
    createMany?: SharedSpecCreateManyUserInputEnvelope
    connect?: Enumerable<SharedSpecWhereUniqueInput>
  }

  export type SharedSpecUncheckedCreateNestedManyWithoutSharedByInput = {
    create?: XOR<Enumerable<SharedSpecCreateWithoutSharedByInput>, Enumerable<SharedSpecUncheckedCreateWithoutSharedByInput>>
    connectOrCreate?: Enumerable<SharedSpecCreateOrConnectWithoutSharedByInput>
    createMany?: SharedSpecCreateManySharedByInputEnvelope
    connect?: Enumerable<SharedSpecWhereUniqueInput>
  }

  export type RecipeUncheckedCreateNestedManyWithoutPostedByInput = {
    create?: XOR<Enumerable<RecipeCreateWithoutPostedByInput>, Enumerable<RecipeUncheckedCreateWithoutPostedByInput>>
    connectOrCreate?: Enumerable<RecipeCreateOrConnectWithoutPostedByInput>
    createMany?: RecipeCreateManyPostedByInputEnvelope
    connect?: Enumerable<RecipeWhereUniqueInput>
  }

  export type SpecUncheckedCreateNestedManyWithoutPostedByInput = {
    create?: XOR<Enumerable<SpecCreateWithoutPostedByInput>, Enumerable<SpecUncheckedCreateWithoutPostedByInput>>
    connectOrCreate?: Enumerable<SpecCreateOrConnectWithoutPostedByInput>
    createMany?: SpecCreateManyPostedByInputEnvelope
    connect?: Enumerable<SpecWhereUniqueInput>
  }

  export type IngredientUncheckedCreateNestedManyWithoutPostedByInput = {
    create?: XOR<Enumerable<IngredientCreateWithoutPostedByInput>, Enumerable<IngredientUncheckedCreateWithoutPostedByInput>>
    connectOrCreate?: Enumerable<IngredientCreateOrConnectWithoutPostedByInput>
    createMany?: IngredientCreateManyPostedByInputEnvelope
    connect?: Enumerable<IngredientWhereUniqueInput>
  }

  export type TouchUncheckedCreateNestedManyWithoutPostedByInput = {
    create?: XOR<Enumerable<TouchCreateWithoutPostedByInput>, Enumerable<TouchUncheckedCreateWithoutPostedByInput>>
    connectOrCreate?: Enumerable<TouchCreateOrConnectWithoutPostedByInput>
    createMany?: TouchCreateManyPostedByInputEnvelope
    connect?: Enumerable<TouchWhereUniqueInput>
  }

  export type AdminOnSpecUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AdminOnSpecCreateWithoutUserInput>, Enumerable<AdminOnSpecUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AdminOnSpecCreateOrConnectWithoutUserInput>
    createMany?: AdminOnSpecCreateManyUserInputEnvelope
    connect?: Enumerable<AdminOnSpecWhereUniqueInput>
  }

  export type AdminOnSpecUncheckedCreateNestedManyWithoutAssignedByInput = {
    create?: XOR<Enumerable<AdminOnSpecCreateWithoutAssignedByInput>, Enumerable<AdminOnSpecUncheckedCreateWithoutAssignedByInput>>
    connectOrCreate?: Enumerable<AdminOnSpecCreateOrConnectWithoutAssignedByInput>
    createMany?: AdminOnSpecCreateManyAssignedByInputEnvelope
    connect?: Enumerable<AdminOnSpecWhereUniqueInput>
  }

  export type GroupModUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<GroupModCreateWithoutUsersInput>, Enumerable<GroupModUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<GroupModCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<GroupModUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: GroupModCreateManyUsersInputEnvelope
    set?: Enumerable<GroupModWhereUniqueInput>
    disconnect?: Enumerable<GroupModWhereUniqueInput>
    delete?: Enumerable<GroupModWhereUniqueInput>
    connect?: Enumerable<GroupModWhereUniqueInput>
    update?: Enumerable<GroupModUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<GroupModUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<GroupModScalarWhereInput>
  }

  export type GroupUserUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<GroupUserCreateWithoutUsersInput>, Enumerable<GroupUserUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<GroupUserCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<GroupUserUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: GroupUserCreateManyUsersInputEnvelope
    set?: Enumerable<GroupUserWhereUniqueInput>
    disconnect?: Enumerable<GroupUserWhereUniqueInput>
    delete?: Enumerable<GroupUserWhereUniqueInput>
    connect?: Enumerable<GroupUserWhereUniqueInput>
    update?: Enumerable<GroupUserUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<GroupUserUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<GroupUserScalarWhereInput>
  }

  export type UserDataUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<UserDataCreateWithoutUsersInput>, Enumerable<UserDataUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<UserDataCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<UserDataUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: UserDataCreateManyUsersInputEnvelope
    set?: Enumerable<UserDataWhereUniqueInput>
    disconnect?: Enumerable<UserDataWhereUniqueInput>
    delete?: Enumerable<UserDataWhereUniqueInput>
    connect?: Enumerable<UserDataWhereUniqueInput>
    update?: Enumerable<UserDataUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<UserDataUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<UserDataScalarWhereInput>
  }

  export type SharedIngredientUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<SharedIngredientCreateWithoutUserInput>, Enumerable<SharedIngredientUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SharedIngredientCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<SharedIngredientUpsertWithWhereUniqueWithoutUserInput>
    createMany?: SharedIngredientCreateManyUserInputEnvelope
    set?: Enumerable<SharedIngredientWhereUniqueInput>
    disconnect?: Enumerable<SharedIngredientWhereUniqueInput>
    delete?: Enumerable<SharedIngredientWhereUniqueInput>
    connect?: Enumerable<SharedIngredientWhereUniqueInput>
    update?: Enumerable<SharedIngredientUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<SharedIngredientUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<SharedIngredientScalarWhereInput>
  }

  export type SharedIngredientUpdateManyWithoutSharedByNestedInput = {
    create?: XOR<Enumerable<SharedIngredientCreateWithoutSharedByInput>, Enumerable<SharedIngredientUncheckedCreateWithoutSharedByInput>>
    connectOrCreate?: Enumerable<SharedIngredientCreateOrConnectWithoutSharedByInput>
    upsert?: Enumerable<SharedIngredientUpsertWithWhereUniqueWithoutSharedByInput>
    createMany?: SharedIngredientCreateManySharedByInputEnvelope
    set?: Enumerable<SharedIngredientWhereUniqueInput>
    disconnect?: Enumerable<SharedIngredientWhereUniqueInput>
    delete?: Enumerable<SharedIngredientWhereUniqueInput>
    connect?: Enumerable<SharedIngredientWhereUniqueInput>
    update?: Enumerable<SharedIngredientUpdateWithWhereUniqueWithoutSharedByInput>
    updateMany?: Enumerable<SharedIngredientUpdateManyWithWhereWithoutSharedByInput>
    deleteMany?: Enumerable<SharedIngredientScalarWhereInput>
  }

  export type SharedSpecUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<SharedSpecCreateWithoutUserInput>, Enumerable<SharedSpecUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SharedSpecCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<SharedSpecUpsertWithWhereUniqueWithoutUserInput>
    createMany?: SharedSpecCreateManyUserInputEnvelope
    set?: Enumerable<SharedSpecWhereUniqueInput>
    disconnect?: Enumerable<SharedSpecWhereUniqueInput>
    delete?: Enumerable<SharedSpecWhereUniqueInput>
    connect?: Enumerable<SharedSpecWhereUniqueInput>
    update?: Enumerable<SharedSpecUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<SharedSpecUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<SharedSpecScalarWhereInput>
  }

  export type SharedSpecUpdateManyWithoutSharedByNestedInput = {
    create?: XOR<Enumerable<SharedSpecCreateWithoutSharedByInput>, Enumerable<SharedSpecUncheckedCreateWithoutSharedByInput>>
    connectOrCreate?: Enumerable<SharedSpecCreateOrConnectWithoutSharedByInput>
    upsert?: Enumerable<SharedSpecUpsertWithWhereUniqueWithoutSharedByInput>
    createMany?: SharedSpecCreateManySharedByInputEnvelope
    set?: Enumerable<SharedSpecWhereUniqueInput>
    disconnect?: Enumerable<SharedSpecWhereUniqueInput>
    delete?: Enumerable<SharedSpecWhereUniqueInput>
    connect?: Enumerable<SharedSpecWhereUniqueInput>
    update?: Enumerable<SharedSpecUpdateWithWhereUniqueWithoutSharedByInput>
    updateMany?: Enumerable<SharedSpecUpdateManyWithWhereWithoutSharedByInput>
    deleteMany?: Enumerable<SharedSpecScalarWhereInput>
  }

  export type RecipeUpdateManyWithoutPostedByNestedInput = {
    create?: XOR<Enumerable<RecipeCreateWithoutPostedByInput>, Enumerable<RecipeUncheckedCreateWithoutPostedByInput>>
    connectOrCreate?: Enumerable<RecipeCreateOrConnectWithoutPostedByInput>
    upsert?: Enumerable<RecipeUpsertWithWhereUniqueWithoutPostedByInput>
    createMany?: RecipeCreateManyPostedByInputEnvelope
    set?: Enumerable<RecipeWhereUniqueInput>
    disconnect?: Enumerable<RecipeWhereUniqueInput>
    delete?: Enumerable<RecipeWhereUniqueInput>
    connect?: Enumerable<RecipeWhereUniqueInput>
    update?: Enumerable<RecipeUpdateWithWhereUniqueWithoutPostedByInput>
    updateMany?: Enumerable<RecipeUpdateManyWithWhereWithoutPostedByInput>
    deleteMany?: Enumerable<RecipeScalarWhereInput>
  }

  export type SpecUpdateManyWithoutPostedByNestedInput = {
    create?: XOR<Enumerable<SpecCreateWithoutPostedByInput>, Enumerable<SpecUncheckedCreateWithoutPostedByInput>>
    connectOrCreate?: Enumerable<SpecCreateOrConnectWithoutPostedByInput>
    upsert?: Enumerable<SpecUpsertWithWhereUniqueWithoutPostedByInput>
    createMany?: SpecCreateManyPostedByInputEnvelope
    set?: Enumerable<SpecWhereUniqueInput>
    disconnect?: Enumerable<SpecWhereUniqueInput>
    delete?: Enumerable<SpecWhereUniqueInput>
    connect?: Enumerable<SpecWhereUniqueInput>
    update?: Enumerable<SpecUpdateWithWhereUniqueWithoutPostedByInput>
    updateMany?: Enumerable<SpecUpdateManyWithWhereWithoutPostedByInput>
    deleteMany?: Enumerable<SpecScalarWhereInput>
  }

  export type IngredientUpdateManyWithoutPostedByNestedInput = {
    create?: XOR<Enumerable<IngredientCreateWithoutPostedByInput>, Enumerable<IngredientUncheckedCreateWithoutPostedByInput>>
    connectOrCreate?: Enumerable<IngredientCreateOrConnectWithoutPostedByInput>
    upsert?: Enumerable<IngredientUpsertWithWhereUniqueWithoutPostedByInput>
    createMany?: IngredientCreateManyPostedByInputEnvelope
    set?: Enumerable<IngredientWhereUniqueInput>
    disconnect?: Enumerable<IngredientWhereUniqueInput>
    delete?: Enumerable<IngredientWhereUniqueInput>
    connect?: Enumerable<IngredientWhereUniqueInput>
    update?: Enumerable<IngredientUpdateWithWhereUniqueWithoutPostedByInput>
    updateMany?: Enumerable<IngredientUpdateManyWithWhereWithoutPostedByInput>
    deleteMany?: Enumerable<IngredientScalarWhereInput>
  }

  export type TouchUpdateManyWithoutPostedByNestedInput = {
    create?: XOR<Enumerable<TouchCreateWithoutPostedByInput>, Enumerable<TouchUncheckedCreateWithoutPostedByInput>>
    connectOrCreate?: Enumerable<TouchCreateOrConnectWithoutPostedByInput>
    upsert?: Enumerable<TouchUpsertWithWhereUniqueWithoutPostedByInput>
    createMany?: TouchCreateManyPostedByInputEnvelope
    set?: Enumerable<TouchWhereUniqueInput>
    disconnect?: Enumerable<TouchWhereUniqueInput>
    delete?: Enumerable<TouchWhereUniqueInput>
    connect?: Enumerable<TouchWhereUniqueInput>
    update?: Enumerable<TouchUpdateWithWhereUniqueWithoutPostedByInput>
    updateMany?: Enumerable<TouchUpdateManyWithWhereWithoutPostedByInput>
    deleteMany?: Enumerable<TouchScalarWhereInput>
  }

  export type AdminOnSpecUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AdminOnSpecCreateWithoutUserInput>, Enumerable<AdminOnSpecUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AdminOnSpecCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AdminOnSpecUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AdminOnSpecCreateManyUserInputEnvelope
    set?: Enumerable<AdminOnSpecWhereUniqueInput>
    disconnect?: Enumerable<AdminOnSpecWhereUniqueInput>
    delete?: Enumerable<AdminOnSpecWhereUniqueInput>
    connect?: Enumerable<AdminOnSpecWhereUniqueInput>
    update?: Enumerable<AdminOnSpecUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AdminOnSpecUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AdminOnSpecScalarWhereInput>
  }

  export type AdminOnSpecUpdateManyWithoutAssignedByNestedInput = {
    create?: XOR<Enumerable<AdminOnSpecCreateWithoutAssignedByInput>, Enumerable<AdminOnSpecUncheckedCreateWithoutAssignedByInput>>
    connectOrCreate?: Enumerable<AdminOnSpecCreateOrConnectWithoutAssignedByInput>
    upsert?: Enumerable<AdminOnSpecUpsertWithWhereUniqueWithoutAssignedByInput>
    createMany?: AdminOnSpecCreateManyAssignedByInputEnvelope
    set?: Enumerable<AdminOnSpecWhereUniqueInput>
    disconnect?: Enumerable<AdminOnSpecWhereUniqueInput>
    delete?: Enumerable<AdminOnSpecWhereUniqueInput>
    connect?: Enumerable<AdminOnSpecWhereUniqueInput>
    update?: Enumerable<AdminOnSpecUpdateWithWhereUniqueWithoutAssignedByInput>
    updateMany?: Enumerable<AdminOnSpecUpdateManyWithWhereWithoutAssignedByInput>
    deleteMany?: Enumerable<AdminOnSpecScalarWhereInput>
  }

  export type GroupModUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<GroupModCreateWithoutUsersInput>, Enumerable<GroupModUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<GroupModCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<GroupModUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: GroupModCreateManyUsersInputEnvelope
    set?: Enumerable<GroupModWhereUniqueInput>
    disconnect?: Enumerable<GroupModWhereUniqueInput>
    delete?: Enumerable<GroupModWhereUniqueInput>
    connect?: Enumerable<GroupModWhereUniqueInput>
    update?: Enumerable<GroupModUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<GroupModUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<GroupModScalarWhereInput>
  }

  export type GroupUserUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<GroupUserCreateWithoutUsersInput>, Enumerable<GroupUserUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<GroupUserCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<GroupUserUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: GroupUserCreateManyUsersInputEnvelope
    set?: Enumerable<GroupUserWhereUniqueInput>
    disconnect?: Enumerable<GroupUserWhereUniqueInput>
    delete?: Enumerable<GroupUserWhereUniqueInput>
    connect?: Enumerable<GroupUserWhereUniqueInput>
    update?: Enumerable<GroupUserUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<GroupUserUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<GroupUserScalarWhereInput>
  }

  export type UserDataUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<UserDataCreateWithoutUsersInput>, Enumerable<UserDataUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<UserDataCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<UserDataUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: UserDataCreateManyUsersInputEnvelope
    set?: Enumerable<UserDataWhereUniqueInput>
    disconnect?: Enumerable<UserDataWhereUniqueInput>
    delete?: Enumerable<UserDataWhereUniqueInput>
    connect?: Enumerable<UserDataWhereUniqueInput>
    update?: Enumerable<UserDataUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<UserDataUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<UserDataScalarWhereInput>
  }

  export type SharedIngredientUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<SharedIngredientCreateWithoutUserInput>, Enumerable<SharedIngredientUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SharedIngredientCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<SharedIngredientUpsertWithWhereUniqueWithoutUserInput>
    createMany?: SharedIngredientCreateManyUserInputEnvelope
    set?: Enumerable<SharedIngredientWhereUniqueInput>
    disconnect?: Enumerable<SharedIngredientWhereUniqueInput>
    delete?: Enumerable<SharedIngredientWhereUniqueInput>
    connect?: Enumerable<SharedIngredientWhereUniqueInput>
    update?: Enumerable<SharedIngredientUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<SharedIngredientUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<SharedIngredientScalarWhereInput>
  }

  export type SharedIngredientUncheckedUpdateManyWithoutSharedByNestedInput = {
    create?: XOR<Enumerable<SharedIngredientCreateWithoutSharedByInput>, Enumerable<SharedIngredientUncheckedCreateWithoutSharedByInput>>
    connectOrCreate?: Enumerable<SharedIngredientCreateOrConnectWithoutSharedByInput>
    upsert?: Enumerable<SharedIngredientUpsertWithWhereUniqueWithoutSharedByInput>
    createMany?: SharedIngredientCreateManySharedByInputEnvelope
    set?: Enumerable<SharedIngredientWhereUniqueInput>
    disconnect?: Enumerable<SharedIngredientWhereUniqueInput>
    delete?: Enumerable<SharedIngredientWhereUniqueInput>
    connect?: Enumerable<SharedIngredientWhereUniqueInput>
    update?: Enumerable<SharedIngredientUpdateWithWhereUniqueWithoutSharedByInput>
    updateMany?: Enumerable<SharedIngredientUpdateManyWithWhereWithoutSharedByInput>
    deleteMany?: Enumerable<SharedIngredientScalarWhereInput>
  }

  export type SharedSpecUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<SharedSpecCreateWithoutUserInput>, Enumerable<SharedSpecUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SharedSpecCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<SharedSpecUpsertWithWhereUniqueWithoutUserInput>
    createMany?: SharedSpecCreateManyUserInputEnvelope
    set?: Enumerable<SharedSpecWhereUniqueInput>
    disconnect?: Enumerable<SharedSpecWhereUniqueInput>
    delete?: Enumerable<SharedSpecWhereUniqueInput>
    connect?: Enumerable<SharedSpecWhereUniqueInput>
    update?: Enumerable<SharedSpecUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<SharedSpecUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<SharedSpecScalarWhereInput>
  }

  export type SharedSpecUncheckedUpdateManyWithoutSharedByNestedInput = {
    create?: XOR<Enumerable<SharedSpecCreateWithoutSharedByInput>, Enumerable<SharedSpecUncheckedCreateWithoutSharedByInput>>
    connectOrCreate?: Enumerable<SharedSpecCreateOrConnectWithoutSharedByInput>
    upsert?: Enumerable<SharedSpecUpsertWithWhereUniqueWithoutSharedByInput>
    createMany?: SharedSpecCreateManySharedByInputEnvelope
    set?: Enumerable<SharedSpecWhereUniqueInput>
    disconnect?: Enumerable<SharedSpecWhereUniqueInput>
    delete?: Enumerable<SharedSpecWhereUniqueInput>
    connect?: Enumerable<SharedSpecWhereUniqueInput>
    update?: Enumerable<SharedSpecUpdateWithWhereUniqueWithoutSharedByInput>
    updateMany?: Enumerable<SharedSpecUpdateManyWithWhereWithoutSharedByInput>
    deleteMany?: Enumerable<SharedSpecScalarWhereInput>
  }

  export type RecipeUncheckedUpdateManyWithoutPostedByNestedInput = {
    create?: XOR<Enumerable<RecipeCreateWithoutPostedByInput>, Enumerable<RecipeUncheckedCreateWithoutPostedByInput>>
    connectOrCreate?: Enumerable<RecipeCreateOrConnectWithoutPostedByInput>
    upsert?: Enumerable<RecipeUpsertWithWhereUniqueWithoutPostedByInput>
    createMany?: RecipeCreateManyPostedByInputEnvelope
    set?: Enumerable<RecipeWhereUniqueInput>
    disconnect?: Enumerable<RecipeWhereUniqueInput>
    delete?: Enumerable<RecipeWhereUniqueInput>
    connect?: Enumerable<RecipeWhereUniqueInput>
    update?: Enumerable<RecipeUpdateWithWhereUniqueWithoutPostedByInput>
    updateMany?: Enumerable<RecipeUpdateManyWithWhereWithoutPostedByInput>
    deleteMany?: Enumerable<RecipeScalarWhereInput>
  }

  export type SpecUncheckedUpdateManyWithoutPostedByNestedInput = {
    create?: XOR<Enumerable<SpecCreateWithoutPostedByInput>, Enumerable<SpecUncheckedCreateWithoutPostedByInput>>
    connectOrCreate?: Enumerable<SpecCreateOrConnectWithoutPostedByInput>
    upsert?: Enumerable<SpecUpsertWithWhereUniqueWithoutPostedByInput>
    createMany?: SpecCreateManyPostedByInputEnvelope
    set?: Enumerable<SpecWhereUniqueInput>
    disconnect?: Enumerable<SpecWhereUniqueInput>
    delete?: Enumerable<SpecWhereUniqueInput>
    connect?: Enumerable<SpecWhereUniqueInput>
    update?: Enumerable<SpecUpdateWithWhereUniqueWithoutPostedByInput>
    updateMany?: Enumerable<SpecUpdateManyWithWhereWithoutPostedByInput>
    deleteMany?: Enumerable<SpecScalarWhereInput>
  }

  export type IngredientUncheckedUpdateManyWithoutPostedByNestedInput = {
    create?: XOR<Enumerable<IngredientCreateWithoutPostedByInput>, Enumerable<IngredientUncheckedCreateWithoutPostedByInput>>
    connectOrCreate?: Enumerable<IngredientCreateOrConnectWithoutPostedByInput>
    upsert?: Enumerable<IngredientUpsertWithWhereUniqueWithoutPostedByInput>
    createMany?: IngredientCreateManyPostedByInputEnvelope
    set?: Enumerable<IngredientWhereUniqueInput>
    disconnect?: Enumerable<IngredientWhereUniqueInput>
    delete?: Enumerable<IngredientWhereUniqueInput>
    connect?: Enumerable<IngredientWhereUniqueInput>
    update?: Enumerable<IngredientUpdateWithWhereUniqueWithoutPostedByInput>
    updateMany?: Enumerable<IngredientUpdateManyWithWhereWithoutPostedByInput>
    deleteMany?: Enumerable<IngredientScalarWhereInput>
  }

  export type TouchUncheckedUpdateManyWithoutPostedByNestedInput = {
    create?: XOR<Enumerable<TouchCreateWithoutPostedByInput>, Enumerable<TouchUncheckedCreateWithoutPostedByInput>>
    connectOrCreate?: Enumerable<TouchCreateOrConnectWithoutPostedByInput>
    upsert?: Enumerable<TouchUpsertWithWhereUniqueWithoutPostedByInput>
    createMany?: TouchCreateManyPostedByInputEnvelope
    set?: Enumerable<TouchWhereUniqueInput>
    disconnect?: Enumerable<TouchWhereUniqueInput>
    delete?: Enumerable<TouchWhereUniqueInput>
    connect?: Enumerable<TouchWhereUniqueInput>
    update?: Enumerable<TouchUpdateWithWhereUniqueWithoutPostedByInput>
    updateMany?: Enumerable<TouchUpdateManyWithWhereWithoutPostedByInput>
    deleteMany?: Enumerable<TouchScalarWhereInput>
  }

  export type AdminOnSpecUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AdminOnSpecCreateWithoutUserInput>, Enumerable<AdminOnSpecUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AdminOnSpecCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AdminOnSpecUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AdminOnSpecCreateManyUserInputEnvelope
    set?: Enumerable<AdminOnSpecWhereUniqueInput>
    disconnect?: Enumerable<AdminOnSpecWhereUniqueInput>
    delete?: Enumerable<AdminOnSpecWhereUniqueInput>
    connect?: Enumerable<AdminOnSpecWhereUniqueInput>
    update?: Enumerable<AdminOnSpecUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AdminOnSpecUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AdminOnSpecScalarWhereInput>
  }

  export type AdminOnSpecUncheckedUpdateManyWithoutAssignedByNestedInput = {
    create?: XOR<Enumerable<AdminOnSpecCreateWithoutAssignedByInput>, Enumerable<AdminOnSpecUncheckedCreateWithoutAssignedByInput>>
    connectOrCreate?: Enumerable<AdminOnSpecCreateOrConnectWithoutAssignedByInput>
    upsert?: Enumerable<AdminOnSpecUpsertWithWhereUniqueWithoutAssignedByInput>
    createMany?: AdminOnSpecCreateManyAssignedByInputEnvelope
    set?: Enumerable<AdminOnSpecWhereUniqueInput>
    disconnect?: Enumerable<AdminOnSpecWhereUniqueInput>
    delete?: Enumerable<AdminOnSpecWhereUniqueInput>
    connect?: Enumerable<AdminOnSpecWhereUniqueInput>
    update?: Enumerable<AdminOnSpecUpdateWithWhereUniqueWithoutAssignedByInput>
    updateMany?: Enumerable<AdminOnSpecUpdateManyWithWhereWithoutAssignedByInput>
    deleteMany?: Enumerable<AdminOnSpecScalarWhereInput>
  }

  export type IngredientCreateNestedOneWithoutSharedIngredientInput = {
    create?: XOR<IngredientCreateWithoutSharedIngredientInput, IngredientUncheckedCreateWithoutSharedIngredientInput>
    connectOrCreate?: IngredientCreateOrConnectWithoutSharedIngredientInput
    connect?: IngredientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSharedIngredientInput = {
    create?: XOR<UserCreateWithoutSharedIngredientInput, UserUncheckedCreateWithoutSharedIngredientInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharedIngredientInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutIngredientSharedByInput = {
    create?: XOR<UserCreateWithoutIngredientSharedByInput, UserUncheckedCreateWithoutIngredientSharedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutIngredientSharedByInput
    connect?: UserWhereUniqueInput
  }

  export type IngredientUpdateOneRequiredWithoutSharedIngredientNestedInput = {
    create?: XOR<IngredientCreateWithoutSharedIngredientInput, IngredientUncheckedCreateWithoutSharedIngredientInput>
    connectOrCreate?: IngredientCreateOrConnectWithoutSharedIngredientInput
    upsert?: IngredientUpsertWithoutSharedIngredientInput
    connect?: IngredientWhereUniqueInput
    update?: XOR<IngredientUpdateWithoutSharedIngredientInput, IngredientUncheckedUpdateWithoutSharedIngredientInput>
  }

  export type UserUpdateOneRequiredWithoutSharedIngredientNestedInput = {
    create?: XOR<UserCreateWithoutSharedIngredientInput, UserUncheckedCreateWithoutSharedIngredientInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharedIngredientInput
    upsert?: UserUpsertWithoutSharedIngredientInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutSharedIngredientInput, UserUncheckedUpdateWithoutSharedIngredientInput>
  }

  export type UserUpdateOneRequiredWithoutIngredientSharedByNestedInput = {
    create?: XOR<UserCreateWithoutIngredientSharedByInput, UserUncheckedCreateWithoutIngredientSharedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutIngredientSharedByInput
    upsert?: UserUpsertWithoutIngredientSharedByInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutIngredientSharedByInput, UserUncheckedUpdateWithoutIngredientSharedByInput>
  }

  export type SpecCreateNestedOneWithoutSharedSpecInput = {
    create?: XOR<SpecCreateWithoutSharedSpecInput, SpecUncheckedCreateWithoutSharedSpecInput>
    connectOrCreate?: SpecCreateOrConnectWithoutSharedSpecInput
    connect?: SpecWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSharedSpecInput = {
    create?: XOR<UserCreateWithoutSharedSpecInput, UserUncheckedCreateWithoutSharedSpecInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharedSpecInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSpecSharedByInput = {
    create?: XOR<UserCreateWithoutSpecSharedByInput, UserUncheckedCreateWithoutSpecSharedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutSpecSharedByInput
    connect?: UserWhereUniqueInput
  }

  export type SpecUpdateOneRequiredWithoutSharedSpecNestedInput = {
    create?: XOR<SpecCreateWithoutSharedSpecInput, SpecUncheckedCreateWithoutSharedSpecInput>
    connectOrCreate?: SpecCreateOrConnectWithoutSharedSpecInput
    upsert?: SpecUpsertWithoutSharedSpecInput
    connect?: SpecWhereUniqueInput
    update?: XOR<SpecUpdateWithoutSharedSpecInput, SpecUncheckedUpdateWithoutSharedSpecInput>
  }

  export type UserUpdateOneRequiredWithoutSharedSpecNestedInput = {
    create?: XOR<UserCreateWithoutSharedSpecInput, UserUncheckedCreateWithoutSharedSpecInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharedSpecInput
    upsert?: UserUpsertWithoutSharedSpecInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutSharedSpecInput, UserUncheckedUpdateWithoutSharedSpecInput>
  }

  export type UserUpdateOneRequiredWithoutSpecSharedByNestedInput = {
    create?: XOR<UserCreateWithoutSpecSharedByInput, UserUncheckedCreateWithoutSpecSharedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutSpecSharedByInput
    upsert?: UserUpsertWithoutSpecSharedByInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutSpecSharedByInput, UserUncheckedUpdateWithoutSpecSharedByInput>
  }

  export type SpecCreateNestedOneWithoutAdminOnSpecInput = {
    create?: XOR<SpecCreateWithoutAdminOnSpecInput, SpecUncheckedCreateWithoutAdminOnSpecInput>
    connectOrCreate?: SpecCreateOrConnectWithoutAdminOnSpecInput
    connect?: SpecWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAdminOnSpecInput = {
    create?: XOR<UserCreateWithoutAdminOnSpecInput, UserUncheckedCreateWithoutAdminOnSpecInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminOnSpecInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAdminAssignedByInput = {
    create?: XOR<UserCreateWithoutAdminAssignedByInput, UserUncheckedCreateWithoutAdminAssignedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminAssignedByInput
    connect?: UserWhereUniqueInput
  }

  export type SpecUpdateOneRequiredWithoutAdminOnSpecNestedInput = {
    create?: XOR<SpecCreateWithoutAdminOnSpecInput, SpecUncheckedCreateWithoutAdminOnSpecInput>
    connectOrCreate?: SpecCreateOrConnectWithoutAdminOnSpecInput
    upsert?: SpecUpsertWithoutAdminOnSpecInput
    connect?: SpecWhereUniqueInput
    update?: XOR<SpecUpdateWithoutAdminOnSpecInput, SpecUncheckedUpdateWithoutAdminOnSpecInput>
  }

  export type UserUpdateOneRequiredWithoutAdminOnSpecNestedInput = {
    create?: XOR<UserCreateWithoutAdminOnSpecInput, UserUncheckedCreateWithoutAdminOnSpecInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminOnSpecInput
    upsert?: UserUpsertWithoutAdminOnSpecInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAdminOnSpecInput, UserUncheckedUpdateWithoutAdminOnSpecInput>
  }

  export type UserUpdateOneRequiredWithoutAdminAssignedByNestedInput = {
    create?: XOR<UserCreateWithoutAdminAssignedByInput, UserUncheckedCreateWithoutAdminAssignedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminAssignedByInput
    upsert?: UserUpsertWithoutAdminAssignedByInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAdminAssignedByInput, UserUncheckedUpdateWithoutAdminAssignedByInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedDecimalNullableFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedDecimalNullableWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type GroupIngredientCreateWithoutGroupsInput = {
    ingredient: IngredientCreateNestedOneWithoutGroupIngredientInput
  }

  export type GroupIngredientUncheckedCreateWithoutGroupsInput = {
    ingredientId: number
  }

  export type GroupIngredientCreateOrConnectWithoutGroupsInput = {
    where: GroupIngredientWhereUniqueInput
    create: XOR<GroupIngredientCreateWithoutGroupsInput, GroupIngredientUncheckedCreateWithoutGroupsInput>
  }

  export type GroupIngredientCreateManyGroupsInputEnvelope = {
    data: Enumerable<GroupIngredientCreateManyGroupsInput>
    skipDuplicates?: boolean
  }

  export type GroupModCreateWithoutGroupsInput = {
    users: UserCreateNestedOneWithoutGroupModInput
  }

  export type GroupModUncheckedCreateWithoutGroupsInput = {
    userId: string
  }

  export type GroupModCreateOrConnectWithoutGroupsInput = {
    where: GroupModWhereUniqueInput
    create: XOR<GroupModCreateWithoutGroupsInput, GroupModUncheckedCreateWithoutGroupsInput>
  }

  export type GroupModCreateManyGroupsInputEnvelope = {
    data: Enumerable<GroupModCreateManyGroupsInput>
    skipDuplicates?: boolean
  }

  export type GroupSpecCreateWithoutGroupsInput = {
    spec: SpecCreateNestedOneWithoutGroupSpecInput
  }

  export type GroupSpecUncheckedCreateWithoutGroupsInput = {
    specId: number
  }

  export type GroupSpecCreateOrConnectWithoutGroupsInput = {
    where: GroupSpecWhereUniqueInput
    create: XOR<GroupSpecCreateWithoutGroupsInput, GroupSpecUncheckedCreateWithoutGroupsInput>
  }

  export type GroupSpecCreateManyGroupsInputEnvelope = {
    data: Enumerable<GroupSpecCreateManyGroupsInput>
    skipDuplicates?: boolean
  }

  export type GroupUserCreateWithoutGroupsInput = {
    users: UserCreateNestedOneWithoutGroupUserInput
  }

  export type GroupUserUncheckedCreateWithoutGroupsInput = {
    userId: string
  }

  export type GroupUserCreateOrConnectWithoutGroupsInput = {
    where: GroupUserWhereUniqueInput
    create: XOR<GroupUserCreateWithoutGroupsInput, GroupUserUncheckedCreateWithoutGroupsInput>
  }

  export type GroupUserCreateManyGroupsInputEnvelope = {
    data: Enumerable<GroupUserCreateManyGroupsInput>
    skipDuplicates?: boolean
  }

  export type GroupIngredientUpsertWithWhereUniqueWithoutGroupsInput = {
    where: GroupIngredientWhereUniqueInput
    update: XOR<GroupIngredientUpdateWithoutGroupsInput, GroupIngredientUncheckedUpdateWithoutGroupsInput>
    create: XOR<GroupIngredientCreateWithoutGroupsInput, GroupIngredientUncheckedCreateWithoutGroupsInput>
  }

  export type GroupIngredientUpdateWithWhereUniqueWithoutGroupsInput = {
    where: GroupIngredientWhereUniqueInput
    data: XOR<GroupIngredientUpdateWithoutGroupsInput, GroupIngredientUncheckedUpdateWithoutGroupsInput>
  }

  export type GroupIngredientUpdateManyWithWhereWithoutGroupsInput = {
    where: GroupIngredientScalarWhereInput
    data: XOR<GroupIngredientUpdateManyMutationInput, GroupIngredientUncheckedUpdateManyWithoutGroupIngredientInput>
  }

  export type GroupIngredientScalarWhereInput = {
    AND?: Enumerable<GroupIngredientScalarWhereInput>
    OR?: Enumerable<GroupIngredientScalarWhereInput>
    NOT?: Enumerable<GroupIngredientScalarWhereInput>
    groupId?: IntFilter | number
    ingredientId?: IntFilter | number
  }

  export type GroupModUpsertWithWhereUniqueWithoutGroupsInput = {
    where: GroupModWhereUniqueInput
    update: XOR<GroupModUpdateWithoutGroupsInput, GroupModUncheckedUpdateWithoutGroupsInput>
    create: XOR<GroupModCreateWithoutGroupsInput, GroupModUncheckedCreateWithoutGroupsInput>
  }

  export type GroupModUpdateWithWhereUniqueWithoutGroupsInput = {
    where: GroupModWhereUniqueInput
    data: XOR<GroupModUpdateWithoutGroupsInput, GroupModUncheckedUpdateWithoutGroupsInput>
  }

  export type GroupModUpdateManyWithWhereWithoutGroupsInput = {
    where: GroupModScalarWhereInput
    data: XOR<GroupModUpdateManyMutationInput, GroupModUncheckedUpdateManyWithoutGroupModInput>
  }

  export type GroupModScalarWhereInput = {
    AND?: Enumerable<GroupModScalarWhereInput>
    OR?: Enumerable<GroupModScalarWhereInput>
    NOT?: Enumerable<GroupModScalarWhereInput>
    userId?: StringFilter | string
    groupId?: IntFilter | number
  }

  export type GroupSpecUpsertWithWhereUniqueWithoutGroupsInput = {
    where: GroupSpecWhereUniqueInput
    update: XOR<GroupSpecUpdateWithoutGroupsInput, GroupSpecUncheckedUpdateWithoutGroupsInput>
    create: XOR<GroupSpecCreateWithoutGroupsInput, GroupSpecUncheckedCreateWithoutGroupsInput>
  }

  export type GroupSpecUpdateWithWhereUniqueWithoutGroupsInput = {
    where: GroupSpecWhereUniqueInput
    data: XOR<GroupSpecUpdateWithoutGroupsInput, GroupSpecUncheckedUpdateWithoutGroupsInput>
  }

  export type GroupSpecUpdateManyWithWhereWithoutGroupsInput = {
    where: GroupSpecScalarWhereInput
    data: XOR<GroupSpecUpdateManyMutationInput, GroupSpecUncheckedUpdateManyWithoutGroupSpecInput>
  }

  export type GroupSpecScalarWhereInput = {
    AND?: Enumerable<GroupSpecScalarWhereInput>
    OR?: Enumerable<GroupSpecScalarWhereInput>
    NOT?: Enumerable<GroupSpecScalarWhereInput>
    groupId?: IntFilter | number
    specId?: IntFilter | number
  }

  export type GroupUserUpsertWithWhereUniqueWithoutGroupsInput = {
    where: GroupUserWhereUniqueInput
    update: XOR<GroupUserUpdateWithoutGroupsInput, GroupUserUncheckedUpdateWithoutGroupsInput>
    create: XOR<GroupUserCreateWithoutGroupsInput, GroupUserUncheckedCreateWithoutGroupsInput>
  }

  export type GroupUserUpdateWithWhereUniqueWithoutGroupsInput = {
    where: GroupUserWhereUniqueInput
    data: XOR<GroupUserUpdateWithoutGroupsInput, GroupUserUncheckedUpdateWithoutGroupsInput>
  }

  export type GroupUserUpdateManyWithWhereWithoutGroupsInput = {
    where: GroupUserScalarWhereInput
    data: XOR<GroupUserUpdateManyMutationInput, GroupUserUncheckedUpdateManyWithoutGroupUserInput>
  }

  export type GroupUserScalarWhereInput = {
    AND?: Enumerable<GroupUserScalarWhereInput>
    OR?: Enumerable<GroupUserScalarWhereInput>
    NOT?: Enumerable<GroupUserScalarWhereInput>
    userId?: StringFilter | string
    groupId?: IntFilter | number
  }

  export type GroupsCreateWithoutGroupIngredientInput = {
    groupName: string
    dateCreated: Date | string
    GroupMod?: GroupModCreateNestedManyWithoutGroupsInput
    GroupSpec?: GroupSpecCreateNestedManyWithoutGroupsInput
    GroupUser?: GroupUserCreateNestedManyWithoutGroupsInput
  }

  export type GroupsUncheckedCreateWithoutGroupIngredientInput = {
    id?: number
    groupName: string
    dateCreated: Date | string
    GroupMod?: GroupModUncheckedCreateNestedManyWithoutGroupsInput
    GroupSpec?: GroupSpecUncheckedCreateNestedManyWithoutGroupsInput
    GroupUser?: GroupUserUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type GroupsCreateOrConnectWithoutGroupIngredientInput = {
    where: GroupsWhereUniqueInput
    create: XOR<GroupsCreateWithoutGroupIngredientInput, GroupsUncheckedCreateWithoutGroupIngredientInput>
  }

  export type IngredientCreateWithoutGroupIngredientInput = {
    dateCreated?: Date | string
    name: string
    amount?: number | null
    unit?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    source?: string | null
    postedBy?: UserCreateNestedOneWithoutIngredientInput
    touch?: TouchCreateNestedManyWithoutIngredientInput
    sharedIngredient?: SharedIngredientCreateNestedManyWithoutIngredientInput
  }

  export type IngredientUncheckedCreateWithoutGroupIngredientInput = {
    id?: number
    dateCreated?: Date | string
    name: string
    amount?: number | null
    unit?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    source?: string | null
    postedById: string
    touch?: TouchUncheckedCreateNestedManyWithoutIngredientInput
    sharedIngredient?: SharedIngredientUncheckedCreateNestedManyWithoutIngredientInput
  }

  export type IngredientCreateOrConnectWithoutGroupIngredientInput = {
    where: IngredientWhereUniqueInput
    create: XOR<IngredientCreateWithoutGroupIngredientInput, IngredientUncheckedCreateWithoutGroupIngredientInput>
  }

  export type GroupsUpsertWithoutGroupIngredientInput = {
    update: XOR<GroupsUpdateWithoutGroupIngredientInput, GroupsUncheckedUpdateWithoutGroupIngredientInput>
    create: XOR<GroupsCreateWithoutGroupIngredientInput, GroupsUncheckedCreateWithoutGroupIngredientInput>
  }

  export type GroupsUpdateWithoutGroupIngredientInput = {
    groupName?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    GroupMod?: GroupModUpdateManyWithoutGroupsNestedInput
    GroupSpec?: GroupSpecUpdateManyWithoutGroupsNestedInput
    GroupUser?: GroupUserUpdateManyWithoutGroupsNestedInput
  }

  export type GroupsUncheckedUpdateWithoutGroupIngredientInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupName?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    GroupMod?: GroupModUncheckedUpdateManyWithoutGroupsNestedInput
    GroupSpec?: GroupSpecUncheckedUpdateManyWithoutGroupsNestedInput
    GroupUser?: GroupUserUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type IngredientUpsertWithoutGroupIngredientInput = {
    update: XOR<IngredientUpdateWithoutGroupIngredientInput, IngredientUncheckedUpdateWithoutGroupIngredientInput>
    create: XOR<IngredientCreateWithoutGroupIngredientInput, IngredientUncheckedCreateWithoutGroupIngredientInput>
  }

  export type IngredientUpdateWithoutGroupIngredientInput = {
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    postedBy?: UserUpdateOneWithoutIngredientNestedInput
    touch?: TouchUpdateManyWithoutIngredientNestedInput
    sharedIngredient?: SharedIngredientUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientUncheckedUpdateWithoutGroupIngredientInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    postedById?: StringFieldUpdateOperationsInput | string
    touch?: TouchUncheckedUpdateManyWithoutIngredientNestedInput
    sharedIngredient?: SharedIngredientUncheckedUpdateManyWithoutIngredientNestedInput
  }

  export type GroupsCreateWithoutGroupModInput = {
    groupName: string
    dateCreated: Date | string
    groupIngredient?: GroupIngredientCreateNestedManyWithoutGroupsInput
    GroupSpec?: GroupSpecCreateNestedManyWithoutGroupsInput
    GroupUser?: GroupUserCreateNestedManyWithoutGroupsInput
  }

  export type GroupsUncheckedCreateWithoutGroupModInput = {
    id?: number
    groupName: string
    dateCreated: Date | string
    groupIngredient?: GroupIngredientUncheckedCreateNestedManyWithoutGroupsInput
    GroupSpec?: GroupSpecUncheckedCreateNestedManyWithoutGroupsInput
    GroupUser?: GroupUserUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type GroupsCreateOrConnectWithoutGroupModInput = {
    where: GroupsWhereUniqueInput
    create: XOR<GroupsCreateWithoutGroupModInput, GroupsUncheckedCreateWithoutGroupModInput>
  }

  export type UserCreateWithoutGroupModInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    email: string
    password: string
    groupUser?: GroupUserCreateNestedManyWithoutUsersInput
    userData?: UserDataCreateNestedManyWithoutUsersInput
    sharedIngredient?: SharedIngredientCreateNestedManyWithoutUserInput
    ingredientSharedBy?: SharedIngredientCreateNestedManyWithoutSharedByInput
    sharedSpec?: SharedSpecCreateNestedManyWithoutUserInput
    specSharedBy?: SharedSpecCreateNestedManyWithoutSharedByInput
    recipes?: RecipeCreateNestedManyWithoutPostedByInput
    spec?: SpecCreateNestedManyWithoutPostedByInput
    ingredient?: IngredientCreateNestedManyWithoutPostedByInput
    touch?: TouchCreateNestedManyWithoutPostedByInput
    adminOnSpec?: AdminOnSpecCreateNestedManyWithoutUserInput
    adminAssignedBy?: AdminOnSpecCreateNestedManyWithoutAssignedByInput
  }

  export type UserUncheckedCreateWithoutGroupModInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    email: string
    password: string
    groupUser?: GroupUserUncheckedCreateNestedManyWithoutUsersInput
    userData?: UserDataUncheckedCreateNestedManyWithoutUsersInput
    sharedIngredient?: SharedIngredientUncheckedCreateNestedManyWithoutUserInput
    ingredientSharedBy?: SharedIngredientUncheckedCreateNestedManyWithoutSharedByInput
    sharedSpec?: SharedSpecUncheckedCreateNestedManyWithoutUserInput
    specSharedBy?: SharedSpecUncheckedCreateNestedManyWithoutSharedByInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutPostedByInput
    spec?: SpecUncheckedCreateNestedManyWithoutPostedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutPostedByInput
    touch?: TouchUncheckedCreateNestedManyWithoutPostedByInput
    adminOnSpec?: AdminOnSpecUncheckedCreateNestedManyWithoutUserInput
    adminAssignedBy?: AdminOnSpecUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type UserCreateOrConnectWithoutGroupModInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGroupModInput, UserUncheckedCreateWithoutGroupModInput>
  }

  export type GroupsUpsertWithoutGroupModInput = {
    update: XOR<GroupsUpdateWithoutGroupModInput, GroupsUncheckedUpdateWithoutGroupModInput>
    create: XOR<GroupsCreateWithoutGroupModInput, GroupsUncheckedCreateWithoutGroupModInput>
  }

  export type GroupsUpdateWithoutGroupModInput = {
    groupName?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    groupIngredient?: GroupIngredientUpdateManyWithoutGroupsNestedInput
    GroupSpec?: GroupSpecUpdateManyWithoutGroupsNestedInput
    GroupUser?: GroupUserUpdateManyWithoutGroupsNestedInput
  }

  export type GroupsUncheckedUpdateWithoutGroupModInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupName?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    groupIngredient?: GroupIngredientUncheckedUpdateManyWithoutGroupsNestedInput
    GroupSpec?: GroupSpecUncheckedUpdateManyWithoutGroupsNestedInput
    GroupUser?: GroupUserUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type UserUpsertWithoutGroupModInput = {
    update: XOR<UserUpdateWithoutGroupModInput, UserUncheckedUpdateWithoutGroupModInput>
    create: XOR<UserCreateWithoutGroupModInput, UserUncheckedCreateWithoutGroupModInput>
  }

  export type UserUpdateWithoutGroupModInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    groupUser?: GroupUserUpdateManyWithoutUsersNestedInput
    userData?: UserDataUpdateManyWithoutUsersNestedInput
    sharedIngredient?: SharedIngredientUpdateManyWithoutUserNestedInput
    ingredientSharedBy?: SharedIngredientUpdateManyWithoutSharedByNestedInput
    sharedSpec?: SharedSpecUpdateManyWithoutUserNestedInput
    specSharedBy?: SharedSpecUpdateManyWithoutSharedByNestedInput
    recipes?: RecipeUpdateManyWithoutPostedByNestedInput
    spec?: SpecUpdateManyWithoutPostedByNestedInput
    ingredient?: IngredientUpdateManyWithoutPostedByNestedInput
    touch?: TouchUpdateManyWithoutPostedByNestedInput
    adminOnSpec?: AdminOnSpecUpdateManyWithoutUserNestedInput
    adminAssignedBy?: AdminOnSpecUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUncheckedUpdateWithoutGroupModInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    groupUser?: GroupUserUncheckedUpdateManyWithoutUsersNestedInput
    userData?: UserDataUncheckedUpdateManyWithoutUsersNestedInput
    sharedIngredient?: SharedIngredientUncheckedUpdateManyWithoutUserNestedInput
    ingredientSharedBy?: SharedIngredientUncheckedUpdateManyWithoutSharedByNestedInput
    sharedSpec?: SharedSpecUncheckedUpdateManyWithoutUserNestedInput
    specSharedBy?: SharedSpecUncheckedUpdateManyWithoutSharedByNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutPostedByNestedInput
    spec?: SpecUncheckedUpdateManyWithoutPostedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutPostedByNestedInput
    touch?: TouchUncheckedUpdateManyWithoutPostedByNestedInput
    adminOnSpec?: AdminOnSpecUncheckedUpdateManyWithoutUserNestedInput
    adminAssignedBy?: AdminOnSpecUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type GroupsCreateWithoutGroupSpecInput = {
    groupName: string
    dateCreated: Date | string
    groupIngredient?: GroupIngredientCreateNestedManyWithoutGroupsInput
    GroupMod?: GroupModCreateNestedManyWithoutGroupsInput
    GroupUser?: GroupUserCreateNestedManyWithoutGroupsInput
  }

  export type GroupsUncheckedCreateWithoutGroupSpecInput = {
    id?: number
    groupName: string
    dateCreated: Date | string
    groupIngredient?: GroupIngredientUncheckedCreateNestedManyWithoutGroupsInput
    GroupMod?: GroupModUncheckedCreateNestedManyWithoutGroupsInput
    GroupUser?: GroupUserUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type GroupsCreateOrConnectWithoutGroupSpecInput = {
    where: GroupsWhereUniqueInput
    create: XOR<GroupsCreateWithoutGroupSpecInput, GroupsUncheckedCreateWithoutGroupSpecInput>
  }

  export type SpecCreateWithoutGroupSpecInput = {
    specName?: string
    postedBy?: UserCreateNestedOneWithoutSpecInput
    instructions?: string | null
    glassware?: string | null
    ice?: string | null
    sharedSpec?: SharedSpecCreateNestedManyWithoutSpecInput
    recipe?: RecipeCreateNestedOneWithoutSpecInput
    touch?: TouchCreateNestedManyWithoutSpecInput
    adminOnSpec?: AdminOnSpecCreateNestedManyWithoutSpecInput
  }

  export type SpecUncheckedCreateWithoutGroupSpecInput = {
    id?: number
    specName?: string
    postedById: string
    instructions?: string | null
    glassware?: string | null
    ice?: string | null
    sharedSpec?: SharedSpecUncheckedCreateNestedManyWithoutSpecInput
    recipeId?: number | null
    touch?: TouchUncheckedCreateNestedManyWithoutSpecInput
    adminOnSpec?: AdminOnSpecUncheckedCreateNestedManyWithoutSpecInput
  }

  export type SpecCreateOrConnectWithoutGroupSpecInput = {
    where: SpecWhereUniqueInput
    create: XOR<SpecCreateWithoutGroupSpecInput, SpecUncheckedCreateWithoutGroupSpecInput>
  }

  export type GroupsUpsertWithoutGroupSpecInput = {
    update: XOR<GroupsUpdateWithoutGroupSpecInput, GroupsUncheckedUpdateWithoutGroupSpecInput>
    create: XOR<GroupsCreateWithoutGroupSpecInput, GroupsUncheckedCreateWithoutGroupSpecInput>
  }

  export type GroupsUpdateWithoutGroupSpecInput = {
    groupName?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    groupIngredient?: GroupIngredientUpdateManyWithoutGroupsNestedInput
    GroupMod?: GroupModUpdateManyWithoutGroupsNestedInput
    GroupUser?: GroupUserUpdateManyWithoutGroupsNestedInput
  }

  export type GroupsUncheckedUpdateWithoutGroupSpecInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupName?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    groupIngredient?: GroupIngredientUncheckedUpdateManyWithoutGroupsNestedInput
    GroupMod?: GroupModUncheckedUpdateManyWithoutGroupsNestedInput
    GroupUser?: GroupUserUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type SpecUpsertWithoutGroupSpecInput = {
    update: XOR<SpecUpdateWithoutGroupSpecInput, SpecUncheckedUpdateWithoutGroupSpecInput>
    create: XOR<SpecCreateWithoutGroupSpecInput, SpecUncheckedCreateWithoutGroupSpecInput>
  }

  export type SpecUpdateWithoutGroupSpecInput = {
    specName?: StringFieldUpdateOperationsInput | string
    postedBy?: UserUpdateOneWithoutSpecNestedInput
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    sharedSpec?: SharedSpecUpdateManyWithoutSpecNestedInput
    recipe?: RecipeUpdateOneWithoutSpecNestedInput
    touch?: TouchUpdateManyWithoutSpecNestedInput
    adminOnSpec?: AdminOnSpecUpdateManyWithoutSpecNestedInput
  }

  export type SpecUncheckedUpdateWithoutGroupSpecInput = {
    id?: IntFieldUpdateOperationsInput | number
    specName?: StringFieldUpdateOperationsInput | string
    postedById?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    sharedSpec?: SharedSpecUncheckedUpdateManyWithoutSpecNestedInput
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
    touch?: TouchUncheckedUpdateManyWithoutSpecNestedInput
    adminOnSpec?: AdminOnSpecUncheckedUpdateManyWithoutSpecNestedInput
  }

  export type GroupsCreateWithoutGroupUserInput = {
    groupName: string
    dateCreated: Date | string
    groupIngredient?: GroupIngredientCreateNestedManyWithoutGroupsInput
    GroupMod?: GroupModCreateNestedManyWithoutGroupsInput
    GroupSpec?: GroupSpecCreateNestedManyWithoutGroupsInput
  }

  export type GroupsUncheckedCreateWithoutGroupUserInput = {
    id?: number
    groupName: string
    dateCreated: Date | string
    groupIngredient?: GroupIngredientUncheckedCreateNestedManyWithoutGroupsInput
    GroupMod?: GroupModUncheckedCreateNestedManyWithoutGroupsInput
    GroupSpec?: GroupSpecUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type GroupsCreateOrConnectWithoutGroupUserInput = {
    where: GroupsWhereUniqueInput
    create: XOR<GroupsCreateWithoutGroupUserInput, GroupsUncheckedCreateWithoutGroupUserInput>
  }

  export type UserCreateWithoutGroupUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    email: string
    password: string
    groupMod?: GroupModCreateNestedManyWithoutUsersInput
    userData?: UserDataCreateNestedManyWithoutUsersInput
    sharedIngredient?: SharedIngredientCreateNestedManyWithoutUserInput
    ingredientSharedBy?: SharedIngredientCreateNestedManyWithoutSharedByInput
    sharedSpec?: SharedSpecCreateNestedManyWithoutUserInput
    specSharedBy?: SharedSpecCreateNestedManyWithoutSharedByInput
    recipes?: RecipeCreateNestedManyWithoutPostedByInput
    spec?: SpecCreateNestedManyWithoutPostedByInput
    ingredient?: IngredientCreateNestedManyWithoutPostedByInput
    touch?: TouchCreateNestedManyWithoutPostedByInput
    adminOnSpec?: AdminOnSpecCreateNestedManyWithoutUserInput
    adminAssignedBy?: AdminOnSpecCreateNestedManyWithoutAssignedByInput
  }

  export type UserUncheckedCreateWithoutGroupUserInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    email: string
    password: string
    groupMod?: GroupModUncheckedCreateNestedManyWithoutUsersInput
    userData?: UserDataUncheckedCreateNestedManyWithoutUsersInput
    sharedIngredient?: SharedIngredientUncheckedCreateNestedManyWithoutUserInput
    ingredientSharedBy?: SharedIngredientUncheckedCreateNestedManyWithoutSharedByInput
    sharedSpec?: SharedSpecUncheckedCreateNestedManyWithoutUserInput
    specSharedBy?: SharedSpecUncheckedCreateNestedManyWithoutSharedByInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutPostedByInput
    spec?: SpecUncheckedCreateNestedManyWithoutPostedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutPostedByInput
    touch?: TouchUncheckedCreateNestedManyWithoutPostedByInput
    adminOnSpec?: AdminOnSpecUncheckedCreateNestedManyWithoutUserInput
    adminAssignedBy?: AdminOnSpecUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type UserCreateOrConnectWithoutGroupUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGroupUserInput, UserUncheckedCreateWithoutGroupUserInput>
  }

  export type GroupsUpsertWithoutGroupUserInput = {
    update: XOR<GroupsUpdateWithoutGroupUserInput, GroupsUncheckedUpdateWithoutGroupUserInput>
    create: XOR<GroupsCreateWithoutGroupUserInput, GroupsUncheckedCreateWithoutGroupUserInput>
  }

  export type GroupsUpdateWithoutGroupUserInput = {
    groupName?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    groupIngredient?: GroupIngredientUpdateManyWithoutGroupsNestedInput
    GroupMod?: GroupModUpdateManyWithoutGroupsNestedInput
    GroupSpec?: GroupSpecUpdateManyWithoutGroupsNestedInput
  }

  export type GroupsUncheckedUpdateWithoutGroupUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupName?: StringFieldUpdateOperationsInput | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    groupIngredient?: GroupIngredientUncheckedUpdateManyWithoutGroupsNestedInput
    GroupMod?: GroupModUncheckedUpdateManyWithoutGroupsNestedInput
    GroupSpec?: GroupSpecUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type UserUpsertWithoutGroupUserInput = {
    update: XOR<UserUpdateWithoutGroupUserInput, UserUncheckedUpdateWithoutGroupUserInput>
    create: XOR<UserCreateWithoutGroupUserInput, UserUncheckedCreateWithoutGroupUserInput>
  }

  export type UserUpdateWithoutGroupUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    groupMod?: GroupModUpdateManyWithoutUsersNestedInput
    userData?: UserDataUpdateManyWithoutUsersNestedInput
    sharedIngredient?: SharedIngredientUpdateManyWithoutUserNestedInput
    ingredientSharedBy?: SharedIngredientUpdateManyWithoutSharedByNestedInput
    sharedSpec?: SharedSpecUpdateManyWithoutUserNestedInput
    specSharedBy?: SharedSpecUpdateManyWithoutSharedByNestedInput
    recipes?: RecipeUpdateManyWithoutPostedByNestedInput
    spec?: SpecUpdateManyWithoutPostedByNestedInput
    ingredient?: IngredientUpdateManyWithoutPostedByNestedInput
    touch?: TouchUpdateManyWithoutPostedByNestedInput
    adminOnSpec?: AdminOnSpecUpdateManyWithoutUserNestedInput
    adminAssignedBy?: AdminOnSpecUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUncheckedUpdateWithoutGroupUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    groupMod?: GroupModUncheckedUpdateManyWithoutUsersNestedInput
    userData?: UserDataUncheckedUpdateManyWithoutUsersNestedInput
    sharedIngredient?: SharedIngredientUncheckedUpdateManyWithoutUserNestedInput
    ingredientSharedBy?: SharedIngredientUncheckedUpdateManyWithoutSharedByNestedInput
    sharedSpec?: SharedSpecUncheckedUpdateManyWithoutUserNestedInput
    specSharedBy?: SharedSpecUncheckedUpdateManyWithoutSharedByNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutPostedByNestedInput
    spec?: SpecUncheckedUpdateManyWithoutPostedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutPostedByNestedInput
    touch?: TouchUncheckedUpdateManyWithoutPostedByNestedInput
    adminOnSpec?: AdminOnSpecUncheckedUpdateManyWithoutUserNestedInput
    adminAssignedBy?: AdminOnSpecUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type UserCreateWithoutIngredientInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    email: string
    password: string
    groupMod?: GroupModCreateNestedManyWithoutUsersInput
    groupUser?: GroupUserCreateNestedManyWithoutUsersInput
    userData?: UserDataCreateNestedManyWithoutUsersInput
    sharedIngredient?: SharedIngredientCreateNestedManyWithoutUserInput
    ingredientSharedBy?: SharedIngredientCreateNestedManyWithoutSharedByInput
    sharedSpec?: SharedSpecCreateNestedManyWithoutUserInput
    specSharedBy?: SharedSpecCreateNestedManyWithoutSharedByInput
    recipes?: RecipeCreateNestedManyWithoutPostedByInput
    spec?: SpecCreateNestedManyWithoutPostedByInput
    touch?: TouchCreateNestedManyWithoutPostedByInput
    adminOnSpec?: AdminOnSpecCreateNestedManyWithoutUserInput
    adminAssignedBy?: AdminOnSpecCreateNestedManyWithoutAssignedByInput
  }

  export type UserUncheckedCreateWithoutIngredientInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    email: string
    password: string
    groupMod?: GroupModUncheckedCreateNestedManyWithoutUsersInput
    groupUser?: GroupUserUncheckedCreateNestedManyWithoutUsersInput
    userData?: UserDataUncheckedCreateNestedManyWithoutUsersInput
    sharedIngredient?: SharedIngredientUncheckedCreateNestedManyWithoutUserInput
    ingredientSharedBy?: SharedIngredientUncheckedCreateNestedManyWithoutSharedByInput
    sharedSpec?: SharedSpecUncheckedCreateNestedManyWithoutUserInput
    specSharedBy?: SharedSpecUncheckedCreateNestedManyWithoutSharedByInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutPostedByInput
    spec?: SpecUncheckedCreateNestedManyWithoutPostedByInput
    touch?: TouchUncheckedCreateNestedManyWithoutPostedByInput
    adminOnSpec?: AdminOnSpecUncheckedCreateNestedManyWithoutUserInput
    adminAssignedBy?: AdminOnSpecUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type UserCreateOrConnectWithoutIngredientInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIngredientInput, UserUncheckedCreateWithoutIngredientInput>
  }

  export type GroupIngredientCreateWithoutIngredientInput = {
    groups: GroupsCreateNestedOneWithoutGroupIngredientInput
  }

  export type GroupIngredientUncheckedCreateWithoutIngredientInput = {
    groupId: number
  }

  export type GroupIngredientCreateOrConnectWithoutIngredientInput = {
    where: GroupIngredientWhereUniqueInput
    create: XOR<GroupIngredientCreateWithoutIngredientInput, GroupIngredientUncheckedCreateWithoutIngredientInput>
  }

  export type GroupIngredientCreateManyIngredientInputEnvelope = {
    data: Enumerable<GroupIngredientCreateManyIngredientInput>
    skipDuplicates?: boolean
  }

  export type TouchCreateWithoutIngredientInput = {
    order?: number | null
    amount?: number | null
    unit?: string | null
    spec?: SpecCreateNestedOneWithoutTouchInput
    postedBy?: UserCreateNestedOneWithoutTouchInput
  }

  export type TouchUncheckedCreateWithoutIngredientInput = {
    id?: number
    order?: number | null
    amount?: number | null
    unit?: string | null
    specId?: number | null
    postedById: string
  }

  export type TouchCreateOrConnectWithoutIngredientInput = {
    where: TouchWhereUniqueInput
    create: XOR<TouchCreateWithoutIngredientInput, TouchUncheckedCreateWithoutIngredientInput>
  }

  export type TouchCreateManyIngredientInputEnvelope = {
    data: Enumerable<TouchCreateManyIngredientInput>
    skipDuplicates?: boolean
  }

  export type SharedIngredientCreateWithoutIngredientInput = {
    sharedAt?: Date | string
    user: UserCreateNestedOneWithoutSharedIngredientInput
    sharedBy: UserCreateNestedOneWithoutIngredientSharedByInput
  }

  export type SharedIngredientUncheckedCreateWithoutIngredientInput = {
    userId: string
    sharedById: string
    sharedAt?: Date | string
  }

  export type SharedIngredientCreateOrConnectWithoutIngredientInput = {
    where: SharedIngredientWhereUniqueInput
    create: XOR<SharedIngredientCreateWithoutIngredientInput, SharedIngredientUncheckedCreateWithoutIngredientInput>
  }

  export type SharedIngredientCreateManyIngredientInputEnvelope = {
    data: Enumerable<SharedIngredientCreateManyIngredientInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutIngredientInput = {
    update: XOR<UserUpdateWithoutIngredientInput, UserUncheckedUpdateWithoutIngredientInput>
    create: XOR<UserCreateWithoutIngredientInput, UserUncheckedCreateWithoutIngredientInput>
  }

  export type UserUpdateWithoutIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    groupMod?: GroupModUpdateManyWithoutUsersNestedInput
    groupUser?: GroupUserUpdateManyWithoutUsersNestedInput
    userData?: UserDataUpdateManyWithoutUsersNestedInput
    sharedIngredient?: SharedIngredientUpdateManyWithoutUserNestedInput
    ingredientSharedBy?: SharedIngredientUpdateManyWithoutSharedByNestedInput
    sharedSpec?: SharedSpecUpdateManyWithoutUserNestedInput
    specSharedBy?: SharedSpecUpdateManyWithoutSharedByNestedInput
    recipes?: RecipeUpdateManyWithoutPostedByNestedInput
    spec?: SpecUpdateManyWithoutPostedByNestedInput
    touch?: TouchUpdateManyWithoutPostedByNestedInput
    adminOnSpec?: AdminOnSpecUpdateManyWithoutUserNestedInput
    adminAssignedBy?: AdminOnSpecUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUncheckedUpdateWithoutIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    groupMod?: GroupModUncheckedUpdateManyWithoutUsersNestedInput
    groupUser?: GroupUserUncheckedUpdateManyWithoutUsersNestedInput
    userData?: UserDataUncheckedUpdateManyWithoutUsersNestedInput
    sharedIngredient?: SharedIngredientUncheckedUpdateManyWithoutUserNestedInput
    ingredientSharedBy?: SharedIngredientUncheckedUpdateManyWithoutSharedByNestedInput
    sharedSpec?: SharedSpecUncheckedUpdateManyWithoutUserNestedInput
    specSharedBy?: SharedSpecUncheckedUpdateManyWithoutSharedByNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutPostedByNestedInput
    spec?: SpecUncheckedUpdateManyWithoutPostedByNestedInput
    touch?: TouchUncheckedUpdateManyWithoutPostedByNestedInput
    adminOnSpec?: AdminOnSpecUncheckedUpdateManyWithoutUserNestedInput
    adminAssignedBy?: AdminOnSpecUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type GroupIngredientUpsertWithWhereUniqueWithoutIngredientInput = {
    where: GroupIngredientWhereUniqueInput
    update: XOR<GroupIngredientUpdateWithoutIngredientInput, GroupIngredientUncheckedUpdateWithoutIngredientInput>
    create: XOR<GroupIngredientCreateWithoutIngredientInput, GroupIngredientUncheckedCreateWithoutIngredientInput>
  }

  export type GroupIngredientUpdateWithWhereUniqueWithoutIngredientInput = {
    where: GroupIngredientWhereUniqueInput
    data: XOR<GroupIngredientUpdateWithoutIngredientInput, GroupIngredientUncheckedUpdateWithoutIngredientInput>
  }

  export type GroupIngredientUpdateManyWithWhereWithoutIngredientInput = {
    where: GroupIngredientScalarWhereInput
    data: XOR<GroupIngredientUpdateManyMutationInput, GroupIngredientUncheckedUpdateManyWithoutGroupIngredientInput>
  }

  export type TouchUpsertWithWhereUniqueWithoutIngredientInput = {
    where: TouchWhereUniqueInput
    update: XOR<TouchUpdateWithoutIngredientInput, TouchUncheckedUpdateWithoutIngredientInput>
    create: XOR<TouchCreateWithoutIngredientInput, TouchUncheckedCreateWithoutIngredientInput>
  }

  export type TouchUpdateWithWhereUniqueWithoutIngredientInput = {
    where: TouchWhereUniqueInput
    data: XOR<TouchUpdateWithoutIngredientInput, TouchUncheckedUpdateWithoutIngredientInput>
  }

  export type TouchUpdateManyWithWhereWithoutIngredientInput = {
    where: TouchScalarWhereInput
    data: XOR<TouchUpdateManyMutationInput, TouchUncheckedUpdateManyWithoutTouchInput>
  }

  export type TouchScalarWhereInput = {
    AND?: Enumerable<TouchScalarWhereInput>
    OR?: Enumerable<TouchScalarWhereInput>
    NOT?: Enumerable<TouchScalarWhereInput>
    id?: IntFilter | number
    ingredientId?: IntNullableFilter | number | null
    order?: IntNullableFilter | number | null
    amount?: FloatNullableFilter | number | null
    unit?: StringNullableFilter | string | null
    specId?: IntNullableFilter | number | null
    postedById?: StringFilter | string
  }

  export type SharedIngredientUpsertWithWhereUniqueWithoutIngredientInput = {
    where: SharedIngredientWhereUniqueInput
    update: XOR<SharedIngredientUpdateWithoutIngredientInput, SharedIngredientUncheckedUpdateWithoutIngredientInput>
    create: XOR<SharedIngredientCreateWithoutIngredientInput, SharedIngredientUncheckedCreateWithoutIngredientInput>
  }

  export type SharedIngredientUpdateWithWhereUniqueWithoutIngredientInput = {
    where: SharedIngredientWhereUniqueInput
    data: XOR<SharedIngredientUpdateWithoutIngredientInput, SharedIngredientUncheckedUpdateWithoutIngredientInput>
  }

  export type SharedIngredientUpdateManyWithWhereWithoutIngredientInput = {
    where: SharedIngredientScalarWhereInput
    data: XOR<SharedIngredientUpdateManyMutationInput, SharedIngredientUncheckedUpdateManyWithoutSharedIngredientInput>
  }

  export type SharedIngredientScalarWhereInput = {
    AND?: Enumerable<SharedIngredientScalarWhereInput>
    OR?: Enumerable<SharedIngredientScalarWhereInput>
    NOT?: Enumerable<SharedIngredientScalarWhereInput>
    userId?: StringFilter | string
    ingredientId?: IntFilter | number
    sharedById?: StringFilter | string
    sharedAt?: DateTimeFilter | Date | string
  }

  export type IngredientCreateWithoutTouchInput = {
    dateCreated?: Date | string
    name: string
    amount?: number | null
    unit?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    source?: string | null
    postedBy?: UserCreateNestedOneWithoutIngredientInput
    groupIngredient?: GroupIngredientCreateNestedManyWithoutIngredientInput
    sharedIngredient?: SharedIngredientCreateNestedManyWithoutIngredientInput
  }

  export type IngredientUncheckedCreateWithoutTouchInput = {
    id?: number
    dateCreated?: Date | string
    name: string
    amount?: number | null
    unit?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    source?: string | null
    postedById: string
    groupIngredient?: GroupIngredientUncheckedCreateNestedManyWithoutIngredientInput
    sharedIngredient?: SharedIngredientUncheckedCreateNestedManyWithoutIngredientInput
  }

  export type IngredientCreateOrConnectWithoutTouchInput = {
    where: IngredientWhereUniqueInput
    create: XOR<IngredientCreateWithoutTouchInput, IngredientUncheckedCreateWithoutTouchInput>
  }

  export type SpecCreateWithoutTouchInput = {
    specName?: string
    postedBy?: UserCreateNestedOneWithoutSpecInput
    instructions?: string | null
    glassware?: string | null
    ice?: string | null
    groupSpec?: GroupSpecCreateNestedManyWithoutSpecInput
    sharedSpec?: SharedSpecCreateNestedManyWithoutSpecInput
    recipe?: RecipeCreateNestedOneWithoutSpecInput
    adminOnSpec?: AdminOnSpecCreateNestedManyWithoutSpecInput
  }

  export type SpecUncheckedCreateWithoutTouchInput = {
    id?: number
    specName?: string
    postedById: string
    instructions?: string | null
    glassware?: string | null
    ice?: string | null
    groupSpec?: GroupSpecUncheckedCreateNestedManyWithoutSpecInput
    sharedSpec?: SharedSpecUncheckedCreateNestedManyWithoutSpecInput
    recipeId?: number | null
    adminOnSpec?: AdminOnSpecUncheckedCreateNestedManyWithoutSpecInput
  }

  export type SpecCreateOrConnectWithoutTouchInput = {
    where: SpecWhereUniqueInput
    create: XOR<SpecCreateWithoutTouchInput, SpecUncheckedCreateWithoutTouchInput>
  }

  export type UserCreateWithoutTouchInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    email: string
    password: string
    groupMod?: GroupModCreateNestedManyWithoutUsersInput
    groupUser?: GroupUserCreateNestedManyWithoutUsersInput
    userData?: UserDataCreateNestedManyWithoutUsersInput
    sharedIngredient?: SharedIngredientCreateNestedManyWithoutUserInput
    ingredientSharedBy?: SharedIngredientCreateNestedManyWithoutSharedByInput
    sharedSpec?: SharedSpecCreateNestedManyWithoutUserInput
    specSharedBy?: SharedSpecCreateNestedManyWithoutSharedByInput
    recipes?: RecipeCreateNestedManyWithoutPostedByInput
    spec?: SpecCreateNestedManyWithoutPostedByInput
    ingredient?: IngredientCreateNestedManyWithoutPostedByInput
    adminOnSpec?: AdminOnSpecCreateNestedManyWithoutUserInput
    adminAssignedBy?: AdminOnSpecCreateNestedManyWithoutAssignedByInput
  }

  export type UserUncheckedCreateWithoutTouchInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    email: string
    password: string
    groupMod?: GroupModUncheckedCreateNestedManyWithoutUsersInput
    groupUser?: GroupUserUncheckedCreateNestedManyWithoutUsersInput
    userData?: UserDataUncheckedCreateNestedManyWithoutUsersInput
    sharedIngredient?: SharedIngredientUncheckedCreateNestedManyWithoutUserInput
    ingredientSharedBy?: SharedIngredientUncheckedCreateNestedManyWithoutSharedByInput
    sharedSpec?: SharedSpecUncheckedCreateNestedManyWithoutUserInput
    specSharedBy?: SharedSpecUncheckedCreateNestedManyWithoutSharedByInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutPostedByInput
    spec?: SpecUncheckedCreateNestedManyWithoutPostedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutPostedByInput
    adminOnSpec?: AdminOnSpecUncheckedCreateNestedManyWithoutUserInput
    adminAssignedBy?: AdminOnSpecUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type UserCreateOrConnectWithoutTouchInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTouchInput, UserUncheckedCreateWithoutTouchInput>
  }

  export type IngredientUpsertWithoutTouchInput = {
    update: XOR<IngredientUpdateWithoutTouchInput, IngredientUncheckedUpdateWithoutTouchInput>
    create: XOR<IngredientCreateWithoutTouchInput, IngredientUncheckedCreateWithoutTouchInput>
  }

  export type IngredientUpdateWithoutTouchInput = {
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    postedBy?: UserUpdateOneWithoutIngredientNestedInput
    groupIngredient?: GroupIngredientUpdateManyWithoutIngredientNestedInput
    sharedIngredient?: SharedIngredientUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientUncheckedUpdateWithoutTouchInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    postedById?: StringFieldUpdateOperationsInput | string
    groupIngredient?: GroupIngredientUncheckedUpdateManyWithoutIngredientNestedInput
    sharedIngredient?: SharedIngredientUncheckedUpdateManyWithoutIngredientNestedInput
  }

  export type SpecUpsertWithoutTouchInput = {
    update: XOR<SpecUpdateWithoutTouchInput, SpecUncheckedUpdateWithoutTouchInput>
    create: XOR<SpecCreateWithoutTouchInput, SpecUncheckedCreateWithoutTouchInput>
  }

  export type SpecUpdateWithoutTouchInput = {
    specName?: StringFieldUpdateOperationsInput | string
    postedBy?: UserUpdateOneWithoutSpecNestedInput
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    groupSpec?: GroupSpecUpdateManyWithoutSpecNestedInput
    sharedSpec?: SharedSpecUpdateManyWithoutSpecNestedInput
    recipe?: RecipeUpdateOneWithoutSpecNestedInput
    adminOnSpec?: AdminOnSpecUpdateManyWithoutSpecNestedInput
  }

  export type SpecUncheckedUpdateWithoutTouchInput = {
    id?: IntFieldUpdateOperationsInput | number
    specName?: StringFieldUpdateOperationsInput | string
    postedById?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    groupSpec?: GroupSpecUncheckedUpdateManyWithoutSpecNestedInput
    sharedSpec?: SharedSpecUncheckedUpdateManyWithoutSpecNestedInput
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
    adminOnSpec?: AdminOnSpecUncheckedUpdateManyWithoutSpecNestedInput
  }

  export type UserUpsertWithoutTouchInput = {
    update: XOR<UserUpdateWithoutTouchInput, UserUncheckedUpdateWithoutTouchInput>
    create: XOR<UserCreateWithoutTouchInput, UserUncheckedCreateWithoutTouchInput>
  }

  export type UserUpdateWithoutTouchInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    groupMod?: GroupModUpdateManyWithoutUsersNestedInput
    groupUser?: GroupUserUpdateManyWithoutUsersNestedInput
    userData?: UserDataUpdateManyWithoutUsersNestedInput
    sharedIngredient?: SharedIngredientUpdateManyWithoutUserNestedInput
    ingredientSharedBy?: SharedIngredientUpdateManyWithoutSharedByNestedInput
    sharedSpec?: SharedSpecUpdateManyWithoutUserNestedInput
    specSharedBy?: SharedSpecUpdateManyWithoutSharedByNestedInput
    recipes?: RecipeUpdateManyWithoutPostedByNestedInput
    spec?: SpecUpdateManyWithoutPostedByNestedInput
    ingredient?: IngredientUpdateManyWithoutPostedByNestedInput
    adminOnSpec?: AdminOnSpecUpdateManyWithoutUserNestedInput
    adminAssignedBy?: AdminOnSpecUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUncheckedUpdateWithoutTouchInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    groupMod?: GroupModUncheckedUpdateManyWithoutUsersNestedInput
    groupUser?: GroupUserUncheckedUpdateManyWithoutUsersNestedInput
    userData?: UserDataUncheckedUpdateManyWithoutUsersNestedInput
    sharedIngredient?: SharedIngredientUncheckedUpdateManyWithoutUserNestedInput
    ingredientSharedBy?: SharedIngredientUncheckedUpdateManyWithoutSharedByNestedInput
    sharedSpec?: SharedSpecUncheckedUpdateManyWithoutUserNestedInput
    specSharedBy?: SharedSpecUncheckedUpdateManyWithoutSharedByNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutPostedByNestedInput
    spec?: SpecUncheckedUpdateManyWithoutPostedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutPostedByNestedInput
    adminOnSpec?: AdminOnSpecUncheckedUpdateManyWithoutUserNestedInput
    adminAssignedBy?: AdminOnSpecUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type UserCreateWithoutRecipesInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    email: string
    password: string
    groupMod?: GroupModCreateNestedManyWithoutUsersInput
    groupUser?: GroupUserCreateNestedManyWithoutUsersInput
    userData?: UserDataCreateNestedManyWithoutUsersInput
    sharedIngredient?: SharedIngredientCreateNestedManyWithoutUserInput
    ingredientSharedBy?: SharedIngredientCreateNestedManyWithoutSharedByInput
    sharedSpec?: SharedSpecCreateNestedManyWithoutUserInput
    specSharedBy?: SharedSpecCreateNestedManyWithoutSharedByInput
    spec?: SpecCreateNestedManyWithoutPostedByInput
    ingredient?: IngredientCreateNestedManyWithoutPostedByInput
    touch?: TouchCreateNestedManyWithoutPostedByInput
    adminOnSpec?: AdminOnSpecCreateNestedManyWithoutUserInput
    adminAssignedBy?: AdminOnSpecCreateNestedManyWithoutAssignedByInput
  }

  export type UserUncheckedCreateWithoutRecipesInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    email: string
    password: string
    groupMod?: GroupModUncheckedCreateNestedManyWithoutUsersInput
    groupUser?: GroupUserUncheckedCreateNestedManyWithoutUsersInput
    userData?: UserDataUncheckedCreateNestedManyWithoutUsersInput
    sharedIngredient?: SharedIngredientUncheckedCreateNestedManyWithoutUserInput
    ingredientSharedBy?: SharedIngredientUncheckedCreateNestedManyWithoutSharedByInput
    sharedSpec?: SharedSpecUncheckedCreateNestedManyWithoutUserInput
    specSharedBy?: SharedSpecUncheckedCreateNestedManyWithoutSharedByInput
    spec?: SpecUncheckedCreateNestedManyWithoutPostedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutPostedByInput
    touch?: TouchUncheckedCreateNestedManyWithoutPostedByInput
    adminOnSpec?: AdminOnSpecUncheckedCreateNestedManyWithoutUserInput
    adminAssignedBy?: AdminOnSpecUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type UserCreateOrConnectWithoutRecipesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecipesInput, UserUncheckedCreateWithoutRecipesInput>
  }

  export type SpecCreateWithoutRecipeInput = {
    specName?: string
    postedBy?: UserCreateNestedOneWithoutSpecInput
    instructions?: string | null
    glassware?: string | null
    ice?: string | null
    groupSpec?: GroupSpecCreateNestedManyWithoutSpecInput
    sharedSpec?: SharedSpecCreateNestedManyWithoutSpecInput
    touch?: TouchCreateNestedManyWithoutSpecInput
    adminOnSpec?: AdminOnSpecCreateNestedManyWithoutSpecInput
  }

  export type SpecUncheckedCreateWithoutRecipeInput = {
    id?: number
    specName?: string
    postedById: string
    instructions?: string | null
    glassware?: string | null
    ice?: string | null
    groupSpec?: GroupSpecUncheckedCreateNestedManyWithoutSpecInput
    sharedSpec?: SharedSpecUncheckedCreateNestedManyWithoutSpecInput
    touch?: TouchUncheckedCreateNestedManyWithoutSpecInput
    adminOnSpec?: AdminOnSpecUncheckedCreateNestedManyWithoutSpecInput
  }

  export type SpecCreateOrConnectWithoutRecipeInput = {
    where: SpecWhereUniqueInput
    create: XOR<SpecCreateWithoutRecipeInput, SpecUncheckedCreateWithoutRecipeInput>
  }

  export type SpecCreateManyRecipeInputEnvelope = {
    data: Enumerable<SpecCreateManyRecipeInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutRecipesInput = {
    update: XOR<UserUpdateWithoutRecipesInput, UserUncheckedUpdateWithoutRecipesInput>
    create: XOR<UserCreateWithoutRecipesInput, UserUncheckedCreateWithoutRecipesInput>
  }

  export type UserUpdateWithoutRecipesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    groupMod?: GroupModUpdateManyWithoutUsersNestedInput
    groupUser?: GroupUserUpdateManyWithoutUsersNestedInput
    userData?: UserDataUpdateManyWithoutUsersNestedInput
    sharedIngredient?: SharedIngredientUpdateManyWithoutUserNestedInput
    ingredientSharedBy?: SharedIngredientUpdateManyWithoutSharedByNestedInput
    sharedSpec?: SharedSpecUpdateManyWithoutUserNestedInput
    specSharedBy?: SharedSpecUpdateManyWithoutSharedByNestedInput
    spec?: SpecUpdateManyWithoutPostedByNestedInput
    ingredient?: IngredientUpdateManyWithoutPostedByNestedInput
    touch?: TouchUpdateManyWithoutPostedByNestedInput
    adminOnSpec?: AdminOnSpecUpdateManyWithoutUserNestedInput
    adminAssignedBy?: AdminOnSpecUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUncheckedUpdateWithoutRecipesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    groupMod?: GroupModUncheckedUpdateManyWithoutUsersNestedInput
    groupUser?: GroupUserUncheckedUpdateManyWithoutUsersNestedInput
    userData?: UserDataUncheckedUpdateManyWithoutUsersNestedInput
    sharedIngredient?: SharedIngredientUncheckedUpdateManyWithoutUserNestedInput
    ingredientSharedBy?: SharedIngredientUncheckedUpdateManyWithoutSharedByNestedInput
    sharedSpec?: SharedSpecUncheckedUpdateManyWithoutUserNestedInput
    specSharedBy?: SharedSpecUncheckedUpdateManyWithoutSharedByNestedInput
    spec?: SpecUncheckedUpdateManyWithoutPostedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutPostedByNestedInput
    touch?: TouchUncheckedUpdateManyWithoutPostedByNestedInput
    adminOnSpec?: AdminOnSpecUncheckedUpdateManyWithoutUserNestedInput
    adminAssignedBy?: AdminOnSpecUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type SpecUpsertWithWhereUniqueWithoutRecipeInput = {
    where: SpecWhereUniqueInput
    update: XOR<SpecUpdateWithoutRecipeInput, SpecUncheckedUpdateWithoutRecipeInput>
    create: XOR<SpecCreateWithoutRecipeInput, SpecUncheckedCreateWithoutRecipeInput>
  }

  export type SpecUpdateWithWhereUniqueWithoutRecipeInput = {
    where: SpecWhereUniqueInput
    data: XOR<SpecUpdateWithoutRecipeInput, SpecUncheckedUpdateWithoutRecipeInput>
  }

  export type SpecUpdateManyWithWhereWithoutRecipeInput = {
    where: SpecScalarWhereInput
    data: XOR<SpecUpdateManyMutationInput, SpecUncheckedUpdateManyWithoutSpecInput>
  }

  export type SpecScalarWhereInput = {
    AND?: Enumerable<SpecScalarWhereInput>
    OR?: Enumerable<SpecScalarWhereInput>
    NOT?: Enumerable<SpecScalarWhereInput>
    id?: IntFilter | number
    specName?: StringFilter | string
    postedById?: StringFilter | string
    instructions?: StringNullableFilter | string | null
    glassware?: StringNullableFilter | string | null
    ice?: StringNullableFilter | string | null
    recipeId?: IntNullableFilter | number | null
  }

  export type UserCreateWithoutSpecInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    email: string
    password: string
    groupMod?: GroupModCreateNestedManyWithoutUsersInput
    groupUser?: GroupUserCreateNestedManyWithoutUsersInput
    userData?: UserDataCreateNestedManyWithoutUsersInput
    sharedIngredient?: SharedIngredientCreateNestedManyWithoutUserInput
    ingredientSharedBy?: SharedIngredientCreateNestedManyWithoutSharedByInput
    sharedSpec?: SharedSpecCreateNestedManyWithoutUserInput
    specSharedBy?: SharedSpecCreateNestedManyWithoutSharedByInput
    recipes?: RecipeCreateNestedManyWithoutPostedByInput
    ingredient?: IngredientCreateNestedManyWithoutPostedByInput
    touch?: TouchCreateNestedManyWithoutPostedByInput
    adminOnSpec?: AdminOnSpecCreateNestedManyWithoutUserInput
    adminAssignedBy?: AdminOnSpecCreateNestedManyWithoutAssignedByInput
  }

  export type UserUncheckedCreateWithoutSpecInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    email: string
    password: string
    groupMod?: GroupModUncheckedCreateNestedManyWithoutUsersInput
    groupUser?: GroupUserUncheckedCreateNestedManyWithoutUsersInput
    userData?: UserDataUncheckedCreateNestedManyWithoutUsersInput
    sharedIngredient?: SharedIngredientUncheckedCreateNestedManyWithoutUserInput
    ingredientSharedBy?: SharedIngredientUncheckedCreateNestedManyWithoutSharedByInput
    sharedSpec?: SharedSpecUncheckedCreateNestedManyWithoutUserInput
    specSharedBy?: SharedSpecUncheckedCreateNestedManyWithoutSharedByInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutPostedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutPostedByInput
    touch?: TouchUncheckedCreateNestedManyWithoutPostedByInput
    adminOnSpec?: AdminOnSpecUncheckedCreateNestedManyWithoutUserInput
    adminAssignedBy?: AdminOnSpecUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type UserCreateOrConnectWithoutSpecInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSpecInput, UserUncheckedCreateWithoutSpecInput>
  }

  export type GroupSpecCreateWithoutSpecInput = {
    groups: GroupsCreateNestedOneWithoutGroupSpecInput
  }

  export type GroupSpecUncheckedCreateWithoutSpecInput = {
    groupId: number
  }

  export type GroupSpecCreateOrConnectWithoutSpecInput = {
    where: GroupSpecWhereUniqueInput
    create: XOR<GroupSpecCreateWithoutSpecInput, GroupSpecUncheckedCreateWithoutSpecInput>
  }

  export type GroupSpecCreateManySpecInputEnvelope = {
    data: Enumerable<GroupSpecCreateManySpecInput>
    skipDuplicates?: boolean
  }

  export type SharedSpecCreateWithoutSpecInput = {
    sharedAt?: Date | string
    user: UserCreateNestedOneWithoutSharedSpecInput
    sharedBy: UserCreateNestedOneWithoutSpecSharedByInput
  }

  export type SharedSpecUncheckedCreateWithoutSpecInput = {
    userId: string
    sharedById: string
    sharedAt?: Date | string
  }

  export type SharedSpecCreateOrConnectWithoutSpecInput = {
    where: SharedSpecWhereUniqueInput
    create: XOR<SharedSpecCreateWithoutSpecInput, SharedSpecUncheckedCreateWithoutSpecInput>
  }

  export type SharedSpecCreateManySpecInputEnvelope = {
    data: Enumerable<SharedSpecCreateManySpecInput>
    skipDuplicates?: boolean
  }

  export type RecipeCreateWithoutSpecInput = {
    createdAt?: Date | string
    name: string
    origin: string
    history?: string | null
    postedBy?: UserCreateNestedOneWithoutRecipesInput
  }

  export type RecipeUncheckedCreateWithoutSpecInput = {
    id?: number
    createdAt?: Date | string
    name: string
    origin: string
    history?: string | null
    postedById: string
  }

  export type RecipeCreateOrConnectWithoutSpecInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutSpecInput, RecipeUncheckedCreateWithoutSpecInput>
  }

  export type TouchCreateWithoutSpecInput = {
    order?: number | null
    amount?: number | null
    unit?: string | null
    ingredient?: IngredientCreateNestedOneWithoutTouchInput
    postedBy?: UserCreateNestedOneWithoutTouchInput
  }

  export type TouchUncheckedCreateWithoutSpecInput = {
    id?: number
    ingredientId?: number | null
    order?: number | null
    amount?: number | null
    unit?: string | null
    postedById: string
  }

  export type TouchCreateOrConnectWithoutSpecInput = {
    where: TouchWhereUniqueInput
    create: XOR<TouchCreateWithoutSpecInput, TouchUncheckedCreateWithoutSpecInput>
  }

  export type TouchCreateManySpecInputEnvelope = {
    data: Enumerable<TouchCreateManySpecInput>
    skipDuplicates?: boolean
  }

  export type AdminOnSpecCreateWithoutSpecInput = {
    assignedAt?: Date | string
    user: UserCreateNestedOneWithoutAdminOnSpecInput
    assignedBy: UserCreateNestedOneWithoutAdminAssignedByInput
  }

  export type AdminOnSpecUncheckedCreateWithoutSpecInput = {
    userId: string
    assignedById: string
    assignedAt?: Date | string
  }

  export type AdminOnSpecCreateOrConnectWithoutSpecInput = {
    where: AdminOnSpecWhereUniqueInput
    create: XOR<AdminOnSpecCreateWithoutSpecInput, AdminOnSpecUncheckedCreateWithoutSpecInput>
  }

  export type AdminOnSpecCreateManySpecInputEnvelope = {
    data: Enumerable<AdminOnSpecCreateManySpecInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSpecInput = {
    update: XOR<UserUpdateWithoutSpecInput, UserUncheckedUpdateWithoutSpecInput>
    create: XOR<UserCreateWithoutSpecInput, UserUncheckedCreateWithoutSpecInput>
  }

  export type UserUpdateWithoutSpecInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    groupMod?: GroupModUpdateManyWithoutUsersNestedInput
    groupUser?: GroupUserUpdateManyWithoutUsersNestedInput
    userData?: UserDataUpdateManyWithoutUsersNestedInput
    sharedIngredient?: SharedIngredientUpdateManyWithoutUserNestedInput
    ingredientSharedBy?: SharedIngredientUpdateManyWithoutSharedByNestedInput
    sharedSpec?: SharedSpecUpdateManyWithoutUserNestedInput
    specSharedBy?: SharedSpecUpdateManyWithoutSharedByNestedInput
    recipes?: RecipeUpdateManyWithoutPostedByNestedInput
    ingredient?: IngredientUpdateManyWithoutPostedByNestedInput
    touch?: TouchUpdateManyWithoutPostedByNestedInput
    adminOnSpec?: AdminOnSpecUpdateManyWithoutUserNestedInput
    adminAssignedBy?: AdminOnSpecUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSpecInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    groupMod?: GroupModUncheckedUpdateManyWithoutUsersNestedInput
    groupUser?: GroupUserUncheckedUpdateManyWithoutUsersNestedInput
    userData?: UserDataUncheckedUpdateManyWithoutUsersNestedInput
    sharedIngredient?: SharedIngredientUncheckedUpdateManyWithoutUserNestedInput
    ingredientSharedBy?: SharedIngredientUncheckedUpdateManyWithoutSharedByNestedInput
    sharedSpec?: SharedSpecUncheckedUpdateManyWithoutUserNestedInput
    specSharedBy?: SharedSpecUncheckedUpdateManyWithoutSharedByNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutPostedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutPostedByNestedInput
    touch?: TouchUncheckedUpdateManyWithoutPostedByNestedInput
    adminOnSpec?: AdminOnSpecUncheckedUpdateManyWithoutUserNestedInput
    adminAssignedBy?: AdminOnSpecUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type GroupSpecUpsertWithWhereUniqueWithoutSpecInput = {
    where: GroupSpecWhereUniqueInput
    update: XOR<GroupSpecUpdateWithoutSpecInput, GroupSpecUncheckedUpdateWithoutSpecInput>
    create: XOR<GroupSpecCreateWithoutSpecInput, GroupSpecUncheckedCreateWithoutSpecInput>
  }

  export type GroupSpecUpdateWithWhereUniqueWithoutSpecInput = {
    where: GroupSpecWhereUniqueInput
    data: XOR<GroupSpecUpdateWithoutSpecInput, GroupSpecUncheckedUpdateWithoutSpecInput>
  }

  export type GroupSpecUpdateManyWithWhereWithoutSpecInput = {
    where: GroupSpecScalarWhereInput
    data: XOR<GroupSpecUpdateManyMutationInput, GroupSpecUncheckedUpdateManyWithoutGroupSpecInput>
  }

  export type SharedSpecUpsertWithWhereUniqueWithoutSpecInput = {
    where: SharedSpecWhereUniqueInput
    update: XOR<SharedSpecUpdateWithoutSpecInput, SharedSpecUncheckedUpdateWithoutSpecInput>
    create: XOR<SharedSpecCreateWithoutSpecInput, SharedSpecUncheckedCreateWithoutSpecInput>
  }

  export type SharedSpecUpdateWithWhereUniqueWithoutSpecInput = {
    where: SharedSpecWhereUniqueInput
    data: XOR<SharedSpecUpdateWithoutSpecInput, SharedSpecUncheckedUpdateWithoutSpecInput>
  }

  export type SharedSpecUpdateManyWithWhereWithoutSpecInput = {
    where: SharedSpecScalarWhereInput
    data: XOR<SharedSpecUpdateManyMutationInput, SharedSpecUncheckedUpdateManyWithoutSharedSpecInput>
  }

  export type SharedSpecScalarWhereInput = {
    AND?: Enumerable<SharedSpecScalarWhereInput>
    OR?: Enumerable<SharedSpecScalarWhereInput>
    NOT?: Enumerable<SharedSpecScalarWhereInput>
    userId?: StringFilter | string
    specId?: IntFilter | number
    sharedById?: StringFilter | string
    sharedAt?: DateTimeFilter | Date | string
  }

  export type RecipeUpsertWithoutSpecInput = {
    update: XOR<RecipeUpdateWithoutSpecInput, RecipeUncheckedUpdateWithoutSpecInput>
    create: XOR<RecipeCreateWithoutSpecInput, RecipeUncheckedCreateWithoutSpecInput>
  }

  export type RecipeUpdateWithoutSpecInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    history?: NullableStringFieldUpdateOperationsInput | string | null
    postedBy?: UserUpdateOneWithoutRecipesNestedInput
  }

  export type RecipeUncheckedUpdateWithoutSpecInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    history?: NullableStringFieldUpdateOperationsInput | string | null
    postedById?: StringFieldUpdateOperationsInput | string
  }

  export type TouchUpsertWithWhereUniqueWithoutSpecInput = {
    where: TouchWhereUniqueInput
    update: XOR<TouchUpdateWithoutSpecInput, TouchUncheckedUpdateWithoutSpecInput>
    create: XOR<TouchCreateWithoutSpecInput, TouchUncheckedCreateWithoutSpecInput>
  }

  export type TouchUpdateWithWhereUniqueWithoutSpecInput = {
    where: TouchWhereUniqueInput
    data: XOR<TouchUpdateWithoutSpecInput, TouchUncheckedUpdateWithoutSpecInput>
  }

  export type TouchUpdateManyWithWhereWithoutSpecInput = {
    where: TouchScalarWhereInput
    data: XOR<TouchUpdateManyMutationInput, TouchUncheckedUpdateManyWithoutTouchInput>
  }

  export type AdminOnSpecUpsertWithWhereUniqueWithoutSpecInput = {
    where: AdminOnSpecWhereUniqueInput
    update: XOR<AdminOnSpecUpdateWithoutSpecInput, AdminOnSpecUncheckedUpdateWithoutSpecInput>
    create: XOR<AdminOnSpecCreateWithoutSpecInput, AdminOnSpecUncheckedCreateWithoutSpecInput>
  }

  export type AdminOnSpecUpdateWithWhereUniqueWithoutSpecInput = {
    where: AdminOnSpecWhereUniqueInput
    data: XOR<AdminOnSpecUpdateWithoutSpecInput, AdminOnSpecUncheckedUpdateWithoutSpecInput>
  }

  export type AdminOnSpecUpdateManyWithWhereWithoutSpecInput = {
    where: AdminOnSpecScalarWhereInput
    data: XOR<AdminOnSpecUpdateManyMutationInput, AdminOnSpecUncheckedUpdateManyWithoutAdminOnSpecInput>
  }

  export type AdminOnSpecScalarWhereInput = {
    AND?: Enumerable<AdminOnSpecScalarWhereInput>
    OR?: Enumerable<AdminOnSpecScalarWhereInput>
    NOT?: Enumerable<AdminOnSpecScalarWhereInput>
    userId?: StringFilter | string
    specId?: IntFilter | number
    assignedById?: StringFilter | string
    assignedAt?: DateTimeFilter | Date | string
  }

  export type UserCreateWithoutUserDataInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    email: string
    password: string
    groupMod?: GroupModCreateNestedManyWithoutUsersInput
    groupUser?: GroupUserCreateNestedManyWithoutUsersInput
    sharedIngredient?: SharedIngredientCreateNestedManyWithoutUserInput
    ingredientSharedBy?: SharedIngredientCreateNestedManyWithoutSharedByInput
    sharedSpec?: SharedSpecCreateNestedManyWithoutUserInput
    specSharedBy?: SharedSpecCreateNestedManyWithoutSharedByInput
    recipes?: RecipeCreateNestedManyWithoutPostedByInput
    spec?: SpecCreateNestedManyWithoutPostedByInput
    ingredient?: IngredientCreateNestedManyWithoutPostedByInput
    touch?: TouchCreateNestedManyWithoutPostedByInput
    adminOnSpec?: AdminOnSpecCreateNestedManyWithoutUserInput
    adminAssignedBy?: AdminOnSpecCreateNestedManyWithoutAssignedByInput
  }

  export type UserUncheckedCreateWithoutUserDataInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    email: string
    password: string
    groupMod?: GroupModUncheckedCreateNestedManyWithoutUsersInput
    groupUser?: GroupUserUncheckedCreateNestedManyWithoutUsersInput
    sharedIngredient?: SharedIngredientUncheckedCreateNestedManyWithoutUserInput
    ingredientSharedBy?: SharedIngredientUncheckedCreateNestedManyWithoutSharedByInput
    sharedSpec?: SharedSpecUncheckedCreateNestedManyWithoutUserInput
    specSharedBy?: SharedSpecUncheckedCreateNestedManyWithoutSharedByInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutPostedByInput
    spec?: SpecUncheckedCreateNestedManyWithoutPostedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutPostedByInput
    touch?: TouchUncheckedCreateNestedManyWithoutPostedByInput
    adminOnSpec?: AdminOnSpecUncheckedCreateNestedManyWithoutUserInput
    adminAssignedBy?: AdminOnSpecUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type UserCreateOrConnectWithoutUserDataInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserDataInput, UserUncheckedCreateWithoutUserDataInput>
  }

  export type UserUpsertWithoutUserDataInput = {
    update: XOR<UserUpdateWithoutUserDataInput, UserUncheckedUpdateWithoutUserDataInput>
    create: XOR<UserCreateWithoutUserDataInput, UserUncheckedCreateWithoutUserDataInput>
  }

  export type UserUpdateWithoutUserDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    groupMod?: GroupModUpdateManyWithoutUsersNestedInput
    groupUser?: GroupUserUpdateManyWithoutUsersNestedInput
    sharedIngredient?: SharedIngredientUpdateManyWithoutUserNestedInput
    ingredientSharedBy?: SharedIngredientUpdateManyWithoutSharedByNestedInput
    sharedSpec?: SharedSpecUpdateManyWithoutUserNestedInput
    specSharedBy?: SharedSpecUpdateManyWithoutSharedByNestedInput
    recipes?: RecipeUpdateManyWithoutPostedByNestedInput
    spec?: SpecUpdateManyWithoutPostedByNestedInput
    ingredient?: IngredientUpdateManyWithoutPostedByNestedInput
    touch?: TouchUpdateManyWithoutPostedByNestedInput
    adminOnSpec?: AdminOnSpecUpdateManyWithoutUserNestedInput
    adminAssignedBy?: AdminOnSpecUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUserDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    groupMod?: GroupModUncheckedUpdateManyWithoutUsersNestedInput
    groupUser?: GroupUserUncheckedUpdateManyWithoutUsersNestedInput
    sharedIngredient?: SharedIngredientUncheckedUpdateManyWithoutUserNestedInput
    ingredientSharedBy?: SharedIngredientUncheckedUpdateManyWithoutSharedByNestedInput
    sharedSpec?: SharedSpecUncheckedUpdateManyWithoutUserNestedInput
    specSharedBy?: SharedSpecUncheckedUpdateManyWithoutSharedByNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutPostedByNestedInput
    spec?: SpecUncheckedUpdateManyWithoutPostedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutPostedByNestedInput
    touch?: TouchUncheckedUpdateManyWithoutPostedByNestedInput
    adminOnSpec?: AdminOnSpecUncheckedUpdateManyWithoutUserNestedInput
    adminAssignedBy?: AdminOnSpecUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type GroupModCreateWithoutUsersInput = {
    groups: GroupsCreateNestedOneWithoutGroupModInput
  }

  export type GroupModUncheckedCreateWithoutUsersInput = {
    groupId: number
  }

  export type GroupModCreateOrConnectWithoutUsersInput = {
    where: GroupModWhereUniqueInput
    create: XOR<GroupModCreateWithoutUsersInput, GroupModUncheckedCreateWithoutUsersInput>
  }

  export type GroupModCreateManyUsersInputEnvelope = {
    data: Enumerable<GroupModCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type GroupUserCreateWithoutUsersInput = {
    groups: GroupsCreateNestedOneWithoutGroupUserInput
  }

  export type GroupUserUncheckedCreateWithoutUsersInput = {
    groupId: number
  }

  export type GroupUserCreateOrConnectWithoutUsersInput = {
    where: GroupUserWhereUniqueInput
    create: XOR<GroupUserCreateWithoutUsersInput, GroupUserUncheckedCreateWithoutUsersInput>
  }

  export type GroupUserCreateManyUsersInputEnvelope = {
    data: Enumerable<GroupUserCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type UserDataCreateWithoutUsersInput = {
    userBio?: string | null
    workPlace?: string | null
    profilePicture?: string | null
  }

  export type UserDataUncheckedCreateWithoutUsersInput = {
    id?: number
    userBio?: string | null
    workPlace?: string | null
    profilePicture?: string | null
  }

  export type UserDataCreateOrConnectWithoutUsersInput = {
    where: UserDataWhereUniqueInput
    create: XOR<UserDataCreateWithoutUsersInput, UserDataUncheckedCreateWithoutUsersInput>
  }

  export type UserDataCreateManyUsersInputEnvelope = {
    data: Enumerable<UserDataCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type SharedIngredientCreateWithoutUserInput = {
    sharedAt?: Date | string
    ingredient: IngredientCreateNestedOneWithoutSharedIngredientInput
    sharedBy: UserCreateNestedOneWithoutIngredientSharedByInput
  }

  export type SharedIngredientUncheckedCreateWithoutUserInput = {
    ingredientId: number
    sharedById: string
    sharedAt?: Date | string
  }

  export type SharedIngredientCreateOrConnectWithoutUserInput = {
    where: SharedIngredientWhereUniqueInput
    create: XOR<SharedIngredientCreateWithoutUserInput, SharedIngredientUncheckedCreateWithoutUserInput>
  }

  export type SharedIngredientCreateManyUserInputEnvelope = {
    data: Enumerable<SharedIngredientCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type SharedIngredientCreateWithoutSharedByInput = {
    sharedAt?: Date | string
    ingredient: IngredientCreateNestedOneWithoutSharedIngredientInput
    user: UserCreateNestedOneWithoutSharedIngredientInput
  }

  export type SharedIngredientUncheckedCreateWithoutSharedByInput = {
    userId: string
    ingredientId: number
    sharedAt?: Date | string
  }

  export type SharedIngredientCreateOrConnectWithoutSharedByInput = {
    where: SharedIngredientWhereUniqueInput
    create: XOR<SharedIngredientCreateWithoutSharedByInput, SharedIngredientUncheckedCreateWithoutSharedByInput>
  }

  export type SharedIngredientCreateManySharedByInputEnvelope = {
    data: Enumerable<SharedIngredientCreateManySharedByInput>
    skipDuplicates?: boolean
  }

  export type SharedSpecCreateWithoutUserInput = {
    sharedAt?: Date | string
    spec: SpecCreateNestedOneWithoutSharedSpecInput
    sharedBy: UserCreateNestedOneWithoutSpecSharedByInput
  }

  export type SharedSpecUncheckedCreateWithoutUserInput = {
    specId: number
    sharedById: string
    sharedAt?: Date | string
  }

  export type SharedSpecCreateOrConnectWithoutUserInput = {
    where: SharedSpecWhereUniqueInput
    create: XOR<SharedSpecCreateWithoutUserInput, SharedSpecUncheckedCreateWithoutUserInput>
  }

  export type SharedSpecCreateManyUserInputEnvelope = {
    data: Enumerable<SharedSpecCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type SharedSpecCreateWithoutSharedByInput = {
    sharedAt?: Date | string
    spec: SpecCreateNestedOneWithoutSharedSpecInput
    user: UserCreateNestedOneWithoutSharedSpecInput
  }

  export type SharedSpecUncheckedCreateWithoutSharedByInput = {
    userId: string
    specId: number
    sharedAt?: Date | string
  }

  export type SharedSpecCreateOrConnectWithoutSharedByInput = {
    where: SharedSpecWhereUniqueInput
    create: XOR<SharedSpecCreateWithoutSharedByInput, SharedSpecUncheckedCreateWithoutSharedByInput>
  }

  export type SharedSpecCreateManySharedByInputEnvelope = {
    data: Enumerable<SharedSpecCreateManySharedByInput>
    skipDuplicates?: boolean
  }

  export type RecipeCreateWithoutPostedByInput = {
    createdAt?: Date | string
    name: string
    origin: string
    history?: string | null
    spec?: SpecCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutPostedByInput = {
    id?: number
    createdAt?: Date | string
    name: string
    origin: string
    history?: string | null
    spec?: SpecUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutPostedByInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutPostedByInput, RecipeUncheckedCreateWithoutPostedByInput>
  }

  export type RecipeCreateManyPostedByInputEnvelope = {
    data: Enumerable<RecipeCreateManyPostedByInput>
    skipDuplicates?: boolean
  }

  export type SpecCreateWithoutPostedByInput = {
    specName?: string
    instructions?: string | null
    glassware?: string | null
    ice?: string | null
    groupSpec?: GroupSpecCreateNestedManyWithoutSpecInput
    sharedSpec?: SharedSpecCreateNestedManyWithoutSpecInput
    recipe?: RecipeCreateNestedOneWithoutSpecInput
    touch?: TouchCreateNestedManyWithoutSpecInput
    adminOnSpec?: AdminOnSpecCreateNestedManyWithoutSpecInput
  }

  export type SpecUncheckedCreateWithoutPostedByInput = {
    id?: number
    specName?: string
    instructions?: string | null
    glassware?: string | null
    ice?: string | null
    groupSpec?: GroupSpecUncheckedCreateNestedManyWithoutSpecInput
    sharedSpec?: SharedSpecUncheckedCreateNestedManyWithoutSpecInput
    recipeId?: number | null
    touch?: TouchUncheckedCreateNestedManyWithoutSpecInput
    adminOnSpec?: AdminOnSpecUncheckedCreateNestedManyWithoutSpecInput
  }

  export type SpecCreateOrConnectWithoutPostedByInput = {
    where: SpecWhereUniqueInput
    create: XOR<SpecCreateWithoutPostedByInput, SpecUncheckedCreateWithoutPostedByInput>
  }

  export type SpecCreateManyPostedByInputEnvelope = {
    data: Enumerable<SpecCreateManyPostedByInput>
    skipDuplicates?: boolean
  }

  export type IngredientCreateWithoutPostedByInput = {
    dateCreated?: Date | string
    name: string
    amount?: number | null
    unit?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    source?: string | null
    groupIngredient?: GroupIngredientCreateNestedManyWithoutIngredientInput
    touch?: TouchCreateNestedManyWithoutIngredientInput
    sharedIngredient?: SharedIngredientCreateNestedManyWithoutIngredientInput
  }

  export type IngredientUncheckedCreateWithoutPostedByInput = {
    id?: number
    dateCreated?: Date | string
    name: string
    amount?: number | null
    unit?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    source?: string | null
    groupIngredient?: GroupIngredientUncheckedCreateNestedManyWithoutIngredientInput
    touch?: TouchUncheckedCreateNestedManyWithoutIngredientInput
    sharedIngredient?: SharedIngredientUncheckedCreateNestedManyWithoutIngredientInput
  }

  export type IngredientCreateOrConnectWithoutPostedByInput = {
    where: IngredientWhereUniqueInput
    create: XOR<IngredientCreateWithoutPostedByInput, IngredientUncheckedCreateWithoutPostedByInput>
  }

  export type IngredientCreateManyPostedByInputEnvelope = {
    data: Enumerable<IngredientCreateManyPostedByInput>
    skipDuplicates?: boolean
  }

  export type TouchCreateWithoutPostedByInput = {
    order?: number | null
    amount?: number | null
    unit?: string | null
    ingredient?: IngredientCreateNestedOneWithoutTouchInput
    spec?: SpecCreateNestedOneWithoutTouchInput
  }

  export type TouchUncheckedCreateWithoutPostedByInput = {
    id?: number
    ingredientId?: number | null
    order?: number | null
    amount?: number | null
    unit?: string | null
    specId?: number | null
  }

  export type TouchCreateOrConnectWithoutPostedByInput = {
    where: TouchWhereUniqueInput
    create: XOR<TouchCreateWithoutPostedByInput, TouchUncheckedCreateWithoutPostedByInput>
  }

  export type TouchCreateManyPostedByInputEnvelope = {
    data: Enumerable<TouchCreateManyPostedByInput>
    skipDuplicates?: boolean
  }

  export type AdminOnSpecCreateWithoutUserInput = {
    assignedAt?: Date | string
    spec: SpecCreateNestedOneWithoutAdminOnSpecInput
    assignedBy: UserCreateNestedOneWithoutAdminAssignedByInput
  }

  export type AdminOnSpecUncheckedCreateWithoutUserInput = {
    specId: number
    assignedById: string
    assignedAt?: Date | string
  }

  export type AdminOnSpecCreateOrConnectWithoutUserInput = {
    where: AdminOnSpecWhereUniqueInput
    create: XOR<AdminOnSpecCreateWithoutUserInput, AdminOnSpecUncheckedCreateWithoutUserInput>
  }

  export type AdminOnSpecCreateManyUserInputEnvelope = {
    data: Enumerable<AdminOnSpecCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type AdminOnSpecCreateWithoutAssignedByInput = {
    assignedAt?: Date | string
    spec: SpecCreateNestedOneWithoutAdminOnSpecInput
    user: UserCreateNestedOneWithoutAdminOnSpecInput
  }

  export type AdminOnSpecUncheckedCreateWithoutAssignedByInput = {
    userId: string
    specId: number
    assignedAt?: Date | string
  }

  export type AdminOnSpecCreateOrConnectWithoutAssignedByInput = {
    where: AdminOnSpecWhereUniqueInput
    create: XOR<AdminOnSpecCreateWithoutAssignedByInput, AdminOnSpecUncheckedCreateWithoutAssignedByInput>
  }

  export type AdminOnSpecCreateManyAssignedByInputEnvelope = {
    data: Enumerable<AdminOnSpecCreateManyAssignedByInput>
    skipDuplicates?: boolean
  }

  export type GroupModUpsertWithWhereUniqueWithoutUsersInput = {
    where: GroupModWhereUniqueInput
    update: XOR<GroupModUpdateWithoutUsersInput, GroupModUncheckedUpdateWithoutUsersInput>
    create: XOR<GroupModCreateWithoutUsersInput, GroupModUncheckedCreateWithoutUsersInput>
  }

  export type GroupModUpdateWithWhereUniqueWithoutUsersInput = {
    where: GroupModWhereUniqueInput
    data: XOR<GroupModUpdateWithoutUsersInput, GroupModUncheckedUpdateWithoutUsersInput>
  }

  export type GroupModUpdateManyWithWhereWithoutUsersInput = {
    where: GroupModScalarWhereInput
    data: XOR<GroupModUpdateManyMutationInput, GroupModUncheckedUpdateManyWithoutGroupModInput>
  }

  export type GroupUserUpsertWithWhereUniqueWithoutUsersInput = {
    where: GroupUserWhereUniqueInput
    update: XOR<GroupUserUpdateWithoutUsersInput, GroupUserUncheckedUpdateWithoutUsersInput>
    create: XOR<GroupUserCreateWithoutUsersInput, GroupUserUncheckedCreateWithoutUsersInput>
  }

  export type GroupUserUpdateWithWhereUniqueWithoutUsersInput = {
    where: GroupUserWhereUniqueInput
    data: XOR<GroupUserUpdateWithoutUsersInput, GroupUserUncheckedUpdateWithoutUsersInput>
  }

  export type GroupUserUpdateManyWithWhereWithoutUsersInput = {
    where: GroupUserScalarWhereInput
    data: XOR<GroupUserUpdateManyMutationInput, GroupUserUncheckedUpdateManyWithoutGroupUserInput>
  }

  export type UserDataUpsertWithWhereUniqueWithoutUsersInput = {
    where: UserDataWhereUniqueInput
    update: XOR<UserDataUpdateWithoutUsersInput, UserDataUncheckedUpdateWithoutUsersInput>
    create: XOR<UserDataCreateWithoutUsersInput, UserDataUncheckedCreateWithoutUsersInput>
  }

  export type UserDataUpdateWithWhereUniqueWithoutUsersInput = {
    where: UserDataWhereUniqueInput
    data: XOR<UserDataUpdateWithoutUsersInput, UserDataUncheckedUpdateWithoutUsersInput>
  }

  export type UserDataUpdateManyWithWhereWithoutUsersInput = {
    where: UserDataScalarWhereInput
    data: XOR<UserDataUpdateManyMutationInput, UserDataUncheckedUpdateManyWithoutUserDataInput>
  }

  export type UserDataScalarWhereInput = {
    AND?: Enumerable<UserDataScalarWhereInput>
    OR?: Enumerable<UserDataScalarWhereInput>
    NOT?: Enumerable<UserDataScalarWhereInput>
    id?: IntFilter | number
    userId?: StringNullableFilter | string | null
    userBio?: StringNullableFilter | string | null
    workPlace?: StringNullableFilter | string | null
    profilePicture?: StringNullableFilter | string | null
  }

  export type SharedIngredientUpsertWithWhereUniqueWithoutUserInput = {
    where: SharedIngredientWhereUniqueInput
    update: XOR<SharedIngredientUpdateWithoutUserInput, SharedIngredientUncheckedUpdateWithoutUserInput>
    create: XOR<SharedIngredientCreateWithoutUserInput, SharedIngredientUncheckedCreateWithoutUserInput>
  }

  export type SharedIngredientUpdateWithWhereUniqueWithoutUserInput = {
    where: SharedIngredientWhereUniqueInput
    data: XOR<SharedIngredientUpdateWithoutUserInput, SharedIngredientUncheckedUpdateWithoutUserInput>
  }

  export type SharedIngredientUpdateManyWithWhereWithoutUserInput = {
    where: SharedIngredientScalarWhereInput
    data: XOR<SharedIngredientUpdateManyMutationInput, SharedIngredientUncheckedUpdateManyWithoutSharedIngredientInput>
  }

  export type SharedIngredientUpsertWithWhereUniqueWithoutSharedByInput = {
    where: SharedIngredientWhereUniqueInput
    update: XOR<SharedIngredientUpdateWithoutSharedByInput, SharedIngredientUncheckedUpdateWithoutSharedByInput>
    create: XOR<SharedIngredientCreateWithoutSharedByInput, SharedIngredientUncheckedCreateWithoutSharedByInput>
  }

  export type SharedIngredientUpdateWithWhereUniqueWithoutSharedByInput = {
    where: SharedIngredientWhereUniqueInput
    data: XOR<SharedIngredientUpdateWithoutSharedByInput, SharedIngredientUncheckedUpdateWithoutSharedByInput>
  }

  export type SharedIngredientUpdateManyWithWhereWithoutSharedByInput = {
    where: SharedIngredientScalarWhereInput
    data: XOR<SharedIngredientUpdateManyMutationInput, SharedIngredientUncheckedUpdateManyWithoutIngredientSharedByInput>
  }

  export type SharedSpecUpsertWithWhereUniqueWithoutUserInput = {
    where: SharedSpecWhereUniqueInput
    update: XOR<SharedSpecUpdateWithoutUserInput, SharedSpecUncheckedUpdateWithoutUserInput>
    create: XOR<SharedSpecCreateWithoutUserInput, SharedSpecUncheckedCreateWithoutUserInput>
  }

  export type SharedSpecUpdateWithWhereUniqueWithoutUserInput = {
    where: SharedSpecWhereUniqueInput
    data: XOR<SharedSpecUpdateWithoutUserInput, SharedSpecUncheckedUpdateWithoutUserInput>
  }

  export type SharedSpecUpdateManyWithWhereWithoutUserInput = {
    where: SharedSpecScalarWhereInput
    data: XOR<SharedSpecUpdateManyMutationInput, SharedSpecUncheckedUpdateManyWithoutSharedSpecInput>
  }

  export type SharedSpecUpsertWithWhereUniqueWithoutSharedByInput = {
    where: SharedSpecWhereUniqueInput
    update: XOR<SharedSpecUpdateWithoutSharedByInput, SharedSpecUncheckedUpdateWithoutSharedByInput>
    create: XOR<SharedSpecCreateWithoutSharedByInput, SharedSpecUncheckedCreateWithoutSharedByInput>
  }

  export type SharedSpecUpdateWithWhereUniqueWithoutSharedByInput = {
    where: SharedSpecWhereUniqueInput
    data: XOR<SharedSpecUpdateWithoutSharedByInput, SharedSpecUncheckedUpdateWithoutSharedByInput>
  }

  export type SharedSpecUpdateManyWithWhereWithoutSharedByInput = {
    where: SharedSpecScalarWhereInput
    data: XOR<SharedSpecUpdateManyMutationInput, SharedSpecUncheckedUpdateManyWithoutSpecSharedByInput>
  }

  export type RecipeUpsertWithWhereUniqueWithoutPostedByInput = {
    where: RecipeWhereUniqueInput
    update: XOR<RecipeUpdateWithoutPostedByInput, RecipeUncheckedUpdateWithoutPostedByInput>
    create: XOR<RecipeCreateWithoutPostedByInput, RecipeUncheckedCreateWithoutPostedByInput>
  }

  export type RecipeUpdateWithWhereUniqueWithoutPostedByInput = {
    where: RecipeWhereUniqueInput
    data: XOR<RecipeUpdateWithoutPostedByInput, RecipeUncheckedUpdateWithoutPostedByInput>
  }

  export type RecipeUpdateManyWithWhereWithoutPostedByInput = {
    where: RecipeScalarWhereInput
    data: XOR<RecipeUpdateManyMutationInput, RecipeUncheckedUpdateManyWithoutRecipesInput>
  }

  export type RecipeScalarWhereInput = {
    AND?: Enumerable<RecipeScalarWhereInput>
    OR?: Enumerable<RecipeScalarWhereInput>
    NOT?: Enumerable<RecipeScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    name?: StringFilter | string
    origin?: StringFilter | string
    history?: StringNullableFilter | string | null
    postedById?: StringFilter | string
  }

  export type SpecUpsertWithWhereUniqueWithoutPostedByInput = {
    where: SpecWhereUniqueInput
    update: XOR<SpecUpdateWithoutPostedByInput, SpecUncheckedUpdateWithoutPostedByInput>
    create: XOR<SpecCreateWithoutPostedByInput, SpecUncheckedCreateWithoutPostedByInput>
  }

  export type SpecUpdateWithWhereUniqueWithoutPostedByInput = {
    where: SpecWhereUniqueInput
    data: XOR<SpecUpdateWithoutPostedByInput, SpecUncheckedUpdateWithoutPostedByInput>
  }

  export type SpecUpdateManyWithWhereWithoutPostedByInput = {
    where: SpecScalarWhereInput
    data: XOR<SpecUpdateManyMutationInput, SpecUncheckedUpdateManyWithoutSpecInput>
  }

  export type IngredientUpsertWithWhereUniqueWithoutPostedByInput = {
    where: IngredientWhereUniqueInput
    update: XOR<IngredientUpdateWithoutPostedByInput, IngredientUncheckedUpdateWithoutPostedByInput>
    create: XOR<IngredientCreateWithoutPostedByInput, IngredientUncheckedCreateWithoutPostedByInput>
  }

  export type IngredientUpdateWithWhereUniqueWithoutPostedByInput = {
    where: IngredientWhereUniqueInput
    data: XOR<IngredientUpdateWithoutPostedByInput, IngredientUncheckedUpdateWithoutPostedByInput>
  }

  export type IngredientUpdateManyWithWhereWithoutPostedByInput = {
    where: IngredientScalarWhereInput
    data: XOR<IngredientUpdateManyMutationInput, IngredientUncheckedUpdateManyWithoutIngredientInput>
  }

  export type IngredientScalarWhereInput = {
    AND?: Enumerable<IngredientScalarWhereInput>
    OR?: Enumerable<IngredientScalarWhereInput>
    NOT?: Enumerable<IngredientScalarWhereInput>
    id?: IntFilter | number
    dateCreated?: DateTimeFilter | Date | string
    name?: StringFilter | string
    amount?: IntNullableFilter | number | null
    unit?: StringNullableFilter | string | null
    price?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    source?: StringNullableFilter | string | null
    postedById?: StringFilter | string
  }

  export type TouchUpsertWithWhereUniqueWithoutPostedByInput = {
    where: TouchWhereUniqueInput
    update: XOR<TouchUpdateWithoutPostedByInput, TouchUncheckedUpdateWithoutPostedByInput>
    create: XOR<TouchCreateWithoutPostedByInput, TouchUncheckedCreateWithoutPostedByInput>
  }

  export type TouchUpdateWithWhereUniqueWithoutPostedByInput = {
    where: TouchWhereUniqueInput
    data: XOR<TouchUpdateWithoutPostedByInput, TouchUncheckedUpdateWithoutPostedByInput>
  }

  export type TouchUpdateManyWithWhereWithoutPostedByInput = {
    where: TouchScalarWhereInput
    data: XOR<TouchUpdateManyMutationInput, TouchUncheckedUpdateManyWithoutTouchInput>
  }

  export type AdminOnSpecUpsertWithWhereUniqueWithoutUserInput = {
    where: AdminOnSpecWhereUniqueInput
    update: XOR<AdminOnSpecUpdateWithoutUserInput, AdminOnSpecUncheckedUpdateWithoutUserInput>
    create: XOR<AdminOnSpecCreateWithoutUserInput, AdminOnSpecUncheckedCreateWithoutUserInput>
  }

  export type AdminOnSpecUpdateWithWhereUniqueWithoutUserInput = {
    where: AdminOnSpecWhereUniqueInput
    data: XOR<AdminOnSpecUpdateWithoutUserInput, AdminOnSpecUncheckedUpdateWithoutUserInput>
  }

  export type AdminOnSpecUpdateManyWithWhereWithoutUserInput = {
    where: AdminOnSpecScalarWhereInput
    data: XOR<AdminOnSpecUpdateManyMutationInput, AdminOnSpecUncheckedUpdateManyWithoutAdminOnSpecInput>
  }

  export type AdminOnSpecUpsertWithWhereUniqueWithoutAssignedByInput = {
    where: AdminOnSpecWhereUniqueInput
    update: XOR<AdminOnSpecUpdateWithoutAssignedByInput, AdminOnSpecUncheckedUpdateWithoutAssignedByInput>
    create: XOR<AdminOnSpecCreateWithoutAssignedByInput, AdminOnSpecUncheckedCreateWithoutAssignedByInput>
  }

  export type AdminOnSpecUpdateWithWhereUniqueWithoutAssignedByInput = {
    where: AdminOnSpecWhereUniqueInput
    data: XOR<AdminOnSpecUpdateWithoutAssignedByInput, AdminOnSpecUncheckedUpdateWithoutAssignedByInput>
  }

  export type AdminOnSpecUpdateManyWithWhereWithoutAssignedByInput = {
    where: AdminOnSpecScalarWhereInput
    data: XOR<AdminOnSpecUpdateManyMutationInput, AdminOnSpecUncheckedUpdateManyWithoutAdminAssignedByInput>
  }

  export type IngredientCreateWithoutSharedIngredientInput = {
    dateCreated?: Date | string
    name: string
    amount?: number | null
    unit?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    source?: string | null
    postedBy?: UserCreateNestedOneWithoutIngredientInput
    groupIngredient?: GroupIngredientCreateNestedManyWithoutIngredientInput
    touch?: TouchCreateNestedManyWithoutIngredientInput
  }

  export type IngredientUncheckedCreateWithoutSharedIngredientInput = {
    id?: number
    dateCreated?: Date | string
    name: string
    amount?: number | null
    unit?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    source?: string | null
    postedById: string
    groupIngredient?: GroupIngredientUncheckedCreateNestedManyWithoutIngredientInput
    touch?: TouchUncheckedCreateNestedManyWithoutIngredientInput
  }

  export type IngredientCreateOrConnectWithoutSharedIngredientInput = {
    where: IngredientWhereUniqueInput
    create: XOR<IngredientCreateWithoutSharedIngredientInput, IngredientUncheckedCreateWithoutSharedIngredientInput>
  }

  export type UserCreateWithoutSharedIngredientInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    email: string
    password: string
    groupMod?: GroupModCreateNestedManyWithoutUsersInput
    groupUser?: GroupUserCreateNestedManyWithoutUsersInput
    userData?: UserDataCreateNestedManyWithoutUsersInput
    ingredientSharedBy?: SharedIngredientCreateNestedManyWithoutSharedByInput
    sharedSpec?: SharedSpecCreateNestedManyWithoutUserInput
    specSharedBy?: SharedSpecCreateNestedManyWithoutSharedByInput
    recipes?: RecipeCreateNestedManyWithoutPostedByInput
    spec?: SpecCreateNestedManyWithoutPostedByInput
    ingredient?: IngredientCreateNestedManyWithoutPostedByInput
    touch?: TouchCreateNestedManyWithoutPostedByInput
    adminOnSpec?: AdminOnSpecCreateNestedManyWithoutUserInput
    adminAssignedBy?: AdminOnSpecCreateNestedManyWithoutAssignedByInput
  }

  export type UserUncheckedCreateWithoutSharedIngredientInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    email: string
    password: string
    groupMod?: GroupModUncheckedCreateNestedManyWithoutUsersInput
    groupUser?: GroupUserUncheckedCreateNestedManyWithoutUsersInput
    userData?: UserDataUncheckedCreateNestedManyWithoutUsersInput
    ingredientSharedBy?: SharedIngredientUncheckedCreateNestedManyWithoutSharedByInput
    sharedSpec?: SharedSpecUncheckedCreateNestedManyWithoutUserInput
    specSharedBy?: SharedSpecUncheckedCreateNestedManyWithoutSharedByInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutPostedByInput
    spec?: SpecUncheckedCreateNestedManyWithoutPostedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutPostedByInput
    touch?: TouchUncheckedCreateNestedManyWithoutPostedByInput
    adminOnSpec?: AdminOnSpecUncheckedCreateNestedManyWithoutUserInput
    adminAssignedBy?: AdminOnSpecUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type UserCreateOrConnectWithoutSharedIngredientInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSharedIngredientInput, UserUncheckedCreateWithoutSharedIngredientInput>
  }

  export type UserCreateWithoutIngredientSharedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    email: string
    password: string
    groupMod?: GroupModCreateNestedManyWithoutUsersInput
    groupUser?: GroupUserCreateNestedManyWithoutUsersInput
    userData?: UserDataCreateNestedManyWithoutUsersInput
    sharedIngredient?: SharedIngredientCreateNestedManyWithoutUserInput
    sharedSpec?: SharedSpecCreateNestedManyWithoutUserInput
    specSharedBy?: SharedSpecCreateNestedManyWithoutSharedByInput
    recipes?: RecipeCreateNestedManyWithoutPostedByInput
    spec?: SpecCreateNestedManyWithoutPostedByInput
    ingredient?: IngredientCreateNestedManyWithoutPostedByInput
    touch?: TouchCreateNestedManyWithoutPostedByInput
    adminOnSpec?: AdminOnSpecCreateNestedManyWithoutUserInput
    adminAssignedBy?: AdminOnSpecCreateNestedManyWithoutAssignedByInput
  }

  export type UserUncheckedCreateWithoutIngredientSharedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    email: string
    password: string
    groupMod?: GroupModUncheckedCreateNestedManyWithoutUsersInput
    groupUser?: GroupUserUncheckedCreateNestedManyWithoutUsersInput
    userData?: UserDataUncheckedCreateNestedManyWithoutUsersInput
    sharedIngredient?: SharedIngredientUncheckedCreateNestedManyWithoutUserInput
    sharedSpec?: SharedSpecUncheckedCreateNestedManyWithoutUserInput
    specSharedBy?: SharedSpecUncheckedCreateNestedManyWithoutSharedByInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutPostedByInput
    spec?: SpecUncheckedCreateNestedManyWithoutPostedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutPostedByInput
    touch?: TouchUncheckedCreateNestedManyWithoutPostedByInput
    adminOnSpec?: AdminOnSpecUncheckedCreateNestedManyWithoutUserInput
    adminAssignedBy?: AdminOnSpecUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type UserCreateOrConnectWithoutIngredientSharedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIngredientSharedByInput, UserUncheckedCreateWithoutIngredientSharedByInput>
  }

  export type IngredientUpsertWithoutSharedIngredientInput = {
    update: XOR<IngredientUpdateWithoutSharedIngredientInput, IngredientUncheckedUpdateWithoutSharedIngredientInput>
    create: XOR<IngredientCreateWithoutSharedIngredientInput, IngredientUncheckedCreateWithoutSharedIngredientInput>
  }

  export type IngredientUpdateWithoutSharedIngredientInput = {
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    postedBy?: UserUpdateOneWithoutIngredientNestedInput
    groupIngredient?: GroupIngredientUpdateManyWithoutIngredientNestedInput
    touch?: TouchUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientUncheckedUpdateWithoutSharedIngredientInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    postedById?: StringFieldUpdateOperationsInput | string
    groupIngredient?: GroupIngredientUncheckedUpdateManyWithoutIngredientNestedInput
    touch?: TouchUncheckedUpdateManyWithoutIngredientNestedInput
  }

  export type UserUpsertWithoutSharedIngredientInput = {
    update: XOR<UserUpdateWithoutSharedIngredientInput, UserUncheckedUpdateWithoutSharedIngredientInput>
    create: XOR<UserCreateWithoutSharedIngredientInput, UserUncheckedCreateWithoutSharedIngredientInput>
  }

  export type UserUpdateWithoutSharedIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    groupMod?: GroupModUpdateManyWithoutUsersNestedInput
    groupUser?: GroupUserUpdateManyWithoutUsersNestedInput
    userData?: UserDataUpdateManyWithoutUsersNestedInput
    ingredientSharedBy?: SharedIngredientUpdateManyWithoutSharedByNestedInput
    sharedSpec?: SharedSpecUpdateManyWithoutUserNestedInput
    specSharedBy?: SharedSpecUpdateManyWithoutSharedByNestedInput
    recipes?: RecipeUpdateManyWithoutPostedByNestedInput
    spec?: SpecUpdateManyWithoutPostedByNestedInput
    ingredient?: IngredientUpdateManyWithoutPostedByNestedInput
    touch?: TouchUpdateManyWithoutPostedByNestedInput
    adminOnSpec?: AdminOnSpecUpdateManyWithoutUserNestedInput
    adminAssignedBy?: AdminOnSpecUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSharedIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    groupMod?: GroupModUncheckedUpdateManyWithoutUsersNestedInput
    groupUser?: GroupUserUncheckedUpdateManyWithoutUsersNestedInput
    userData?: UserDataUncheckedUpdateManyWithoutUsersNestedInput
    ingredientSharedBy?: SharedIngredientUncheckedUpdateManyWithoutSharedByNestedInput
    sharedSpec?: SharedSpecUncheckedUpdateManyWithoutUserNestedInput
    specSharedBy?: SharedSpecUncheckedUpdateManyWithoutSharedByNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutPostedByNestedInput
    spec?: SpecUncheckedUpdateManyWithoutPostedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutPostedByNestedInput
    touch?: TouchUncheckedUpdateManyWithoutPostedByNestedInput
    adminOnSpec?: AdminOnSpecUncheckedUpdateManyWithoutUserNestedInput
    adminAssignedBy?: AdminOnSpecUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUpsertWithoutIngredientSharedByInput = {
    update: XOR<UserUpdateWithoutIngredientSharedByInput, UserUncheckedUpdateWithoutIngredientSharedByInput>
    create: XOR<UserCreateWithoutIngredientSharedByInput, UserUncheckedCreateWithoutIngredientSharedByInput>
  }

  export type UserUpdateWithoutIngredientSharedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    groupMod?: GroupModUpdateManyWithoutUsersNestedInput
    groupUser?: GroupUserUpdateManyWithoutUsersNestedInput
    userData?: UserDataUpdateManyWithoutUsersNestedInput
    sharedIngredient?: SharedIngredientUpdateManyWithoutUserNestedInput
    sharedSpec?: SharedSpecUpdateManyWithoutUserNestedInput
    specSharedBy?: SharedSpecUpdateManyWithoutSharedByNestedInput
    recipes?: RecipeUpdateManyWithoutPostedByNestedInput
    spec?: SpecUpdateManyWithoutPostedByNestedInput
    ingredient?: IngredientUpdateManyWithoutPostedByNestedInput
    touch?: TouchUpdateManyWithoutPostedByNestedInput
    adminOnSpec?: AdminOnSpecUpdateManyWithoutUserNestedInput
    adminAssignedBy?: AdminOnSpecUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUncheckedUpdateWithoutIngredientSharedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    groupMod?: GroupModUncheckedUpdateManyWithoutUsersNestedInput
    groupUser?: GroupUserUncheckedUpdateManyWithoutUsersNestedInput
    userData?: UserDataUncheckedUpdateManyWithoutUsersNestedInput
    sharedIngredient?: SharedIngredientUncheckedUpdateManyWithoutUserNestedInput
    sharedSpec?: SharedSpecUncheckedUpdateManyWithoutUserNestedInput
    specSharedBy?: SharedSpecUncheckedUpdateManyWithoutSharedByNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutPostedByNestedInput
    spec?: SpecUncheckedUpdateManyWithoutPostedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutPostedByNestedInput
    touch?: TouchUncheckedUpdateManyWithoutPostedByNestedInput
    adminOnSpec?: AdminOnSpecUncheckedUpdateManyWithoutUserNestedInput
    adminAssignedBy?: AdminOnSpecUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type SpecCreateWithoutSharedSpecInput = {
    specName?: string
    postedBy?: UserCreateNestedOneWithoutSpecInput
    instructions?: string | null
    glassware?: string | null
    ice?: string | null
    groupSpec?: GroupSpecCreateNestedManyWithoutSpecInput
    recipe?: RecipeCreateNestedOneWithoutSpecInput
    touch?: TouchCreateNestedManyWithoutSpecInput
    adminOnSpec?: AdminOnSpecCreateNestedManyWithoutSpecInput
  }

  export type SpecUncheckedCreateWithoutSharedSpecInput = {
    id?: number
    specName?: string
    postedById: string
    instructions?: string | null
    glassware?: string | null
    ice?: string | null
    groupSpec?: GroupSpecUncheckedCreateNestedManyWithoutSpecInput
    recipeId?: number | null
    touch?: TouchUncheckedCreateNestedManyWithoutSpecInput
    adminOnSpec?: AdminOnSpecUncheckedCreateNestedManyWithoutSpecInput
  }

  export type SpecCreateOrConnectWithoutSharedSpecInput = {
    where: SpecWhereUniqueInput
    create: XOR<SpecCreateWithoutSharedSpecInput, SpecUncheckedCreateWithoutSharedSpecInput>
  }

  export type UserCreateWithoutSharedSpecInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    email: string
    password: string
    groupMod?: GroupModCreateNestedManyWithoutUsersInput
    groupUser?: GroupUserCreateNestedManyWithoutUsersInput
    userData?: UserDataCreateNestedManyWithoutUsersInput
    sharedIngredient?: SharedIngredientCreateNestedManyWithoutUserInput
    ingredientSharedBy?: SharedIngredientCreateNestedManyWithoutSharedByInput
    specSharedBy?: SharedSpecCreateNestedManyWithoutSharedByInput
    recipes?: RecipeCreateNestedManyWithoutPostedByInput
    spec?: SpecCreateNestedManyWithoutPostedByInput
    ingredient?: IngredientCreateNestedManyWithoutPostedByInput
    touch?: TouchCreateNestedManyWithoutPostedByInput
    adminOnSpec?: AdminOnSpecCreateNestedManyWithoutUserInput
    adminAssignedBy?: AdminOnSpecCreateNestedManyWithoutAssignedByInput
  }

  export type UserUncheckedCreateWithoutSharedSpecInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    email: string
    password: string
    groupMod?: GroupModUncheckedCreateNestedManyWithoutUsersInput
    groupUser?: GroupUserUncheckedCreateNestedManyWithoutUsersInput
    userData?: UserDataUncheckedCreateNestedManyWithoutUsersInput
    sharedIngredient?: SharedIngredientUncheckedCreateNestedManyWithoutUserInput
    ingredientSharedBy?: SharedIngredientUncheckedCreateNestedManyWithoutSharedByInput
    specSharedBy?: SharedSpecUncheckedCreateNestedManyWithoutSharedByInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutPostedByInput
    spec?: SpecUncheckedCreateNestedManyWithoutPostedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutPostedByInput
    touch?: TouchUncheckedCreateNestedManyWithoutPostedByInput
    adminOnSpec?: AdminOnSpecUncheckedCreateNestedManyWithoutUserInput
    adminAssignedBy?: AdminOnSpecUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type UserCreateOrConnectWithoutSharedSpecInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSharedSpecInput, UserUncheckedCreateWithoutSharedSpecInput>
  }

  export type UserCreateWithoutSpecSharedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    email: string
    password: string
    groupMod?: GroupModCreateNestedManyWithoutUsersInput
    groupUser?: GroupUserCreateNestedManyWithoutUsersInput
    userData?: UserDataCreateNestedManyWithoutUsersInput
    sharedIngredient?: SharedIngredientCreateNestedManyWithoutUserInput
    ingredientSharedBy?: SharedIngredientCreateNestedManyWithoutSharedByInput
    sharedSpec?: SharedSpecCreateNestedManyWithoutUserInput
    recipes?: RecipeCreateNestedManyWithoutPostedByInput
    spec?: SpecCreateNestedManyWithoutPostedByInput
    ingredient?: IngredientCreateNestedManyWithoutPostedByInput
    touch?: TouchCreateNestedManyWithoutPostedByInput
    adminOnSpec?: AdminOnSpecCreateNestedManyWithoutUserInput
    adminAssignedBy?: AdminOnSpecCreateNestedManyWithoutAssignedByInput
  }

  export type UserUncheckedCreateWithoutSpecSharedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    email: string
    password: string
    groupMod?: GroupModUncheckedCreateNestedManyWithoutUsersInput
    groupUser?: GroupUserUncheckedCreateNestedManyWithoutUsersInput
    userData?: UserDataUncheckedCreateNestedManyWithoutUsersInput
    sharedIngredient?: SharedIngredientUncheckedCreateNestedManyWithoutUserInput
    ingredientSharedBy?: SharedIngredientUncheckedCreateNestedManyWithoutSharedByInput
    sharedSpec?: SharedSpecUncheckedCreateNestedManyWithoutUserInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutPostedByInput
    spec?: SpecUncheckedCreateNestedManyWithoutPostedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutPostedByInput
    touch?: TouchUncheckedCreateNestedManyWithoutPostedByInput
    adminOnSpec?: AdminOnSpecUncheckedCreateNestedManyWithoutUserInput
    adminAssignedBy?: AdminOnSpecUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type UserCreateOrConnectWithoutSpecSharedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSpecSharedByInput, UserUncheckedCreateWithoutSpecSharedByInput>
  }

  export type SpecUpsertWithoutSharedSpecInput = {
    update: XOR<SpecUpdateWithoutSharedSpecInput, SpecUncheckedUpdateWithoutSharedSpecInput>
    create: XOR<SpecCreateWithoutSharedSpecInput, SpecUncheckedCreateWithoutSharedSpecInput>
  }

  export type SpecUpdateWithoutSharedSpecInput = {
    specName?: StringFieldUpdateOperationsInput | string
    postedBy?: UserUpdateOneWithoutSpecNestedInput
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    groupSpec?: GroupSpecUpdateManyWithoutSpecNestedInput
    recipe?: RecipeUpdateOneWithoutSpecNestedInput
    touch?: TouchUpdateManyWithoutSpecNestedInput
    adminOnSpec?: AdminOnSpecUpdateManyWithoutSpecNestedInput
  }

  export type SpecUncheckedUpdateWithoutSharedSpecInput = {
    id?: IntFieldUpdateOperationsInput | number
    specName?: StringFieldUpdateOperationsInput | string
    postedById?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    groupSpec?: GroupSpecUncheckedUpdateManyWithoutSpecNestedInput
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
    touch?: TouchUncheckedUpdateManyWithoutSpecNestedInput
    adminOnSpec?: AdminOnSpecUncheckedUpdateManyWithoutSpecNestedInput
  }

  export type UserUpsertWithoutSharedSpecInput = {
    update: XOR<UserUpdateWithoutSharedSpecInput, UserUncheckedUpdateWithoutSharedSpecInput>
    create: XOR<UserCreateWithoutSharedSpecInput, UserUncheckedCreateWithoutSharedSpecInput>
  }

  export type UserUpdateWithoutSharedSpecInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    groupMod?: GroupModUpdateManyWithoutUsersNestedInput
    groupUser?: GroupUserUpdateManyWithoutUsersNestedInput
    userData?: UserDataUpdateManyWithoutUsersNestedInput
    sharedIngredient?: SharedIngredientUpdateManyWithoutUserNestedInput
    ingredientSharedBy?: SharedIngredientUpdateManyWithoutSharedByNestedInput
    specSharedBy?: SharedSpecUpdateManyWithoutSharedByNestedInput
    recipes?: RecipeUpdateManyWithoutPostedByNestedInput
    spec?: SpecUpdateManyWithoutPostedByNestedInput
    ingredient?: IngredientUpdateManyWithoutPostedByNestedInput
    touch?: TouchUpdateManyWithoutPostedByNestedInput
    adminOnSpec?: AdminOnSpecUpdateManyWithoutUserNestedInput
    adminAssignedBy?: AdminOnSpecUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSharedSpecInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    groupMod?: GroupModUncheckedUpdateManyWithoutUsersNestedInput
    groupUser?: GroupUserUncheckedUpdateManyWithoutUsersNestedInput
    userData?: UserDataUncheckedUpdateManyWithoutUsersNestedInput
    sharedIngredient?: SharedIngredientUncheckedUpdateManyWithoutUserNestedInput
    ingredientSharedBy?: SharedIngredientUncheckedUpdateManyWithoutSharedByNestedInput
    specSharedBy?: SharedSpecUncheckedUpdateManyWithoutSharedByNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutPostedByNestedInput
    spec?: SpecUncheckedUpdateManyWithoutPostedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutPostedByNestedInput
    touch?: TouchUncheckedUpdateManyWithoutPostedByNestedInput
    adminOnSpec?: AdminOnSpecUncheckedUpdateManyWithoutUserNestedInput
    adminAssignedBy?: AdminOnSpecUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUpsertWithoutSpecSharedByInput = {
    update: XOR<UserUpdateWithoutSpecSharedByInput, UserUncheckedUpdateWithoutSpecSharedByInput>
    create: XOR<UserCreateWithoutSpecSharedByInput, UserUncheckedCreateWithoutSpecSharedByInput>
  }

  export type UserUpdateWithoutSpecSharedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    groupMod?: GroupModUpdateManyWithoutUsersNestedInput
    groupUser?: GroupUserUpdateManyWithoutUsersNestedInput
    userData?: UserDataUpdateManyWithoutUsersNestedInput
    sharedIngredient?: SharedIngredientUpdateManyWithoutUserNestedInput
    ingredientSharedBy?: SharedIngredientUpdateManyWithoutSharedByNestedInput
    sharedSpec?: SharedSpecUpdateManyWithoutUserNestedInput
    recipes?: RecipeUpdateManyWithoutPostedByNestedInput
    spec?: SpecUpdateManyWithoutPostedByNestedInput
    ingredient?: IngredientUpdateManyWithoutPostedByNestedInput
    touch?: TouchUpdateManyWithoutPostedByNestedInput
    adminOnSpec?: AdminOnSpecUpdateManyWithoutUserNestedInput
    adminAssignedBy?: AdminOnSpecUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSpecSharedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    groupMod?: GroupModUncheckedUpdateManyWithoutUsersNestedInput
    groupUser?: GroupUserUncheckedUpdateManyWithoutUsersNestedInput
    userData?: UserDataUncheckedUpdateManyWithoutUsersNestedInput
    sharedIngredient?: SharedIngredientUncheckedUpdateManyWithoutUserNestedInput
    ingredientSharedBy?: SharedIngredientUncheckedUpdateManyWithoutSharedByNestedInput
    sharedSpec?: SharedSpecUncheckedUpdateManyWithoutUserNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutPostedByNestedInput
    spec?: SpecUncheckedUpdateManyWithoutPostedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutPostedByNestedInput
    touch?: TouchUncheckedUpdateManyWithoutPostedByNestedInput
    adminOnSpec?: AdminOnSpecUncheckedUpdateManyWithoutUserNestedInput
    adminAssignedBy?: AdminOnSpecUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type SpecCreateWithoutAdminOnSpecInput = {
    specName?: string
    postedBy?: UserCreateNestedOneWithoutSpecInput
    instructions?: string | null
    glassware?: string | null
    ice?: string | null
    groupSpec?: GroupSpecCreateNestedManyWithoutSpecInput
    sharedSpec?: SharedSpecCreateNestedManyWithoutSpecInput
    recipe?: RecipeCreateNestedOneWithoutSpecInput
    touch?: TouchCreateNestedManyWithoutSpecInput
  }

  export type SpecUncheckedCreateWithoutAdminOnSpecInput = {
    id?: number
    specName?: string
    postedById: string
    instructions?: string | null
    glassware?: string | null
    ice?: string | null
    groupSpec?: GroupSpecUncheckedCreateNestedManyWithoutSpecInput
    sharedSpec?: SharedSpecUncheckedCreateNestedManyWithoutSpecInput
    recipeId?: number | null
    touch?: TouchUncheckedCreateNestedManyWithoutSpecInput
  }

  export type SpecCreateOrConnectWithoutAdminOnSpecInput = {
    where: SpecWhereUniqueInput
    create: XOR<SpecCreateWithoutAdminOnSpecInput, SpecUncheckedCreateWithoutAdminOnSpecInput>
  }

  export type UserCreateWithoutAdminOnSpecInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    email: string
    password: string
    groupMod?: GroupModCreateNestedManyWithoutUsersInput
    groupUser?: GroupUserCreateNestedManyWithoutUsersInput
    userData?: UserDataCreateNestedManyWithoutUsersInput
    sharedIngredient?: SharedIngredientCreateNestedManyWithoutUserInput
    ingredientSharedBy?: SharedIngredientCreateNestedManyWithoutSharedByInput
    sharedSpec?: SharedSpecCreateNestedManyWithoutUserInput
    specSharedBy?: SharedSpecCreateNestedManyWithoutSharedByInput
    recipes?: RecipeCreateNestedManyWithoutPostedByInput
    spec?: SpecCreateNestedManyWithoutPostedByInput
    ingredient?: IngredientCreateNestedManyWithoutPostedByInput
    touch?: TouchCreateNestedManyWithoutPostedByInput
    adminAssignedBy?: AdminOnSpecCreateNestedManyWithoutAssignedByInput
  }

  export type UserUncheckedCreateWithoutAdminOnSpecInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    email: string
    password: string
    groupMod?: GroupModUncheckedCreateNestedManyWithoutUsersInput
    groupUser?: GroupUserUncheckedCreateNestedManyWithoutUsersInput
    userData?: UserDataUncheckedCreateNestedManyWithoutUsersInput
    sharedIngredient?: SharedIngredientUncheckedCreateNestedManyWithoutUserInput
    ingredientSharedBy?: SharedIngredientUncheckedCreateNestedManyWithoutSharedByInput
    sharedSpec?: SharedSpecUncheckedCreateNestedManyWithoutUserInput
    specSharedBy?: SharedSpecUncheckedCreateNestedManyWithoutSharedByInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutPostedByInput
    spec?: SpecUncheckedCreateNestedManyWithoutPostedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutPostedByInput
    touch?: TouchUncheckedCreateNestedManyWithoutPostedByInput
    adminAssignedBy?: AdminOnSpecUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type UserCreateOrConnectWithoutAdminOnSpecInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminOnSpecInput, UserUncheckedCreateWithoutAdminOnSpecInput>
  }

  export type UserCreateWithoutAdminAssignedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    email: string
    password: string
    groupMod?: GroupModCreateNestedManyWithoutUsersInput
    groupUser?: GroupUserCreateNestedManyWithoutUsersInput
    userData?: UserDataCreateNestedManyWithoutUsersInput
    sharedIngredient?: SharedIngredientCreateNestedManyWithoutUserInput
    ingredientSharedBy?: SharedIngredientCreateNestedManyWithoutSharedByInput
    sharedSpec?: SharedSpecCreateNestedManyWithoutUserInput
    specSharedBy?: SharedSpecCreateNestedManyWithoutSharedByInput
    recipes?: RecipeCreateNestedManyWithoutPostedByInput
    spec?: SpecCreateNestedManyWithoutPostedByInput
    ingredient?: IngredientCreateNestedManyWithoutPostedByInput
    touch?: TouchCreateNestedManyWithoutPostedByInput
    adminOnSpec?: AdminOnSpecCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdminAssignedByInput = {
    id?: string
    userName: string
    firstName?: string | null
    lastName?: string | null
    dateJoined?: Date | string
    email: string
    password: string
    groupMod?: GroupModUncheckedCreateNestedManyWithoutUsersInput
    groupUser?: GroupUserUncheckedCreateNestedManyWithoutUsersInput
    userData?: UserDataUncheckedCreateNestedManyWithoutUsersInput
    sharedIngredient?: SharedIngredientUncheckedCreateNestedManyWithoutUserInput
    ingredientSharedBy?: SharedIngredientUncheckedCreateNestedManyWithoutSharedByInput
    sharedSpec?: SharedSpecUncheckedCreateNestedManyWithoutUserInput
    specSharedBy?: SharedSpecUncheckedCreateNestedManyWithoutSharedByInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutPostedByInput
    spec?: SpecUncheckedCreateNestedManyWithoutPostedByInput
    ingredient?: IngredientUncheckedCreateNestedManyWithoutPostedByInput
    touch?: TouchUncheckedCreateNestedManyWithoutPostedByInput
    adminOnSpec?: AdminOnSpecUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdminAssignedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminAssignedByInput, UserUncheckedCreateWithoutAdminAssignedByInput>
  }

  export type SpecUpsertWithoutAdminOnSpecInput = {
    update: XOR<SpecUpdateWithoutAdminOnSpecInput, SpecUncheckedUpdateWithoutAdminOnSpecInput>
    create: XOR<SpecCreateWithoutAdminOnSpecInput, SpecUncheckedCreateWithoutAdminOnSpecInput>
  }

  export type SpecUpdateWithoutAdminOnSpecInput = {
    specName?: StringFieldUpdateOperationsInput | string
    postedBy?: UserUpdateOneWithoutSpecNestedInput
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    groupSpec?: GroupSpecUpdateManyWithoutSpecNestedInput
    sharedSpec?: SharedSpecUpdateManyWithoutSpecNestedInput
    recipe?: RecipeUpdateOneWithoutSpecNestedInput
    touch?: TouchUpdateManyWithoutSpecNestedInput
  }

  export type SpecUncheckedUpdateWithoutAdminOnSpecInput = {
    id?: IntFieldUpdateOperationsInput | number
    specName?: StringFieldUpdateOperationsInput | string
    postedById?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    groupSpec?: GroupSpecUncheckedUpdateManyWithoutSpecNestedInput
    sharedSpec?: SharedSpecUncheckedUpdateManyWithoutSpecNestedInput
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
    touch?: TouchUncheckedUpdateManyWithoutSpecNestedInput
  }

  export type UserUpsertWithoutAdminOnSpecInput = {
    update: XOR<UserUpdateWithoutAdminOnSpecInput, UserUncheckedUpdateWithoutAdminOnSpecInput>
    create: XOR<UserCreateWithoutAdminOnSpecInput, UserUncheckedCreateWithoutAdminOnSpecInput>
  }

  export type UserUpdateWithoutAdminOnSpecInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    groupMod?: GroupModUpdateManyWithoutUsersNestedInput
    groupUser?: GroupUserUpdateManyWithoutUsersNestedInput
    userData?: UserDataUpdateManyWithoutUsersNestedInput
    sharedIngredient?: SharedIngredientUpdateManyWithoutUserNestedInput
    ingredientSharedBy?: SharedIngredientUpdateManyWithoutSharedByNestedInput
    sharedSpec?: SharedSpecUpdateManyWithoutUserNestedInput
    specSharedBy?: SharedSpecUpdateManyWithoutSharedByNestedInput
    recipes?: RecipeUpdateManyWithoutPostedByNestedInput
    spec?: SpecUpdateManyWithoutPostedByNestedInput
    ingredient?: IngredientUpdateManyWithoutPostedByNestedInput
    touch?: TouchUpdateManyWithoutPostedByNestedInput
    adminAssignedBy?: AdminOnSpecUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminOnSpecInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    groupMod?: GroupModUncheckedUpdateManyWithoutUsersNestedInput
    groupUser?: GroupUserUncheckedUpdateManyWithoutUsersNestedInput
    userData?: UserDataUncheckedUpdateManyWithoutUsersNestedInput
    sharedIngredient?: SharedIngredientUncheckedUpdateManyWithoutUserNestedInput
    ingredientSharedBy?: SharedIngredientUncheckedUpdateManyWithoutSharedByNestedInput
    sharedSpec?: SharedSpecUncheckedUpdateManyWithoutUserNestedInput
    specSharedBy?: SharedSpecUncheckedUpdateManyWithoutSharedByNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutPostedByNestedInput
    spec?: SpecUncheckedUpdateManyWithoutPostedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutPostedByNestedInput
    touch?: TouchUncheckedUpdateManyWithoutPostedByNestedInput
    adminAssignedBy?: AdminOnSpecUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUpsertWithoutAdminAssignedByInput = {
    update: XOR<UserUpdateWithoutAdminAssignedByInput, UserUncheckedUpdateWithoutAdminAssignedByInput>
    create: XOR<UserCreateWithoutAdminAssignedByInput, UserUncheckedCreateWithoutAdminAssignedByInput>
  }

  export type UserUpdateWithoutAdminAssignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    groupMod?: GroupModUpdateManyWithoutUsersNestedInput
    groupUser?: GroupUserUpdateManyWithoutUsersNestedInput
    userData?: UserDataUpdateManyWithoutUsersNestedInput
    sharedIngredient?: SharedIngredientUpdateManyWithoutUserNestedInput
    ingredientSharedBy?: SharedIngredientUpdateManyWithoutSharedByNestedInput
    sharedSpec?: SharedSpecUpdateManyWithoutUserNestedInput
    specSharedBy?: SharedSpecUpdateManyWithoutSharedByNestedInput
    recipes?: RecipeUpdateManyWithoutPostedByNestedInput
    spec?: SpecUpdateManyWithoutPostedByNestedInput
    ingredient?: IngredientUpdateManyWithoutPostedByNestedInput
    touch?: TouchUpdateManyWithoutPostedByNestedInput
    adminOnSpec?: AdminOnSpecUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminAssignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    groupMod?: GroupModUncheckedUpdateManyWithoutUsersNestedInput
    groupUser?: GroupUserUncheckedUpdateManyWithoutUsersNestedInput
    userData?: UserDataUncheckedUpdateManyWithoutUsersNestedInput
    sharedIngredient?: SharedIngredientUncheckedUpdateManyWithoutUserNestedInput
    ingredientSharedBy?: SharedIngredientUncheckedUpdateManyWithoutSharedByNestedInput
    sharedSpec?: SharedSpecUncheckedUpdateManyWithoutUserNestedInput
    specSharedBy?: SharedSpecUncheckedUpdateManyWithoutSharedByNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutPostedByNestedInput
    spec?: SpecUncheckedUpdateManyWithoutPostedByNestedInput
    ingredient?: IngredientUncheckedUpdateManyWithoutPostedByNestedInput
    touch?: TouchUncheckedUpdateManyWithoutPostedByNestedInput
    adminOnSpec?: AdminOnSpecUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GroupIngredientCreateManyGroupsInput = {
    ingredientId: number
  }

  export type GroupModCreateManyGroupsInput = {
    userId: string
  }

  export type GroupSpecCreateManyGroupsInput = {
    specId: number
  }

  export type GroupUserCreateManyGroupsInput = {
    userId: string
  }

  export type GroupIngredientUpdateWithoutGroupsInput = {
    ingredient?: IngredientUpdateOneRequiredWithoutGroupIngredientNestedInput
  }

  export type GroupIngredientUncheckedUpdateWithoutGroupsInput = {
    ingredientId?: IntFieldUpdateOperationsInput | number
  }

  export type GroupIngredientUncheckedUpdateManyWithoutGroupIngredientInput = {
    ingredientId?: IntFieldUpdateOperationsInput | number
  }

  export type GroupModUpdateWithoutGroupsInput = {
    users?: UserUpdateOneRequiredWithoutGroupModNestedInput
  }

  export type GroupModUncheckedUpdateWithoutGroupsInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type GroupModUncheckedUpdateManyWithoutGroupModInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type GroupSpecUpdateWithoutGroupsInput = {
    spec?: SpecUpdateOneRequiredWithoutGroupSpecNestedInput
  }

  export type GroupSpecUncheckedUpdateWithoutGroupsInput = {
    specId?: IntFieldUpdateOperationsInput | number
  }

  export type GroupSpecUncheckedUpdateManyWithoutGroupSpecInput = {
    specId?: IntFieldUpdateOperationsInput | number
  }

  export type GroupUserUpdateWithoutGroupsInput = {
    users?: UserUpdateOneRequiredWithoutGroupUserNestedInput
  }

  export type GroupUserUncheckedUpdateWithoutGroupsInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type GroupUserUncheckedUpdateManyWithoutGroupUserInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type GroupIngredientCreateManyIngredientInput = {
    groupId: number
  }

  export type TouchCreateManyIngredientInput = {
    id?: number
    order?: number | null
    amount?: number | null
    unit?: string | null
    specId?: number | null
    postedById: string
  }

  export type SharedIngredientCreateManyIngredientInput = {
    userId: string
    sharedById: string
    sharedAt?: Date | string
  }

  export type GroupIngredientUpdateWithoutIngredientInput = {
    groups?: GroupsUpdateOneRequiredWithoutGroupIngredientNestedInput
  }

  export type GroupIngredientUncheckedUpdateWithoutIngredientInput = {
    groupId?: IntFieldUpdateOperationsInput | number
  }

  export type TouchUpdateWithoutIngredientInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    spec?: SpecUpdateOneWithoutTouchNestedInput
    postedBy?: UserUpdateOneWithoutTouchNestedInput
  }

  export type TouchUncheckedUpdateWithoutIngredientInput = {
    id?: IntFieldUpdateOperationsInput | number
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    specId?: NullableIntFieldUpdateOperationsInput | number | null
    postedById?: StringFieldUpdateOperationsInput | string
  }

  export type TouchUncheckedUpdateManyWithoutTouchInput = {
    id?: IntFieldUpdateOperationsInput | number
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    specId?: NullableIntFieldUpdateOperationsInput | number | null
    postedById?: StringFieldUpdateOperationsInput | string
  }

  export type SharedIngredientUpdateWithoutIngredientInput = {
    sharedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSharedIngredientNestedInput
    sharedBy?: UserUpdateOneRequiredWithoutIngredientSharedByNestedInput
  }

  export type SharedIngredientUncheckedUpdateWithoutIngredientInput = {
    userId?: StringFieldUpdateOperationsInput | string
    sharedById?: StringFieldUpdateOperationsInput | string
    sharedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedIngredientUncheckedUpdateManyWithoutSharedIngredientInput = {
    userId?: StringFieldUpdateOperationsInput | string
    sharedById?: StringFieldUpdateOperationsInput | string
    sharedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecCreateManyRecipeInput = {
    id?: number
    specName?: string
    postedById: string
    instructions?: string | null
    glassware?: string | null
    ice?: string | null
  }

  export type SpecUpdateWithoutRecipeInput = {
    specName?: StringFieldUpdateOperationsInput | string
    postedBy?: UserUpdateOneWithoutSpecNestedInput
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    groupSpec?: GroupSpecUpdateManyWithoutSpecNestedInput
    sharedSpec?: SharedSpecUpdateManyWithoutSpecNestedInput
    touch?: TouchUpdateManyWithoutSpecNestedInput
    adminOnSpec?: AdminOnSpecUpdateManyWithoutSpecNestedInput
  }

  export type SpecUncheckedUpdateWithoutRecipeInput = {
    id?: IntFieldUpdateOperationsInput | number
    specName?: StringFieldUpdateOperationsInput | string
    postedById?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    groupSpec?: GroupSpecUncheckedUpdateManyWithoutSpecNestedInput
    sharedSpec?: SharedSpecUncheckedUpdateManyWithoutSpecNestedInput
    touch?: TouchUncheckedUpdateManyWithoutSpecNestedInput
    adminOnSpec?: AdminOnSpecUncheckedUpdateManyWithoutSpecNestedInput
  }

  export type SpecUncheckedUpdateManyWithoutSpecInput = {
    id?: IntFieldUpdateOperationsInput | number
    specName?: StringFieldUpdateOperationsInput | string
    postedById?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GroupSpecCreateManySpecInput = {
    groupId: number
  }

  export type SharedSpecCreateManySpecInput = {
    userId: string
    sharedById: string
    sharedAt?: Date | string
  }

  export type TouchCreateManySpecInput = {
    id?: number
    ingredientId?: number | null
    order?: number | null
    amount?: number | null
    unit?: string | null
    postedById: string
  }

  export type AdminOnSpecCreateManySpecInput = {
    userId: string
    assignedById: string
    assignedAt?: Date | string
  }

  export type GroupSpecUpdateWithoutSpecInput = {
    groups?: GroupsUpdateOneRequiredWithoutGroupSpecNestedInput
  }

  export type GroupSpecUncheckedUpdateWithoutSpecInput = {
    groupId?: IntFieldUpdateOperationsInput | number
  }

  export type SharedSpecUpdateWithoutSpecInput = {
    sharedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSharedSpecNestedInput
    sharedBy?: UserUpdateOneRequiredWithoutSpecSharedByNestedInput
  }

  export type SharedSpecUncheckedUpdateWithoutSpecInput = {
    userId?: StringFieldUpdateOperationsInput | string
    sharedById?: StringFieldUpdateOperationsInput | string
    sharedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedSpecUncheckedUpdateManyWithoutSharedSpecInput = {
    userId?: StringFieldUpdateOperationsInput | string
    sharedById?: StringFieldUpdateOperationsInput | string
    sharedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TouchUpdateWithoutSpecInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    ingredient?: IngredientUpdateOneWithoutTouchNestedInput
    postedBy?: UserUpdateOneWithoutTouchNestedInput
  }

  export type TouchUncheckedUpdateWithoutSpecInput = {
    id?: IntFieldUpdateOperationsInput | number
    ingredientId?: NullableIntFieldUpdateOperationsInput | number | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    postedById?: StringFieldUpdateOperationsInput | string
  }

  export type AdminOnSpecUpdateWithoutSpecInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdminOnSpecNestedInput
    assignedBy?: UserUpdateOneRequiredWithoutAdminAssignedByNestedInput
  }

  export type AdminOnSpecUncheckedUpdateWithoutSpecInput = {
    userId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminOnSpecUncheckedUpdateManyWithoutAdminOnSpecInput = {
    userId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupModCreateManyUsersInput = {
    groupId: number
  }

  export type GroupUserCreateManyUsersInput = {
    groupId: number
  }

  export type UserDataCreateManyUsersInput = {
    id?: number
    userBio?: string | null
    workPlace?: string | null
    profilePicture?: string | null
  }

  export type SharedIngredientCreateManyUserInput = {
    ingredientId: number
    sharedById: string
    sharedAt?: Date | string
  }

  export type SharedIngredientCreateManySharedByInput = {
    userId: string
    ingredientId: number
    sharedAt?: Date | string
  }

  export type SharedSpecCreateManyUserInput = {
    specId: number
    sharedById: string
    sharedAt?: Date | string
  }

  export type SharedSpecCreateManySharedByInput = {
    userId: string
    specId: number
    sharedAt?: Date | string
  }

  export type RecipeCreateManyPostedByInput = {
    id?: number
    createdAt?: Date | string
    name: string
    origin: string
    history?: string | null
  }

  export type SpecCreateManyPostedByInput = {
    id?: number
    specName?: string
    instructions?: string | null
    glassware?: string | null
    ice?: string | null
    recipeId?: number | null
  }

  export type IngredientCreateManyPostedByInput = {
    id?: number
    dateCreated?: Date | string
    name: string
    amount?: number | null
    unit?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    source?: string | null
  }

  export type TouchCreateManyPostedByInput = {
    id?: number
    ingredientId?: number | null
    order?: number | null
    amount?: number | null
    unit?: string | null
    specId?: number | null
  }

  export type AdminOnSpecCreateManyUserInput = {
    specId: number
    assignedById: string
    assignedAt?: Date | string
  }

  export type AdminOnSpecCreateManyAssignedByInput = {
    userId: string
    specId: number
    assignedAt?: Date | string
  }

  export type GroupModUpdateWithoutUsersInput = {
    groups?: GroupsUpdateOneRequiredWithoutGroupModNestedInput
  }

  export type GroupModUncheckedUpdateWithoutUsersInput = {
    groupId?: IntFieldUpdateOperationsInput | number
  }

  export type GroupUserUpdateWithoutUsersInput = {
    groups?: GroupsUpdateOneRequiredWithoutGroupUserNestedInput
  }

  export type GroupUserUncheckedUpdateWithoutUsersInput = {
    groupId?: IntFieldUpdateOperationsInput | number
  }

  export type UserDataUpdateWithoutUsersInput = {
    userBio?: NullableStringFieldUpdateOperationsInput | string | null
    workPlace?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserDataUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    userBio?: NullableStringFieldUpdateOperationsInput | string | null
    workPlace?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserDataUncheckedUpdateManyWithoutUserDataInput = {
    id?: IntFieldUpdateOperationsInput | number
    userBio?: NullableStringFieldUpdateOperationsInput | string | null
    workPlace?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SharedIngredientUpdateWithoutUserInput = {
    sharedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ingredient?: IngredientUpdateOneRequiredWithoutSharedIngredientNestedInput
    sharedBy?: UserUpdateOneRequiredWithoutIngredientSharedByNestedInput
  }

  export type SharedIngredientUncheckedUpdateWithoutUserInput = {
    ingredientId?: IntFieldUpdateOperationsInput | number
    sharedById?: StringFieldUpdateOperationsInput | string
    sharedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedIngredientUpdateWithoutSharedByInput = {
    sharedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ingredient?: IngredientUpdateOneRequiredWithoutSharedIngredientNestedInput
    user?: UserUpdateOneRequiredWithoutSharedIngredientNestedInput
  }

  export type SharedIngredientUncheckedUpdateWithoutSharedByInput = {
    userId?: StringFieldUpdateOperationsInput | string
    ingredientId?: IntFieldUpdateOperationsInput | number
    sharedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedIngredientUncheckedUpdateManyWithoutIngredientSharedByInput = {
    userId?: StringFieldUpdateOperationsInput | string
    ingredientId?: IntFieldUpdateOperationsInput | number
    sharedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedSpecUpdateWithoutUserInput = {
    sharedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spec?: SpecUpdateOneRequiredWithoutSharedSpecNestedInput
    sharedBy?: UserUpdateOneRequiredWithoutSpecSharedByNestedInput
  }

  export type SharedSpecUncheckedUpdateWithoutUserInput = {
    specId?: IntFieldUpdateOperationsInput | number
    sharedById?: StringFieldUpdateOperationsInput | string
    sharedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedSpecUpdateWithoutSharedByInput = {
    sharedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spec?: SpecUpdateOneRequiredWithoutSharedSpecNestedInput
    user?: UserUpdateOneRequiredWithoutSharedSpecNestedInput
  }

  export type SharedSpecUncheckedUpdateWithoutSharedByInput = {
    userId?: StringFieldUpdateOperationsInput | string
    specId?: IntFieldUpdateOperationsInput | number
    sharedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedSpecUncheckedUpdateManyWithoutSpecSharedByInput = {
    userId?: StringFieldUpdateOperationsInput | string
    specId?: IntFieldUpdateOperationsInput | number
    sharedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipeUpdateWithoutPostedByInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    history?: NullableStringFieldUpdateOperationsInput | string | null
    spec?: SpecUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutPostedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    history?: NullableStringFieldUpdateOperationsInput | string | null
    spec?: SpecUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateManyWithoutRecipesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    history?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpecUpdateWithoutPostedByInput = {
    specName?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    groupSpec?: GroupSpecUpdateManyWithoutSpecNestedInput
    sharedSpec?: SharedSpecUpdateManyWithoutSpecNestedInput
    recipe?: RecipeUpdateOneWithoutSpecNestedInput
    touch?: TouchUpdateManyWithoutSpecNestedInput
    adminOnSpec?: AdminOnSpecUpdateManyWithoutSpecNestedInput
  }

  export type SpecUncheckedUpdateWithoutPostedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    specName?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    glassware?: NullableStringFieldUpdateOperationsInput | string | null
    ice?: NullableStringFieldUpdateOperationsInput | string | null
    groupSpec?: GroupSpecUncheckedUpdateManyWithoutSpecNestedInput
    sharedSpec?: SharedSpecUncheckedUpdateManyWithoutSpecNestedInput
    recipeId?: NullableIntFieldUpdateOperationsInput | number | null
    touch?: TouchUncheckedUpdateManyWithoutSpecNestedInput
    adminOnSpec?: AdminOnSpecUncheckedUpdateManyWithoutSpecNestedInput
  }

  export type IngredientUpdateWithoutPostedByInput = {
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    groupIngredient?: GroupIngredientUpdateManyWithoutIngredientNestedInput
    touch?: TouchUpdateManyWithoutIngredientNestedInput
    sharedIngredient?: SharedIngredientUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientUncheckedUpdateWithoutPostedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    groupIngredient?: GroupIngredientUncheckedUpdateManyWithoutIngredientNestedInput
    touch?: TouchUncheckedUpdateManyWithoutIngredientNestedInput
    sharedIngredient?: SharedIngredientUncheckedUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientUncheckedUpdateManyWithoutIngredientInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TouchUpdateWithoutPostedByInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    ingredient?: IngredientUpdateOneWithoutTouchNestedInput
    spec?: SpecUpdateOneWithoutTouchNestedInput
  }

  export type TouchUncheckedUpdateWithoutPostedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    ingredientId?: NullableIntFieldUpdateOperationsInput | number | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    specId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AdminOnSpecUpdateWithoutUserInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spec?: SpecUpdateOneRequiredWithoutAdminOnSpecNestedInput
    assignedBy?: UserUpdateOneRequiredWithoutAdminAssignedByNestedInput
  }

  export type AdminOnSpecUncheckedUpdateWithoutUserInput = {
    specId?: IntFieldUpdateOperationsInput | number
    assignedById?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminOnSpecUpdateWithoutAssignedByInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spec?: SpecUpdateOneRequiredWithoutAdminOnSpecNestedInput
    user?: UserUpdateOneRequiredWithoutAdminOnSpecNestedInput
  }

  export type AdminOnSpecUncheckedUpdateWithoutAssignedByInput = {
    userId?: StringFieldUpdateOperationsInput | string
    specId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminOnSpecUncheckedUpdateManyWithoutAdminAssignedByInput = {
    userId?: StringFieldUpdateOperationsInput | string
    specId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}